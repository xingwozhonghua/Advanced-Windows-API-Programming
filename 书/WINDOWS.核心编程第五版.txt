Dedication
•二"匕*矣七
To Kristin, words cannot express how Ifeel about our life together. I cherish our family and all our adventures. 5
I'm filled each day with loveforyou.
To Aidan, you have been an inspiration to me and have taught me to play and have fun. Watching you grow up has been so rewarding and enjoyable for me. Ifeel lucky to be able to partake in your life; it has made me a better person.
To My New Baby Boy (shipping QI 2008), you have been wantedfor so long it's hard to believe that you re almost here. You bring completeness and balance to our family. I look forward to playing with you, learning who you are, and enjoying our time together.
—Jeffrey Richter
To my wife Florence, au moins cette fois c est dcrit: je t aime Flo.
To my parents who cannot believe that learning English with Dungeons & Dragons rules could have been so efficient.
—Christophe Nasarre
■ ,•'：.，嫌S .-f-Vv•- ? - •' ：策-
一、9
2) alt y
二8
Hello to my Chinese readers,
寄语中国读者1
浩顷京斜".做礴顿
I have visited your country several times now and am
always in awe at the beauty and rich culture that you hsve
On each visit, I have made some firiends and everyone has always been very gracious towards me.
I am very pleased to know that my book has been translated into your native language and I hope that you enjoy reading it as much as I enjoyed producing it.
Many years ago, operating systems were small enough that it was possible to understand the entire system.
Ml粉，
But today, operating systems are so big and are changing so quickly that understanding the whole system is not something that any single person can accomplish.
For those of you pursuing a career in programming, Td recommend you learn as much about the base systems (such as Windows and the CLR) as possible.
Then, I recommend that you specialize in a particular area such as graphics, web services, web sites, GUI programming with Windows Forms or Windows Presentation Foundation, etc.
I believe that following this path will be the best way for you to become successful as a software developer.
Best wishes!
Jefirey Richter (http://wintellect.com)
寄语中国读者2
Hello, Chinese readers,
疏 fee last coi^le of years, Fve been lucky enough to woik closely with one of our development teams in Shanghai. It has been surprising to me that we were all sharing almost the same way of working and thinking. The only one <4tinyw obstacle in our perfect team was... the language: us had to use a language different from our own native language. Even if we were all fluent in English, it would have been so efficient if we could have all spoken... Chinese. This is the exact purpose of this updated Chinese version of "Windows Via C++"： allows you to much more easily understand how to leverage the power of Windows fbr your own applications and software systems.
I'm French and writing in English is not... well... it would have been much more easier to write this book in French. You can imagine that writing it in Chinese would have been impossible based on the only two words I have memorized ("Hello" and "Thanks” if you wonder). I would like to thank SGuy fbr his very scrupulous work on the Chinese version of the book which allows you to have in your handls a real update with technical changes.
Good luck for your travel into Windows and “Xie xie" fbr reading this book!
Christophe Nasarre
①注：削子昂。
((Windows核心编程(第5版)》?出版前言
在刚刚过去的第29届奥运会上，气势恢弘、美轮美奂的开幕式，精彩纷呈、欢呼不断的赛 我们度过了多少个激动人心的不眠之夜！开幕式呈「位宏伟气势演绎的各种形式的 给人留下深刻的印象，同时也凸现了我们这个时代的主旋律。是的，“事成于和睦, 力生于团结。”电影《赤壁》中，饰演周瑜的梁朝伟同样也以一个简单的动作强调了 “和” 的重要作用。
值此《Windows核心编程(第5版)》出版之际，心里也同样洋溢着一样的情结。作为此书 的出版者，我们得到了很多方面的支持，从拿到选题、遴选译者，再到后期的反复审稿， 来自社内领导和同仁，来自兄弟出版社，来自微软公司，来自译者，来自读者的支持和热 情，大大增强了我们出好书，出精品书的信心和决心，能得到这么多的支持和关注，实乃 三生有幸！在此特别向各位表示由衷的感谢！
正所谓“玉不琢，不成器”，一本经典著作，不仅要内容精确，还少不了版式和其他细节 的精心雕琢与编排。
•	优秀译者是高品质译著的源泉 甄选译者的时候，很多读者朋友踊跃报名，他们都 希望能参与此书的工作，为Windows编程领域作出贡献。在此，向他们表示由衷 的感谢。他们当中，有70后的资深程序员，也有80后的高手程序员，更有朝气蓬 勃的在校学生。考虑到质量和时间的因素，最后确定由微软中国研发集团服务器及 开发工具事业部的葛子昂主译，周靖和廖敏参与。优秀译者是高品质译著的源泉， 这一点在本书上得以充分的验证。他们在翻译过程中，秉承一贯的严谨风格，在字 里行间进行认真的推敲，并认真对代码进行了相应的调试和实践。葛子昂作为主译, 不仅精心规划进度，还牺牲了休息时间主动承担了大部分工作，责无旁贷地对全书 进行统稿，他对本书的认真程度，让人钦佩。兄弟出版社朋友对本书翻译的参与， 也使我大受鼓舞。从他们身上，能够深切地体会到他们的敬业精神，他们是真正的 爱书人，全心全意为读者着想的人。为读者奉献更丰盛的技术图书盛宴，促进技术 图书的健康发展，这是我们共同的心愿。
•	来自微软的支持 本书由微软中国区微软最有价值专家(Most Valuable Professional, MVP)集体审阅，他们对本书给与高度评价，在此感谢刘彦博、蒋晟和王涛为代表 的Microsoft MVPo他们是一群令人敬佩的人，他们具备一种或多种微软技术专业 知识，积极参与在线或离线的社群活动，经常与其他专业人士分享知识和专业技能。
indows核心编程（第5版）
他们平易近人，是受人尊敬和信任的专家。在全球90多个国家，这样的MVP有近 4000名。目前中国区就有215名。
•	大人物的推荐序 本书由Windows Internals（深入解析Windows操作系统）作者提笔 所写，他对本书的内容和结构给予了充分的肯定。
•	精美、雅致的版式	在版式设计方面，我们突破技术类图书的常规，精心设计了
页眉和章首页，为读者提供更赏心悦目的阅读感受。
•	Jeffrey照片和亲笔签名 Microsoft Press的陈充帮我们穿针引线，引入Jeffrey的“大 头照”、家庭照和亲笔签名，这些都会在书中呈现出来。此外，Jeffrey还计划在 2009年4月访问中国，届时欢迎读者朋友参与他的见面会，与他一起探讨和体验 Windows编程乐趣。
•	索引为方便读者查阅，我们在译文相应部分添加了原书页码，同时保留原书索弓I， 并将其附于书后。
•	读后感分享 对于一本好书，很多读者都有自己的心得和感想，并希望和同道中人 切磋，这一点，我们将成立一个专门的书友会，读者可以在其中畅所欲言，在
«Windows核心编程》书友会这个大家庭中共同成长。详情请关注我社网站首页上 的公告。
作为出版工作者，我们要感谢来自译者和读者的支持和鼓励，没有他们，就没有佳作的诞 生。关于本书的任何意见和建议，欢迎发送邮件到wenkq@tup.tsinghua.edu.cn,我们一直在 聆听大家的心声。
清华大学出版社
你是否在Windows平台上开发应用程序？你是否希望对Windows提供的各项服务有更深 入的理解？你是否需要使用Windows提供的高级功能？你是否在找寻一些Windows实用
技术来解决项目中的难题？如果对上述问题的回答是肯定的，那么你绝对不应该错过本书.
自这本《Windows核心编程（第4版）》出版至今，转眼间已经过去了八年。在这八年期间, Windows 世界己经发生了许多变化，Windows XP、Windows 2003、Windows Vista 以及 Windows Server2008相继推出。与之对应的，《Windows核心编程》（第5版）也与时俱进, 针对最新的操作系统进行更新，为我们了解并发挥最新的平台特性提供了宝贵的指引。
这是一本Windows系统编程的权威专著，许多年之前我就已经读过它的第4版；这是一本 生动的教科书，它帮助我更深入地了解Windows系统；同时它又是一本参考书，在我开发 Windows应用程序的过程中遇到问题时，我会到本书中寻找答案。希望它同样能够为你答 疑解惑，并解决你的实际问题。
本书由葛子昂、周靖、廖敏共同翻译：第8〜22章由葛子昂翻译，第1〜6章由周靖翻译， 第23〜26章及附录由廖敏翻译，第7章由刘江友情客串翻译，全书由葛子昂最终审阅和统 稿。鉴于时间和精力有限，一些翻译难免存在不足甚至错误之处，为此我建立了一份网上 勘误表。如果读者发现任何错误，都可以通过该网页与我联系，一旦确认，我会立即将其 更新到勘误表中。勘误表的网址为
www.gesoftfhctory.com/ge/WindowsViaCpp。	▲
最后，感谢Jeffrey和Christophe在本书翻译过 程中不厌其烦地解答我的问题，核实并纠正英 文版中发现的一些错误。感谢李劲松、王渊峰、 张羿、孙展波、谭映辉以及孙祺对中文版的全 部或部分章节进行了审阅并提出宝贵的意见。 感谢潘爱民在百忙中抽空阅读部分译稿，并给 以反馈。感谢妻儿和家人对我的理解和支持， 本书的翻译工作占用了本应属于你们的时间， 现在终于可以有更多时间来陪伴你们了。
附：作译者近照（左为葛子昂，右为Jeffrey）
葛子昂
氐或破翩涣成砒蝠妙备茗律盘涪j论 q A」* n宙. .值
—译序2
1993年，本书第1版Advanced NT出版的时候，我和三个朋友一起成立了 一个''四喜工作 室” o由于四个人只有一台计算机，所以我们几个每天一睁眼，第一件事情便是抢占计算 机。这台286配置简单，根本无法与现在的计算机相提并论，而且当时也没有网络，所以 计算机的用途非常有限，主要也就是文字处理，玩游戏，编简单程序等，但它带给我们的 乐趣至今难以忘怀。受限于当时的环境，数据和游戏的交换也基本上在圈内好友之间进行,
就像搞地下活动一样约好时间地点碰头。幸运的是，由此结交了一大批计算机爱好者，后
来他们大多成为IT届的领军人物。
其时，从大环境看，我国网络也开始悄然起步。1993年年初，中国科学院高能物理研究所 接入斯坦福大学线性加速器中心的64K专线开通，国内科学家开始在国内使用电子邮件。 随后几个月的时间，金桥工程和域名体系的确立和部署，三大院校网的连接，最终将我国 带入信息高速公路，推动我国IT业的迅猛发展。
由此而来的便是计算机类图书和报纸期刊的炙手可热，《电脑报》等IT媒体相继崛起，计 算机图书更是出现供不应求的现象。在当时，即便是从国外引进版权再翻译出版的图书， 也能轻松突破几万册的销量，计算机图书的发展达到全盛时期。
在这个时期，国内开发人员先后成为Jeffrey和McConell等大师的拥寇。因为在IT界，虽 然资深程序员不胜枚举，但同时又是深受程序员喜爱的技术图书作家的乏善可陈。而像他 们那样，曾经写过多部书，部部都引人入胜，令人醍醐灌顶，就更是凤毛麟角。他们是 Windows编程世界中的中流砥柱，也是Windows技术当之无愧的布道者。曾有不少读者放 言，只要是Jeffrey的书，他们必定会花时间研读，并加以收藏。这一点都不夸张，我们同 时代的很多人都是在这批书的滋润下成长起来的。他们熟读了 Advanced NT之后，又如痴 如狂地捧起了 Advanced Windows 和 Programming Application for Microsoft Windows 等续作。 他们是Jeffrey的粉丝，同时也是微软开发阵营的主力军。
随着微软宣布放弃对Windows XP以及以前版本的支持，Windows Vista的普及势在必行， 迟早会安装到普通用户的计算机上。Windows Vista有很多吸引人的新特性，相信大家不用 不知道，一用忘不了。（在翻译Microsoft Press的Windows Vista Inside Out —书的过程中， 我已经深切体会到她的妙处。）作为一名程序员，有必要在第一时间适应并习惯于为新的操 作系统编写程序。历经15年，《Windows核心编程》也随着Windows操作系统的“改朝
dows核心编程（第5版）	，
换代”，升级到第5版，即Windows via C/C++o如果您要用C/C++开发Windows应用程 序，那就不要走弯路，直接让Jeffrey告诉您如何利用Windows的新特性和新函数来编写出 高效、优美的Windows应用程序。
对于本书的学习，谨以《史记•孔子世家》中孔子学琴一文与大家共勉（请原谅，这里引用 了我另一本书的译序，因其寓意深刻，故忍不住又拿出来与大家分享@））：
孔子学鼓琴师襄子，十日不进。师襄子曰：“可以益矣。”孔子曰：“丘已习其 曲矣，未得其数也。”有间，曰：“已习其数，可以益矣。”孔子曰：“丘未得 其志也。”有间，曰：“已习其志，可以益矣。”孔子曰：“丘未得其为人也。” 有间，有所穆然深思焉，有所怡然高望而远志焉。曰：“丘得其为人，黯然而黑， 几然而长，眼如望羊，如王四国，非文王其谁能为此也！”师襄子辟席再拜，曰：
“师盖云文王操也。”
期望读者朋友也能达到学习的三大境界：学习掌握演奏（编程）的技巧；领会其中的志趣； 熟悉乐曲（程序）的作者。
翻译过程中，感谢我的家人和朋友的诸多帮助和理解，他们是文天山、曹伟、文娟、马文 喜、张旭等。尤其要感谢我的乖女儿。这个暑假，她的成长令人激赏！
同时，还要感谢其他几名译者以及微软公司的技术专家们，感谢他们为本书的质量进行了 严格的把关。最后，欢迎读者指出本书的疏漏和不足之处，如果对我翻译的部分（第1〜6 章）有什么意见和建议，请访问我的博客（transbot.blog. 163.com）,在此留言指出。我在这里 为自己翻译的图书开辟了专栏，专门用于和读者们分享勘误和其他有用的信息。
周靖



当Jeffrey清我为本书写一篇序的时候，我爽快地答应了。我还记得在上个世纪90年代早 期寻找本书第1版《高级Windows NT编程》(Advanced Windows NT)Bt的情形。那时我刚 刚开始开发Windows应用程序。在我开发诸如Filemdii Regmon以及Hand!eEx(现在叫 Process Explorer)之类的应用程序时，它既是一本指南，又是一本参考手册。本书第1版面 向 Windows 系统编程，而 Charles Petzold 的《Windows 编程》(Programming Windows)则面 向用户界面编程。
在过去的几年中，Jeffrey已经将他关注的重点转向了托管代码，这使得为本书作序对我来 说大有意义。Jeffrey已经成为.NET CLR和C#系统编程的权威，当Microsoft还在设计.NET 的时候，他的这种转换就己经开始了。他还不时地“嘲弄”我和我的搭档David Solomon --我们合著了《深入解析Windows操作系统》(Windows Internals)系列，说本机代码编程 (native code programming)经日暮西山。我和David始终坚信本机代码编程由于具有不同 的API、不同的失败语5C(failure semantics)＞不同的部署方式以及不同的运行时特征，因此 将继续满足某一类应用程序的需求，或者至少是满足部分应用程序的需求。相当一部分 Windows客户端应用程序仍然是用本机代码编写的，甚至Microsoft的旗舰服务器端应用程 序,包括IIS、SQL Server以及Exchange,几乎完全是用本机代码编写的，或者使用了用 本机代码编写的组件。因此，我将本书视作Jeffrey对我们这种信念的无言的肯定。
Windows 一直在演化，本书亦是如此。它之前已经经历了许多个版本，甚至书名也一变再 变。比如，本书上一版名为 Programming Applications for Microsoft Windowso 但无论书名 如何改变，它的每一版在我的书架上都占有一席之地。(这与Jeffrey给我在书上签名不无关 系，不仅如此，而且所签的内容还是我选的，比如“我从Mark那里学到了一切”之类可 供炫耀的话。)这一个版本不仅只是换了一个新的书名，它还介绍了 Windows Vista和 Windows Server 2008中引入的最新API,包括线程、安全、异常处理以及I/O。
本书提供了大量的编程实例，既紧凑又有效地展示了各种关键概念，这使得它尤其有用。 许多作者在将代码与读者分享的时候，并没有认识到许多开发人员会直接将代码复制和粘 贴到将要发行的应用程序中去。但与我们在互联网上搜索到的代码不同，Jeffrey和 Christophe己经确保书中的代码在编写时兼顾了高质量和高准确性。
我相信，无论您是Windows应用程序编程的新手，还是完全用本机代码来编写应用程序或
Mndows核心编程(第5版)
通过P/Invoke来调用.NET Framework未提供的API的老手，都会发现本书的价值。它将有 助于发挥强大的平台特性并降低其复杂度，帮助开发人员开发伸缩性更好、更可靠、更安 全以及性能更高的应用程序。显然，它依旧会出现在我的书架上，希望这一次Jeffrey和 Christophe都能为我签上“我从Mark那里学到了一切”。
Mark Russinovich (Windows Internals 作者) Technical Fellow Microsoft Corporation
Christophe 的家人
没有妻子Florence的爱和支持，没有女儿Celia永不满足的好奇心，没有爱猫Canelle和 Nougat时不时发出的咕噜声，Christophe nJ能无法写就本书第5版。现在，我没有任何好 的借口可以逃避对你们的照顾！
技术支持
对于写就这样一本经典的图书，单凭个人的研究是不够的。我们要向Microsoft曾经帮助过 我们的员工表示诚挚的谢意。具体说来，我们要感谢Arun Kishan,对于我们提出的怪问题 或者复杂问题，他总能迅速找到答案或者立即找到Windows开发团队中合适的人提供更详 细的解释。我们还要感谢 Kinshuman Kinshumann, Stephan Doll, Wedson Almeida Filho, Eric Li, Jean-Yves Poublan, Sandeep Ranade, Alan Chan, Ale Contenti, Kang Su Gatlin, Kai Hsu, Mehmet lyigun, Ken Jung, Pavel Lebedynskiy, Paul Sliwowicz 和 Landy Wang。 此外，还有负责解答Microsoft内部社区所贴问题和分享其渊博知识的其他人士，如 Raymond Chen, Sunggook Chue, Chris Corio, Larry Osterman, Richard Russell, Mark Russinovich, Mike Sheldon, Damien Watkins 和 Junfbng Zhango 最后要特别感谢 John “Bugslayer” Robbins和Kenny Kerr,他们对本书各章提供了出色的反馈意见。
Microsoft Press 编辑团队
我们要感谢本书组稿编辑Ben Ryan对Christophe这样一个法国小伙儿的信任，感谢经理 Lynn Finnel和Curtis Philips的耐心。感谢Scott Seely为保证技术准确性而进行的搜索查找， 感谢Roger LeBlanc在将Christophe的法国式英语变得更容易理解这方面所表现出来的天 才，感谢Andrea Fox字斟句酌的校对。除了 Redmond团队成员外,我们还要感谢Joyanta Sen 花费大量宝贵的私人时间为我们所提供的帮助。
indows核心编程（第5版）
互致谢意
Christophe要向Jeffrey Richter表示诚挚的谢意，感谢他相信自己不会弄砸第5版。
Jefirey也要感谢Christophe兢兢业业，恪尽职守，在研究、重新组织、重写和重修本书内 容以期接近Jeff完美要求所做的努力。
Microsoft Windows是一个复杂的操作系统。它提供的特性非常丰富，对任何个人而言，要 想完全透彻地理解整个系统几乎不可能。其复杂性也使我们很难确定应该把主要精力集中 在哪些地方。万丈高楼平地起，就我个人而言，我始终倾向于从最底层开始，深刻理解系 统的基本构件。一旦掌握了最基本的东西，就很容易向自己的知识库中遂亲添赢鱼*膏有 的东西。所以本书将集中介绍Windows的基本构件和基础概念，对于构架和实现Windows 应用程序来说，这些都是必须掌握的。简而言之，本书是向读者介绍各个Windows特性， 并介绍如何通过C和C++语言来了解并使用这些特性。
虽然本书不会涵盖某些Windows概念，比如组件对象模型(Component Object Model ,后面 简称为COM),但COM是在进程、线程、内存管理、DLL、线程本地存储区以及Unicode 等基本构件的基础上构建的。如果了解了这些基本构件，那么要理解COM就相当于理解 如何使用这些基本构件。对于那些试图跳过这些基本构件，悉心钻研COM体系结构的朋 友，我深表同情。要完善知识库，他们还有很长一段路要走，这必然会对他们的代码和软 件开发进度产生很大的负面影响。
Microsoft .NET Framework 的公共语言运行时(Common Language Runtime, CLR)是本书未 涉及的另一种技术(感兴趣的朋友可以阅读我的另一本专著《框架设计：CLRviaC#》)。不 过，CLR是作为动态链接库(dynamic link library, DLL)中的一个COM对象来实现的，它 需要被载入到进程中，它需要使用线程来执行代码，它需要处理Unicode字符串，它还需 要在内存中对这些字符串进行管理。因此，本书所介绍的基本构件仍然有助于软件开发人 员编写托管代码。此外，借助于CLR的平台调用(Platform Invocation, P/Invoke)技术，我 们可以调用本书所介绍的各种Windows API。
如此一*来，本书的宗旨是介绍每一个Windows开发人员都应该掌握的基本的Windows构 件(至少在我看来如此)。在介绍每一个构件的时候，我还会描述系统是如何使用这些构件 的，我们自己的应用程序如何充分利用这些构件。在很多章中，我会介绍如何创建自己的 构件。我们自己的构件一般都实现为普通函数或C廿类，它们把一些Windows构件组合在 一起，从而创造出一个整体，其结果远远大于各部分之和。
64位Windows操作系统
Microsoft发售支持x86 CPU体系结构的32位Windows操作系统己经有多年的历史。如今， Microsoft还提供支持x64和IA-64 CPU体系结构的64位Windows操作系统。基于这些64
WS核心编程（第5版）
位CPU体系结构的计算机迅速为市场所接受。事实上，在不远的将来，所有台式机和服务 器都将使用64位CPUo为此，Microsoft已发表声明，Windows Server 2008将是最后一款 32位版本的Windows操作系统！对于开发人员而言，现在是时候集中精力让自己的应用程 序能在64位Windows操作系统上正常运行了。贯穿本书，将全面覆盖相关的知识，让开 发人员的应用程序能够在64位Windows操作系统（同时也包括32位Windows）上正常运行。
应用程序从64位地址空间所获得的最大的好处是，能够轻松处理大量数据，因为应用程序 的进程不再受限于2GB可用地址空间。即使应用程序并不需要所有这些空间，Windows 本身也可以利用这个显然大得多的地址空间（约8TB）来加快运行速度。
对于64位Windows操作系统，我们需要了解哪些呢？下面简单看一看。
•	64位Windows内核是32位Windows内核的移植版本。这意味着以前所学的32位 Windows所有细节和难点均适用于64位Windowso事实上，Microsoft己经修改了 32位Windows的源代码，使其既可以编译生成32位系统，也可以编译生成64位 系统。两个系统使用同一个源代码库，所以新的特性和缺陷的修复会同时应用于这 两个系统。
•	因为内核使用相同的代码和基本概念，所以在两个平台上的Windows API是一样 的。这意味着我们不必重新设计或实现应用程序，就能让它在64位Windows操作 系统上运行。我们只需要对源代码做少许改动，然后重新构建应用程序即可。
•	为了保持向后兼容性，64位Windows操作系统是可以执行32位应用程序的。但是， 如果应用程序是作为64位应用程序来生成的，那么它的性能会有显著的提高。
•	因为移植32位代码非常容易，所以64位Windows操作系统中已经有很多的设备 驱动程序、工具和应用程序了。遗憾的是，Visual Studio是32位的，而且Microsoft 似乎还并不急于将其移植为64位的。不过，好消息是32位的Visual Studio在64 位Windows操作系统上的确运行得非常好，只不过其数据结构的地址空间有限。 而且，我们还可以用Visual Studio来调试64位应用程序。
•	并不需要学习太多新知识。大多数数据类型仍然保持32位宽度，这是很多读者很 高兴看到的。它们是INT, DWORD, LONG和BOOL等。事实上，大多数情况下 我们只需要担心指针和句柄，因为它们现在变成64位了。
对于如何将现有源代码修改为64位,Microsoft已经提供了相当丰富的信息，所以我们不 打算在本书中深入这些细节。不过，在我写每一章的时候，我都会考虑到64位Windows 操作系统。在适当的时候，我会加入64位Windows的特定信息。同时，我还在64位Windows 中编译和测试了本书中的所有示例程序。所以，如果读者效仿书中的示例程序和我的做法, 那么创建一个能够为32位或64位Windows编译的源代码库应该完全不成问题。
Windows核心编程（第5版）》中有哪些新内容
在过去，本书曾经被冠以“Advanced NT”,uAdvanced Windows和“Programming Application for Microsoft Windows"等名字。为保持这个传统，本书的第5版也有一个新的书名，即 Windows via C/C++。新的书名表示本书是为打算理解Windows的C和C++程序员设计的。
前 言
第 5 版全面覆盖了 Windows XP, Windows Vista 和 Windows Server 2008 中的 170 个新增函 数和Windows特性。
有些章已经全部重写，比如第11章，这一章解释了如何使用新的线程池APL第4版原有 的各章都已经大幅修订，以突出介绍新的特性。例如，在第4章，现在已经包含了用户帐 户控制(User Account Control)的介绍，第8章现在介绍了新的同步机制。
同时，我还更全面地介绍了 C/C++运行库如何与操作系统交互，特别强调安全性和异常处 理。最后，第5版新增了两章内容，解释了 I/O操作的工作原理以及如何深入理解新的 Windows Error Reporting系统，此系统改变了我们必须考虑应用程序错误报告和应用程序 恢复的方式。
除了新的结构和更深入的介绍，我还增加了大量新的内容。第5版着重在以下几个方面进 行了更深入的讲解。
•	Windows Vista和Windows Server 2008新增特性 当然，除非本书涵盖了 Windows XP, Windows Vista, Windows Server 2008和C/C++运行库的所有新特性，否则它 就算不上是真正的修订。第5版着重强调安全字符串函数、内核对象变化(比如名 称空间和边界描述符)、线程和进程属性列表、线程和I/O优先级安排、取消同步 I/O、向量异常处理等方面的最新信息。
•	64位Windows支持 本书旨在解决64位Windows的特定问题，所有示例程序都在 64位Windows上生成并测试过。
•	使用C++语言 示例程序使用C++语言，所需要的代码更少，而且C++的逻辑更清 楚，也更容易理解。
•	可重用的代码我尽可能让源代码既通用，又可重用。这样一来，读者只需对单独 的函数或者整个C++类稍作改动或根本无须做改动，就可以在自己的应用程序中使 用它们。C++语言的使用进一步增强了代码的可重用性。
•	Processinfo实用工具前凡版中一直都有的这个特殊示例程序己经被增强，可以显 示进程拥有者、命令行和UAD相关详情。
•	LockCop实用工具这个示例程序是新增的。它显示了系统中有哪些进程正在运行。 一旦选定了一个进程，这个工具就会列出进程中的所有线程，以及每个线程是被哪 种同步机制阻塞，同时明确地指出死锁的情况。
•	API拦截 我介绍了一些更新后的C++类，这些类使得对进程中的一个或所有模块 进行API拦截变得相当简单。我的代码甚至拦截了应用程序在运行的时候对 LoadLibrary和GetProcAddress的调用，这进一步加强了对API的拦截。
•	结构化异常处理有所增强 我重写并重新组织了结构化异常处理的内容。我进一步 介绍了未处理异常，并针对如何根据自己的需求自定义Windows Error Reporting 系统。
示例代码和系统需求
本书的示例程序可以从本书配套网页下载，网址如下：
XVII
险dows核心编程（第5版）
http://www.wintellect.com/books.aspx
为了构建示例程序，读者朋友需要安装Visual Studio 2005或更新版本，Microsoft Platform SDK fbr Windows Vista 和 Windows Server 2008（有些版本的 Visual Studio 自带这个 SDK）。 此外，要运行示例程序，还需要一台已安装Windows Vista（或更新的版本）的计算机（或虚拟 机）。
本书支持
我们已经尽力确保本书及其配套内容的准确性。我们会将收集到的勘误或改动添加到一个 勘误表中，读者可以从以下网址下载这个勘误表：
http://www.wintellect.com/books.aspx
问题和评论
有关本书或者网络配套内容的任何评论、问题或想法，或者通过访问上述网址仍然未能解 决的疑惑，请通过电子邮件发送给Microsoft Press：
mspinput@microsoft.com
或者将信件寄到以下地址：
Microsoft Press
Attn： Windows via C/C++ Edition
One Microsoft Way
Redmond, WA 98052-6399
请注意，上述地址并不提供对Microsoft软件产品的支持。
XVIII
第1章提尊误处理.............•绑翳
1.1定义白己的错误代码.........7
1.2	ErrorShow 示例程序...7
第2章	字符和字符串处理........10
2.1字符编码.............11
2.2	ANSI字符和Unicode字符
与字符串数据类型.........12
2.3	Windows 中的 Unicode 函数
和ANSI函数..........14
2.4 C运行库中的Unicode函数
和ANSI函数..............16
2.5	C运行库中的安全字符串函数.......17
2.5.1初识新的安全字符串函数........18 2.5.2在处理字符串时如何获得
更多控制...........21
2.5.3	Windows字符串函数.23
2.6	为何要用 Unicode......24
2.7推荐的字符和字符串处理方式......25
2.8	Unicode与ANSI字符串转换.26
2.8.1	导出 ANSI 和 Unicode DLL
函数............28
ansi 还是
Unicode.......29
第3章内核对象.暨
3.1何为内核对象............32
3.1.1使用计数.........34
3.1.2内核对象的安全性.....34
3.2进程内核对象句柄表.........36
3.2.1创建一个内核对象.....37
3.2.2关闭内核对象.......38
3.3跨进程边界共享内核对象.......42
3.3.1使用对象句柄继承.....42
3.3.2改变句柄的标志......45
3.3.3 为对象命名.......46
3.3.4终端服务命名空间.....50
3.3.5 专有命名空间......51
3.3.6复制对象句柄.......58
第II部分工
第4章进程.................65
4.1编写第•个Windows应用程序.66
4.1.1进程实例句柄......71
4.1.2进程前一-个实例的句柄.72
4.1.3进程的命令行......73
4.1.4进程的环境变量.....74
4.1.5进程的关联性......79
4.1.6进程的错误模式.....79
作机理
4.1.7进程当前所在的驱动器
和目录..................80
4.1.8进程的当前目录..............81
4.1.9	系统版本................82
4.2	CreateProcess 函 数.........85
4.2.1	pszApplicationName 和
pszCommandLine 参数....86
4.2.2	psaProcess» psaThread
Mows核心编程（第5版） 
和 blnheritHandles	参数..87
4.2.3	fdwCreate 参数........89
4.2.4	pvEnvironment 参数....91
4.2.5	pszCurDir参数.........92
4.2.6	psiStartlnfb 参数.....92
4.2.7	ppiProclnfb参数.......98
4.3终止进程.....................100
4.3.1主线程的入曰点函数返回......100
4.3.2	ExitProcess 函数.....101
4.3.3	TerminateProcess函数.102
4.3.4当进程中的所有线程终止时..103 43.5当进程终止运行时.............103
4.4子进程......................104
4.5管理员以标准用户权限运行时............106
4.5.1自动提升进程的权限...........109
4.5.2手动提升进程的权限........111
4.5.3何为当前权限上下文........112
4.5.4枚举系统中正在运行的
进程...................114
4.5.5 Process Information 示例
程序...................115
第5章作业..........................121
5.1对作业中的进程施加限制..............124
5.2将进程放入作业中.................131
5.3终止作业中的所有线程...............132
5.4	作业通知....................135
5.5	Job Lab 示例程序............138
第6章线程基础........................140
6.1何时创建线程...................141
6.2何时不应该创建线程................143
6.3编写第一个线程函数................144
6.4	CreateThread 函数.........144
6.4.1	psa 参数.............145
6.4.2	cbStackSize 参数.....145
6.4.3	pfhStartAddr 和 pvParam
参数...................146
6.4.4	dwCreateFlags......147
6.4.5	pdwThreadlD........147
6.5终止运行线程...................148
6.5.1线程函数返回..........148
6.5.2	ExitThread 函数..148
6.5.3	TerminateThread 函数.149
6.5.4	进程终止运行时........149
6.5.5线程终止运行时.........150
6.6线程内幕.................150
6.7	C/C++运行库注意事项........153
6.7.1	用 beginthreadex 而不要用
CreateThread 创建线程.161
6.7.2绝对不应该调用的C/C++
运行库函数.........161
6.8	了解自己的身份.............162
第7章	线程调度、优先级和关联性......165
7.1线程的挂起和恢复.............166
7.2进程的挂起和恢复.............167
7.3	睡眠................  169
7.4切换到另一个线程.............169
7.5在超线程CPU上切换到另一个
线程...................170
7.6线程的执行时间..............170
7.7在实际上下文中谈CONTEXT
结构...................174
7.8	线程优先级...............178
7.9从抽象角度看优先级............179
7.10	优先级编程..............182
7.10.1动态提升线程优先级......185
7.10.2为前台进程微调调度程序....186
7.10.3调度I/O请求优先级.....186
7.10.4	Scheduling Lab 示例程序.....188
7.11	关联性................192
第8章	用户模式下的线程同步..........197
8.1原子访问:Interlocked系列函数.198
8.2高速缓存行................203
83高级线程同步................205
8.4	关键段.................207
8.4.1关键段：细节..........209
8.4.2关键段和旋转锁.........212
8.4.3关键段和错误处理........213
8.5	Slim W写锁............214
7
目 录
8.6 条件变量.......................217
8.6.1	Queue示例程序.............218
8.6.2在停止线程时的死锁问题......225
8.6.3	一些有用的窍门和技巧............227
第9章	用内核对象进行线程同步................230
9.1等待函数........................232
9.2等待成功所引起的副作用.................235
9.3	事件内核对象.....................236
9.4可等待的计时器内核对象.................245
9.4.1让可等待的计时器添加APC
调用......................248
9.4.2计时器的剩余问题...............250
9.5	信号量内核对象....................251
9.6互斥量内核对象.....................253
9.6.1遗弃问题...................255
9.6.2互斥量与关键段的比较.............256
9.6.3	Queue示例程序.............256
9.7线程同步对象速查表...................264
9.8其他的线程同步函数...................265
9.8.1异步设备I/O................265
9.8.2	WaitForlnputldle 函数...265
9.8.3	MsgWaitForMultipleObjects(Ex)
函数......................266
9.8.4	WaitForDebugEvent 函数..267
9.8.5	SignalObjectAndWait函数.267
9.8.6使用等待链遍历API来检测
死锁......................268
第10章	同步设备I /0与异步设备I /0..... 275
10.1打开和关闭设备....................276
10.2使用文件设备.....................285
10.2.1取得文件的大小...............285
第m部分
第13章Windows内存体系结构.................355
13.1进程的虚拟地址空间..................355
13.2虚拟地址空间的分区..................356
13.2.1空指针赋值分区...............357
13.2.2用户模式分区................357
10.2.2设置文件指针的位置......286
10.2.3设置文件尾..........288
103	执行同步设备I/O..........289
10.3.1将数据刷新至设备.......289
103.2	同步I/O的取消......290
10.4	异步设备I/O基础..........291
10.4.1	OVERLAPPED 结构.292
10.4.2异步设备I/O的注意事项.....294
10.4.3取消队列中的设备I/O 请求...................296
10.5接收I/O请求完成通知.........296
10.5.1触发设备内核对象.......297
10.5.2触发事件内核对象.......298
10.5.3	可提醒 I/O.......301
10.5.4	I/O 完成端口......306
10.5.5模拟已完成的I/O请求..316
第11章	Windows线程池.........324
11.1情形1：以异步方式调用函数.......325
11.1.1显式地控制工作项.......325
11.1.2	Batch 示例程序....327
11.2情形2：每隔一段时间调用一个 函数..............330
113情形3：在内核对象触发时调用
—个函数.................335
11.4情形4：在异步I/O请求完成时
调用一个函数...............337
11.5回调函数的终止操作...........339
11.5.1对线程池进行定制.......340
11.5.2得体地销毁线程池：
清理组..........342
第12章纤程.....................345
内存管理
13.3	地址空间中的区域...........360
13.4给区域调拨物理存储器..........361
13.5物理存储器和页交换文件.........362
13.6页面保护属性..............365
13-6.1写时复制...........366
听dows核心编程（第5版）
13.6.2	—些特殊的访问保护属性
标志..........367
13.7实例分析.............367
13.8数据对齐的重要性.........375
第14章探索虚拟内存..............379
14.1系统信息.............379
14.2	虚拟内存状态..........387
14.3	NUMA机器中的内存管理....388
14.4确定地址空间的状态........391
14.4.1	VMQuery 函数.392
14.4.2示例程序：虚拟内存映射....397 第15章	在应用程序中使用虚拟内存....400
15.1预订地址空间区域.........400
15.2给区域调拨物理存储器.......402
15.3同时预订和调拨物理存储器.....403
15.4何时调拨物理存储器........405
15.5撤销调拨物理存储器及释放区域.....407 15.5.1何时撤销调拨物理存储器....407 15.5.2虚拟内存分配示例程序........408 15.6	改变保护属性..........414
15.7重置物理存储器的内容.......415
15.8	地址窗口扩展..........419
第16章线程栈.................429
16.1	C/C++运行库的栈检查函数..433
16.2	Summation示例程序...435
第17章	内存映射文件..........440
17.1映射到内存的可执行文件和DLL....44】 17.1.1同一个可执行文件或DLL
的多个实例不会共享静态 数据......“442
17.1.2在同一个可执行文件或DLL
的多个实例间共享静态 数据............444
17.1.3	Application Instances 示例
程序..........449
17.2映射到内存的数据文件.......451
17.2.1方法1：—个文件，一块
缓存..........451
17.2.2方法2：两个文件，一块
缓存............452
17.2.3方法3： —个文件，两块
缓存............452
17.2.4方法4： 一个文件，零个
缓存..................453
17.3使用内存映射文件...............453
17.3.1第1步：创建或打开文件
内核对象................454
173.2第2步：创建文件映射
内核对象..........455
173.3第3步：将文件的数据映射 到进程的地址空间.......458
173.4第4步：从进程的地址空间
撤销对文件数据的映射.….…461
17.3.5第5步和第6步：关闭文件 映射对象和文件对象......462
17.3.6	File Reverse 示例程序.463
17.4用内存映射文件来处理大文件..........469
17.5内存映射文件和-•致性............470
17.6给内存映射文件指定基地址...........471
17.7内存映射文件的实现细节............472
17.8用内存映射文件在进程间共享
数据..............473
17.9以页交换文件为后备存储器的
内存映射文件..................474
17.10稀疏调拨的内存映射文件...........478
第18章堆.........................491
18.1进程的默认堆.................491
18.2为什么要创建额外的堆.............492
18.2.1对组件进行保护............493
18.2.2更有效的内存管理...........493
.	18.2.3使内存访问局部化.....494
18.2.4避免线程同步的开销..........494
18.2.5	快速释放..............495
18.3如何创建额外的堆...............495
18.3.1从堆中分配内存块...........497
18.3.2调整内存块的大小...........498
18.3.3获得内存块的大小...........499
183.4释放内存块...............500
XXII
目 录
183.5	销毁堆..............500
18.3.6在C++中使用堆.........500
18.4其他堆函数
503
第IV部分动态链接库
第19章
19.1
19.2
第20章
20.1
20.2
DLL 基础............509
DLL和进程的地址空间.......510
纵观全局..............512
19.2.1 构建 DLL 模块..514
19.2.2构建可执行模块.....519
19.2.3运行可执行模块.....522
DLL高级技术...........524
DLL模块的显式载入和符号链接....524
20.1.1显式地载入DLL模块...525
20.1.2显式地卸载DLL模块...529
20.1.3显式地链接到导出符号........532
DLL的入口点函数.........533
20.5	已知的 DLL........553
20.6	DLL 重定向........555
20.7模块的基地址重定位.......556
20.8模块的绑定...........562
第21章线程局部存储区............565
21.1	动态 TLS.........566
21.2	静态 TLS.........570
第22章DLL注入和API拦截........572
22.1	DLL注入的一个例子.....573
22.2使用注册表来注入DLL.....575
22.3	使用 Windows 挂钩来注入 DLL....... 576
22.4使用远程.线程来注入DLL...587
20.3
20.4
20.2.1	DLL_PROCESS_ ATTACH
通知................534
20.2.2	DLL_PROCESS_DETACH
通知................535
20.23 DLL_THREAD_ATTACH
通知...............537
20.2.4	DLL_THREAD_DETACH
通知...............538
20.2.5	DllMain的序列化调用...538
20.2.6	DllMain 和 C/C++运行库......541
延迟载入DLL...............542
函数转发器.................553
22.4.1	Inject Library 示例程序.591
22.4.2	Image Walk DLL.596
22.5	使用木马DLL来注入DLL......598
22.6把DLL作为调试器来注入........598
22.7	使用CreateProcess来注入代码.599
22.8	API拦截的一个例子...........599
22.8.1通过覆盖代码来拦API.....600
22.8.2通过修改模块的导入段来
拦截 API...........601
22.8.3	Last MessageBox Infb 示例
程序...............604
第V部分结构化异常处理
第23章
第24章
24.1
24.2
终止处理程序............621
异常处理程序与软件异常638
通过实例理解异常过滤程序
和异常处理程序................638
24.1.1	Funcmeisterl 函数.639
24.1.2	Funcmeister2 函数.639
EXCEPT1ON_EXECUTE_
HANDLER................641
24.2.1	一些有用的例子.........642
24.2.2	全局展开............645
24.2.3停止全局展开...........647
24.3	EXCEPTION_CONTINUE_
EXECUTION..............648
24.4	EXCEPTION_CONTINUE_
SEARCH.................650
24.5	GetExceptionCode......652
XXIII.
T
WS核心编程（第5版）
24.6	GetExcept ion I n formation.656
24.7	软件异常........................659
第25章	未处理异常、向量化异常处理
与C++异常...........663
25.1	UnhandledExceptionFilter 函数
详解...............665
25.2	即时调试........................671
253	电子表格示例程序....................673
25.4向量化异常和继续处理程序......681
25.5	C++异常与结构化异常的比较..............683
25.6异常与调试器.......................684
第26章	错误报告与应用程序恢复………688
26.1	Windows错误报告控制台..............688
26.2可编程的Windows错误报告..............691
26.3对进程中所有的问题报告进行
定制...............693
26.4问题报告的创建与定制...................694
26.4.1创建一个自定义的问题
报告....................697
26.4.2设置报告参数：
WerReportSetParameter.698
26.4.3将小型转储文件放入报告：
WerReportAddDump......698
26.4.4将任意文件放入报告：
WerReportAddFile......699
26.4.5修改对话框文本：
WerReportSetUI Option.700
26.4.6提交错误报告：
WerReportSubmit.......700
26.4.7关闭问题报告：
WerReportCloseHandle.702
26.4.8	Customized WER 示例
程序...............702
26.5应用程序的自动重启与恢复..........708
26.5.1应用程序的自动重启.......708
26.5.2对应用程序恢复的支持........709
第VI部分
附录A构建环境............713
附录B消息嬷宏、子控件宏和API宏.....724
索引.................729

第2章 第3章
错误处理
字符和字符串处理 内核对象
僵照艘舰昭哪.』：，•： ：：?,叩啊 WE。： ffTFF=^ ..E • •]



电0
第1章错误处理
在深入讨论Microsoft Windows提供的诸多特性之前,应该先理解各个Windows函数是如 何进行错误处理的。
调用Windows函数时，它会先验证我们传给它的参数，然后再开始执行任务。如果传入的 参数无效，或者由于其他原因导致操作无法执行，则函数的返回值将指出函数因为某些原 因失败了。表1-1展示了大多数Windows函数使用的返回值的数据类型。
	表1-1常见的Windows函数返回值数据类型
数据类型	指出函数调用失败的值
VOID	这个函数不可能失败。只有极少数Windows函数的返回值类型为VOID
BOOL	如果函数失败，返回值为0：否则，返回值是一个非0值。应避免测试返回值是否 为TRUE；最稳妥的做法是检查它是否不为FALSE
HANDLE	如果函数失败，则返回值通常为NULL；否则，HANDLE将标识一个可以操纵的 对象。请注意这种返回值，因为某些函数会返回为INVALID_HANDLE_VALUE 的一个句柄值，它被定义为-1。函数的Platform SDK文档清楚说明了函数是返回 NULL 还是 INVALID_HANDLE_VALUE 来标识失败
PVOID	如果函数调用失败，则返回值为NULL；否则，PVOID将标识一个数据块的内存地址
LONG/DWORD	这种类型比较棘手。返回计数的函数通常会返回一个LONG或DWORD。如果函 数出于某种原因不能对我们想要计数的东西进行计数，它通常会返回0或-1（具体 取决于函数）。如果要调用一个返回LONG/DWORD的函数，务必仔细阅读Platform SDK文档，确保我们会正确地检查可能出现的错误
通常情况下，如果Windows函数能返回错误代码，将有助于我们理解函数调用为什么会失 败。Microsoft编辑了一个列表，其中列出了所有可能的错误代码，并为每个错误代码都分 配了一个32位的编号。
一
在内部，当Windows函数检测到错误时，它会使用一种名为“线程本地存储区”（thread-local
■^^dows核心编程（第5版）	一
storage）的机制将相应的错误代码与“主调线程”（或者说发出调用的线程，即calling thread） 关联到一起（线程本地存储区的详情将在第21章讨论）。这种机制使不同的线程能独立运行, 不会出现相互干扰对方的错误代码的情况。函数返回时，其返回值会指出已发生一个错误。 要查看具体是什么错误，请调用GetLastError函数，如下所示：
DWORD GetLastError（）；
此函数的作用很简单，就是返回由上一个函数调用设置的线程的32位错误代码。
有了 32位错误代码之后，接着需要把它转换为更有用的信息。WinError.h头文件包含了 Microsoft定义的错误代码列表。为便于体验，下面摘录了其中的一部分：
// Messageld： ERROR_SUCCESS
//
// MessageText:
//
// The operation completed successfully.
//
#define ERROR_SUCCESS	OL
#define NO_ERROR OL	// dderror
#define SEC_E_OK	((HRESULT)OxOOOOOOOOL)
//
// Messageld: ERROR_INVALID_FUNCTION
//
// MessageText:
//
// Incorrect function.
//
ttdefine ERROR_INVALID_FUNCTION	IL	// dderror
//
// Messageld： ERROR_FILE_NOT_FOUND
//
// MessageText:
//
// The system cannot find the file specified.
//
#define ERROR_FILE_NOT_FOUND	2L
//
// Messageld: ERROR_PATH_NOT_FOUND
//
// MessageText:
//
// The system cannot find the path specified.
//
#define ERROR_PATH_NOT_FOUND	3L
//
// Messageld: ERROR_TOO_MANY_OPEN_FILES
//
// MessageText:
//
// The system cannot open the file.
//
#define ERROR_TOO_MANY_OPEN_FILES	4L
//
// Messageld: ERROR_ACCESS_DENIED
//
// MessageText:
//
// Access is denied.
//
ttdefine ERROR_ACCESS_DENIED
3-5黔
可以看出，每个错误都有三种表示：一个消息ID（一个可在源代码中使用的宏，用于与 GetLastError的返回值进行比较）、消息文本（描述错误的英文文本）和一个编号（应该避免使 用此编号，尽量使用消息ID）。注意，这里只摘录了 WinError.h头文件的极小一部分，整 个文件的长度超过39 000行！
Windows函数失败之后，应该马上调用GetLastError,因为假如又调用了另一个Windows 函数，则此值很可能被改写。注意，成功调用的Windows函数可能用ERROR_SUCCESS 改写此值。
一些Windows函数调用成功可能是缘于不同的原因。例如，创建一个具名事件内核对象时， 以下两种情况均会成功：对象实际完成创建，或者存在一个同名的事件内核对象。应用程 序也许需要知道成功的原因。为返回这种信息，Microsoft选择采用“上一个错误代码"（last error code）机制。所以，特定函数调用成功时，可以调用GetLastError来确定额外的信息。 对于具有这种行为的函数,Platform SDK文档会清楚指明能以这种方式调用GetLastError。 文档中提供了 CreateEvent函数的一个例子；如果已经存在具名事件，就返回 ERROR_ALREADY__EXISTSo
调试程序时，我发现对线程的“上一个错误代码”进行监视是相当有用的。在Microsoft Visual Studio中，Microsoft的调试器支持一个很有用的功能——我们可以配置Watch（监视） 窗口，让它始终显示线程的上一个错误代码和错误的文本描述。具体的做法是：在Watch 窗口中选择一•行，然后输入$err,hro我们来看看图1-1的例子。在这个例子中，我已经调用 了 CreateFile 函数。该函数返回值为 INVALID_HANDLE_VALUE （-1）的一个 HANDLE,指 出它无法打开指定文件。但是Watch窗口指出，上一个错误代码（也就是调用GetLastError 函数返回的错误代码）是0x00000002o多亏有了,hr限定符，Watch窗口进一步指出错误 代码2是“The system cannot find the file specified.w （系统找不到指定文件）。这就是在 WinError.h头文件中为错误代码2列出的消息文本。
▼ [ eWinMain(HlNSTANCE hlmUnceExe. HINSTANCE. PTSTR pszCmdl ▼
10Qint WINAPI _tWinMain(HINSTANCE hlnstanceExe, HINSTANCE, PTSTR pszGndLine, Snt) {
HAQLE hFile - CreateFi 1 eCTEXTfc:\\Jeff **) , 0, 0, NULL, OPEN_£XISTING, 0, NULL); return(O);
• $err,hr 0x00000002 The aystem cannot find the file specified.
图1-1在Visual Studio的Watch窗口中使用$err,hr来查看当前线程的“上一个错误代码”
Vindows核心编程(第5版)
Visual Studio还搭载了一个很小的实用程序，名为Error Lookup。利用它，可以将错误代码 转换为相应的文本描述。如下图所示。
如果我在自己写的程序中检测到一个错误，我可能希望向用户显示错误的文本描述，而不 是显示一个干巴巴的错误编号。Windows提供了一个函数，可以将错误代码转换为相应的 文本描述。此函数名为FormatMessage,如下所示：
DWORD FormatMessage(
DWORD dwFlags,
LPCVOID pSource,
DWORD dwMessageld,
DWORD dwLanguageld,
PTSTR pszBuffer,
DWORD nSize,
va_list *Arguments)；
FormatMessage的功能实际相当丰富，若想生成向用户显示的字符串，那么它是首选的一 种方式。之所以说它好用，一个原因是它能轻松地支持多种语言七它能获取一个语言标识 符作为参数，并返回那种语言的文本。当然，我们首先必须翻译字符串，并将翻译好的消 息表(message table)资源嵌入自己的.exe或DLL模块中。但在此之后，这个函数就能自动选 择正确的字符串。ErrorShow示例程序(参见后文)演示了如何调用这个函数将Microsoft定 义的错误代码编号转换为相应的文本描述。
经常有人问我，Microsoft是否维护着一个左控列表，其中完整列出了每个Windows函数可 能返回的所有错误代码。很遗憾，答案是否定的。而且，Microsoft决不可能提供这样的列 表，因为随着新版本的操作系统的问世，这样的列表将很难构建和维护。
6
这种列表的问题在于，我们町以调用一个Windows函数，但在内部，这个函数可能调用另 一个函数，后者又可能调用其他函数……以此类推。出于众多原因，任何一个函数都可能 失败。有时，当一个函数失败时，较高级别的函数也许能够恢复，并继续执行我们希望的 操作。要创建这种主控列表，Microsoft必须跟踪每个函数的路径，生成所有可能的错误代 码的列表。这是非常难的。而目.，随着新版本的操作系统的发布，这些函数的执行路径也 可能发生改变。
①译注：这里的语言是n然语言,如汉语、英讷等，而不是计算机编程语言。
e
第1章错误处理
1.1定义自己的错误代码
前面讲述了 Windows函数如何向其调用者指出错误。除此之外，Microsoft还允许将这种机 制用于我们自己的函数中。假定我们要写一个供其他人调用的函数。这个函数可能会因为 这样或那样的原因而失败，所以需要向调用者指出错误。
为了指出错误，只需设置线程的上一个错误代码，然后令自己的函数返回FALSE, INVALID_HANDLE_VALUE、NULL或者其他合适的值。为了设置线程的上一个错误代 码，只需调用以下函数，并传递我们认为合适的任何32位值：
VOID SetLastError(DWORD dwErrCode);
我会尽量使用WinErronh中现有的代码——只要代码能很好地反映我想报告的错误。如果 WinError.h中的任何一个代码都不能准确反映一个错误，就可以创建自己的代码。错误代 码是一个32位数，由表1-2描述的几个不同的字段组成。
表1-2错误代码的不同字段
位	31-30	29	28	27-16	15-0
内容	严重性	Microsoft/客户	保留	Facility 代码	异常代码
含义	0=成功 1 =信息(提示) 2=警告 3=错误	0 = Microsoft 定 义的代码 1 =客户定义的 代码	必须为0	前256个值由 Microsoft 保留	Microsoft/ 客户 定义的代码
这些字段将在第24章详细讨论。就目前来说，唯一需要注意的重要字段是第29位。Microsoft 承诺，在它所生成的所有错误代码中，此位将始终为0。但是，如果要创建我们自己的错 误代码，就必须在此位放入一个lo通过这种方式，可以保证我们的错误代码绝不会与 Microsoft现在和将来定义的错误代码冲突。注意，Facility字段非常大，足以容纳4096个 可能的值。其中，前256个值是为Microsoft保留的，其余的值可由我们自己的应用程序来 定义。
1.2	ErrorShow示例程序
ErrorShow应用程序(01-ErrorShow.exe)演示了如何得到一个错误代码的文本描述。此应用 程序的源代码和资源文件可以在本弓配套网页的01-ErrorShow目录中找到，网址为 http://wintellect.com/Books.aspx。
简单地说，这个应用程序展示了调试器的Watch窗口和Error Lookup程序是如何工作的(参 见前面的两个屏幕截图)。启动程序时，将出现下图所示窗口。
7
ows核心编程（第5版）
可以在编辑控件中输入任何错误代码。单击Look Up按钮后，错误的文本描述将在对话框 底部的可滚动窗口中显示。对于这个应用程序，我们唯一感兴趣的是如何调用 FormatMessageo下面展示了我如何使用这个函数：
// Get the error code
DWORD dwError = GetDlgltemlnt(hwnd, IDC_ERRORCODE, NULL, FALSE);
HLOCAL hlocal = NULL; // Buffer that gets the error message string
// Use the default system locale since we look for Windows messages
// Note: this MAKELANGID combination has a value of 0
DWORD systemLocale = MAKELANGID(LANG-NEUTRAL, SUBLANG_NEUTRAL);
// Get the error code's textual description
BOOL fOk = FormatMessage(
FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS I FORMAT_MESSAGE_ALLOCATE_BUFFER,
NULL, dwError, systemLocale,
(PTSTR) &hlocal, 0, NULL);
if (JfOk) (
// Is it a network-related error?
HMODULE hDll = LoadLibraryEx(TEXT("netmsg.dll"), NULL, DONT_RESOLVE_DLL_REFERENCES);
if (hDll != NULL) (
fOk = FormatMessage(
FORMAT_MESSAGE_FROM_HMODULE I FORMAT_MESSAGE_IGNORE_INSERTS I FORMAT_MESSAGE_ALLOCATE_BUFFER, hDll, dwError, systemLocale, (PTSTR) &hlocal, 0, NULL);
FreeLibrary(hDll);
}
)
if (fOk && (hlocal != NULL)) (
SetDlgltemText(hwnd, IDC_ERRORTEXT, (PCTSTR) LocalLock(hlocal));
LocalFree(hlocal)；
} else { SetDlgltemText(hwnd, IDC_ERRORTEXT, TEXT("No text found for this error number."));
上述代码中，第一行从编辑控件获取错误代码。然后，指向一个内存块的句柄被实例化并 初始化为NULL。FormatMessage函数在内部分配一块内存，并返回指向这块内存的句柄。
调用 FormatMessage 时，我向它传入了 FORMAT_MESSAGE_FROM_SYSTEM 标志。
该标志告诉FormatMessage：我们希望获得与一个系统定义的错误代码对应的字符串。另 夕卜，还传入了 FORMAT_MESSAGE_ALLOCATE_BUFFER标志，要求该函数分配一块 足以容纳错误文本描述的内存。此块内存的句柄将在hlocal变量中返回。
FORMAT_MESSAGEJGNOREJNSERTS标志则允许我们获得含有％占位符的消息。这 些占位符将被Windows用来提供更多上下文相关信息，如下图所示。
第1章错误处理
Error: 10目	| Look up ] BQn top
Insert the diskette for drive X.
如果不传递这个标志，就必须在Arguments参数中提供这些占位符的值。但这对于Error Show程序来说是不可能的，因为消息的内容事先是未知的。
第三个参数指出想要查找的错误代码。第四个参数指出要用什么语言来显示文本描述。由 于我们对Windows本身所提供的消息感兴趣，所以将根据两个特定的常量（即 LANG_NEUTRAL和SUBLANG_NEUTRAL）来生成语言标识符，这两个常量联合到一起 将生成一个0值——即操作系统的默认语言。这种情况下，我们不能硬编码一种特定的语 言，因为事先并不知道操作系统的安装语言是什么。
如果FormatMessage成功，文本描述就在这块内存中，我把它复制到对话框底部的可滚动 窗口中。如果FormatMessage失败，我会尝试在NetMsg.dll模块中查找消息代码，看错误 是否与网络有关（有关如何在磁盘上搜索DLL的详情，请参见第20章）。利用NetMsg.dll 模块的句柄，我再一次调用FormatMessageo由此可见，每个DLL（或.exe）都可以有自己的 一套错误代码。我们也可以向自己的模块添加错误代码，具体做法是使用Message Compiler（MC.exe）来创建一个消息资源并将其添加到DLL（或.exe）模块中。Visual Studio的 Error Lookup工具允许我们使用Modules对话框来完成这个操作。
O
2.5	C运行库中的安全字符串函数
2.6	为何要用Unicode
2.7推荐的字符和字符串处理方式
2.8	Unicode与ANSI字符串转换
随着Microsoft Windows在世界各地日渐流行，作为软件开发人员，将眼光投向全球市场显 得越发重要。美国版本的软件在发布时间上比国际版本早6个月，这样的事情一度屡见不 鲜。但是，随着操作系统对国际化的支持日益增强，为国际市场发布软件产品变得越来越 容易，美国版本和国际化版本的软件在发布时间上的间隔变得越来越短。
Windows 一如继往地为开发人员提供支持，帮助他们本地化自己的应用程序。应用程 序可以通过各种函数来获得一个国家特有的信息，并能检查控制面板的设置来判断用 户当前的首选项。Windows甚至能为应用程序支持不同的字体。最后一点同时也是非 常重要的一点是，Windows Vista开始提供对Unicode 5.0的支持(详情参见“Extend The Global Reach Of Your Applications With Unicode 5.0” 一文，网址为 http://msdn.microsoft.com/ msdnmag7issues/O7/01 /Unicode/default.aspx)。
缓冲区溢出错误(这是处理字符串时的典型错误)已成为针对应用程序乃至操作系统的各个 组件发起安全攻击的媒介。这几年，Microsoft从内部和外部两个方面主动出击，倾尽全力 提升Windows世界的安全水平。本章将介绍Microsoft在C运行库中新增的函数。我们应 该使用这些新函数来防止应用程序在处理字符串时发生缓冲区溢出。
本章的位置之所以如此靠前，是由于我极力主张在应用程序始终使用Unicode字符串，而 且始终应该通过新的安全字符串函数来处理这些字符串。可以看出，与如何安全使用 Unicode字符串相关的问题在本书的每一章和每一个示例程序中都有涉及。如果源代码尚未 使用Unicode,最好能将源代码迁移至Unicode,这会增强应用程序的执行性能，并为本地 化工作奠定基础。另外，它还有利于同COM和.NET Framework的互操作。
11
第2章字符和字符串处理
2.1字符编码
一直以来，本地化的核心问题就是处理不同字符集的问题。多年来，我们一直在将文本字 符串编码成一组以0结尾的单字节字符。许多人对此已经习以为常。调用strlen,它会返回 “以0结尾的一个ANSI单字节字符数组”中的字符数。
问题是，某些语言文字系统(例如日本汉字)的字符集有非常多的符号。但一个字节最多只 能表示256个符号，这是远远不够的。为了支持这些语言文字系统，双字节字符集 (double-byte character set, DBCS)应运而生。在双字节字符集中，一个字符串中的每个字符 都由1个或2个字节组成。以日本汉字为例，如果第一个字符在0x81到0x9F之间，或者 在OxEO到OxFC之间，就必须检查下一个字节，才能判断出一个完整的汉字。对程序员而 言，和双字节字符集打交道如同一场噩梦，因为某些字符是1个字节宽，而有的字符却是 2个字节宽。幸运的是，我们可以把DBCS放到一边，专心利用Windows函数和C运行库 对Unicode字符串的支持。
Unicode是1988年由Apple和Xerox共同建立的一项标准。1991年，成立了专门的协会来 开发和推动 Unicodeo 该协会Ul Apple、Compaq> Hewlett-Packard、IBM、Microsoft、Oracle> Silicon Graphics、Sybase> Unisys和Xerox等多家公司组成(协会成员的最新列表可从 http://www.Unicode.org获得)。该组织负责维护Unicode标准。Unicode的完整描述可以参 考 Addison-Wesley 出版的 The Unicode Standard 一书，该书可通过 http://www.Unicode.org 获得。
在Windows Vista中，每个Unicode字符都使用UTF.16编码，UTF的全称是Unicode Transformation Format(Unicode转换格式)。UTF-16将每个字符编码为2个字节(或者说16 位)。在本书中，在谈到Unicode时，除非专门声明，否则一般都是指UTF-16编码。Windows 之所以使用UTF-16,是因为全球各地使用的大部分语言中，每个字符很容易用一个16位 值来表示。这样一来，应用程序很容易遍历字符串并计算出它的长度。但是，16位不足以 表示某些语言的所有字符。对于这些语言，UTF-16支持使用代理(surrogate),后者是用32 位(或者说4个字节)来表示一个字符的一种方式。由于只有少数应用程序需要表示这些语 言中的字符，所以UTF-16在节省空间和简化编码这两个目标之间，提供了一个很好的折 衷。注意，.NET Framework始终使用UTF-16来编码所有字符和字符串，所以在我们开发 的Windows应用程序中，如果需要在本机代码(native code)和托管代码(managed code)之间 传递字符或字符串，使用UTF-16能改进性能和减少内存消耗。
另外还有其他用于表示字符的UTF标准，具体如下。
• UTF-8 UTF-8将一些字符编码为1个字节，一些字符编码为2个字节，一些字符 编码为3个字节，一些字符编码为4个字节。值在0x0080以下的字符压缩为1个 字节，这对美国使用的字符非常适合。0x0080和0X07FF之间的字符转换为2个字 节，这对欧洲和中东地区的语言非常适用。0x0800以上的字符都转换为3个字节， 适合东亚地区的语言。最后，代理对(surrogate pair)被写为4个字节。UTF-8是一种
相当流行的编码格式。但在对值为0x0800及以上的大量字符进行编码的时候，不 如UTF.16高效。
• UTF-32 UTF-32将每个字符都编码为4个字节。如果打算写一个简单的算法来遍 历字符（任何语言中使用的字符），但又不想处理字节数不定的字符，这种编码方式 就非常有用。例如，如果采用UTF-32编码方式，就不需要关心代理（surrogate）的问 题，因为每个字符都是4个字符。显然，从内存使用这个角度来看，UTF-32并不 是一种高效的编码格式。因此，在将字符串保存到文件或传到网络的时候，很少会 用到这种格式。这种编码格式一般在应用程序内部使用。
目前，Unicode为阿拉伯语、汉语拼音、西里尔文（俄语）、希腊语、希伯来语、日语片假名、 朝鲜语和拉丁语（英语）字符 一这些字符称为文字符号（script—定义了码位（code point, 即一个符号在字符集中的位置）。每个版本的Unicode都在现有•的文字符号的基础上引入了 新的字符，甚至会引入新的文字符号，比如腓尼基文（一种古地中海文字）。字符集中还包 含大量标点符号、数学符号、技术符号、箭头、装饰标志、读音符号以及其他字符。
这65 536个字符被划分为若干个区域，表2-1展示了部分区域以及分配到这些区域的字符。
表2-1 Unicode字符集和字母表
6位代码	字符	16位代码	字母/书写符号
0000-007F	ASCH	O3OQ-O36F	常见的变音符号
0080-C0FF	西欧语系字母	0400-04FF	西里尔字母
0100-017F	欧洲拉丁字母	053Q-058F	亚美尼亚文
0180-0IFF	扩充拉丁字母	0590-05FF	希伯来文
0250-02AF	标准音标	0600-06FF	阿拉伯文
02B0-02FF	进格修饰字母	0900-097F	梵文字母
2.2	ANSI字符和Unicode字符与字符串数据类型
我们知道，C语言用char数据类型来表示一个8位ANSI字符。默认情况下，在源代码中 声明一个字符串时，。编译器会把字符串中的字符转换成由8位char数据类型构成的一个 数组：
// An 8-bit character
char c = •A'；
// An array of 99 8-bit. character and 8-bit terminating zero
char szBuffer[100] = "A String"；
Microsoft的C/C++编译器定义了 一个内建的数据类型wchar_t,它表示一个16位的Unicode （UTF.16）字符。因为早期版本的Microsoft编译器没有提供这个内建的数据类型，所以编译
第2章字符和字符串处理
器只有在指定了/Zc:wcharj编译器开关时，才会定义这个数据类型。默认情况下，在 Microsoft Visual Studio中新建一个C_h■项目时，这个编译器开关是指定的。建议始终指定 这个编译器开关，这样才能借助于编译器夭生就能理解的内建基元类型来更好地操纵 Unicode 字符。
说明 在编译器内建对wchar t的支持之前，有一个C头文件定义了一个wchar t数据类 型，如下所示：
typedef unsigned short wchar t；
声明Unicode字符和字符串的方法如下所示：
// A 16-bit character
wchar_t c = L*A*;
// An array up to 99 16-bit characters and a 16-bit terminating zero wchar_t szBuffer[100] = L"A String"；
字符串之前的大写字母L通知编译器该字符串应当编译为一个Unicode字符串。当编译器 将此字符串放入程序的数据段时，会使用UTF16来编码每个字符。在这个简单的例子中， 在每个ASCII字符之间都用一个0来加以区分。
为了与C语言稍微有一些区分，Windows开发团队希望定义自己的数据类型。于是，他们 在Windows头文件WinNT.h中定义了以下数据类型：
typedef char CHAR； //An 8-bit character
typedef wchar_t WCHAR； // A 16-bit character
除此之外，WinNT.h头文件还定义了一系列能为我们提供大量方便的数据类型，可以用它 来处理字符指针和字符串指针：
// Pointer to 8-bit character(s)
typedef CHAR *PCHAR;
typedef CHAR *PSTR;
typedef CONST CHAR *PCSTR
// Pointer to 16-bit character(s)
typedef WCHAR *PWCHAR;
typedef WCHAR *PWSTR;
typedef CONST WCHAR *PCWSTR;
说明 仔细查看WinNT.h头文件，会看到如下定义：
typedef _nullterminated WCHAR *NWPSTR, *LPWSTR, *PWSTR;
前缀_nullterminated是一个头部注解(header annotation),它描述了 一个类型如 何用作函数的参数和返回值。在Visual Studio企业版中，可以在项目属性中设置 代码分析(Code Analysis)选项。这样会把/analyze开关添加到编译器的命令行中。 这样一来，假如我们的代码调用函数的方式违反头部注解所定义的语义，编译器 就会检测到这类问题。注意，只有编译器的企业版才支持这个/analyze开关。为 保证本书所提供的代码的可读性，所有头部注解都已被删除。要想更多地了解

fl^^dows核心编程(第5版) .
header annotation 语言，请参考 MSDN 文档 "Header AnnotationsM ,网址是 http://msdn2.microsoft.com/En-US/library/aa383701.aspXo
在源代码中，具体使用哪种数据类型并不重要，但最好能保持一致，以增强代码的可维护 性。就我个人而言，作为Windows程序员，我会坚持使用Windows数据类型，因为这些 数据类型与MSDN文档相符，有利于增强代码的可读性。
另外，在写代码的时候，可以使用ANSI或Unicode字符/字符串使其能够通过编译。WinNT.h 定义了以下类型和宏：
#ifdef UNICODE
typedef WCHAR TCHAR, *PTCHAR, PTSTR;
typedef CONST WCHAR *PCTSTR;
#define _TEXT(quote) quote // r_winnt
#define _TEXT(quote) L##quote
#else
typedef CHAR TCHAR, *PTCHAR, PTSTR;
typedef CONST CHAR *PCTSTR;
#define _TEXT(quote) quote
#endif
ttdefine TEXT(quote) _TEXT(quote)
利用这些类型和宏(少数不太常用的没有在这里列出)来写代码，无论使用ANSI还是 Unicode字符，它都能通过编译。如下所示：
//If UNICODE defined, a 16-bit character； else an 8-bit character
TCHAR c = TEXT('A');■
// If UNICODE defined, an array of 16-bit character； else 8-bit character
TCHAR szBuffer[100] = TEXT("A String")；
2.3	Windows中的Unicode函数和ANSI函数
自Windows NT起，Windows的所有版本都完全用Unicode来构建。也就是说，所有核心 函数（创建窗口、显示文本、进行字符串处理等等）都需要Unicode字符串。调用Windows 函数时，如果向它传入一个ANSI字符串（由单字节字符组成的一个字符串），那么函数首先 会把字符串转换为Unicode,再把结果传给操作系统。如果希望函数返回ANSI字符串，那 么操作系统会先把Unicode字符串转换为ANSI字符串，再把结果返回给我们的应用程序。 所有这些转换都是在幕后进行的。当然，为了执行这些字符串转换，系统会产生时间和内 存上的开销。
如果一个Windows函数的多数列表中有字符串，则该函数通常有两个版本。例如，一个
第2章字符和字符串处理
CreateWindowEx 接受 Unicode 字符串，另一个 CreateWindowEx 则接受 ANSI 字符串。 虽然事实如此，但两个函数的原型实际如下：
HWND WINAPI CreateWindowExW(
DWORD dwExStyle,
PCWSTR pClassName, // A Unicode string
PCWSTR pWindowName, // A Unicode string
DWORD dwStyle,
int X,
int Y,
int nWidth,
int nHeight,
HWND hWndParent,
HMENU hMenu,
HINSTANCE hlnstance,
PVOID pParam);
HWND WINAPI CreateWindowExA(
DWORD dwExStyle,
PCSTR pClassName, // An ANSI string
PCSTR pWindowName, // An ANSI string
DWORD dwStyle,
int X,
int Y,
int nwidth,
int nHeight,
HWND hWndParent,
HMENU hMenu,
HINSTANCE hlnstance,
PVOID pParam);
CreateWindowExW这个版本接受Unicode字符串。函数名末尾的大写字母W代表wide。 Unicode字符都是16位宽,所以它们常常被称作宽(wide)字符。CreateWindowExA末尾的 大写字母A表明该函数接受ANSI字符串。
但在平时，我们只是在自己的代码中调用CreateWindowEx ,不会直接调用 CreateWindowExW 或 CreateWindowExA。在 WinUser.h 中，CreateWindowEx 实际是一 个宏，它的定义如下：
#ifdef UNICODE
#define CreateWindowEx CreateWindowExW
#else
#define CreateWindowEx CreateWindowExA
ttendif
编译源代码模块时，是否定义UNICODE决定着要调用哪一个版本的CreateWindowEx。 用Visual Studio创建一个新项目的时候，它默认会定义UNICODE。所以，在默认情况下， 对CreateWindowEx的任何调用都会将这个宏扩展为CreateWindowExW-------------即Unicode
版本的 CreateWindowEx。
在 Windows Vista 中，CreateWindowExA 的源代码只是一个转换层(translation layer),它负 责分配内存，以便将ANSI字符串转换为Unicode字符串。然后，代码会调用 CreateWindowExW ,并向它传递转换后的字符串。CreateWindowExW 返回时， CreateWindowExA会释放它的内存缓冲区，并将窗口句柄返回。所以，对于要在缓冲区中 填充字符串的任何函数，在应用程序能够处理字符串之前，系统必须先将Unicode字符串 转换为非Unicode形式。由于系统必须执行所有这些转换，所以应用程序需要更多内存，
e
indows核心编程（第5版）
而且运行速度较慢。为了使应用程序的执行更高效，一开始应该就用Unicode来开发程序。 另外，目前己知Windows的这些转换函数中存在一些bug,所以避免使用它们还有助于消 除一些潜在的bugo	一
如果是在创建供其他软件开发人员使用的动态链接库（dynamic-link library, DLL）,可考虑 使用这种技术：在DLL中提供导出的两个函数，一个ANSI版本的，一个Unicode版本的。 在ANSI版本中，只是分配内存，执行必要的字符串转换，然后调用该函数的Unicode版 本。我将在本章的2.8.1节“导出ANSI和Unicode DLL函数”演示这个过程。
Windows API中的一些函数（如WinExec和OpenFile）存在的唯一目的就是为了向后兼容16 位Windows程序，因为后者只支持ANSI字符串。在开发的新程序中，应避免使用这些函 数。在使用WinExec和OpenFile调用的地方，应该用CreateProcess和CreateFile函数调 用来代替。在内部，老函数总是会调用新函数。但老函数的最大问题在于，它们不接受 Unicode字符串，血且支持的功能一般都要少一些。调用这些函数的时候，必须向其传递 ANSI字符串。在Windows Vista中，大部分尚未废弃的函数都有Unicode和ANSI两个版 本。然而，Microsoft逐渐开始倾向于某些函数只提供Unicode版本，如 ReadDirectoryChangesW 和 CreateProcessWithLogonW.
Microsoft将COM从16位Windows移植到Win32时，做出了一个重要决策：所有•需要字 符串作为参数的COM接口方法都只接受Unicode字符串。这是一个明智的决策，因为 COM 一般用于让不同的组件彼此间进行“对话”，而Unicode是传递字符串最理想的选择。 在应用程序中全面使用Unicode,可以使它与COM的交互变得更容易。
最后，当资源编译器编译完所有资源后，输出文件就是资源的一个二进制形式。资源中的 字符串值（字符串表、对话框模板、菜单等）始终是以Unicode字符串的形式保存的。在 Windows Vista中，如果应用程序没有定义UNICODE宏，那么操作系统将执行内部转换。 例如，在编译源模块时，如果没有定义UNICODE,那么对LoadString的调用实际会调用 LoadStringA函数。然后，LoadStringA读取资源中的Unicode字符串，并把它转换成ANSI 形式。最后，函数将转换为ANSI形式的字符串返回应用程序。
2.4	C运行库中的Unicode函数和ANSI函数
和Windows函数一样，C运行库提供了一系列函数来处理ANSI字符和字符串，并提供了 另一系列函数来处理Unicode字符与字符串。然而，与Windows不同的是，ANSI版本的 函数是“自力更生”的:它们不会把字符串转换为Unicode形式,再从内部调用函数的Unicode 版本。当然，Unicode版本的函数也是“自力更生”的，它们不会在内部调用ANSI版本。
在C运行库中，strlen就是一个能返回ANSI字符串长度的函数。与之对应的是wcslen, 这个C运行库函数能返回Unicode字符串的长度。
C7
第2章字符和字符串处理
这两个函数的原型都在String.h中。为了使源代码既能用ANSI编译，又能用Unicode编译, 还必须包含TChar.h,该文件定义了以下宏：
#ifdef .UNICODE
#define _tcslen	wcslen
#else
#define _tcslen	strlen
#endif
现在，应该在代码中调用_tcsleno如果已经定义了.UNICODE,它会扩展为wcslen；否则， 它会扩展为strleno默认情况下，在Visual Studio中新建一个Ci•项目时，己经定义了 _UNICODE（就像已经定义了 UNICODE 一样）。针对不属于C++标准一部分的标识符，C 运行库始终会为它们附加下划线前缀。但是，Windows团队并没有这样做。所以，在应用 程序中，应确保要么同时定义了 UNICODE和.UNICODE,要么一个都不要定义。附录A 将详细描述CmnHdr.h,本书所有示例代码都将用这个头文件来避免这种问题。
2.5	C运行库中的安全字符串函数
任何修改字符串的函数都存在一个安全隐患：如果目标字符串缓冲区不够大，无法容纳所 生成的字符串，就会导致内存中的数据被破坏（memory corruption）o下面是一个例子：
// The following puts 4 characters in a
// 3-character buffer, resulting in memory corruption
WCHAR szBuffer[3] = L"■;
wcscpy（szBuffer, L"abc"）； // The terminating 0 is a character too!
strcpy和wcscpy函数（以及其他大多数字符串处理函数）的问题在于，它们没有收到指定了 缓冲区最大长度的参数。所以，函数不知道自己会破坏内存。因为不知道会破坏内存，所 以也不会向应用程序报告错误。其结果便是，因为不知道出错，所以我们不知道内存已经 被破坏。另外，如果函数只是简单地失败，而不是破坏任何内存，那是最理想不过的了。
过去，这种行为被恶意软件肆意滥用。现在，Microsoft提供了一系列新的函数来取代C运 行库的不安全的字符串处理函数（如wcscat）o虽然多年以来，这些函数已经成为许多开发 人员的老朋友，但为了写安全的代码，我们应该放弃这些熟悉的、能修改字符串的C运行 库函数（不过，strlen> wcslen和_tcslen等函数是没有问题的，因为它们不会修改传入的字 符——即使它们假设字符串是以0来终止的，而这个假设有时并不一定成立）。相反，应该 使用在Microsoft的StrSafe.h文件中定义新的安全字符串函数。
说明 Microsoft已对ATL和MFC类库的内部实现进行了更新，以使用新的安全字符串函 数。如果我们的应用程序使用了这些库，那么只需重新构建一下应用程序，就能让 它变得更安全。
因为本书不是专门讨论C/C++编程的，所以要想深入了解这个库的用法，推荐参考以下信 息来源。

Mndows核心编程（第5版）
•	MSDN Magazine 的一篇文章，题为 “Repel Attacks on Your Code with the Visual Studio 2005 Safe C and C++ Librariesn ,作者是 Martyn Lovell,网址如下： http://msdn.microsoft.com/msdnmag/issues/05/05/SafeCandC/default.aspXo
•	Channel9的Martyn Lovell视频演示，网址如下：
http ://channeI9.msdn.com/Showpost.aspx?postid=l 86406 o
•	MSDN Online的有关安全字符串的主题，网址如下： http://msdn2.microsoft.com/en-us/library/ms647466.aspxo
•	MSDN Online上的所有C运行库安全替代函数的列表，网址如下： http ://msdn2.microsoft.com/en-us/library/wd3wzwts（VS.80）.aspXo
不过，有一些细节值得在本章进行探讨。首先要讨论新函数采用的模式。然后要谈谈从遗 留函数迁移到对应的安全版本时（比如使用_tcscpy_s来代替_tcscpy）可能会遇到的一些问 题。最后谈谈应该在哪种情况下调用新的StringC*函数。
2.5.1初识新的安全字符串函数
在应用程序中包含StrSafe.h时，String.h也会被包含进来。C运行库中现有的字符串处理函 数（如_tcscpy宏后的那些函数）己被标记为废弃不用。如果使用了这些函数，编译时就会发 出警告。注意，必须在包含其他所有文件之后才包含StrSafe.ho建议利用编译警告来明确 地用安全版本来替换废弃不用的所有函数。每一次替换的时候，都考虑一下是否可能发生 缓冲区溢出；另外，如果不可能从错误中恢复，至少应该考虑如何优雅地终止应用程序。
现有的每一个函数（如_tcscpy或_tcscat）,都有一个对应的新版本的函数。前面的名称相同, 但最后添加了一个_s（代表secure）后缀。所有这些新函数都有一个共同的特征，这有待我 们进一步解释。首先，让我们根据以下这段代码来研究一下它们的原型。在以下这段代码 中，展示了两个普通的字符串函数的定义：
PTSTR _tcscpy （PTSTR strDestination, PCTSTR strSource）；
errno_t _tcscpy_s（PTSTR strDestination, size_t numberOfCharacters,
PCTSTR strSource）;
PTSTR _tcscat （PTSTR strDestination, PCTSTR strSource）；
errao_t _tcscat_s（PTSTR strDestination, size_t numberOfcharacters,
PCTSTR strSource）;
在将一个可写的缓冲区作为参数传递时，必须同时提供它的大小。这个值应该是一个字符 数。通过对缓冲区使用.countof宏（在stdlib.h中定义），我们很容易计算出这个值。
所有安全（后缀为_s）函数的首要任务是验证传给它们的参数值。要检查的项目包括指针不为 NULL,整数在有效范围内，枚举值是有效的，而旦缓冲区足以容纳结果数据。如果这些 检查中的任何一项失败，函数都会设置局部于线程的C运行时变量errnoc然后，并返回 一个errnoj值来指出成功或失败。然而，这些函数并不实际返回①。相反，如果是一次调
①译注：如果指定自己的处理函数，那么这些函数是可以返回的。
第2章字符和字符串处理
试版构建(debug build),它们会显示如图2-1所示的一个对用户不太友好的Debug Assertion Failed对话框。然后，终止应用程序进行。如果是发行版构建(release build),则直接自动终 止应用程序的运行。
19-20
矿―一 一一一E豆云二二.	一E
Debug Assertion Failed!
Program:...
File: .\tcjcpy_s.ini
Line: 30
Expression: (L'Buffer is too small" && 0)
For information on how your program can cause an assertion failure, see the Visual C + + documentation on asserts.
(Pre$5 Retry to debug the application)
I	地。底	I I 吟 J R Ignore
图2-1 遇到错误时显示的Debug Assertion Failed对话框
C运行时实际上允许我们提供自己的函数，这样一来，在它检测到一个无效参数时，就会 调用此函数。然后，在这个函数中，我们可以记录失败，附上一个调试器，或者做其他我 们想做的其他事情。为了启用这个功能，必须先定义好一个函数，其原型如下：
void InvalidParameterHandler(PCTSTR expression, PCTSTR function,
PCTSTR file, unsigned int line, uintptr_t /*pReserved*/);
其中，参数expression描述了 C运行时实现代码中可能出现的函数调用失败，比如(『Buffer is too small” &&0)。可以看出，这种方式也不是用户友好的，不应该向最终用户显示。后 而三个参数同样如此，因为function、file和line分别描述了出现了错误的函数名称、源代 码文件和源代码行号。
说明如果没有定义DEBUG,所有这些参数的值都将为NULL.因此，只有在测试调试 版构建时，才适合用这个处理值来记录错误。在发行版构建中，应该用一条对用户 更友好的消息来替换Debug Assertion Failed对话框，指出由于发生了非预期的错误， 所以应用程序将被迫关闭—— 许还可以将错误记入日志，或者重新启动应用程序. 如果应用程序的内存状态被破坏，就应该停止执行应用程序。不过，最好还是等检 查了 ernio t之后，再判断是否能从错误中恢复。
下一步是调用_setjnvalid__parameterjiandler来注册这个处理程序。然而，仅仅这一步是 不够的，因为Debug Assertion Failed对话框仍会出现。我们要在应用程序开头的地方调用 _CrtSetReportMode(_CRT_ASSERT, 0);,从而禁止可能由C运行时触发的所有Debug Assertion Failed 对话框。
现在，我们在调用String.h中定义的一个遗留函数的替代函数时，就可以检查返回的errno_t 值，了解发生了什么事情。只有返回S_OK值，才表明函数调用是成功的。其他可能的返
e

indows核心编程（第5版）
回值在errno.h中有定义；例如，EINVAL指出我们传递了无效的参数值（比如NULL指针）。
20-21 瀚
下面以一个字符串为例。我们要把它复制到一个缓冲区中，但这个缓冲区的长度刚好就小 一个字符：
TCHAR szBefore[5] = (
TEXT('B'), TEXT(1B'), TEXT(B), TEXT('B1), '\0' )；
TCHAR szBuffer(10] = (
TEXTTEXT
TEXTTEXT
TEXT(*-•), TEXT('- *), TEXT('-•), TEXT,
TEXT('-•), •\o*
TCHAR szAfter[5] = (
TEXT(1A1), TEXT('A'), TEXT(1A *), TEXT('A'), *\0, )；
errno_t result = _tcscpy_s(szBuffer, _countof(szBuffer), TEXT(°0123456789-));
调用_tcscpy_s前，每个变量都有如图2-2所示的内容。
'Watch 1		■却X
| Name	Value	[Type	*
5)。szBefore	0x0012f9f4 MB8B8"	Q ▼ wcharj [5]
国。szBuffer	0x0012f9d8 M	"	Q ▼ wcharjt [10]
国 0 szAfter	0X0012F9C4 "AAAA11	Q ▼ wchar_t ⑸ ▼
图2・2调用_tcscpy_s之前变量的状态
将字符串”1234567890”复制到szBufFer,后者正好10个字符长，所以没有足够的空间来复 制最后的终止字符，\0，。读者也许认为result的值现在为STRUNCATE,最后一个字符9 没有被复制，但实情并非如此。实际返回的结果是ERANGE,每个变量的状态如图2-3 所示。
Watch 1	y	■ 4x
Name	Value	J Type	▲
(±) 0 szBefore	0x0012f9f4 "BB8BM	Q ▼ wchar_t [5]
国 Q szBuffer	0x0012f9d8 "*•	Q ▼ wchar_t [10]
EE) < szAfter	0x0012f9c4 "AAAA"	Q ▼ wchar_t [5] ▼
图2・3	调用Jcscpy_s之后变量的状态	
这里有一个副作用，不查看如图2»4所示的szBuffer后的内存，我们是看不出来的。
Mem 叫 1
Address: 0x0012F9D8
▼㈣! Columns: Auto

0x00IZF9D8
0x001ZF9F3
0xG012FA0E
GxOO12FA29
oo
cc
40
0c
00 fd fd fd
42 00 42 00
00 11 01 00
06 00 00 00
fd
42
00
00
fd fd fd
00 42 00
00 00 00
00 11 01
id fd fd fd id fd fd fd fd td cc 00 00 cc cc cc cc cc cc 6b tc c3 8e 00 40 fa 12 00 IS 27 40 00 04 0c OS 00 00 cc cc cc cc cc cc cc cc 11 01
cc
18
00
00
cc
• 9
00
cc
00
00
fa
as iB.B.B.B...iiiiiikuX2
52 9.........眼
00 ...........iiiiiiii...
图2』
函数调用失败之后szBuffer内存中的内容
第2章字符和字符串处理
szBuffer的第一个字符被设为，\0，，其他所有字节现在都包含值Oxfd。因此，最终的字符串 被截断为一个空字符串，缓冲区剩余的所有字节都已经被设为一个填充符(Oxfd)。
说明 在图2.4中，为什么每个变量后的内存都会被填充为Oxcc这个值呢？答案是，这是 编译器执行运行时检查(/RTCs, /RTCu或/RTC1)的结果，它们会在运行时自动检测 缓冲区溢出。如果不用这些/RTCx标志来编译代码，在内存视图中，就会一个接一 个地显示所有sz*变量。但记住，在构建应用程序时，应该始终要求编译器执行运 行时检查，这样才能在开发周期内，尽早检测到任何缓冲区溢出。
2.5.2在处理字符串时如何获得更多控制
除了新的安全字符串函数，c运行库还新增了一些函数，用于在执行字符串处理时提供更 多控制。例如，我们可以控制填充符，或者指定如何进行截断。自然，c运行库同时为这 些函数提供了 ANSI(A)版本和Unicode(W)版本。其中部分函数的原型如下(还存在更多类似 的函数，在此没有列出)：
HRESULT StringCchCat(PTSTR pszDest, size_t cchDest, PCTSTR pszSrc);
HRESULT StringCchCatEx(PTSTR pszDest, size_t cchDest, PCTSTR pszSrc,
PTSTR *ppszDestEnd/ size_t *pcchRemaining, DWORD dwFlags);
HRESULT StringCchCopy(PTSTR pszDest, size_t cchDest, PCTSTR pszSrc)；
HRESULT StringCchCopyEx(PTSTR pszDest, size_t cchDest, PCTSTR pszSrc,
PTSTR *ppszDestEnd, size_t *pcchRemaining, DWORD dwFlags)；
HRESULT StringCchPrintf(PTSTR pszDest, size_C cchDest,
PCTSTR pszFormat,...);
HRESULT StringCchPrintfEx(PTSTR pszDest, size_t cchDest,
PTSTR *ppszDestEnd, size_t *pcchReinaining, DWORD dwFlags,
PCTSTR pszFormat,...);
可以看出，在所有方法的名称中，都含有一个“Cch” o这表示Count of characters,即字 符数；通常使用.countof宏来获取此值。另外还有一系列名称中含有“Cb”的函数，比如 StringCbCat(Ex), StringCbCopy(Ex)和 StringCbPrintf(Ex)。这些函数要求用字节数来指 定大小，而不是用字符数；通常使用sizeof操作符来获取此值。
所有这些函数返回一个HRESULT,具体的值如表2・2所示。
表2・2安全字符串函数的HRESULT值
HRESULT值	描述
S OK	成功。目标缓冲区中包含源字符串，并以，\0,终止
STRSAFE E INVALID PARAMETER	失败。将NULL值传给了一个参数
STRSAFE E INSUFFICIENT BUFFER	失败。指定目标缓冲区太小，无法容纳整个源字符串
不同于安全(后缀为_s)的函数)，当缓冲区太小的时候，这些函数会执行截断。为了判断是 否发生这种情况，我们可以检测是否返回了 STRSAFE E INSUFFICIENT BUFFERo从
的dows核心编程（第5版） 
StrSafe.h中可以看出，此代码的值是0x8007007a,被SUCCEEDED/FAILED宏定义成失 败。然而，在这种情况下，源缓冲区中可以装入目标可写缓冲区中的那一部分会被复制， 而且最后一个可用的字符会被设为'\0'。所以，在前面的例子中，如果用StringCchCopy来 替代_tcscpy_s,那么szBuffer将包含字符串”012345678”。注意，“截断”这个功能可能是、 也可能不是亟们希望的，具体取决于我们想达到什么目标。这是为什么它会被视为失败的 原因（默认情况下）。例如，如果想连接两个字符串来生成一个路径，那么截断后的结果是 无法使用的。相反，如果是在生成一条反馈给用户的消息，这或许也能够接受。如何处理 被截断的结果，完全由我们自己来决定。
最后但同时也是很重要的一点是，前面出现的许多函数都存在一个扩展（Ex）版本。这些扩 展版本有三个额外的参数，详见表2.3。
	表2・3扩展版本的参数
参数与值	描述
size_t* pcchRemaining	指向一个变量的指针，该变量表示目标缓冲区中还有多少字符 尚未使用。复制的终止字符'\0,不计算在内。例如，如果~个字 符被复制到一个10字符长的缓冲区中，那么返回的结果会是9 —虽然在不截断的情况下，最多只能使用8个字符。如果 pcchRemaining为NULL,就不返回计数
LPTSTR* ppszDestEnd	如果ppszDestEnd不为NULL,它将指向终止字符该字符 位于目标缓冲区所包含的那个字符串的末尾
DWORD dwFlags	由“|"分隔的一个或多个以下值
STRSAFE_FILL_BEHIND_NULL	如果函数成功，dwFlags的低字节用于填充目标缓冲区的剩余 部分（也就是终止字符地'之后的部分）。欲知详情，请参见此表 之后对STRSAFE FILL BYTE的讨论
STRSAFE IGNORE NULLS	把NULL字符串指针视为空字符串（TEXT（””）
STRSAFE_HLL_ON_FAILURE	如果函数失败，就用dwFlags的低字节来填充整个目标缓冲 区，但目标缓冲区的最后一个字符会被设为，\（r,从而确保 结果是一个空字符串。欲知详情，请参见此表之后对 STRSAFE_FILL_BYTE的讨论。如果失败的原因是 STRSAFE_E_INSUFFICIENT_BUFFER,那么在返回的字符 串中，所有字符都会被替换成填充符
STRSAFE_NULL_ON_FAILURE	如果函数失败，就将目标缓冲区的第一个字符设为从而定 义一个空字符串（TEXT（””））。如果失败的原因是 STRSAFE_E_INSUFFICIENT_BUFFER,那么所有截断后的 字符串都会被覆盖
STRSAFE_NO_TRUNCATION	和STRSAFE_NULL_ON_FAILURE的情况一样，如果函数失 败，就把目标缓冲区设为空字符串（TEXT（””））。如果失败的原 因是 STRSAFE_E_INSUFFICIENT_BUFFER,所有截断后的 字符串都会被覆盖
第2章 字符和字符串处理
说明 即使指定了 STRSAFE_NO_TRUNCATION标志，源字符串的字符仍然会被复制—— 直至目标缓冲区的最后一个可用字符。然后，目标缓冲区的第一个和最后一个字符 都被设为，\0\除非是出于对安全性的考虑(而不想保留垃圾数据)，否则这个问题并 不重要。
最后要提到的一个细节与前面说过的“填充符”(filler)有关。在图2-4中，Oxfd这个填 充符替换了，\0,之后的所有字符——直至目标缓冲区的末尾。使用这些函数的Ex版本， 我们可以决定是否执行这种开销较大的填充操作(尤其是在目标缓冲区很大的时候)，以 及用什冬字节值来作为填充符使用。如果将STRSAFE_FILL_BEHIND_NULL加入到 dwFlag ,剩余的字符会被设为 W。如果用STRSAFE_FILL_BYTE宏来替代 STRSAFE_FILL_BEHIND_NULL,那么函数会用指定的字节来填充目标缓冲区中剩余的 部分。
2.5.3	Windows字符串函数
Windows也提供了各种字符串处理函数。其中许多函数(比如Istrcat和Istrcpy)已经不赞成 使用了，因为它们无法检测缓冲区溢出问题。与此同时，ShlwApi.h定义了大量方便好用的 字符串函数，可以用来对操作系统有关的数值进行格式化操作，比如StrFormatKBSize和 StrFormatByteSize。有关shell字符串处理函数的描述，可访问以下网址： http://msdn2.microsoft.com/en-us/Iibrary/ms538658.aspXo
我们经常都要比较字符串以进行相等性测试或者进行排序。为此，最理想的函数是 CompareString(Ex)和CompareStringOrdinaL对于需要以符合用户语言习惯的方式向用 户显示的字符串，请用CompareString(Ex)进行比较。CompareString函数的原型如下： int CompareString(
LCID locale,
DWORD dwCmdFlags,
PCTSTR pStringl,
int cchl,
PCTSTR pString2,
int cch2)；
这个函数对两个字符串进行比较。CompareString的第一个参数指定一个区域设置ID (locale ID, LCID),这是一个32位值，用来标识一种语言。CompareString使用这个LCID 来比较两个字符串，具体做法是检查字符在LCID所标识的语言中的含义。以符合当地语 言习惯的方式来比较，得到的结果对最终用户来说更有意义。不过，这种比较比基于序数 的比较(ordinal comparison)慢。我们可以调用Windows函数GetThreadLocale来得到主调 线程的LCID：
LCID GetThreadLocale()；
CompareString的第二个参数是一组标志，这些标志用于修改函数在比较字符串时采用的 方法。表2V展示了可能的标志。
因Vindows核心编程（第5版）
CompareString的其余4个参数指定了两个字符串及其各自的字符长度（字符数，而不是字 节数据）。如果为cchl参数传入负值，函数会假设pStringl字符串是以。来结尾的，并计 算字符串的长度；同样的道理也适用于cch2参数和pStringl字符串。如果需要更高级的 语言选项，那么应该考虑CompareStringEx函数。
表2V CompareString函数所用的标志
标志	含义
NORMJGNORECASE LINGUISTIC IGNORECASE	忽略大小写
NORM IGNOREKANATYPE	不区分平假名和片假名字符
NORMJGNORENONSPACE LINGUISTIC IGNOREDIACRITIC	忽略non-spacing字符③
NORMJGNORESYMBOLS	忽略符号
NORMJGNOREWIDTH	不区分同一个字符的单字节和双字节形式
SORT STRINGSORT	将标点符号当作符号来处理
为了比较程序内部所用的字符串(如路径名、注册表项/值、XML元素/属性等)，应该使用
CompareStringOrdinal,如下所示：
int CompareStringOrdinal(
PCWSTR pStringl,
int cchCountl,
PCWSTR pString2,
int cchCount2,
BOOL blgnoreCase);
由于这个函数执行的是码位（code-point）比较，不考虑区域设置，所以速度很快。另外，由 于程序内部所用的字符串一般不会向最终用户显示，所以在这种情况下，最适合使用这个 函数。注意，此函数只支持Unicode字符串。
CompareString和CompareStringOrdinal函数的返回值有别于C运行库的*cmp字符串比较 函数的返回值。CompareString（Ordinal）返回0表明函数调用失败，返回 CSTR_LESS_THAN（定义为 1）表明 pString 1 小于 pString2,返回 CSTR_EQUAL（定义为 2） 表明 pStringl 等于 pString2,返回 CSTR_GREATER_THAN（定义为 3）表明 pStringl 大于 pString2o为方便起见，如果函数成功，页们可以从返回值中减去2,从而使结果值与C运 行库函数的结果值（-1, 0和+1）保持一致。
<25
2.6为何要用Unicode
我强烈建议开发人员在开发应用程序的时候使用Unicode字符和字符串。具体理由如下。
①译注：non-spacing字符通常是一些读音符号.

第2章字符和字符串处理
•	Unicode有利于应用程序的本地化。
•	使用Unicode,只需发布一个二进制(.exe或DLL)文件，即可支持所有语言。
•	Unicode提升了应用程序的效率，因为代码执行速度更快，占用内存更少。Windows 内部的一切工作都是使用Unicode字符和Unicode字符串来进行的。所以，假如我 们坚持传入ANSI字符或字符串，Windows就会被迫分配内存，并将ANSI字符或 字符串转换为等价的Unicode形式。
•	使用Unicode,应用程序能轻松调用所有尚未弃用(nondeprecated)的Windows函数, 因为一些Windows函数提供的版本只能处理Unicode字符和字符串。
•	使用Unicode,应用程序的代码很容易与COM集成(后者要求使用Unicode字符和 Unicode字符串)。
•	使用Unicode,应用程序的代码很容易与.NET Framework集成(后者要要求使用 Unicode字符和Unicode字符串)。
•	使用Unicode，能保证应用程序的代码能够轻松操纵我们自己的资源(其中的字符串 总是Unicode形式的)。
2.7推荐的字符和字符串处理方式
基于本章到目前为止的内容，本节首先要总结开发代码时始终要牢记的几点。接下来要提 供一些提示与技巧，以更好地处理Unicode和ANSI字符串。最好现在就将应用程序转换 为支持Unicode的形式，即使当前并不计划立即开始使用Unicode字符。应该遵循的基本 准则如下。
•	开始将文本字符串想象为字符的数组，而不是char或字节的数组。
•	用通用数据类型(如TCHAR/PTSTR)来表示文本字符和字符串。
•	用明确的数据类型(如BYTE和PBYTE)来表示字节、字节指针和数据缓冲区。
•	用TEXT或_T宏来表示字面量字符和字符串，但为了保持一致性和更好的可读性， 请避免两者混用。
•	执行全局替换。(例如，用PTSTR替换PSTR)O
•	修改与字符串有关的计算。例如，函数经常希望我们传给它缓冲区大小的字符数， 而不是字节数。这意味着我们应该传入__countof(szBuffer)^而不是sizeof(szBuffer)。 而且，如果需要为一个字符串分配一个内存块，而且知道字符串中的字符数，那么 要记住内存是以字节来分配的。这意味着我们必须调用malloc(nCharacters* sizeof(TCHAR)),而不是调用malloc(nCharacters)o在前面列出的所有基本准则中， 这是最难记住的一条，而且如果出错，编译器不会提供任何警告或错误信息。所以， 最好定义一个宏来避免犯错：
#define chmalloc(nCharacters) (TCHAR*)malloc(nCharacters * sizeof(TCHAR)).
•	避免使用printf系列函数，尤其是不要用％s和％，字段类型来进行ANSI与 Unicode字符串之间的相互转换。正确的做法是使用MultiByteToWideChar和

Windows核心编程（第5版）
WideCharToMultiByte函数，详情参见后面的2.8节“Unicode与ANSI字符串转 换”。
•	UNICODE和_UNICODE符号要么同时指定，要么都不指定。
对于字符串处理函数，应该遵循以下基本准则。
•	始终使用安全的字符串处理函数，比如后缀为_s的函数，或者前缀为StringCch的 函数。后者主要在我们想明确控制截断的时候使用：如果不想明确控制截断，则首 选前者。
•	不要使用不安全的C运行库字符串处理函数（参见前面的建议）。一般情况下，如果
一个缓冲区处理函数的参数中不包括目标缓冲区的长度，那么我们应该避免使用这 样的函数，同时还应避免自己实现这样的函数，C运行库为缓冲区处理提供了一系 列替代函数，比如 memcpy_s, memmove_s, wmemcpy_s 或 wmemmove_s。只要 定义了 _STDC_WANT_SECURE_LIB_符号，所有这些方法都是可用的； CrtDefs.h默认定义了此符号。所以，不要取消对_STDC_WANT_SECURE_LIB_ 的定义。	一
•	利用/GS （http://msdn2.microsoft.com/en-us/library/aa290051 （VS.71 ）.aspx）和/RTCs 编 译器标志来自动检测缓冲区溢出。
•	不要用Kernel32方法来进行字符串处理，比如Istrcat和Istrcpy。
•	在应用程序的代码中，需要要比较两种字符串。其中，程序字符串包括文件名、 路径、XML元素/属性以及注册表项/值等。对于这些字符串，应使用 CompareStringOrdinal来进行比较。因为它非常快，而且不会考虑用户的区域设 置。这是完全合理的，因为不管程序在世界上的什么地方运行，这种字符串都是不 变的。用户字符串则一般要在用户界面上显示。对于这些字符串，应使用 CompareString（Ex）^比较，因为在比较字符串的时候，它会考虑用户的区域设置。
我们别无选择：作为专业开发人员，我们不能基于不安全的缓冲区处理函数来写代码。正 是这个原因，本书所有代码都是使用C运行库中的这些更安全的函数来写的。
2.8	Unicode与ANSI字符串转换
我们使用Windows函数MultiByteToWideChar将多字节字符串转换为宽字符字符串。 如下所示：
int MultiByteToWideChar( UINT uCodePage, DWORD dwFlags, PCSTR pMultiByteStr, int cbMultiByte, PWSTR pWideCharStr, int cchWideChar)；
uCodePage参数标识了与多字节字符串关联的一个代码页值。dwFlags参数允许我们进行 额外的控制，它会影响带变音符号（比如重音）的字符。但是，一般情况下都不使用这些标 志，所以传给dwFlags参数的值是0（要想进〜步了解可以向这个标志传入哪些值，请阅读
第2章字符和字符串处理
MSDN 联机帮助，网址是 http://msdn2.microsoft.com/en-us/library/ms776413.aspx)。 pMultiByteStr参数指定要转换的字符串，cbMultiByte参数指定字符串的长度(字节数)。 如果传给cbMultiByte参数的值是-1,函数便可自动判断源字符串的长度。
函数将转换所得的Unicode版本的字符串写入内存缓冲区，其内存地址由pWideCharStr 参数所指定。必须在cchWideChar参数中指定这个缓冲区的最大长度(字符数)。如果调用 MultiByteToWideChar,并给cchWideChar参数传入0,函数就不会执行转换，而是返回 一个宽字符数(包括终止字符W),只有当缓冲区能够容纳该数量的宽字符时，转换才会成 功。一般按照以下步骤将一个多字节字符串转换为Unicode形式。
(1)	调用 MultiByteToWideChar,为 pWideCharStr 参数传入 NULL,为 cchWideChar 参数 传入0,为cbMultiByte参数传入T。
(2)	分配一块足以容纳转换后的Unicode字符串的内存。它的大小是上一个 MultiByteToWideChar 调用的返回值乘以 sizeof(wchar_t)o
(3)	再次调用MultiByteToWideChar,这一次将缓冲区地址作为pWideCharStr参数的值传 入，将第一次MultiByteToWideChar调用的返回值乘以sizeoRwchar t)后得到的大小作 为cchWideChar参数的值传入。
(4)	使用转换后的字符串。
(5)	释放Unicode字符串占用的内存块。
对应地，WideCharToMultiByte函数将宽字符字符串转换为多字节字符串，如下所示：
int WideCharToMultiByte(
UINT uCodePage,
DWORD dwFlags,
PCWSTR pWideCharStr,
int cchWideChar,
PSTR pMultiByteStr,	.
int cbMultiByte,
PCSTR pDefaultchar,
PBOOL pfUsedDefaultChar);
这个函数类似于MultiByteToWideChar函数。同样地，uCodePage标识了要与新转换的字 符串关联的代码页。dwFlags参数允许我们指定额外的转换控制。这些标志会影响带变音 符号的字符和系统不能转换的字符。但我们一般不需要进行这种程度的转换控制，因而为 dwFlags参数传入0。
pWideCharStr参数指定要转换的字符串的内存地址，cchWideChar参数指出该字符串的 长度(字符数)。如果为cchWideChar参数传入-1,则由函数来判断源字符串的长度。
转换所得的多字节版本的字符串被写入pMultiByteStr参数所指定的缓冲区。必须在 cbMultiByte参数中指定此缓冲区的最大大小(字节数)。调用WideCharToMultiByte函数 时，如果将。作为cbMultiByte参数的值传入，会导致该函数返回目标缓冲区需要的大小。 将宽字符字符串转换为多字节字符串时，采取的步骤和前面将多字节字符串转换为宽字符 串的步骤相似：唯一不同的是，返回值直接就是确保转换成功所需的字节数，所以无需执
idows核心编程（第5版）
行乘法运算。	一__
28-29 »
注意，与MultiByteToWideChar函数相比，WideCharToMultiByte函数接受的参数要多 两个，分别是pDefauItChar和pfUsedDefaultChar。只有一个字符在uCodePage指定的代 码页中没有对应的表示时，WideCharToMultiByte函数才会使用这两个参数。在遇到一个 不能转换的宽字符时，函数便使用pDefauItChar参数指向的字符。如果这个参数为 NULL（这是很常见的一个情况），函数就会使用一个系统默认的字符。这个默认字符通常是 一个问号。这对文件名来说非常危险，因为问号是一个通配符。
pfUsedDefaultChar参数指向一个布尔变量；在宽字符字符串中，如果至少有一个字符不能 转换为对应的多字节形式，函数就会把这个变量设为TRUE。如果所有字符都能成功转换， 就会把这个变量设为FALSE。我们可以在函数返回后测试该变量，验证宽字符字符串是否 已成功转换。同样地，我们通常为此参数传入NULL值。
有关如何使用这些函数的更完整的描述，请参阅Platform SDK文档。
2.8.1	导出 ANSI 和 Unicode DLL 函数
使用上一节描述的这两个函数，可以轻松创建一个函数的Unicode版本和ANSI版本。例 如，假定我们有一个动态链接库，其中的一个函数能逆转字符串中的所有字符。可以像下 面这样写这个函数的Unicode版本：
BOOL StringReverseW(PWSTR pWideCharStr, DWORD cchLength) (
// Get a pointer to the last character in the string.
PWSTR pEndOfStr = pWideCharStr + wcsnlen_s(pWideCharStr , cchLength) - 1； wchar_t cCharT；
// Repeat until we reach the center character in the string.
while (pWideCharStr < pEndOfStr) (
// Save a character in a temporary variable.
cCharT = *pWideCharStr;
// Put the last character in the first character.
♦pWideCharStr = *pEndOfStr；
// Put the temporary character in the last character. ♦pEndOfStr = cCharT；
// Move in one character from the left. pWideCharStr++；
// Move in one character from the right. pEndOfStr--;
)
// The string is reversed； return success.
return(TRUE)；
)
另外，在写函数的ANSI版本时，可以让它根本不执行逆转字符串的实际工作。相反，在
第2章字符和字符串处理
ANSI版本中，只需让它将ANSI字符串转换成Unicode字符串，然后将Unicode字符串传 给刚才的StringReverseW函数，最后将逆转后的字符串转换回ANSI字符串。如下所示：
BOOL StringReverseA(PSTR pMultiByteStr, DWORD cchLength) ( PWSTR pWideCharStr； int nLenOfWideCharStr；
BOOL fOk = FALSE;
// Calculate the number of characters needed to hold
// the wide-character version of the string. nLenOfWideCharStr = MultiByteToWideChar(CP_ACPZ 0, pMultiByteStr, cchLength, NULL, 0)；
// Allocate memory from the process * default heap to // accommodate the size of the wide-character string.
// Don't forget that Mu11iByteTowideChar returns the // number of characters, not the number of bytes, so // you must multiply by the size of a wide character. pWideCharStr = (PWSTR)HeapAlloc(GetProcessHeap(), 0, nLenOfWideCharStr * sizeof(wchar_t));
if (pWideCharStr == NULL) return(fOk);
// Convert the multibyte string to a wide-character string. MultiByteToWideChar(CP_ACP, 0, pMultiByteStr, cchLength, pWideCharStr, nLenOfWideCharStr)；
// Call the wide-character version of this
// function to do the actual work.
fOk = StringReverseW(pWideCharStr, cchLength)；
if (fOk) (
// Convert the wide-character string back
// to a multibyte string.
WideCharToMultiByte(CP_ACP, 0, pWideCharStr, cchLength, pMultiByteStr, (int)strlen(pMultiByteStr), NULL, NULL);
// Free the memory containing the wide-character string. HeapFree(GetProcessHeap(), 0, pWideCharStr)；
return(fOk)；
最后，在随同动态链接库发布的头文件中，像下面这样提供两个函数的原型:
BOOL StringReverseW(PWSTR pWideCharStr, DWORD cchLength)；
BOOL StringReverseA(PSTR pMultiByteStr, DWORD cchLength)；
#ifdef UNICODE
#define StringReverse StringReverseW
#else
#define StringReverse StringReverseA
#endif // !UNICODE
2.8.2	判断文本是ANSI还是Unicode
Windows的记事本应用程序不仅能打开Unicode文件和ANSI文件，还能创建这两种文
I^^^dows核心编程（第5版）	一
件。来看看图2-5展示的记事本的Save As（另存为）对话框，请注意保存一个文本文件的不 同方式。
UmcodtbiQ endian UTF4

图2-5 Windows Vista记事本应用程序的Save As对话框
对于需要打开文本文件并进行处理的大多数应用程序（比如编译器）而言，如果应用程序能 够在打开一个文件之后分辨出此文件中包含的是ANSI字符还是Unicode字符，将是多么 惬意而方便啊！ IsTextUnicode函数有助于进行这种分辨，该函数由AdvApi32.dll导出并在 WinBase.h 中声明：
BOOL IsTextUnicode（CONST PVOID pvBuffer, int cb, PINT pResult）；
文本文件的问题在于，它们的内容没有任何硬性的、可供快速判断的规则。所以，要判断 文件中包含的是ANSI字符还是Unicode字符，就显得相当困难0 IsTextUnicode函数使用 一系列统计性和确定性方法来猜测缓冲区中的内容。由于这种方法并不精确，因此 IsTextUnicode函数可能会返回错误的结果。
它的第一个参数是pvBuffer,标识了要测试的缓冲区的地址。此数据是一个void指针，因 为还不知道即将面对的是一组ANSI字符还是Unicode字符。
第二个参数是cb,它指定pvBuffer指向的缓冲区的字节数。同样地，由于不知道缓冲区中 是什么，所以cb是一个字节数而不是字符数。注意，我们不必指定整个缓冲区的长度。当 然，IsTextUnicode函数测试的字节数越多，结果越精确。
第三个参数是pResult,这是一个整数的地址，在调用IsTextUnicode函数之前，我们必须 初始化这个整数。在这个整数的初始值中，应指出希望IsTextUnicode执行哪些测试。也
第2章字符和字符串处理
可以为此参数转入NULL,在这种情况下，IsTextUnicode函数将执行它能执行的每一项测 试（详情参阅Platform SDK文档）。
如果IsTextUnicode函数认为缓冲区包含的是Unicode文本，就会返回TRUE；反之则返回 FALSEo在pResult参数指向的整数中，如果指定了具体的测试项目，那么函数在返回之 前，还会设置此整数中的相应位，以反映每个测试项目的结果。
第17章的FileRev示例程序将演示IsTextUnicode函数的具体用法。
、、、9“。厂 I
、	/	2 ：
"3 8 七 I ALT 泓：
,＜切
3.1
3.2
3.3
本章内容
第3章内核对象
何为内核对象 进程内核对象句柄表 跨进程边界共享内核对象


为 了 帮助大家理解 Windows 应用程序编程接□ (application programming interface, AP),首 先让我们探讨一下内核对象(kernel object)及其句柄(handle)。本章讨论的是一些相对抽象的 概念——我们不打算讨论任何具体的内核对象的细节。相反，讨论的是所有内核对象共通 的一些特性。
我本来更愿意从一个更具体的主题开始的，但要想成为一名专业Windows软件开发人员， 透彻理解内核对象至关重要。在系统和我们写的应用程序中，内核对象用于管理进程、线 程和文件等诸多种类的大量资源。本章要介绍的概念将频繁出现在本书其他各章中。不过, 我的确也意识到，除非我们开始使用实际的函数来操纵内核对象，否则不太容易理解本章 讨论的一些主题。所以，在阅读本书其他各章的时候，可能需要回过头来参考本章。
3.1何为内核对象
作为Windows软件开发人员，我们经常都要创建、打开和处理内核对象。系统会创建和处 理几种类型的内核对象，比如访问令牌(access token)对象、事件对象、文件对象、文件映 射对象、I/O完成端口对象、作业对象、邮件槽(mailslot)对象、互斥量(mutex)对象、管道(pipe) 对象、进程对象、信号量(semaphore)对象、线程对象、可等待的计时器(waitabletimer)对象 以及线程池工厂(thread pool worker factory)对象等。利用Sysintemals的免费工具 WinObj(http://wwv/.microsofl.com/technet/sysintemals/utilities/winobj.mspx),可以查看一个包 含所有内核对象类型的列表。为了看到下页图所示的这个列表，必须在Windows资源管理 器中，以管理员身份运行此工具。
这些对象是通过不同名称的函数来创建的，函数的名称并非肯定与操作系统内核级别上使 用的对象类型对应。例如，调用CreateFileMapping函数，系统将创建对应于一个Section 对象的文件映射(如我们在WinObj中所见的那样)。每个内核对象都只是一个内存块，它由 操作系统内核分配，并只能由操作系统内核访问。这个内存块是一个数据结构，其成员维
第3章内核对象
护着与对象相关的信息。少数成员(安全描述符和使用计数等)是所有对象都有的，但其他 大多数成员都是不同类型的对象特有的。例如，进程对象有一个进程ID、一个基本的优先 级和一个退出代码；而文件对象有一个字节偏移量(byte offset)、一个共享模式和一个打开 模式。

sQ3\
O A/cNime 每 Cj B>seNimedOb)ect$ ；-Qj Callback (£ G] Device
Q| Orwer
x O FileSystem
□	global?? G3 KemelObjects O KnownDlb
* XfcJ NLS
口 I	[
□	RPC Control GJ Security
£ GU Sessions
Qj UMDFCommunkatonPorts (£ Qj Windows
Name ^Adapter •ALPC Port •cgx • Controlltr
•D.bugObject
^Desktop
(I Device
Directory
•	Drrvtr t|EtwRegistribon
•	Event
•	EvtntP・i，
■	FikerCommunicabonPort
•	FdterConnectionPort •loCompletion
•	Job
•*y
■	KtyedEvent
•	Mutint
■	Process
H Profile
■	Section
Semaphore
^Session
^Thread
•Timer
•Tmtn
•	TmRm
.TmTm
.TmTx
•Token HTpWorttrfictory
•	Type
•w.ndcwStBtion
•WmiGud
'AObjectTypej
由于内核对象的数据结构只能由操作系统内核访问，所以应用程序不能在内存中定位这些 数据结构并直接更改其内容。Microsoft有意强化了这个限制，确保内核对象结构保持一致 性状态。正是因为有这个限制，所以Microsoft能自由地添加、删除或修改这些结构中的成 员，同时不会干扰任何应用程序的正常运行。
既然不能直接更改这些结构，应用程序应该如何操纵这些内核对象呢？答案是利用 Windows提供的一组函数，这组函数会以最恰当的方式来操纵这些结构。我们始终可以使 用这些函数来访问这些内核对象。调用一个会创建内核对象的函数后，函数会返回一个句 柄(handle),它标识了所创建的对象。可以将这个句柄想象为一个不透明(opaque)的值，它 可由进程中的任何线程使用。在32位Windows进程中，句柄是一个32位值；在64位 Windows进程中，则是一个64位值。为了让操作系统知道我们要对哪个内核对象进行操作, 我们需要将这个句柄传给各种Windows函数。本章后面将进一步论及这些句柄。
为了增强操作系统的可靠性，这些句柄值是与进程相关的。所以，如果将句柄值传给另一
indows核心编程(第5版)
个进程中的线程(通过某种进程间通信方式)，那么另一个进程用我们的进程的句柄值来发 出调用时，就可能失败；甚至更糟糕的是，它们会根据该句柄在我们的进程句柄表的索引 来引用，另一个进程中的完全不同的内核对象。3.3节“跨进程边界共享内核对象”将介绍 3种机制，我们可利用它们实现多个进程成功共享同一个内核对象。
3.1.1使用计数
内核对象的所有者是操作系统内核，而非进程。换言之，如果我们的进程调用一个函数来 创建了一个内核对象，然后进程终止运行，则内核对象并不一定会销毁。大多数情况下， 这个内核对象是会销毁的，但假如另一个进程正在使用我们的进程创建的内核对象，那么 在其他进程停止使用它之前，它是不会销毁的。总之，内核对象的生命期可能长于创建它 的那个进程。
操作系统内核知道当前有多少个进程正在使用一个特定的内核对象，因为每个对象都包含 一个使用计数(usage count)o使用计数是所有内核对象类型都有的一个数据成员。初次创建 一个对象的时候，其使用计数被设为U另一个进程获得对现有内核对象的访问后，使用 计数就会递增。进程终止运行后，操作系统内核将自动递减此进程仍然打开的所有内核对 象的使用计数。如果一旦对象的使用计数变成0,操作系统内核就会销毁该对象。这样一 来，可以保证系统中不存在没有被任何进程引用的内核对象。
3.1.2内核对象的安全性
内核对象町以用一个安全描述符(security descriptor, SD)来保护。安全描述符描述了谁(通 常是对象的创建者)拥有对象；哪些用户和用户被允许访问或使用此对象；哪些组和用户被 拒绝访问此对象。安全描述符通常在编写服务器应用程序的时候使用。但是，在Microsoft Windows Vista中，对于具有专用(private)命名空间的客户端应用程序，这个特性变得更加 明显，详见本章以及4.5节“管理员以标准用户权限运行时”。
用于创建内核对象的所有函数几乎都有指向一个SECURITY_ATTRIBUTES结构的指针 作为参数，如下面的CreateFileMapping函数所示：
HANDLE CreateFileMapping(
HANDLE hFile,
PSECURITY^ATTRIBUTES psa,
DWORD fiProtect,
DWORD dwHaxirntunSizeHigh,
DWORD dwMaximumSizeLow,
PCTSTR pszName)；
大多数应用程序只是为这个参数传入NULL,这样创建的内核对象具有默认的安全性—— 具体包括哪些默认的安全性，要取决于当前进程的安全令牌(securitytoken)o但是，也可以 分配一个SECURITY_ATTRIBUTES结构，并对它进行初始化，再将它的地址传给这个参 数。SECURITY_ATTRIBUTES结构如下所示：
第3章内核对象
typedef struct _SECURITY_ATTRIBUTES (
DWORD nLength；
LPVOID IpSecurityDescriptor；
BOOL blnheritHandle；
} SECURITY_ATTRIBUTES;
虽然这个结构称为SECURITY_ATTRIBUTES，但它实际只包含一个和安全性有关的成 员，即IpSecurityDescriptoro如果想对我们创建的内核对象加以访问限制，就必须创建一 个安全描述符，然后像下面这样初始化SECURITY_ATTRIBUTES结构：
SECURITY_ATTRIBUTES sa；
sa.nLength = sizeof(sa);	// Used for versioning
sa.IpSecurityDescriptor = pSD； // Address of an initialized SD
sa.blnheritHandle = FALSE；	// Discussed later
HANDLE hFileMapping = CreateFileMapping(INVALID_HANDLE_VALUE, &sa, PAGE_READWRITE, 0, 1024, TEXT("MyFileMapping"));
由于这个成员与安全性没有任何关系，所以我将把blnheritHandle成员推迟到3.3.1节“使 用对象句柄继承”讨论。
如果想访问现有的内核对象(而不是新建一个)，必须指定打算对此对象执行哪些操作。例 如，如果想访问一个现有的文件映射内核对象，以便从中读取数据，那么可以像下面这样 调用 OpenFileMapping：
HANDLE hFileMapping = OpenFileMapping(FILE_MAP_READ, FALSE,
TEXT("MyFileMapping"));
将FILE_MAP_READ作为第一个参数传给OpenFileMapping,表明要在获得对这个文件 映射对象的访问权之后，从中读取数据。OpenFileMapping函数在返回一个有效的句柄 值之前，会先执行一次安全检查。如果我(当前登录的用户)被允许访问现有的文件映射 内核对象，OpenFileMapping会返回一个有效的句柄值。但是，如果访问被拒绝，
OpenFileMapping就会返回 NULL ；如果调用 GetLastError ,将返回值 5(ERROR_ACCESS_DENIED)。记住，如果利用返回的句柄来调用一个API,但这个API 需要的权限不是FILE_MAP_READ,那么同样会发生“拒绝访问”错误。由于大多数应 用程序都不使用安全性，所以这里不打算进一步讨论这个主题了。
虽然许多应用程序都不需要关心安全性，但许多Windows函数都要求传入必要的安全访问 信息。为老版本Windows设计的一些应用程序之所以在Windows Vista上不能正常工作， 就是因为在实现这些程序时，没有充分考虑安全性。
例如，假定一个应用程序在启动时要从一个注册表子项中读取一些数据。正确的做法是调 用RegOpenKeyEx,向其传入KEY_QUERY_VALUE,从而指定查询子项数据的权限。
然而，许多应用程序都是为Windows 2000之前的操作系统开发的，对安全性没有任何考虑。 有的软件开发人员还是按照老习惯，在调用RegOpenKeyEx函数的时候，传入 KEY_ALL_ACCESS作为期望的访问权限。之所以喜欢这样做，是由于它更简单，不需要 动脑筋想需要什么权限。但是，这样做的问题在于，对于一个不是管理员的标准用户，注 册表项(比如HKLM)也许是只读的。所以，当这样的应用程序在Windows Vista上面运行时， 调用RegOpenKeyEx函数并传递KEY_ALL_ACCESS就会失败。另外，如果没有正确的
lows核心编程(第5版)
错误检查，运行这样的应用程序会得到完全不可预料的结果。
其实，开发人员只需稍微注意一下安全性，将KEY_ALL_ACCESS改为 KEY_QUERY_VALUE(在本例中只需如此)，应用程序就能在所有操作系统平台上正常运 行了。
忽视正确的安全访问标志是很多开发人员最大的失误之一。只要使用了正确的安全访问标 志，我们的程序就很容易在不同版本的Windows之间移植。不过，还需注意到，每个新版 本的Windows会带来老版本中没有的一套新的限制。例如在Windows Vista中，我们需要 关注“用户帐户控制"(User Account Control, UAC)特性。默认情况下，为安全起见，UAC 会强制应用程序在一个受限的上下文中运行，即使当前用户是Administrators组的成员。我 们将在第4章“进程”详细讨论UAC。
除了使用内核对象，应用程序可能还要使用其他类型的对象，比如菜单、窗口、鼠标光标、 画刷和字体。这些属于用户对象或GDI(Graphical Device Interface)对象，而非内核对象。首 次进行Windows编程时，往往很难区分用户/GDI对象和内核对象。例如，图标是用户对象 还是内核对象？要想判断一个对象是不是内核对象，最简单的方式是查看创建这个对象的 函数。几乎所有创建内核对象的函数都有一个允许我们指定安全属性信息的参数，就像前 面展示的CreateFileMapping函数一样。
相反，用于创建用户对象或GDI对象的函数都没有PSECURITY_ATTRIBUTES参数。例 如下面的Createlcon函数：
HICON Createlcon(
HINSTANCE hinst,
int nWidth,
int nHeight,
BYTE cPlanes,
BYTE cBitsPixel,
CONST BYTE *pbANDbits,
CONST BYTE *pbXORbits);
MSDN 上看一篇文章(网址为 http://msdn.microsoft.com/msdnmag/issues/03/01/GDILeaks)详 细讨论了 GDI和用户对象，以及如何跟踪这些对象。
3.2进程内核对象句柄表
一个进程在初始化时，系统将为它分配一个句柄表(handle table)o这个句柄表仅供内核对象 使用，不适用于用户对象或GDI对象。句柄表的结构如何？如何管理句柄表？这些细节尚 无文档可以参考。一般情况下，我会避免讨论操作系统中没有编档的主题。但这里要破例 一下，因为我认为作为一名优秀的Windows程序员，必须理解如何管理进程的句柄表。由 于这些信息还没有正式编入文档，所以我不敢保证这里所讨论的细节都是准确无误的，而 且不同Windows版本的内部实现肯定有所区别。所以，下面的讨论只是帮助我们增强理解， 而不是让我们正式地学习系统的运行机制。
■37-38
第3章内核对象
表3-1显示了一个进程的句柄表。可以看出，它只是一个由数据结构组成的数组。每个结 构都包含指向一个内核对象的指针、一个访问掩码(access mask)和一些标志。
表3-1进程的句柄表的结构
索引	指向内核对象内存块的指针	访问掩码(包含标志位的一个DWORD)	标志
1	Ox????????	Ox????????	Ox????????
2	Ox????????	Ox????????	Ox????????
	…	♦ ♦・	
3.2.1创建一个内核对象
一个进程首次初始化的时候，其句柄表为空。当进程内的一个线程调用一个会创建内核对 象的函数时(比如CreateFileMapping),内核将为这个对象分配并初始化一个内存块。然后, 内核扫描进程的句柄表，查找一个空白的记录项(empty entry)o由于表3.1展示的是一•个空 白句柄表，所以内核在索引1位置找到空白的记录项，并对其进行初始化。具体地说，指 针成员会被设置成内核对象的数据结构的内部内存地址，访问掩码将被设置成拥有完全访 问权限，标志也会设置(我将在3.3.1节“使用对象句柄继承”讨论标志的问题)。
下面列出了一些用创建内核对象的函数(当然并不完整)：
HANDLE CreateThread(
PSECURITY_ATTRIBUTES psa,
size_t dwStackSize,
LPTHREAD_START_ROUTINE pfnStartAddress,
PVOID pvParam,
DWORD dwCreationFlags,
PDWORD pdwThreadld);
HANDLE CreateFile(
PCTSTR pszFileName,
DWORD dwDesiredAccess,
DWORD dwShareMode,
PSECURITY_ATTRIBUTES psa,
DWORD dwCreationDisposition,
DWORD dwFlagsAndAttributes,
HANDLE hTemplateFile);
HANDLE CreateFileMapping(
HANDLE hFile,
PSECURITY_ATTRIBUTES psa,
DWORD flProtect,
DWORD dwMax imumS i z eH i gh,
DWORD dwMaximumSi zeLow,
PCTSTR pszName)；
HANDLE CreateSemaphore(
PSECURITY_ATTRIBUTES pSa,
LONG UnitialCount,
LONG iMaximumCount,
PCTSTR pszName)；
用于创建内核对象的任何函数都会返回一个与进程相关的句柄，这个句柄可由同一个进程
indows核心编程（第5版）
中运行的所有线程使用。系统用索引来表示内核对象的信息保存在进程句柄表中的具体位 置，要得到实际的索引值，句柄值实际应该除以4（或右移两位，以忽略Windows操作系统 内部使用的最后两位）。所以，在调试应用程序时查看内核对象句柄的实际值时，会看到4、 8之类的很小的值。记住，句柄的含义尚未公开，将来可能发生变化。
调用一个函数时，如果它接受一个内核对象句柄作为参数，就必须把Create*函数返回的值 传给它。在内部，这个函数会查找进程的句柄表，获得目标内核对象的地址，然后以一种 恰当的方式来操纵对象的数据结构。
如果传入一个无效的句柄，函数就会失败，GetLastError会返回6 （ERROR_INVALID_HANDLE）o由于句柄值实际是作为进程句柄表的索引来使用的，所 以这些句柄是与当前这个进程相关的，无法供其他进程使用。如果我们真的在其他进程中 使用它，那么实际引用的只是那个进程的句柄表中位于同一个索引的内核对象——只是索 引值相同而已，我们根本不知道它会指向什么对象。
调用函数来创建一个内核对象时，如果调用失败，那么返回的句柄值通常为O（NULL）,这 就是为什么第一个有效的句柄值为4的原因。之所以失败，可能是由于系统内存不足，或 者遇到了一个安全问题。遗憾的是，有几个函数在调用失败时会返回句柄值- 1（也就是在 WinBase.h中定义的INVALID_HANDLE_VALUE）。例如，如果CreateFile无法打开指定 文件，它会返回INVALID_HANDLE_VALUE,而不是NULL。凡是用于创建内核对象的 函数，在检查它们的返回的值时，务必相当仔细。具体说来，以当前这个例子为例，只有 在调用CreateFile时，才能将它的返回值与INVALID_HANDLE_VALUE进行比较。以下 代码是不正确的：
HANDLE hMutex = CreateMutex (...)； if (hMutex == INVALID_HANDLE_VALUE) (
We will never execute this code because CreatMutex returns NULL if it fails.
类似地，以下代码也是不正确的:
HANDLE hFile = CreateFile (...);
if (hFile == NULL) {
// We will never execute this code because CreateFile // returns INVALID_HANDLE_VALUE (-1) if it fails.
3.2.2关闭内核对象
无论以什么方式创建内核对象，我们都要调用CloseHandle向系统表明我们已经结束使用 对象，如下所示：
BOOL CloseHandle(HANDLE hobject);
在内部，该函数首先检查主调进程的句柄表，验证“传给函数的句柄值”标识的是“进程
第3章内核对象
确实有权访问的一个对象”。如果句柄是有效的，系统就将获得内核对象的数据结构的地 址，并将结构中的“使用计数”成员递减。如果使用计数变成0,内核对象将被销毁，并 从内存中去除。
如果传给CloseHandle函数的是一个无效的句柄，那么可能发生以下两种情况之一：如果 进程是正常运行的，CloseHandle将返回FALSE ,而 GetLastError返回 ERROR_INVALID_HANDLEo如果进程正在被调试，那么系统将抛出0xC0000008异常 （“指定了无效的句柄”），便于我们调试这个错误。
就在CloseHandle函数返回之前，它会清除进程句柄表中对应的记录项——这个句柄现在 对我们的进程来说是无效的，不要再试图用它。无论内核对象当前是否销毁，这个清除过 程都会发生！ 一旦调用CloseHandle,我们的进程就不能访问那个内核对象；但是，如果 对象的使用计数还没有递减至0,它就不会被销毁。这是完全正常的；它表明另外还有一 个或多个进程在使用该对象。当其他进程（通过调用CloseHandle）全部停止使用这个对象 后，对象就会被销毁。
说明 通常，在创建一个内核对象时，我们会将相应的句柄保存到一个变量中。将此变量 作为参数调用CloseHandle函数后，还应同时将这个变量设为NULL。如果不小心 用这个变量来调用了一个Win32函数，可能会发生两种意外情况。第一种可能的情 况是，由于此变量所引用的句柄表记录项已被清除，所以Windows会接收到一个无 效的参数并报告错误。另外，还可能发生另一种更难调试的情况。创建一个新的内 核对象时，Windows会在句柄表中查找空白记录项。所以，如果应用程序已经创建 好一些新的内核对象，那么该变量所引用的句柄表肯定包含某个新建的内核对象。 因此，要函数调用时，一旦错误地用这个尚未设为NULL的变量，就可能会定位到 一个错误类型的内核对■象（这种情况会报错）。更糟的情况是，可能会定位到一个类 型（和已经关闭的内核对象）相同的内核对象（这种情况不会报错）。在第二种情况下， 应用程序的状态将损坏，没有任何办法可以恢复。
假定忘记调用CloseHandle,会发生对象泄漏的情况吗？嗯，不一定。在进程运行期间， 进程可能发生资源（比如内核对象）泄漏的情况。但是，当进程终止运行，操作系统会确保 此进程所使用的所有资源都被释放——这是可以保证的！对于内核对象，操作系统执行的 是以下操作：进程终止时，系统自动扫描该进程的句柄表。如果这个表中有任何有效的记 录项（即进程终止前没有关闭的对象），操作系统会为我们关闭这些对象句柄。只要这些对 象中有一个的使用计数递减至0,内核就会销毁对象。
所以，在应用程序运行时，它可能会泄漏内核对象：但当进程终止运行，系统能保证一切 都被正确清除。顺便说一下，这适用于所有内核对象、资源（包括GDI对象在内）以及内存 块。进程终止运行时，系统会确保我们的进程不会留下任何东西。要在应用程序运行期间 检测内核对象泄漏，一个简单的办法是使用Windows任务管理器。首先，如图3.1所示， 需要选择 View（查看）| Select Columns（选择列）菜单，然后在 Select Process Page Columns（选 择进程页列）对话框中，指定在Processes（进程）选项卡中显示Handles（句柄数）列。
4。
弗idows核心编程（第5版）
Setoct the coUw that wl appear on the Process page of the Task Manager.
尸 Memory ■ Private Workng Set Memory - Commit Size		
Ej Memory - PdQed Pool 0 Memory ・ Non-paged Pool E P^ge FaJts	ra	
[T] Page Fadt Delta □ Base Priority [^Handles		
函 Threads □	USER Objects □	GDI Objects	J	
Ej I/O Reads 切 I/O Writes 01/0 Other Q I/O Read Bytes		
L 1 I J ；
图 3-1 在 Select Process Page Columns 对话框中选择 Handles 列
然后就可以监视任何一个应用程序使用的内核对象数了，如图3-2所示。
图3-2在Windows任务管理器中统计句柄数
如果Handles列显示的数字持续增长，下一步我们就要确定哪些内核对象尚未关闭。为此, 可以使用 Sysintemals提供的一款免费Process Explorer工具（网址是 http://www.microsoft.com/technet/sysintemals/ProcessesAndThreads/ProcessExplorer.mspx）o 首 先，右击下方Handlers窗格'的标题行，并从弹出菜单中选择Select Columns（选择列）。然 后，在图3.3所示的Select Columns对话框中，选中所有列标题。
完成此项操作之后，在View菜单中将Update Speed改为Paused。在顶部的窗格中选择想
① 如果此窗格尚未显示，请在View菜单中选择Show Lower Pane（显示底部窗格）。
第3章内核对象
检查的进程，按F5键来获得一份最新的内核对象列表。然后，启动应用程序并开始执行一 个待查的工作流。完成之后，再次在Process Explorer中按F5键。在此期间生成的每个新 的内核对象都显示为绿色，如图3・4下方较深的区域所示。
图3-3 选择要在Process Explorer的Handle视图中显示的详细信息
Process
CPU Time
0x00020019 0x00000001 OxOOOFOOSF 0x00020019 0x00020019 On00020019
3100 3012
Ox97D6F1EO
Ox9673«OC8 (WO6CC438 0x9664F8O0 0x9FBA8988 0k9FB403CD
HKLM \SYSTEM\ControlS etOOl \ConboT<Se$tk)rt Manage* HKCU
HKLM\SYSTEM\CortfdSe»001\Conlr(ANk\LocA\Wte<nate Sorts HKLM\SYSTEM\Conbo6et001\Conbo^l$\Locate HKLMXSYSTEMgxirolS etOOl \ConbcAN 叭Language Groupt
Handle Users
Access Object Address
1	a(ni22D3
1	0021&828
1	&02:21.203
1	aOQ07.8!2
州—oof
CPU Usage: 8.20% Commit Chirge: 30.54% Processes: 48 Paused
图3V 在Process Explorer中检测新的内核对象
注意，第一列显示了没有关闭的内核对象的类型。为了使我们有更大的机会确定泄漏位置, 第二列提供了内核对象的名称。如下一击所述，利用作为内核对象名称的字符串，便可以 在不同的进程之间共享这个对象。显然，根据第一列的类型和第二列的名称，便可以轻松 判断出哪个对象没有关闭。如果泄漏了大量对象，它们并不一定会被命名，因为只能创建 一个命名对象(named object)的一个实例——其他尝试会单纯地打开那个实例。
OWS核心编程(第5版)
3.3跨进程边界共享内核对象
在很多时候，不同进程中运行的线程需要共享内核对象。下面罗列了一些理由。
•	利用文件映射对象，可以在同一台机器上运行的两个不同进程之间共享数据块。
•	借助邮件槽和命名管道，在网络中的不同计算机上运行的进程可以相互发送数 据块。
•	互斥量、信号量和事件允许不同进程中的线程同步执行。例如，一个应用程序可能 需要在完成某个任务之后，向另一个应用程序发出通知。
由于内核对象的句柄是与每一个进程相关的，所以执行这些任务并不轻松。不过，Microsoft 也有充分的理由需要将句柄设计成“与进程相关的”(process-relative)的。其中最重要的原 因是健壮性(可靠性)。如果把内核对象句柄设计成相对于整个系统，或者说把它们设计成 “系统级”的句柄，一个进程就可以很容易获得到“另一个进程正在使用的一个对象”的 句柄，从而对该进程造成严重破坏。之所以将句柄设计成“与进程相关的”，或者说把它 们设计成“进程级”句柄的，另一个原因是安全性。内核对象是受安全性保护的，进程在 试图操纵一个对象之前，必须先申请操纵它的权限。对象的创建者为了阻止一个未经许可 的用户“碰”自己的对象，只需拒绝该用户访问它。
在下一节，我们要讨论如何利用三种不同的机制来允许进程共享内核对象：使用对象句柄 继承；为对象命名；复制对象句柄。
3.3.1使用对象句柄继承
只有在进程之间有一个父-子关系的时候，才可以使用对象句柄继承。在这种情况下，父 进程有一个或多个内核对象句柄可以使用，而且父进程决定生成一个子进程，并允许子进 程访问父进程的内核对象。为了使这种继承生效，父进程必须执行几个步骤。
首先，当父进程创建一个内核对象时，父进程必须向系统指出它希望这个对象的句柄是可 以继承的。我有时听到别人说起“对象继承”这个词。但是，世界上根本没有“对象继承” 这样的事情。Windows支持的是“对象句柄的继承”；换言之，只有句柄才是可以继承的， 对象本身是不能继承的。
■
为了创建一个可继承的句柄，父进程必须分配并初始化一个SECURITY_ATTRIBUTES 结构，并将这个结构的地址传给具体的Create函数。以下代码创建了一个互斥量对象，并 返回其可继承的句柄：
SECURITY_ATTRIBUTES sa；
sa.nLength = sizeof(sa);
sa.IpSecurityDescriptor = NULL；
sa.blnheritHandle = TRUE； // Make the returned handle inheritable.
HANDLE hMutex = CreateMutex(&sa, FALSE, NULL)；
第3章内核对象
以上代码初始化了一个SECURITY__ATTRIBUTES结构，表明对象要用默认安全性来创 建，而且返回的句柄应该是可继承的。
接下来谈谈在进程的句柄表记录项中保存的标志。句柄表中的每个记录项都有一个指明句 柄是否可以继承的标志位。如果在创建内核对象的时候将NULL作为 PSECURITY_ATTRIBUTES参数传入,则返回的句柄是不可继承的，这个标志位为0。
将blnheritHandle成员设为TRUE,则导致这个标志位被设为1。
以表3.2的进程句柄表为例。在这个例子中，进程有权访问两个内核对象（句柄1和3）。句 柄1是不可继承的，但句柄3是可以继承的。
表3-2包含两个有效记录项的进程句柄表
索引	指向内核对象内存块的指针	访问掩码（包含标志位的一个DWORD）	标志
]	OxFOOOOOOO	Ox????????	0x00000000
2	0x00000000	（不可用）	（不可用）
3	OxFOOOOlO	Ox????????	0x00000001
为了使用对象句柄继承，下一步是由父进程生成子进程。这是通过CreateProcess函数来完 成的，如下所示：
BOOL CreateProcess（
PCTSTR pszApplicationName,
PTSTR pszCommandLine,
PSECURITY_ATTRIBUTES psaProcess,
PSECURITY_ATTRIBUTES psaThread,
BOOL blnheritHandles,
DWORD dwCreat ionFlags,
PVOID pvEnvironment,
PCTSTR pszCurrentDirectory, LPSTARTUPINFO pStartupInfo, PPROCESS_INFORMATION pProcessInformation）;
我们将在第4章详细讨论这个函数，现在请注意blnheritHandles参数。通常情况下，在生 成一个进程时，我们要将该参数设为FALSEo这个值向系统表明：我们不希望子进程继承 父进程句柄表中的“可继承的句柄”。
相反，如果向这个参数传递TRUE,子进程就会继承父进程的“可继承的句柄”的值。传 递TRUE时，操作系统会创建新的子进程，但不允许子进程立即执行它的代码。当然，系 统会为子进程创建-个新的、空白的进程句柄表——就像它为任何一个新进程所做的那样。 但是，由于我们传给CreateProcess函数的blnheritHandles参数的值是TRUE,所以系统 还会多做一件事情：它会遍历父进程的句柄表，对它的每一个记录项进行检查。凡是包含 一个有效的“可继承的句柄”的项，都会被完整地复制到子进程的句柄表。在子进程的句 柄表中，复制项的位置与它在父进程句柄表中的位置是完全一样的。这是非常重要的一个 设计，因为它意味着：在父进程和子进程中，对一个内核对象进行标识的句柄值是完全一 样的。
■
Mows核心编程（第5版）
除了复制句柄表的记录项，系统还会递增内核对象的使用计数，因为两个进程现在都在使 用这个对象。为了销毁内核对象，父进程和子进程要么都对这个对象调用CloseHandle, 要么都终止运行。子进程不一定先终止——但父进程也不一定。事实上，父进程可以在 CreateProcess函数返回之后立即关闭它的内核对象句柄，子进程照样可以操纵这个对象。
表3・3显示了子进程在被允许开始执行之前的句柄表。可以看出，第一项和第二项没有初 始化，所以对子进程来说无效的句柄，不可以使用。但是，索引3标识了一个内核对象。
事实上,•它标识的是地址OxFOOOOOlO处的内核对象，与父进程句柄表中的对象一样。
表3・3继承了父进程的“可继承的句柄”之后，子进程的句柄表的样子
索引	指向内核对象内存块的指针	访问掩码（包含标志位的一个DWORD）	标志
1	0x00000000	（不可用）	（不可用）
2	0x00000000	（不可用）	（不可用）
3	OxFOOOOOlO	Ox????????	0x00000001
第13章将讲到，内核对象的内容被保存在内核地址空间中——系统上运行的所有进程都共 享这个空间。•对于32位系统，这是0x80000000到OxFFFFFFFF之间的内存空间。对于64 位系统，则是0x00000400' 00000000到OxFFFFFFF' FFFFFFFF之间的内存空间。访问掩 码与父进程中的一样，标志也是一样的。这意味着假如子进程用CreateProcess来生成它自 己的子进程（其父进程的孙进程）并将blnheritHandles参数设为TRUE的前提下，孙进程也 会继承这个内核对象句柄。在孙进程的句柄表中，继承的对象句柄将具有相同的句柄值、 相同的访问掩码以及相同的标志。内核对象的使用计数将再次递增。
记住，对象句柄的继承只会在生成了进程的时候发生。假如父进程后来又创建了新的内核 对象，并同样将它们的句柄设为可继承的句柄。那么正在运行的子进程是不会继承这些新 句柄的。
对象句柄继承还有一个非常奇怪的特征：子进程并不知道自己继承了任何句柄。在子进程 的文档中，应指出当它从另一个进程生成时，希望获得对一个内核对象的访问权——只有 在这种情况下，内核对象的句柄继承才是有用的。通常，父应用程序和子应用程序是由同 一家公司编写的；但是，假如一•家公司能在文档中说明子应用程序希望继承哪些对象句柄， 那么另一家公司就可以据此来编写一个了应用程序。	一__
/ ..	:•:二•'勰1"*花
到目前为止，为了使子进程得到它想要的一个内核对象的句柄值，最常见的方式是将句柄 值作为命令行参数传给子进程。子进程的初始化代码将解析命令行（通常是调用—StscanLs）, 并提取句柄值。子进程获得句柄值之后，就会拥有和父进程一样的内核对象访问权限。注 意，句柄继承之所以能够实现，唯一的原因就是“共享的内核对象”的句柄值在父进程和 子进程中是完全一样的。这正是父进程能将句柄值作为命令行参数来传递的原因。
当然，也可以使用其他进程间通信技术将继承的内核对象句柄值从父进程传入子进程。一
第3章内核对象
个技术是让父进程等待子进程完成初始化(利用第9章讨论的WaitForlnputldle函数)；然 后，父进程可以将一条消息发送或发布到由子进程中的一个线程创建的一个窗口。
另一种方式是让父进程向其环境块添加一个环境变量。变量的名称应该是子进程知道的一 个名称，而变量的值应该是准备被子进程继承的那个内核对象的句柄值。然后，当父进程 生成子进程的时候，这个子进程会继承父进程的环境变量，所以能轻松调用 GetEnvironmentVariable来获得这个继承到的内核对象的句柄值。如果子进程还要生成 另一个子进程，这种方式就非常不错，因为环境变量是可以反复继承的。Microsoft知识 库的一篇文章(网址为http://support.microsoft.com/kb/190351)描述了子进程继承父控制台 的特例①。
3.3.2改变句柄的标志
有时可能遇到这样一种情况：父进程创建了一个内核对象，得到了一个可继承的句柄，然 后生成了两个了进程。但是，父进程只希望其中的一个子进程继承内核对象句柄。换言之, 我们有时可能想控制哪些子进程能继承内核对象句柄。可以调用SetHandlelnformation函 数来改变内核对象句柄的继承标志。如下所示：	、
BOOL SetHandlelnformation(
HANDLE hObject,
DWORD dwMask,
DWORD dwFlags)；
可以看出，这个函数有•三个参数。第一个参数hObject标识了一个有效的句柄。第二个参 数dwMask告诉函数我们想更改哪个或者哪些标志。目前，每个句柄都关联了两个标志： #define HANDLE_FLAG_INHERIT	0x00000001
#define HANDLE_FLAG_PROTECT_FROM_CLOSE	0x00000002
如果想把每个对象的标志一次性更改完毕，可以对这两个标志执行一次按位或运算。 SetHandlelnformation函数的第三个参数dwFlags指出希望把标志设为什么。例如，要打 开一个内核对象句柄的继承标志，可以像下面这样写：
SetHandlelnformation(hobj, HANDLE_FLAG_INHERIT/ HANDLE_FLAG_INHERIT);
要关闭这个标志，可•以像下面这样写：
SetHandlelnformation(hObj, HANDLE_FLAG_INHERIT, 0)；
HANDLE_FLAG_PROTECT_FROM_CLOSE标志告诉系统不允许关闭句柄：
SetHandlelnformation(hObj, HANDLE_FLAG_PROTECT_FROM_CLOSE #
HANDLE_FLAG_PROTECT_FROM_CLOSE);
CloseHandle (hobj ) ； // 会引发异常
①译者友情提示：不要看Microsoft自动“机器翻洋”的版本。
如果在调试器下运行，一旦线程试图关闭一个受保护的句柄，CloseHandle就会引发一个 异常。如果在调试器的控制之外，CloseHandle只是返回FALSE。几乎没有多大必要阻止 句柄被关闭。但是，如果我们的一个进程会生成一个子进程，后者再生成一个孙进程，那 么这个标志还是有用的。父进程可能希望孙进程依然能够从了进程那里继承对象句柄。但 是，子进程可能在生成孙进程之前就关闭了那个句柄。如果发生这种情况，父进程就不能 和孙进程通信了，因为可怜的孙进程根本没有继承到内核对象(句柄)。相反，如果将句柄 标记为“PROTECT FROM CLOSE”(禁止关闭)，孙进程就有更大的机会继承到指向一个有 效的、活动的内核对象的句柄。
不过，正如我前面所说的，孙进程现在只是“机会”更大一些。这种方式的不足 之处在于，处于中间位置的那个子进程可以调用以下代码来关闭 HANDLE_FLAG_PROTECT_FROM_CLOSE 标志，然后关闭句柄：
SetHandlelnformation(hobj, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0);
CloseHandle(hObj)；
也就是说，父进程其实是在赌自己的子进程不会执行上述代码。但即使没有这个问题，子 进程真的就会生成孙进程吗？这同样是在赌。反正都是赌，第一个赌看起来也就没有那么 危险了。
考虑到内容的完整性，下面再来讨论一下GetHandlelnformation函数：
BOOL GetHandlelnformation(
HANDLE hObject,
PDWORD pdwFlags)；
这个函数会在pdwFlags指向的DWORD中，返回指定句柄的当前标志。要检查一个句柄 是否可以继承，请执行以下代码：
DWORD dwFlags;
GetHandlelnformation(hObj, &dwFlags)；
BOOL fHandlelsInheritable = (0 != (dwFlags & HANDLE_FLAG_INHERIT));
■
3.3.3为对象命名
跨进程边界共享内核对象的第二个办法是为对象命名。许多(但不是全部)内核对象都可以 进行命名。例如，以下所有函数都可以创建命名的内核对象：
HANDLE CreateMutex(
PSECURITY_ATTRIBUTES psa,
BOOL bln让ialOwner,
PCTSTR pszName);
HANDLE CreateEvent(
PSECURITY_ATTRIBUTES psa,
BOOL bManualReset z
BOOL blnitialState,
PCTSTR pszName);
HANDLE CreateSemaphore(
PSECURITY_ATTRIBUTES psa,
第3章内核对象
LONG UnitialCount,
LONG 1Maximumcount,
PCTSTR pszName);
HANDLE CreateWaitableTimer(
PSECURITY_ATTRIBUTES psa,
BOOL bManualReset,
PCTSTR pszName)；
HANDLE CreateFileMapping(
HANDLE hFile,
PSECURITY_ATTRIBUTES psa,
DWORD fiProtect,
DWORD dwMaximumSizeHigh,
DWORD dwMax imumS i z eLow,
PCTSTR pszName);
HANDLE CreateJobObject(
PSECURITY_ATTRIBUTES psa,
PCTSTR pszName);
所有这些函数的最后一个参数都是pszName。向此参数传入NULL,相当于向系统表明我 们要创建一个未命名的(即匿名)内核对象。如果创建的是一个未命名对象，可以利用上一 节讨论过的继承技术，或者利用下一节即将讨论的DuplicateHandle函数来实现进程间的 对象共享。如果要根据对象名称来共享一个对象，我们必须为此对象指定一个名称。
如果不为pszName参数传递NULL,则应该传入一个“以0为终止符的名称字符串”的地 址。这个名称可以长达MAX_PATH个字符(定义为260)o遗憾的是，Microsoft没有提供 任何专门的机制来保证为内核对象指定的名称是唯一的。例如，假如我们试图创建一个名 为“JeffObj”的对象，那么没有任何一种机制来保证当前不存在一个名为“JeffObj”的对 象。更糟的是，所有这些对象都共享同一个命名空间，即使它们的类型并不相同。例如， 以下CreateSemaphore函数调用肯定会返回NULL,因为已经有一个同名的互斥量对象了： HANDLE hMutex = CreateMutex(NULL, FALSE, TEXT("JeffObj"));
HANDLE hSem = CreateSemaphore (NULL, 1, 1, TEXT ("Jef fObj •'));
DWORD dwErrorCode = GetLastError()；
48M9
执行上述代码之后，如果检查dwErrorCode的值，会发现返回的代码为6 (ERROR_INVALID_HANDLE)o这个错误代码当然说明不了什么问题，不过我们目前对 此无能为力。
知道如何命名对象之后，接着来看看如何以这种方式共享对象。假设进程A启动并调用以 下函数：
HANDLE hMutexProcessA = CreateMutex(NULL, FALSE, TEXT("JeffMutex•))；
这个函数调用创建一个新的互斥量内核对象，并将其命名为“JeffMutex” °注意，在进程 A的句柄(表)中，hMutexProcessA并不是一个可继承的句柄 但是，通过为对象命名来 实现共享时，是否可以继承并非一个必要条件。
如果后来某个进程生成了进程B,那么进程B不一定要是进程A的子进程；它可能是从 Windows资源管理器，也可能是其他某个应用程序生成的。相较于使用句柄继承，利用对
WS核心编程(第5版)
象的名称来共享内核对象，最大的一个优势是“进程B不一定是进程A的子进程”。进程 B开始执行时，它执行以下代码：
HANDLE hMutexProcessB = CreateMutex(NULL, FALSE, TEXT("JeffMutex"));
当进程B调用CreateMutex时，系统首先会查看是否存在一个名为“JeffMutex”的内核对 象。由于确实存在这样的一个对象，所以内核接着检查对象的类型。由于试图创建一个互 斥量对象，而名为“JeffMutex”的对象也是一个互斥量对象，所以系统接着执行一次安全 检查，验证调用者是否拥有对该对象的完全访问权限。如果答案是肯定的，系统就会在进 程B的句柄表中查找一个空白记录项，并将其初始化为指向现有的内核对象。如果对象的 类型不匹配，或调用者被拒绝访问，CreateMutex就会失败(返回NULL)。
说明 用于创建内核对象的函数(比如CreateSemaphore)总是返回具有完全访问权限的句 柄。如果想限制一个句柄的访问权限，可以使用这些函数的扩展版本(有一个ex后 缀)，它们接受一个额外的DWORD dwDesiredAccess参数。例如,可以在调用 CreateSemaphoreEx 时使用或不使用 SEMAPHORE_MODIFY_STATE,从而允许 或禁止对一个信号量句柄调用ReleaseSemaphore。请阅读Windows SDK文档，了 解与每种内核对象的权限细节，网址是http://msdn2.microsoft.com/en-us/library/ ms686670.aspxo
进程B调用CreateMutex成功之后，不会实际地创建一个互斥量对象。相反，会为进程B 分配一个新的句柄值(当然，和所有句柄值一样，这是一个相对于该进程的句柄值)，它标 识了内核中的一个现有的互斥量对象。当然，由于在进程B的句柄表中，用一个新的记录 项来引用了这个对象，所以这个互斥量对象的使用计数会被递增。在进程A和进程B都关 闭这个对象的句柄之前，该对象是不会销毁的。注意，两个进程中的句柄值极有可能是不 同的值。这没有什么关系。进程A用它自己的句柄值来引用那个互斥量对象，进程B也用 它自己的句柄值来引用同一个互斥量对象。
说明 通过名称来实现内核对象共享时，务必关注一点：进程B调用CreateMutex时，它 会向函数传递安全属性信息和第二个参数。如果已经存在一个指定名称的对象，这 些参数就会被忽略'
事实上，完全可以在调用了 Create*之后，马上调用一个GetLastError,判断自己刚 才是真的创建了 一个新的内核对象，还是仅仅是打开了 一个现有的：
HANDLE hMutex = CreateMutex(&sa, FALSE, TEXT(-JeffObj"));
if (GetLastError() == ERROR_ALREADY_EXISTS) (
// Opened a handle to an existing object.
II sa.IpSecurityDescriptor and the second parameter
// (FALSE) are ignored.
} else (
// Created a brand new object.
① 译注：换言之，函数不知道I'l己刚才是新建了-个内核对象，还是打开了 个现有的内核对象。
第3章内核对象
// sa.IpSecurityDescriptor and the second parameter
// (FALSE) are used to construct the object.
}
为了实现这些内核对象的共享，还可以考虑另一个办法。我们可以不调用Create*函数；相 反，可以调用如下所示的一个Open*函数：
HANDLE OpenMutex(
DWORD dwDesiredAccess,
BOOL blnheritHandle,
PCTSTR pszName);
HANDLE OpenEvent(
DWORD dwDesiredAccess,
BOOL blnheritHandle,
PCTSTR pszName)；
HANDLE OpenSemaphore(
DWORD dwDesiredAccess,
BOOL blnheritHandle,
PCTSTR pszName)；
HANDLE OpenWaitableTimer(
DWORD dwDesiredAccess,
BOOL blnheritHandle,
PCTSTR pszName)；
HANDLE OpenFileMapping(
DWORD dwDesiredAccess,
BOOL blnheritHandle,
PCTSTR pszName)；
HANDLE OpenJobObject(
DWORD dwDesiredAccess,	.
BOOL blnheritHandle,
PCTSTR pszName)；
注意，所有这些函数的原型都是一样的。最后一个参数pszName指出内核对象的名称。不 能为这个参数传入NULL,必须传入一个以0为终止符的字符串作为地址。这些函数将在 同一个内核对象命名空间搜索，以查找一个匹配的对象。如果没有找到这个名称的一个内 核对象，函数将返回 NULL, GetLastError 将返回 2(ERROR_FILE_NOT_FOUND)。如 果找到了这个名称的一个内核对象，但类型不同，函数将返回NULL, GetLastError将返 回6(ERROR_INVALID_HANDLE)。如果名称同，类型也同，系统会检查请求的访问(通 过dwDesiredAccess来指定)是否允许。如果允许，就会更新主调进程的句柄表，并使对象 的使用计数递增。如果为blnheritHandle参数传入了 TRUE,那么返回的句柄就是“可继 承的”。
调用Create*函数和调用Open*函数的主要区别在于，如果对象不存在，Create*函数会创 建它：Open*函数则不同，如果对象不存在，它只是简单地以调用失败而告终。
如前所述，Microsoft没有提供任何专门的机制来保证我们创建独一无二的对象名。换言之， 如果用户试图运行来自不同公司的两个程序，而且每个程序都试图创建一个名为 “MyObject”的对象，那么就会出问题。为了确保名称的唯一性，我的建议是创建一个 GUID,并将这个GUID的字符串形式作为自己的对象名称使用。稍后的33.5节“专有命
indows核心编程(第5版)
名空间”中将介绍另一种保证名称唯一性的方式。
我们经常利用命名对象来防止运行一个应用程序的多个实例。为此，只需在Jmain或 _tWinMain函数中调用一个Create*函数来创建一个命名对象(具体创建什么类型无关紧 要)。Create*函数返回后，再调用一下GetLastError。如果GetLastEiror返回 ERROR_ALREADY_EXISTS,表明应用程序的另一个实例正在运行，新的实例就口J以也 出了。以下代码对此进行了说明：
int WINAPI _tWinMain(HINSTANCE hlnstExe, HINSTANCE, PTSTR pszCmdLine,
int nCmdShow) (
HANDLE h = CreateMutex(NULL, FALSE,
TEXT("(FA531CCl-0497-lld3-A180-00105A276C3E)"));
if (GetLastError() == ERROR_ALREADY_EXISTS) (
// There is already an instance of this application running.
// Close the object and immediately return.
CloseHandle(h)；
return(0);
}
// This is the first instance of this application running.
// Before exiting, close the object.
CloseHandle(h);
return(0)；
)
3.3.4终端服务命名空间
注意，终端服务(Terminal Service)的情况和前面描述的稍微有所区别。在正在运行终端服务 的计算机中，有多个用于内核对象的命名空间。其中一个是全局命名空间，所有客户端都 能访问的内核对象要放在这个命名空间中。这个命名空间主要由服务使用。此外，每个客 户端会话(client session)®有一个自己的命名空间。对于两个或多个会话正在运行同一个应 用程序的情况，这样的安排可以避免会话之间彼此干扰---------------个会话不会访问另一个会话
的对象，即使对象的名称相同。
51圈
并非只有服务器才会遇到这种情况，因为Remote Desktop(远程桌面)和快速用户切换(Fast User Switching)特性也是利用终端服务会话来实现的。
说明 在没有任何用户登录的时候，服务会在第一个会话(称为Session 0)中启动，这个会 话不是交互式的。和以前版本的Windows不同，在Windows Vista中，只要用户登 录，应用程序就会在一个新的会话(与服务专用的Session 0不同的一个会话)中启动。 采用这个设计之后，系统核心组件(通常具有较高的权限)就可以更好地与用户不慎 启动的恶意软件(malware)隔离。
对于服务开发人员，由于必须在与客户端应用程序不同的一个会话中运行，所以会 影响到共享内核对象的命名约定。任何对象要想和用户应用程序共享，都必须在全 局命名空间中创建它。快速用户切换也会带来类似的问题。我们知道，利用快速用
第3章内核对象
户切换功能，不同的用户可以登录不同的会话，并分别启动自己的用户应用程序。 如果我们写的一个服务要与这些应用程序通信，就不能假定它和用户应用程序在同 一个会话中运行。要想进一步了解Session 0隔离问题，及其对服务开发人员的影响, 请阅读 wImpact of Session 0 Isolation on Services and Drivers in Windows Vista” 一文， 网址是 http://www.microsoft.com/whdc/system/vista/services.mspx.
如果必须知道我们的进程在哪个Terminal Services会话中运行，可以借助于
ProcessIdToSessionld 函数(由 kemel32.dll 导出，在 WinBase.h 中声明)，如下例所示：
DWORD processID = GetCurrentProcessId()；
DWORD sessionlD;
if (ProcessIdToSessionld(processID, &sessionID)) (
tprintf(
TEXT ('*Process ' %u' runs in Terminal Services session ' %u'	,
processID, sessionlD);
} else {
// ProcessIdToSessionld might fail if you don't have enough rights
// to access the process for which you pass the ID as parameter.
// Notice that it is not the case here because we * re using our own process ID. tprintf(
TEXT("Unable to get Terminal Services session ID for process '%u'"), processID);
}
一个服务的命名内核对象始终位于全局命名空间内的。默认情况下，在终端服务中，应用 程序自己的命名内核对象在会话的命名空间内。不过，我们也可以强制把一个命名对象放 入全局命名空间，具体做法是在其名称前加上“Global、”前缀，如下面的例子所示：
HANDLE h = CreateEvent(NULL, FALSE, FALSE, TEXT("Global\\MyName"));
也可以显式指出我们希望把一个内核对象放入当前会话的命名空间，具体做法式在名称前 加上“Local、”前缀,如下面的例子所示:
HANDLE h = CreateEvent (NULL, FALSE, FALSE, TEXT(•'Local\\MyName"));
■
Microsoft认为Global和Local是保留关键字，所以除非为了强制一个特定的命名空间，否 则不应在对象名称中使用它fl Jo Microsoft还认为Session是保留关键字。所以(举一个例子), 我们可以使用Sessions当前会话ID>\。不过，我们不能使用另一个会话中的名称和Session 前缀来新建一个对象，这样会导致函数调用失败，GetLastError会返回
ERROR_ACCESS_DENIEDo
说明 所有保留关键字都是区分大小写的。
3.3.5	专有命名空间
创建内核对象时，可以传递指向一个SECURITY_ATTRIBUTES结构的指针，从而保护对 该对象的访问。不过，在Windows Vista发布之前，我们不可能防止一个共享对象的名称 被“劫持”。任何进程——即使是最低权限的进程——都能用任何指定的名称来创建一个
如dows核心编程(第5版)
对象。以前面的例子为例(应用程序用一个命名的互斥量对象来检测该程序的一个实例是否 正在运行)，很容易另外写一个应用程序来创建一个同名的内核对象。如果它先于单实例应 用程序启动，“单实例”的应用程序就变成了一个“无实例”的应用程序——始终都是一 启动就退出，错误地认为它自己的另一个实例已在运行。这是大家熟悉的几种拒绝服务(DoS) 攻击的基本机制。注意，未命名的内核对象不会遭受DoS攻击。另外，应用程序使用未命 名对象是相当普遍的，即使这些对象不能在进程之间共享。
如果想确保我们的应用程序创建的内核对象名称永远不会和其他应用程序的名称冲突，或 者想确保它们免遭劫持，可以定义一个自定义的前缀，并把它作为自己的专有命名空间使 用，这和使用Global和Local前缀是相似的。负责创建内核对象的服务器进程将定义一个 边界描述符(boundary descriptor),以对命名空间的名称自身进行保护。
Singleton应用程序(即03-Singleton.exe,对应的Singleton.cpp源代码将在稍后列出)展示了 如何利用专有命名空间，以一种更安全的方式来实现前面描述的单实例应用程序。 (Singleton是单一的意思，即同时只允许该程序的一个实例)。启动程序后，会出现如图3.5 所示的窗口。
图3-5 Singleton的第一个实例正在运行
保持程序的运行状态，然后启动同一个程序，就会出现如图3.6所示的窗口，它指出已经 检测到了程序另一个实例。
53
图3・6第一个实例正在运行，又启动了 Singleton的第二个实例
研究一下Singleton.cpp源代码中的Checkinstances函数，我们便可以理解三个“如何”： ①如何创建一个边界(bondary)；②如何将对应于本地管理员组(Local Administrators)的一个
第3章内核对象
安全描述^(security identifier, SID)和它关联起来；③如何创建或打开其名称被用作互斥量 内核对象前缀的一个专有命名空间。边界描述符将获得一个名称，但更重要的是，它会获 得与它关联的一个特权用户组的SIDo这样一来，Windows就可以确保只有在该用户隶属 于这个特权组时，以其身份运行的应用程序才能在相同的边界中创建相同的命名空间，从 而访问在这个边界中创建的、以专有命名空间的名称作为前缀的内核对象。
如果由于名称和SID泄密，导致一个低特权的恶意程序创建了相同的边界描述符，那么(举 个例子来说)当它试图创建或打开使用一个高特权帐户保护的专有命名空间时，调用就会失 败，GetLastError会返回ERROR_ACCESS_DENIED。如果恶意程序有足够的权限来创 建或打开命名空间，再担心这个就多余了——因为恶意程序有足够的权限来造成更大的破 坏，而非仅仅是劫持一个内核对象名称那么简单。
一
Singleton.cpp
/**********★*******************************★************************★********** Module: Singleton.cpp
Notices： Copyright (c) 2008 Jeffrey Richter & Christophe Nasarre
//
#include #include	■stdafx.h" •resource.h*
♦include #include #include tinclude #include	■..\CommonFiles\CmnHdr.h"	/* See Appendix A. ♦/ <windowsx.h> <Sddl.h>	// for SID management <tchar.h> <strsafe.h>
///////////////////////////////////////////////////////////////////////////////
// Main dialog
HWND g_hDlg；
// Mutex, boundary and namespace used to detect previous running instance HANDLE g_hSingleton = NULL;
HANDLE g__hBoundary = NULL;
HANDLE g_hNamespace = NULL;
// Keep track whether or not the namespace was created or open for clean-up BOOL g_bNamespaceOpened = FALSE;
// Names of boundary and private namespace
PCTSTR g_szBoundary = TEXT(■3-Boundary■);
PCTSTR g__szNamespace = TEXT (" 3 -Namespace *)；
#define DETAILS_CTRL GetDlgItem(g_hDlg/ IDC_EDIT_DETAILS)
//////////////〃/〃///////////////////////////////////////////〃////〃////〃〃/
// Adds a string to the "Details" edit control
void AddText(PCTSTR pszFormat, ・..)(
va_list argList；
lows核心编程（第5版）
va_start(argList, pszFormat);
TCHAR sz[20 * 1024J;
Edit_GetText(DETAILS_CTRL, sz, _countof(sz)); _vstprintf_s(
_tcschr (sz> TEXT(' \0 ') ) , __countof (sz) - _tcslen(sz), pszFormat, argList);
Edit_SetText(DETAILS_CTRLr sz);
va_end(argList);
///////////////////////////////////////////////////////////////////////////////
void Dlg_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify) (
switch (id) (
case IDOK：	,
case IDCANCEL:
// User has clicked on the Exit button
//or dismissed the dialog with ESCAPE EndDialog(hwndz id);
break；
} 、 -
}
///////////////////////////////////////////////////////////////////////////////
void Checkinstances() (
// Create the boundary descriptor g_hBoundary = CreateBoundaryDescriptor(g_szBoundary, 0);
// Create a SID corresponding to the Local Administrator group
BYTE localAdminSID[SECURITY_MAX_SID_SIZE];
PSID pLocalAdminSID = &localAdminSID;
DWORD cbSID = sizeof(localAdminSID);
if (!CreateWellKnownSid(
WinBuiltinAdministratorsSid, NULL, pLocalAdminSID, &cbSID)
){
AddText(TEXT(■AddSIDToBoundaryDescriptor failed： %u\r\n"), GetLastError())；
return；
}
// Associate the Local Admin SID to the boundary descriptor
// --> only applications running under an administrator user
//	will be able to access the kernel objects in the same namespace
if (!AddSIDToBoundaryDescriptor(&g_hBoundary, pLocalAdminSID)) (
AddText(TEXT(•AddSIDToBbundaryDescriptor failed: %u\r\n"), GetLastError());	.
return；
)
// Create the namespace for Local Administrators only
SECURITY.ATTRIBUTES sa；
sa.nLength = sizeof(sa);
sa.blnheritHandle = FALSE;
if (!ConvertStringSecurityDegcriptorToSeCurityDescriptor(
TEXT CD: (A;;GA;;;BA)-),
SDDL_REVISION„1, &sa. IpSecurityDescfriptjit, NULL)) {
AddText(TEXT(•Security Descriptor creation failed： %u\r\n"), GetLastError())； return；	.
第3章内核对象
g_hNamespace =
CreatePrivateNamespace(&sa, g_hBoundaryr g_szNamespace)；
// Don't forget to release memory for the security descriptor LocalFree(sa.IpSecurityDescriptor);
// Check the private namespace creation result
DWORD dwLastError = GetLastError()；
if (g_hNamespace == NULL) {
// Nothing to do if access is denied
// --＞ this code must run under a Local Administrator account
if (dwLastError == ERROR_JkCCESS_DENIED) (
AddText(TEXT("Access denied when creating the namespace.\r\n"))； AddText(TEXT(* You must be running as Administrator.\r\n\r\n"))； return；
} else (
if (dwLastError == ERROR_ALREADY_EXISTS) (
// If another instance has already created the namespace,
//we need to open it instead.
AddText(TEXT(■CreatePrivateNamespace failed: %u\r\n"), dwLastError)； g_hNamespace = OpenPrivateNamespace(g_hBoundaryr g__szNamespace)； if (g_hNamespace == NULL) (
AddText(TEXT(■ and OpenPrivateNamespace failed: %u\r\n")z dwLastError);
return；
} else {
g_bNamespaceOpened = TRUE；
AddText(TEXT(■ but OpenPrivateNamespace succeeded\r\n\r\n"));
}
} else (
AddText(TEXT("Unexpected error occured: %u\r\n\r\n*)r dwLastError);
return；
}
)
}
// Try to create the mutex object with a name
// based on the private namespace
TCHAR szMutexName[64];
StringCchPrintf(szMutexName, _countof(szMutexName), TEXT(B%s\\%s")/ g__szNamespace, TEXT("Singleton"))；
g_hSingleton = CieateMutex(NULL, FALSE, szMutexName);
if (GetLastError() == ERROR_ALREADY_EXISTS) (
// There is already an instance of this Singleton object
AddText(TEXT("Another instance of Singleton is running：\r\n"))；
AddText(TEXT(■一＞ Impossible to access application features.\r\n"));
} else {
// First time the Singleton object is created
AddText(TEXT("First instance of Singleton:\r\nB))；
AddText(TEXT("一＞ Access application features now.\r\n"))；
}
}
///////////////////"////////////TV////////////////////////////////////////////
BOOL Dlg_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM iParam) (
chSETDLGICONS(hwnd, IDI_SINGLETON);
// Keep track of the main dialog window handle
indows核心编程（第5版）
g_hDlg = hwnd；
// Check whether another instance is already running Checkinstances();
return(TRUE)；
}
///////////////////////////////////////////////////////////////////////////////
INT_PTR WINAPI Dlg_Proc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM 1Param) ( switch (uMsg) (
chHANDLE_DLGMSG(hwnd, WM_COMMAND, Dlg_OnCommand); chHANDLE_DLGMSG(hwnd, WM_INITDIALOG, Dlg_OnInitDialog);
}
return(FALSE);
}
//////////////////////////////////////////////////〃///////////////////////////
int APIENTRY _tWinMain(HINSTANCE hlnstance,
HINSTANCE hPrevInstance,
LPTSTR IpCmdLine,
int nCmdShow)
(
UNREFERENCED_PARAMETER(hPrevInstance);
UNREFERENCED^PARAMETER(IpCmdLine);
// Show main window
DialogBox(hlnstance, MAKEINTRESOURCE(IDD_SINGLETON), NULL, Dlg_Proc);
// Don't forget to clean up and release kernel resources
if (g_hSingleton != NULL) ( CloseHandle(g_hSingleton);
)
if (g_hNamespace != NULL) (
if (g_bNamespaceOpened) ( // Open namespace
ClosePrivateNamespace(g_hNamespace, 0)；
} else { // Created namespace
ClosePrivateNamespace(g_hNamespace, PRIVATEL-NAMESPACE_FLAG2DESTR0Y); }
)
if (g_hBoundary != NULL) {
DeleteBoundaryDescriptor(g_hBoundary)；
}
return(0);
}
//////////////////////////////// End of File //////////////////////////////////
54・58
下面来分析一下Checkinstances函数的几个不同的步骤。第一步是创建边界描述符。为此, 需要用一个字符串标识符来命名一个范围，专有命名空间将在这个范围中定义。这个名称 作为以下函数的第一个参数进行传递：
第3章内核对象
HANDLE CreateBoundaryDescriptor(
PCTSTR pszName,
DWORD dwFlags)；
在当前版本的Windows中，第二个参数还没有什么用，因此应该为它传入0。注意，函数 的签名暗示返回值是一个内核对象句柄，但实情并非如此。返回值是一个指针，它指向一 个用户模式的结构，结构中包含了边界的定义。由于这个原因，永远都不要把返回的句柄 值传给 CloseHandle；相反，应该把它传给 DeleteBoundaryDescriptoro
第二步，通过调用以下函数，将一个特权用户组的SID(客户端应用程序将在这些用户的上 下文中运行)与边界描述符关联起来：
BOOL AddSIDToBoundaryDescriptor(
HANDLE* phBoundaryDescriptor,
PSID pRequiredSid);
在Singleton示例程序中，为了创建Local Administrator组的SID,我的办法是调用 AllocateAndlnitializeSid 函数，并将用于描述这个组的 SECURITY_BUILTIN_ DOMAIN_RID 和 DOMAIN_ALIAS_RID_ADMINS 作为参数传入。在 WinNT.h 头文件中， 定义了所有已知的组的一个列表。
调用以下函数来创建专有命名空间时，边界描述符(伪)句柄作为第二个参数传给该函数：
HANDLE CreatePrivateNamespace(
PSECURITY_ATTRIBUTES psa,
PVOID pvBoundaryDescriptor,
PCTSTR pszAliasPrefix):
作为第一个参数传给该函数的SECURITY_ATTR1BUTES是供Windows使用的，用于 允许或禁止一个应用程序通过调用OpenPrivateNamespace来访问命名空间并在其中打 开/创建对象。具体可以使用的选项和“在一个文件系统的目录中可以使用的选项”是完 全一样的。这是为“打开命名空间”设置的一个筛选层。为边界描述符添加的SID决定 了谁能进入边界并创建命名空间。在Singleton例子中，SECURITY_ATTRIBUTE是通 过调用 ConvertStringSecurityDescriptorToSecurityDescriptor 函数来构造的。该函数获 取一个具有复杂语法结构的字符串作为第一个参数。要具体了解安全描述符字符串的语 法,请访问以下两个网址：http://msdn2.microsoft.com/en-us/library/aa374928.aspx 和 http://msdn2.microsoft.com/en-us/library/aa379602.aspxo
虽然CreateBoundaryDescriptor返回的是一个HANDLE(虽然在Microsoft,这不是一个 内核对象句柄，而是一个伪句柄)，但这里pvBoundaryDescriptor的类型是VOID。用 于创建内核对象的字符串前缀被指定为第三个参数。如果试图创建一个已经存在的专有 命名空间，CreatePrivateNamespace 将返回 NULL , GetLastError 将返回 ERROR_ALREADY_EXISTS。在这种情况下，需要使用以下函数来打开现有的专有命名 空间：
HANDLE OpenPrivateNamespace(
PVOID pvBoundaryDescriptor,
PCTSTR pszAliasPrefix)；
5X0
l^^dows核心编程(第5版)
注意，CreatePrivateNamespace 和 OpenPrivateNamespace 返回的 HANDLE 并不是内核对象 句柄；可以调用ClosePrivateNamespace来关闭它们返回的这种伪句柄；
.	BOOLEAN ClosePrivateNamespace(
HANDLE hNamespace,
DWORD dwFlags);
如果我们已经创建了命名空间，而且不希望它在关闭后仍然可见，应该将 PRIVATE__NAMESPACE_FLAG_DESTROY作为第二个参数传给上述函数，反之则传入 0o边界将在以下两种情况下关闭：进程终止运行或者调用DeleteBoundaryDescriptor,并 将边界伪句柄作为其唯一的参数传给它。如果还有内核对象正在使用，命名空间一定不能 关闭。如果在内部还有■内核对象时关闭一个命名空间，其他人就可以在同一个边界中，在 重新创建的一个相同的命名空间中，并在其中创建一个同名的内核对象，使DoS攻击再次 成为可能。
总之，专有命名空间相当于可供我们在其中创建内核对象的一个目录。和其他目录一样， 专有命名空间也有一个和它关联的安全描述符，这个描述符是在调用 CreatePrivateNamespace的时候设置的。但是，和文件系统的目录不同的是，这个命名空 间是没有父目录的，也没有名称——我们将“边界描述符”作为对这个边界进行引用的一 个名称来使用。正是由于这个原因，所以在Sysintemals的Process Explorer中，对于“前 缀以一个专有命名空间为基础”的内核对象，它们显示的是前缀，而不是我们预期 的anamespace nameV9前缀。"・・・\”前缀隐藏了需要保密的信息，能更好地防范潜在的黑 客。我们为专有命名空间指定的名称是~个别名，只在进程内可见。其他进程(甚至是同一 个进程)可以打开同一个专有命名空间，并为它指定一个不同的别名。
创建普通目录时，需要对父目录执执行一次访问检查，确定是否能在其中创建一个子目录。 类似地，为了创建命名空间，要执行一次边界测试——在当前线程的令牌(token)中，必须 包含作为边界一部分的所有SIDo
3.3.6复制对象句柄
跨进程边界共享内核对象的最后一•招是使用DuplicateHandle函数：
BOOL DuplicateHandle(
HANDLE hSourceProcessHandle,
HANDLE hSourceHandle,
HANDLE hTargetProcessHandle,
PHANDLE phTargetHandle,
DWORD dwDesiredAccess,
BOOL blnheritHandle, DWORD dwOptions);
简单地说，这个函数获得一个进程的句柄表中的一个记录项，然后在另一个进程的句柄表 中创建这个记录项的-个副本。DuplicateHandle需要获取几个参数，但它的工作过程实际 是非常简单的。正如本节稍后的例子演示的那样，该函数最常见的一种用法可能涉及系统 中同时运行的三个不同的进程。
第3章内核对象
调用DuplicateHandle时，它的第一个参数和第三个参数（hSourceProcessHandle和 hTargetProcessHandle）是内核对象句柄。这两个句柄本身必须相对于调用DuplicateHandle 函数的那个进程。此外，这两个参数标识的必须是进程内核对象；如果我们传递的句柄指 向的是其他类型的内核对象，函数调用就会失败。我们将在第4章详细讨论进程内核对象。 就目前来说，我们只需知道一旦启动一个浙的进程，系统就会创建一个进程内核对象。
第二个参数hSourceHandle是指向任何类型的内核对象的一个句柄。但是，它的句柄值一 定不能与调用DuplicateHandle函数的那个进程相关。相反，该句柄必须与 hSourceProcessHandle句柄所标识的那个进程相关。函数会将源进程中的句柄信息复制到 hTarget ProcessHanle所标识进程的句柄表中。第四个参数是phTargetHandle,它是一个 HANDLE变量的地址，用来接收复制得到的HANDLE值。
DuplicateHandle的最后三个参数用于指定这个内核对象在目标进程中所对应的句柄表项， 应该使用何种访问掩码和继承标志。dwOptions参数可以为0（零）或者以下两个标志的任意 组合：DUPLICATE_SAME_ACCESS 和 DUPLICATE_CLOSE_SOURCEo
如果指定DUPLICATE_SAME_ACCESS标志，将向DuplicateHandle函数表明我们希望 目标句柄拥有与源进程的句柄一样的访问掩码。使用这个标志后，DuplicateHandle函数会 忽略它的dwDesiredAccess参数。
如果指定DUPLICATE_CLOSE_SOURCE标志，会关闭源进程中的句柄。利用这个标志, 一个进程可以轻松地将一个内核对象传给另一个进程。如果使用了这个标志，内核对象的 使用计数不会受到影响。
我将用一个例子来演示DuplicateHandle函数的工作方式。在这个例子中，进程S是源进 程，它拥有对一个内核对象的访问权：进程T是目标进程，它将获得对这个内核对象访问 权。进程C则是一个催化剂（catalyst）进程，它执行对DuplicateHandle的调用。在本例中， 我是出于演示函数工作方式的目的才将句柄值直接写到代码中。在实际应用中，应该将句 柄值放到变量中，再将变量作为参数传给函数。
进程C的句柄表（参见表3-4）包含两个句柄值，即1和2。句柄值1标识了进程S的进程内 核对象，而句柄值2标识进程T的进程内核对象。
表3V进程C的句柄表
索引	指向内核对象内存块的指针	访问掩码（包含标志位的一个DWORD）	标志
1	0xF0000000（与进程S对应的内核对象）	Ox????????	0x00000000
2	0xF00000l0（与进程T对应的内核对象）	Ox????????	0x00000000
61
表3.5是进程S的句柄表，其中只包含一项，该项的句柄值为2。这个句柄可以标识任何类 型的内核对象——不一定是进程内核对象。

Endows核心编程（第5版）
表3-5进程S的句柄表
索引	指向内核对象内存块的指针	访问掩码（包含标志位的一个DWORD）	标志
1	0x00000000	（不可用）	（不可用）
2	0xF0000020（任意内核对象）	Ox????????	0x00000000
表3-6显示了在进程C调用DuplicateHandle函数之前，进程T的句柄表所包含的内容。 可以看出，进程T的句柄表只包含一项，该项的句柄值为2；句柄项1目前没有使用。
表3书 调用DuplicateHandle函数之前，进程T的句柄表
索引	指向内核对象内存块的指针	访问掩码（包含标志位的一个DWORD）	标志
1	0x00000000	（不可用）	（不可用）
2	0xF0000030（任意内核对象）	Ox????????	0x00000000
如果进程C现在用以下代码来调用DuplicateHandle,那么只有进程T的句柄表会发生变 化，如表3・7所示：
DuplicateHandle（1, 2, 2, &hObj, 0, TRUE, DUPLICATE_SAME_ACCESS）;
表3・7调用DuplicateHandle函数之后，进程T的句柄表
索引	指向内核对象内存块的指针	访问掩码（包含标志位的一个DWORD）	标志
1	0xF0000020	Ox????????	0x00000001
2	0xF0000030（任意内核对象）	Ox????????	0x00000000
在这个过程中，进程S句柄表的第2项被复制到进程T的句柄表的第1项oDuplicateHandle 还用值1来填充了进程C的hObj变量：这个1是进程T的句柄表中的索引，新的记录项 被复制到这个位置。
由于向DuplicateHandle函数传递了 DUPLICATE_SAME_ACCESS标志，所以在进程T 的句柄表中，这个句柄的访问掩码与进程S句柄表的那一个项的访问掩码是一样的。同时, DUPLICATE_SAME_ACCESS 标志会导致 DuplicateHandle 忽略其 dwDesiredAccess 参 数。最后要注意，继承标志位己经被打开，因为己经传给DuplicateHandle函数 blnheritHandle 参数的值为 TRUE。
使用DuplicateHandle函数（来复制内核对象句柄）所遇到的问题和继承（内核对象句柄）时同 样：目标进程不知道它现在能访问一个新的内核对象。所以，进程C必须以某种方式来通 知进程T,告诉它现在可以访问一个内核对象了，而且必须使用某种形式的进程间通信机 制，将hObj中的句柄值传给进程T。显然，使用命令行参数或者更改进程T的环境变量是 行不通的，因为进程己经启动并开始运行了。我们必须使用窗口消息或者其他进程间通信 （IPC）机制。
62-63
第3章内核对象
刚才介绍的是D叩licateHandle最常见的用法。可以看出，它是一个非常灵活的函数。不 过，在涉及三个不同的进程时，它其实是很少使用的(可能是由于进程C不知道进程S使用 的一个对象的句柄值)。通常，在只涉及两个进程的时候，才会调用DupiicateHandle函数。 来设想下面这个情景：一个进程能访问另一个进程也想访问的一个对象；或者说，一个进 程想把一个内核对象的访问权授予另一个进程。例如，假定进程S能访问一个内核对象， 并希望进程T也能访问这个对象，那么可以像下面这样调用DupiicateHandle函数：
// All of the following code is executed by Process S.
// Create a mutex object accessible by Process S.
HANDLE hObjInProcessS = CreateMutex(NULL, FALSE, NULL);
// Get a handle to Process T's kernel object.
HANDLE. hProcessT = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessIdT);
HANDLE hObjInProcessT； // An uninitialized handle relative to Process T.
// Give Process T access to our mutex object.
DupiicateHandle(GetCurrentProcess(), hObjInProcessS, hProcessT,
&hObjInProcessT, 0, FALSE, DUPLICATE_SAME_ACCESS);
// Use some IPC mechanism to get the handle value of hObjInProcessS into Process T.
// We no longer need to communicate with Process T.
CloseHandle(hProcessT);
♦ • ♦
// When Process S no longer needs to use the mutex, it should close it.
CloseHandle(hObjInProcessS)；
调用GetCurrentProcess会返回一个伪句柄，该句柄始终标识主调进程 本例是进程S。 一旦DupiicateHandle函数返回，hObjlnProcessT就是一个相对于进程T的句柄，它标识 的对象就由“进程S中的代码引用的hObjlnProcessS"所标识的对象。在Process S中，永 远不要执行以下代码：
// Process S should never attempt to close the duplicated handle.
CloseHandle(hObjInProcessT)；
如果进程S执行了上述代码，CloseHandle函数调用可能会失败，也可能不会失败。但 CloseHandle函数调用成功与否并不重要。重要的是:假如进程S碰巧能用与hObjInProcessT 相同的句柄值访问一个内核对象，上述函数调用就会成功。换言之，这个调用可能会错误 地关闭一个内核对象；下次进程S试图访问这个内核对象时，肯定会造成应用程序运行失 常(这还只是好听的一种说法)。
还可以通过另一种方式来使用DupiicateHandle：假设一个进程拥有对一个文件映射对象的 读写权限。在程序中的某个位置，我们要调用一个函数，并希望它对文件映射对象进行只 读访问。为了使应用程序变得更健壮，可以使用DupiicateHandle为现有的对象创建一个 新句柄，并确保这个新句柄只有只读权限。然后，把这个只读句柄传给函数。采取这种方 式，函数中的代码绝对不会对文件映射对象执行意外的写入操作。以下代码对此进行了 演示：
int WINAPI _tWinMain(HINSTANCE hlnstExe, HINSTANCE,
LPTSTR szCmdLine, int nCmdShow) (
Vindows核心编程（第5版）
// Create a file-mapping object; the handle has read/write access. HANDLE hFileMapRW = CreateFi1eMapping(INVALID_HANDLE_VALUE,
NULL, PAGE_READWRITE, 0, 10240, NULL);
// Create another handle to the file-mapping object；
// the handle has read-only access.
HANDLE hFileMapRO;
DuplicateHandle(GetCurrentProcess(), hFileMapRW, GetCurrentProcess(), &hFileMapRO, FILE_MAP_READ, FALSE, 0);
// Call the function that should only read from the file mapping. ReadFromTheFi1eMapping(hFileMapRO)；
// Close the read-only file-mapping object.
CloseHandle(hFileMapRO)；
// We can still read/write Che file-mapping object using hFileMapRW.
// When the main codq doesn't access the file mapping anymore,
// close it.
CloseHandle(hFileMapRW)；
64
章章章章章章 呈一Ma■一 4 5 6 7 8 9 与 序？ g
进程
线程调度、优先级和关联性 用户模式下的线程同步 用内核对象进行线程同步
同步设备I/。与异步设备I/O Windows线程池 溥程 塑般
本章内容
0
2
V:
4.1
4.2
4.3
4.4
4.5

第4章进
程
编写第一个Windows应用程序
CreateProcess 函数 终止进程
管理员以宗狷晃k限昙箱
本章将讨论系统如何管理正在运行的所有应用程序。首先解释什么是进程，系统如何创建 一个进程内核对象来管理每个进程。然后解释如何利用与一个进程关联的内核对象来操纵 该进程。接下来，要讨论进程的各种不同的特性（或属性），以及用于查询和更改这些属性 的几个函数。另外，还要讨论如何利用一些函数在系统中创建或生成额外的进程。当然， 最后还要讨论如何终止线程，这是讨论进程时必不可少的主题之一。
一般将进程定义成一个正在运行的程序的一个实例，它由以下两部分构成。
•	一个内核对象，操作系统用它来管理进程。内核对象也是系统保存进程统计信息的 地方。
•	一个地址空间，其中包含所有可执行文件（executable）或DLL模块的代码和数据。 此外，它还包含动态内存分配，比如线程堆栈和堆的分配。
进程是有“惰性”的。进程要做任何事情，都必须让一个线程在它的上下文中运行。该线 程负责执行进程地址空间包含的代码。事实上，一个进程可以有多个线程，所有线程都在 进程的地址空间中“同时”执行代码。为此，每个线程都有它自己的一组CPU寄存器和它 自己的堆栈。每个进程至少要有一个线程来执行进程地址空间包含的代码。当系统创建一 个进程的时候，会自动为进程创建第一个线程，这称为主线程（primary thread）o然后，这个 线程再创建更多的线程，后者再创建更多的线程……。如果没有线程要执行进程地址空间 包含的代码，进程就失去了继续存在的理由。这时，系统会自动销毁进程及其地址空间。
对于所有要运行的线程，操作系统会轮流为每个线程调度一些CPU时间。它会采取循环 （round-robin,轮询或轮流）方式，为每个线程都分配时间片（称为“量”或者“量程”，即 quantum）,从而营造出所有线程都在“并发”运行的假象。图4.1展示了一台单CPU的机 器的工作方式。
如果计算机配备了多个CPU,操作系统会采用更复杂的算法为线程分配CPU时间。
Windows核心编程(第5版)
Microsoft Windows可以同时让不同的CPU执行不同的线程，使多个线程能真正并发运行。 在这种类型的计算机系统中，Windows内核将负责线程的所有管理和调度任务。我们不必 在自己的代码中做任何特别的事情，即可享受到多处理器系统带来的好处。不过，为了更 好地利用这些CPU,需要我们在应用程序的算法中多做一些文章。
线程-线程
图4・1在单CPU的计算机上，操作系统以轮询方式为每个单独的线程分配时间量
4.1编写第一个Windows应用程序
Windows支持两种类型的应用程序:GUI程序和CUI程序。前者是“图形用户界面"(Graphical User Interface)的简称，后者是“控制台用户界面”(Console User Interface)的简称。GUI程 序一个图形化的前端。它可以创建窗口，可以拥有菜单，能通过对话框与用户交互，还能 使用所有标准的“视窗化”的东西。Windows附带的几乎所有应用程序(比如记事本、计算 器和写字板等)都是GUI程序。控制台程序则是基于文本的。它们一般不会创建窗口或进程 消息，而且不需要GUL虽然CUI程序是在屏幕上的一个窗口中运行的，但这个窗口中只 有文本。“命令提示符”(在Windows Vista下为CMD.EXE)是CUI程序的一个典型的例子。 其实，这两种应用程序的界线是非常模糊的。我们完全可以创建出能显示对话框的CUI应 用程序。例如，在执行CMD.EXE并打开“命令提示符”后，便可以执行一个特殊的命令 来显示一个图形化对话框。在其中选择想要执行的命令，不必强行记住命令行解释器所支 持的各种命令。另外，还可以创建一个要向控制台窗口输出文本字符串的GUI应用程序。 例如，我自己写的GUI程序经常都要创建一个控制台窗口，便于我查看应用程序执行期间 的调试信息。不过，我当然要鼓励大家尽可能在程序中使用一个GUI,而不要使用老式的 字符界面，后者对用户来说不太友好！
68
用Microsoft Visual Studio来创建一个应用程序项目时，集成开发环境会设置各种链接 器开关，使链接器将子系统的正确类型嵌入最终生成的可执行文件(executable)中。对于 CUI程序，这个链接器开关是/SUBSYSTEM:CONSOLE,对于GUI程序，则是
第4章进程
/SUBSYSTEM:WINDOWS.,用户运行应用程序时，操作系统的加载程序（loader）会检查可 执行文件映像的文件头，并获取这个子系统值。如果此值表明是一个CUI程序，加载程序 会自动确保有一个可用的文本控制台窗口（比如从命令提示符启动这个程序的时候）。另外, 如有必要，会创建一个新窗口（比如从Windows资源管理器启动这个CUI程序的时候）。如 果此值表明是一个GUI程序，加载器就不会创建控制台窗口；相反，它只是加载这个程序。 一旦应用程序开始运行，操作系统就不再关心应用程序的界面是什么类型的。
Windows应用程序必须有一个入口点函数，应用程序开始运行时，这个函数会被调用。 C/C++开发人员可以使用以下两种入口点函数：
Int WINAPI _tWinMain（
HINSTANCE hlnstanceExe,
HINSTANCE,
PTSTR pszCmdLine,
int nCmdShow）;
int _tmain（
int argc,
TCHAR *argv[],
TCHAR *envp[]）;
注意，具体的符号取决于我们是否要使用Unicode字符串。操作系统实际并不调用我们所 写的入口点函数。相反，它会调用由C/C++运行库实现并在链接时使用-entry:命令行选项 来设置的一个C/C++运行时启动函数。该函数将初始化C/C++运行库，使我们能调用malloc 和free之类的函数。它还确保了在我们的代码开始执行之前，我们声明的任何全局和静态 O+对象都被正确地构造。表4.1总结了源代码要实现什么入口点函数，以及每个入口点函 数应该在什么时候使用。
表4・1应用程序类型和相应的入口点函数
应用程序类型	入口点函数（入口）	嵌入可执行文件的启动函数
处理ANSI字符和字符串的GUI应用程序	tWinMain (WinMain)	WinMainCRTStartup
处理Unicode字符和字符串的GUI应用程序	<WinMain (wWinMain)	wWinMainCRTStartup
处理ANSI字符和字符串的CU【应甬程序	tmain (Main)	mainCRTStartup
处理Unicode字符和字符串的CUI应用程序	tmain (Wmain)	wmainCRTStartup
在链接可执行文件时，链接器将选择正确的C/C++运行库启动函数。如果指定了 /SUBSYSTEM:WINDOWS链接器开关，链接器就会寻找WinMain或wWinMain函 数。如果没有找到这两个函数，链接器将返回一个"unresolved external symboln （无法 解析的外部符号）错误；否则，它将根据具体情况分别选择WinMainCRTStartup或 wWinMainCRTStartup 函数。
类似地，如果指定了 /SUBSYSTEM:CONSOLE链接器开关，链接器就会寻找main或wmain 函数，并根据情况分别选择mainCRTStartup或wmainCRTStartup函数。同样地，如果 main和wmain函数都没有找到，链接器会返回一个uunresolved external symbol”（无法解 析的外部符号）错误。
Windows核心编程（第5版）
不过，一个鲜为人知的事实是，我们完全可以从自己的项目中移除/SUBSYSTEM链接器开 关。一旦这样做，链接器就会自动判断应该将应用程序设为哪一个子系统。链接时，链接 器会检查代码中包括4个函数中的哪一个（WinMain, wWinMain, main或wmain）,并据 此推算可执行文件应该是哪个子系统，以及应该在可执行文件中嵌入哪个C/C++启动函数。
Windows/Visual C什新手开发人员常犯的一个错误是在创建一个新项目时错误选择了项目 类型。例如，开发人员可能选择创建一个新的Win32应用程序项目，但、创建的入口点函数 是main。生成应用程序时，会报告一个链接器错误，因为Win32应用程序项目会设置 /SUBSYSTEM:WINDOWS链接器开美，但WinMain或wWinMain函数并不存在。此时, 开发人员有以下4个选择。
•	把main函数改为WinMaino这通常不是最佳方案，因为开发人员真正希望的可能 是创建一个控制台应用程序。
•	在Visual C++中创建一个新的Win32控制台应用程序项目，然后在新项目中添加现 有的源代码模块。这个办法过于繁琐。它相当于一切都从头开始，而且必须删除原 来的项目文件。
•	在项目属性对话框中，定位到Configuration Properties（配置属性）/Linker（链接 器）/System（系统）/SubSystem（子系统）选项，把/SUBSYSTEM:WINDOWS 开关改为 /SUBSYSTEM:CONSOLE，如图4-2所示。这是最简单的解决方案，很少有人知 道这个窍门。
•	在项目属性对话框中，删除/SUBSYSTEM:WINDOWS开关。这是我个人最偏爱的 选项，因为它能提供最大的灵活性。现在，链接器将根据源代码中实现的函数来执 行正确的操作。用Visual Studio创建一个新的Win32应用程序或Win32控制台应 用程序项目时，这才应该是真正的默认设置啊！
图4-2在项目的属性对话框中，为一个项目选择一个CUI子系统
第4章进程
所有C/C++运行库启动函数所做的事情基本都是一样的，区别在于它们要处理的是ANSI 字符串，还是Unicode字符串；以及在初始化C运行库之后，它们调用的是哪一个入口点 函数。Visual C++自带C运行库的源代码。可以在crtexe.c文件中找到4个启动函数的源代 码。这些启动函数的用途简单总结如下。
•	获取指向新进程的完整命令行的一个指针。
•	获取指向新进程的环境变量的一个指针。
•	初始化C/C++运行库的全局变量。如果包含了 StdLib.h,我们的代码就可以访问这 些变量。表4.2总结了这些变量。
•	初始化C运行库内存分配函数(malloc和calloc)和其他底层I/O例程使用的堆 (heap)o
•	调用所有全局和静态C++类对象的构造函数。
表4.2程序可以访问的C/C++运行库全局变量
变量名称	类型	描述和推荐使用的Windows函数
_osver	unsigned int	操作系统的构建(build)版本号。例如，Windows Vista RTM为build 6000。 所以，osver的值就是6000。请换用GetVersionEx
_winmajor	unsigned int	以十六进制表示的Windows系统的主版本号。对于Windows Vista,该值 为 6。清换用 GetVersionEx
_winminor	unsigned int	以十六进制表示的Windows系统的次版本号。对于Windows Vista,该值 为 0。清换用 GetVersionEx
winver	unsigned int	(winmajor « 8) + winminoro 请换用 GetVersionEx
argc	unsigned int	命令行上传递的参数的个数。请换用GetCommandLine
_argv _wargv	char wchar_t	长度为_argc的一个数组，其中含有指向ANSI/Unicode字符串的指针。 数组中的每-项都指向-个命令行参数。注意，如果定义了.UNICODE, __argv就为NULL；如果没有定义，则_wargv为NULL。请换用 GetCommandLine
_environ _wenviron	char wchar_t	一个指针数组，这些指针指向ANSI/Unicode字符串。数组中的每…项都 指向一个环境字符串。注意，如果没有定义.UNICODE, _wenviron就为 NULL；如果已经定义了.UNICODE, .environ就为NULL。请换用 GetEnvironmentStrings 或 GetEnvironmentVariable
_pgmptr _wpgmptr	char wchar_t	正在运行的程序的名称及其ANSI/Unicode完整路径。注意，如果已经定 义了— UNICODE, _j>gmptr 就为 NULL。如果没有定义.UNICODE, _wpgmptr 就为 NULL。请换用 GetModuleFileName,将 NULL 作为第 一个参数传给该函数
完成所有这些初始化工作之后，C/C++启动函数就会调用应用程序的入口点函数。如果我 们写了一个tWinMain函数，而且定义了.UNICODE,其调用过程将如下所示：
indows核心编程(第5版)
GetStartupInfo(&StartupInfo)；
inc nMainRecVal = wWinMain((HINSTANCE)&_ImageBase, NULL, pszCommandLineUnicode, (Startupinfo.dwFlags & STARTF_USESHOWWINDOW)
? Startuplnfo.wShowWindow : SW_SHOWDEFAULT);
如果没有定义.UNICODE,其调用过程将如下所示：
GetStartupInfo(&StartupInfo);
inc nMainRecVal = WinMain((HINSTANCE)&_ImageBase, NULL, pszConunandLineAnsi, (Startupinfo.dwFlags & STARTF_USESHOWWINDOW)
? Startuplnfo.wShowWindow : SW_SHOWDEFAULT)；
注意，_ImageBase是一个链接器定义的伪变量，表明可执行文件被映射到应用程序内存中 的什么位置。4.1.1节“进程实例句柄”将进一步讨论这个问题。
如果我们写了一个_tmain函数，而且定义了.UNICODE,那么其调用过程如下：
int nMainRetVal = wmain(argc, argv, envp)；
如果没有定义.UNICODE,调用过程如下：
int nMainRetVal = main(argc, argv, envp)；
注意，用Visual Studio向导生成应用程序时,CUI应用程序的入口中没有定义第三个参数(环 境变量块)，如下所示：
int _tmain(int argc, TCHAR* argv[])；
如果需要访问进程的环境变量，只需将上述调用替换成下面这一行：
int _tmain(int argc, TCHAR* argv[]f TCHAR* env[])
这个env参数指向一个数组，数组中包含所有环境变量及其值，两者用等号(=)分隔。对环 境变量的详细讨论将在4.1.4节“进程的环境变量”进行。
入口点函数返回后，启动函数将调用C运行库函数exit,向其传递返回值(nMainRetVal)o exit函数执行以下任务。
•	调用_onexit函数调用所注册的任何一个函数。
•	调用所有全局和静态C++类对象的析构函数。
•	在DEBUG生成中，如果设置了_CRTDBG_LEAK_CHECK_DF标志，就通过调用 ^CrtDumpMemoryLeaks函数来生成内存泄漏报告。
•	调用操作系统的ExitProcess函数，向其传入nMainRetValo这会导致操作系统“杀 死”我们的进程，并设置它的退出代码。
注意，为安全起见，Microsoft并不赞成使用所有这些变量，因为使用了这些变量的代码可 能会在C运行库初始化这些变量之前开始执行。有鉴于此，我们应该直接调用对应的 Windows API 函数。
72
第4章进程
4.1.1进程实例句柄
加载到进程地址空间的每一个可执行文件或者DLL文件都被赋予了一个独一无二的实例 句柄。可执行文件的实例被当作(w)WinMain函数的第一个参数hlnstanceExe传入。在需 要加载资源的函数调用中，一般都要提供此句柄的值。例如，为了从可执行文件的映像中 加载一个图标资源，就需要调用下面这个函数：
HICON Loadicon(
HINSTANCE hlnstance,
PCTSTR pszlcon);
Loadicon函数的第一个参数指出哪个文件(可执行文件或DLL文件)包含了想要加载的资 源。许多应用程序都会将(w)WinMain的hlnstanceExe参数保存在一个全局变量中，使其 很容易被可执行文件的所有代码访问。
Platform SDK文档指出，有的函数需要一个HMODULE类型的参数。下面的
GetModuleFileName函数便是一个例子：
DWORD GetModuleFileName(
HMODULE hlnstModule,
PTSTR pszPath,
DWORD cchPath)；
说明 事实上，HMODULE和HINSTANCE完全是一回事。如果某个函数的文档指出需要 一个HMODULE参数,我们可以传入一个HINSTANCE,反之亦然。之所以有两种 数据类型，是由于在16位Window s中，HMODULE和HINSTANCE表示不同类型 的数据。
(w)WinMain的hlnstanceExe参数的实际值是一个内存基地址；系统将可执行文件的映像 加载到进程地址空间中的这个位置。例如，假如系统打开可执行文件，并将它的内容加载 到地址 0x00400000,则(w)WinMain 的 hlnstanceExe 参数值为 0x00400000o
可执行文件的映像具体加载到哪一个基地址，是由链接器决定的。不同的链接器使用不同 的默认基地址。由于历史原因，Visual Studio链接器使用的默认基地址是0x00400000,这 是在运行Windows 98时，可执行文件的映像能加载到的最低的一个地址。使用Microsoft 链接器的/BASE:address链接器开关，可以更改要将应用程序加载到哪个基地址。
为了知道一个可执行文件或DLL文件被加载到进程地址空间的什么位置，可以使用如下所 示的GetModuleHandle函数来返回一个句柄/基地址：
HMODULE GetModuleHandle(PCTSTR pszModule);
调用这个函数时，要传递一个以0为终止符的字符串，它指定了巳在主调进程的地址空间 中加载的一个可执行文件或DLL文件的名称。如果系统找到了指定的可执行文件或DLL 文件名称，GetModuleHandle就会返回可执行文件/DLL文件映像加载到的基地址。如果
,
Endows核心编程（第5版）
没有找到文件，系统将返回NULLo GetModuleHandle的另一个用法是为pszModule参数 传入NULL,这样可以返回主调进程的可执行文件的基地址。如果我们的代码在一个DLL 中，那么可利用两种方法来了解代码正在什么模块中运行。第一个办法是利用链接器提供 的伪变量_ImageBase,它指向当前正在运行的模块的基地址。如前所述，这是C运行库 启动代码在调用我们的（w）WinMain函数时所做的事情。
第二种方法是调用 GetModuleHandleEx , 将 GET_MODULE_HANDLE_EX_ FLAG_FROM__ADDRESS作为它的第一个参数，将当前函数的地址作为第二个参数。最 后一个参数是一个指向HMODULE的指针，GetModuleHandleEx会用传入函数（即第二个 参数）所在DLL的基地址来填写该指针。以下代码对这两种方法都进行了演示：
extern "C" const IMAGE_DOS__HEADER _ImageBase;
void DumpModule () {
// Get the base address of the running application.
// Can be different from the running module if this code is in a DLL.
HMODULE hModule = GetModuleHandle(NULL)；
_tprintf (TEXT ("with GetModuleHandle (NULL) = Ox%x\r\n*), hModule冒谶
// Use the pseudo-variable _ImageBase to get
// the address of the current module hModule/hlnstance.
_tprintf(TEXT("with_ImageBase = Ox%x\r\nB), (HINSTANCE)&_ImageBase);
// Pass the address of the current method DumpModule	翌
//as parameter to GetModuleHandleEx to get the address
// of the current module hModule/binstance.'/1	/；
hModule = NULL;
GetModuleHandleEx(
get_modulejhandle__ex.flag_fro>caddress ,
(PCTSTR)DumpModule,
&hModule)；
_tprintf(TEXT(*with GetModuleHandleEx = Ox%x\r\n*), hModule)；
}
int _tmain(int argc, TCHAR* argv(J) (
DumpModule();	就炎*峥'•、疙g.‘、'#：潴勤罗
return(0)；
记住GetModuleHandle函数的两大重要特征。首先，它只检查主调进程的地址空间。如果 主调进程没有使用任何通用对话框函数，那么一旦调用GetModuleHandle,并向其传递 ComDlg32,就会导致返回NULL——即使ComDlg32.dll也许已经加载到其他进程的地址 空间。其次，调用GetModuleHandle并向其传递NULL值，会返回进程的地址空间中的可 执行文件的基地址。所以，即使调用GetModuleHandle(NULL)的代码是在一个DLL文件 中，返回值仍是可执行文件的基地址，而非DLL文件的基地址。
4.1.2进程前一个实例的句柄
如前所述，C/C++运行库启动代码总是向(w)WinMain的hPrevInstance参数传递NULLo 该参数用于16位Windows系统，因而仍然将其保留为(w)WinMain的一个参数，目的只是
第4章进程
方便我们移植16位Windows应用程序。绝对不要在自己的代码中引用这个参数。因此, 我始终会像下面这样写自己的(w)WinMain函数t
int WINAPI _tWinMain(
HINSTANCE hlnstanceExe,
HINSTANCE,
PSTR pszCmdLine,
int nCmdShow);
由于没有为第二个参数指定参数名，所以编译器不会报告一个“参数没有被引用到” (parameter not referenced)警告。Visual Studio选择了一个不同的解决方案：在向导生成的 C++ GUI项目中，利用了 UNREFERENCED_PARAMETER宏来消除这种警告。下面这 段代码对此进行了演示：
int APIENTRY _tWinMain(HINSTANCE hlnstance,
HINSTANCE hPrevInstance,
LPTSTR IpCmdLine,
int nCmdShow) {
UNREFERENCED_PARAMETER(hPrevInstance);
UNREFERENCED_PARAMETER(IpCmdLine);
4.1.3进程的命令行
系统在创建一个新进程时，会传一个命令行给它。这个命令行几乎总是非空的；至少，用 于创建新进程的可执行文件的名称是命令行上的第一个标记(token)o不过，在后面讨论 CreateProcess函数的时候，我们会知道进程能接收只由一个字符构成的命令行，即用于终 止字符串的0。C运行库的启动代码开始执行一个GUI应用程序时，会调用Windows函数 GetCommandLine来获取进程的完整命令行，忽略可执行文件的名称，然后将指向命令行 剩余部分的一个指针传给WinMain的pszCmdLine参数。
应用程序可以通过自己选择的任何一种方式来分析和解释命令行字符串。我们实际上可以 写数据到pszCmdLine参数所指向的内存缓冲区，但在任何情况下，写入缓冲区的时候都 不应该越界。就我个人而言，我始终把它当作一个只读的缓冲区来对待。如果想对命令行 进行改动，我首先会将命令行缓冲区复制到我的应用程序的一个本地缓冲区，再对自己的 本地缓冲区进行修改。
我们也可以效仿C运行库的例子，通过调用GetCommandLine函数来获得一个指向进程 完整命令行的指针，如下所示：
PTSTR GetCommandLine()；
该函数返回一个缓冲区指针，缓冲区中包含完整的命令行(包括已执行的文件的完整路径 名)。注意，GetCommandLine返回的总是同一个缓冲区的地址。这是不应该向pszCmdLine 写入数据的另一个理由：它指向同一个缓冲区，修改它之后，就没办法知道原来的命令行 是什么。

lows核心编程(第5版)
许多应用程序都倾向于将命令行解析成一组单独的标记。虽然Microsoft反对继续使用全局 变量_argc和_argv(或_wargv),但应用程序仍然可以使用它们来访问对命令行的每个 标记。利用在ShellAPI.h文件中声明并由Shell32.dll导出的函数CommandLineToArgvW, 即可将任何Unicode字符串分解成单独的标记：
PWSTR* CommandLineToArgvW(
PWSTR pszCmdLine,
int* pNumArgs);
正如函数名最后的W所暗示的一样，这个函数只有Unicode版本(W代表wide)。第一个 参数pszCmdLine指向一个命令行字符串。这通常是前面的GetCommandLineW函数调用 的返回值。pNumArgs参数是一个整数的地址，该整数被设为命令行中的实参的数目。 CommandLineToArgvW返回的是一个Unicode字符串指针数组的地址。
CommandLineToArgvW在内部分配内存。许多应用程序不会释放这块内存 它们依靠 操作系统在进程终止时释放这块内存。这是完全可以接受的。不过，如果想自己释放内存, 正确的做法就是调用HeapFree,如下所示：
int nNumArgs；
PWSTR *ppArgv = CommandLineToArgvW(GetCommandLineW(), SnNumArgs)；
// Use che arguments...
if (*ppArgv[1] == L'x') (
• • •
}
// Free the memory block
HeapFree(GetProcessHeap(), 0, ppArgv)；
4.1.4进程的环境变量
每个进程都有一个与它关联的环境块(environment block),这是在进程地址空间内分配的一 块内存，其中包含字符串和下面相似：
=：：=：：\
VarNamel=VarValuel\O
VarName2=VarValue2\0
VarName3=VarValue3\0 ...
VarNameX=VarValueX\O
\0
每个字符串的第一部分是一个环境变量的名称，后跟一个等号，等号之后是希望赋给此变 量的值。注意，除了第一个字符串，块中可能还有其他字符串是以等号(=)开头的。 这种字符串不作为环境变量使用，详情参见4.1.8节“进程的当前目录”。
前面已介绍了访问环境块的两种方式，它们分别使用了不同形式的输出，需要采用不同的 方法来解析。第一种方式是调用GetEnvironmentStrings函数来获取完整的环境块。得到 的环境块的格式与前一段描述的完全一致。下面的代码展示了如何在这种情况下提取环境 变量及其内容：
第4章进程
void DumpEnvStrings() (
PTSTR pEnvBlock = GetEnvironmentStrings();
// Parse the block with the following format:
//
// =.. •
// var=value\O
//
// var=value\0\0
// Note that some other strings might begin with '=•.
// Here is an example when the application is started from a network share. // [0]	\
// (1) =C:=C:\Windows\System32
// [2] =ExitCode=00000000
//
TCHAR szName[MAX_PATH];
TCHAR szValue[MAX_PATH];
PTSTR pszCurrent = pEnvBlock;
HRESULT hr = S_OK;
PCTSTR pszPos = NULL;
int current = 0;
while (pszCurrent != NULL) (
// Skip the meaningless strings like:
// ■=::
if (*pszCurrent != TEXT(•=')) (
// Look for '=' separator.
pszPos = _tcschr(pszCurrent, TEXT('=•))；
// Point now to the first character of the value. pszPos++；
// Copy the variable name. size_t cbNameLength = // Without the' = *
(size_t)pszPos - (size_t)pszCurrent - sizeof(TCHAR);
hr = StringCbCopyN(szName, MAX_PATH, pszCurrent, cbNameLength)； if (FAILED(hr)) {
break；
// Copy the variable value with the last NULL character
// and allow truncation because this is for UI only.艾：夜*" hr = StringCchCopyN(szValue, MAX_PATH, pszPos, _tcslen(pszPos)+1)； if (SUCCEEDED(hr)) (
_tprintf(TEXT("(%u] %s=%8\r\nB)/ current, szName, szValue)；
} else // something wrong happened; check for truncation, if (hr == STRSAFE_E_INSUFFICIENT-BUFFER) (
_tprintf(TEXT(•[%u] %s»%s...\r\n"), current, szName, szValue);
} else ( // This should never occur.	如：藉：
_tprintf(
TEXT(*[%u] %s=???\r\n"), current, szName );
break；
}
} else (
.tprintf(TEXT(*[%u] %s\r\n")r
}
// Next variable please.
current++；
// Move to the end of the string, while (*pszCurrent != TEXT('\0*)) pszCurrent++；
pszCurrent++；
// Check if it was not the last string, if (*pszCurrent == TEXT(*\0'))
e
Endows核心编程(第5版)
break;
}；
// Don't forget to free the memory.
FreeEnvi ronment Strings(pEnvBlock)；
"'K!	HI ■
, 77-79
以=开头的无效字符串会被跳过。其他每个有效的字符串会被逐一解析。=字符被用作名称 与值之间的分隔符。如果不再需要GetEnvironmentStrings函数返回的内存块，应调用 FreeEnvironmentStrings 函数来释放它：
BOOL FreeEnvironmentStrings(PTSTR pszEnvironmentBlock);
注意，在上述代码段中，使用了 C运行库的安全字符串函数。目的是利用StringCbCopyN 算出字符串的长度(以字节为单位)，如果长度太长以至于目标缓冲区装不下，就用 StringCchCopyN函数来截断。
访问环境变量的第二种方式是CUT程序专用的，它通过应用程序main入口点函数所接收 的TCHAR* env[]参数来实现。不同于GetEnvironmentStrings返回的值，env是一个字符 串指针数组，每个指针都指向一个不同的环境变量(其定义采用常规的“名称=值”的格式)。 在数组中，指向最后一个环境变量字符串的指针的后面，会有一个NULL指针，表明这是 数组的末尾，如下所示：
void DumpEnvVariables(PTSTR pEnvBlock[]) (
int current = 0;
PTSTR* pElement = (PTSTR *)pEnvBlock;
PTSTR pCurrent = NULL;
while (pElement != NULL) (
pCurrent = (PTSTR)(*pElement);
if (pCurrent == NULL) (
//没有更多的环境变量了
pElement = NULL;
} else (
_tprintf(TEXT("[%u] %s\r\n")# current, pCurrent)；
current++； pElement++;
}
}
t--	强场—点馈，繇顾霉醵撅谶嚣憩骚精麟嬲
注意，以等号开头的那些无效字符串在我们接收到env之前就巳经被移除了，所以不必进 行处理。
由于等号用于分隔名称和值，所以它并不是名称的一部分。另外，空格是有意义的。例如， 如果声明了以下两个变量，然后再比较XYZ和ABC的值，系统就会报告两个变量不相同， 因为等号之前和之后的任何空格都会被考虑在内：
XYZ= Windows (注意等号后的空格)
ABC=Windows
例如，如果想添加以下两个字符串到环境块，那么名字后带有空格的环境变量XYZ就会包
第4章进程
含Home,而名字后不带空格的环境变量XYZ就会包含Work,如下所示：
XYZ =Home （注意等号前的空格）
XYZ=Work
用户登录Windows时，系统会创建外壳（shell）进程，并将一组环境字符串与其关联。系统 通过检查注册表中的两个注册表项来获得初始的环境字符串。
第一个注册表项包含应用于系统的所有环境变量的列表：
HKEY_LOCAL_MACHINE\SYSTEMXCurrentControlSet\Control\Session Manager\Environment
第二个注册表项包含应用于当前登录用户的所有环境变量的列表：
HKEY_CURRENT_USER\Environment
用户可以添加、删除或更改所有这些变量，具体做法是从Control Panel（控制面板）中选择 System（系统），然后单击Advanced System Settins（高级系统设置）链接，然后单击Enviroment Variable（环境变量）按钮，随后将弹出下图所示的对话框。
Umt vanwes far cnaavre
Syitem v mrtr.n
VanaUe	V4	*
J<TJ»UGGSL.. c^xts	」
J<T_pCEajTAB...	Jwotofte..
NK«X.P..・ SRV、：5boto，g/g侦igoftc…
ComSpec	C: Wndows.yston32gnd.exe ■
1 — _〕「c*0* _]
要有管理员权限才能更改system variables（系统变量）列表中包含的变量。
应用程序还可以使用各种注册表函数来修改这些注册表项。不过，为了使改动对所有应用 程序生效，用户必须注销并重新登录。有的应用程序（比如资源管理器、任务管理器和控制 面板）可以在其主窗口接收到WM_SETTINGCHANGE消息时，用新的注册表项来更新它 们的环境块。例如，假如更新了注册表项，并希望应用程序立即更新它们的环境块，可以 进行如下调用：
SendMessage（HWND_BROADCASTZ WM_SETTINGCHANGE, 0, （LPARAM） TEXT（"Environment"））;
通常，子进程会继承一组环境变量，这些环境变量和父进程的环境变量相同。不过，父进 程可以控制哪些环境变量允许子进程继承，详情参见后文对CreateProcess函数的讨论。这 里所说的“继承”是指子进程获得父进程的环境块的一个副本，这个副本是子进程专用的。

核心编程(第5版)
换言之，子进程和父进程并不共享同一个环境块。这意味着子进程可以在自己的环境块中 添加、删除或修改变量，但这些改动不会影响到父进程的环境块。
应用程序经常利用环境变量让用户精细地调整其行为。用户创建一个环境变量并进行初始 化。然后，当用户调用应用程序时，应用程序在环境块中查找变量。如果找到变量，就会 解析变量的值，并调整其自己的行为。
环境块的问题是，用户不容易设置或理解它们。用户需要正确拼写变量名称，而且还必须 知道变量值的确切格式。另一方面，绝大多数图形应用程序都允许用户使用对话框来调整 应用程序的行为。这个办法对用户来说要友好得多。
如果仍然想使用环境变量，有几个函数可供我们的应用程序调用。可以使用 GetEnvironmentVariable函数来判断一个环境变量是否存在；如果存在，它的值又是什 么。如下所示：
DWORD GetEnvironmentVariable(
PCTSTR pszName,
PTSTR pszValue,
DWORD cchvalue);
调用GetEnvironmentVariable时，pszName指向预期的变量名称，pszValue指向保存变 量值的缓冲区，而cchValue指出缓冲区大小(用字符数来表示)。如果在环境中找到变量名， GetEnvironmentVariable函数将返回复制到缓冲区的字符数；如果在环境中没有找到变量 名，就返回0。然而，由于我们不知道需要多少个字符来保存一个环境变量的值，所以 GetEnvironmentVariable允许我们向cchValue参数的值传入0,此时它会返回所需字符的 数量，其中包括末尾的NULL字符。以下代码演示了如何安全地使用这个函数：
void PrintEnvironmentVariable(PCTSTR pszVariableNaine) {
PTSTR pszValue = NULL;
// Get the size of the buffer that is required to store the value DWORD dwResult = GetEnvironmentVariable(pszVariableNaine, pszValue, 0); if (dwResult != 0)(
// Allocate the buffer to store the environment variable value DWORD size = dwResult * sizeof(TCHAR); pszValue = (PTSTR)malloc(size); GetEnvironmentVariable(pszVariableNainer pszValue, size); _tprintf (TEXT( *%s=%s\nB), pszVariableNaine, pszValue)； free(pszValue);
else (
_tprintf(TEXT(■'%s,=<unknown value>\n*), pszVar:
普W蜂"	•顼
}
}
}
在许多字符串的内部，都包含了 “可替换字符串”。例如，我在注册表的某个地方发现了 下面这个字符串：
%USERPROFILE%\Documents
两个百分号(%)之间的这部分内容就是一个“可替换字符串”。在这种情况下，环境变量 USERPROFILE的值应该放在这里。在我的机器上，USERPROFILE环境变量的值如下:
C:\Users\jrichter
所以，执行字符串替换之后，生成的扩展字符串是:
第4章进程
C:\Users\jrichter\Documents
由于这种形式的字符串替换非常常见，所以Windows专门提供了 ExpandEnvironmentStrings 函数，如下所示：
DWORD ExpandEnvironmentStrings(
PTCSTR pszSrc,
PTSTR pszDst,
DWORD chSize);
调用这个函数时,pszSrc参数是包含“可替换环境变量字符串”的一个字符串的地址opszDst 参数是用于接收扩展字符串的一个缓冲区的地址，而chSize参数是这个缓冲区的最大大小 (用字符数来表示)。返回值是保存扩展字符串所需的缓冲区的大小(用字符数来表示)。如果 chSize参数小于此值，％%变量就不会扩展，而是被替换为空字符串。所以，通常要调用 两次 ExpandEnvironmentStrings 函数，如下所示：
DWORD chValue =
ExpandEnvironmentStrings(TEXT(・PATH=,%PATH%,'), NULL, 0);
PTSTR pszBuffer = new TCHAR[chValue];
chValue = ExpandEnvironmentStrings(TEXT(・PATH=•%PATH%'■), pszBuffer^ chValue); _tprintf(TEXT("%s\r\nB), pszBuffer)；
deleted pszBuffer；
最后，可以使用SetEnvironmentVariable函数添加一个变量，删除一个变量，或者修改一 个变量的值*
BOOL SetEnvironmentVariable(
PCTSTR pszName,
PCTSTR pszValue);
此函数将pszName所标识的一个变量设为pszValue参数所标识的值。如果己经有一个具 有指定名称的变量，SetEnvironmentVariable函数就会修改它的值。如果指定的变量不存 在，就添加这个变量。如果pszValue为NULL,则从环境块中删除该变量。
应该始终使用这些函数来操纵进程的环境块。
4.1.5进程的关联性
通常，进程中的线程可以在主机的任何CPU上执行。然而，也可以强迫线程在可用CPU 的一个子集上运行，这称为“处理器关联性” (processor affinity),详情将在第7章讨论。 子进程继承了其父进程的关联性。
4.1.6进程的错误模式
与每个进程都关联了一组标志，这些标志的作用是让系统知道进程如何响应严重错误，包 括磁盘介质错误、未处理的异常、文件查找错误以及数据对齐错误等。进程可以调用 SetErrorMode函数来告诉系统如何处理这些错误：
I^^dows核心编程(第5版)
UINT SetErrorMode(UINT fuErrorMode);
fuErrorMode参数是表4-3列出的标志按位或的结果。
表 4-3 SetErrorMode 的标志	
标志	描述
SEM_FAILCRITICALERRORS	系统不显示严重错误处理程序(critical-error-handler)消息 框，并将错误返回主调进程
SEM_NOGPFAULTERRORBOX	系统不显示常规保护错误(general-protection-fault)消息框。 此标志只应该由调试程序设置；该调试程序用一个异常处 理程序来自行处理常规保护(general protection» GP)错误
SEM NOOPENHLEERRORBOX	系统查找文件失败时，不显示消息框
SEM_NOALIGNMENTFAULTEXCEPT	系统自动修复内存对齐错误，并使应用程序看不到这些错 误。此标志对x86/x64处理器无效
默认情况下，子进程会继承父进程的错误模式标志。换言之，如果一个进程已经打开了 SEM_NOGPFAULTERRORBOX标志，并生成了一个子进程，则子进程也会打开这个标 志。京过，子进程自己并不知道这一点，而且在编写它时，或许根本没有考虑到要处理GP 错误。如果一个GP错误发生在子进程的一个线程中，则子进程可能在不通知用户的情况 下终止。父进程可以阻止子进程继承其错误模式，方法是在调用CreateProcess时指定 CREATE_DEFAULT_ERROR_MODE 标志(我们将在本章稍后讨论 CreateProcess)。
4.1.7进程当前所在的驱动器和目录
如果不提供完整的路径名，各种Windows函数会在当前驱动器的当前目录查找文件和目录。 例如，如果进程中的一个线程调用CreateFile来打开一个文件(未指定完整路径名)，系统 将在当前驱动器和目录查找该文件。
系统在内部跟踪记录着一个进程的当前驱动器和目录。由于这种信息是以进程为单位来维 护的，所以假如进程中的一个线程更改了当前驱动器或目录，那么对于该进程中的所有线 程来说，此信息被更改了。
一个线程可以调用以下两个函数来获取和设置其所在进程的当前驱动器和目录：
DWORD GetCurrentDirectory(
DWORD cchCurDir,
PTSTR pszCurDir)；
BOOL SetCurrentDirectory(PCTSTR pszCurDir);
如果提供的缓冲区不够大，GetCurrentDirectory将返回保存此文件夹所需要的字符数(包 括末尾的W字符)，而且不会向缓冲区复制任何内容。在此情况下，可以将缓冲区设为 NULLo如果调用成功，就会返回字符串的长度(字符数)。在这种情况下返回的长度并不包
第4章进程
括末尾的⑩。
说明 WinDef.h文件中被定义为260的常量MAX_PATH是目录名称或文件名称的最大字 符数。所以在调用GetCurrentDirectory的时候，向该函数传递由MAX_PATH个 TCHAR类型的元素构成的一个缓冲区是非常安全的。
4.1.8进程的当前目录
系统跟踪记录着进程的当前驱动器和目录，但它没有记录每个驱动器的当前目录。不过， 利用操作系统提供的支持，可以处理多个驱动器的当前目录。这个支持是通过进程的环境 字符串来提供的。例如，一个进程可以有如下所示的两个环境变量：
=C:=C:\Utility\Bin
=D：=D：\Program Files
上述变量指出进程在C驱动器的当前目录为\Ut山ty\Bin,在D驱动器的当前目录为'Program Fileso
如果调用一个函数，并且传入的路径名限定的是当前驱动器以外的驱动器，系统会在进程 的环境块中查找与指定驱动器号(也称盘符)关联的变量。如果找到与指定驱动器号关联的 变量，系统就将变曜的值作为当前目录使用。如果变量没有找到，系统就假定指定驱动器 的当前目录是它的根目录。
例如,假定进程的当前目录为C:\Utility\Bin,而且我们调用CreateFile来打开D:ReadMe.Txt, 那么系统就会查找环境变量=D:。由于=D:变量是存在的，所以系统将尝试从D:\Program Files目录打开ReadMe.Txt文件。如果=D:变量不存在，系统就会试着从D盘的根目录打开 ReadMe.Txt文件。Windows的文件函数从来不会添加或更改驱动器号环境变量一一它们只 是读取这种变量。
说明 可以使用C运行库函数_chdir而不是Windows的SetCurrentDirectory函数来更改 当前目录。_chdir函数在内部调用SetCurrentDirectory,但chdir还会调用 SetEnvironmentVariable来添加或修改环境变量，从而使不同驱动器的当前目录得 以保留。
如果一个父进程创建了一个希望传给子进程的环境块，子进程的环境块就不会自动继承父 进程的当前目录。相反，子进程的当前目录默认为每个驱动器的根目录。如果希望子进程 继承父进程的当前目录，父进程就必须在生成子进程之前，创建这些驱动器号环境变量， 并把它们添加到环境块中。父进程可以通过调用GetFullPathName来获得它的当前目录：
DWORD GetFullPathName(
PCTSTR pszFile,
DWORD cchPath,
PTSTR pszPath,
PTSTR *ppszFilePart)；
西idows核心编程(第5版)
I.
例如，要想获得C驱动器的当前目录，可以像下面这样调用GetFullPathName：
TCHAR szCurDir[MAX_PATH];
DWORD cchLength = GetFullPathName(TEXT("C:"), MAX_PATH, szCurDir, NULL); 其结果就是，驱动器号环境变量通常必须放在环境块的开始处。
4.1.9系统版本
很多时候，应用程序需要判断用户所运行的Windows系统的版本。例如，应用程序也许会 调用CreateFileTransacted之类的函数，以利用Windows的事务处理式(transacted)文件系 统功能。但是，只有Windows Vista完整实现了这些函数。
在很长的时间里，Windows 应用程序编程接口(Application Programming Interface, API)—直 在提供一个Get Version函数：
DWORD GetVersion()；
这个函数具有悠久的历史。它最初是为16位Windows系统设计的。其思路非常简单，在 高位字(high word)中返回MS-DOS版本号，在低位字(low word)中返回Windows版本号。
在每个字中，高位字节(high byte)代表主版本号，低位字节(low byte)代表次版本号。
遗憾的是，写代码的程序员犯了一个小错误，造成Windows版本号的顺序颠倒了，即主版 本号跑到了低位字节，次版本号跑到了高位字节。由于许多程序员己经开始使用这个函数, 所以Microsoft被迫保留这个函数的错误形式，并修改相应文档以指明这个错误。
鉴于围绕着GetVersion而产生的一些困惑，Microsoft添加了一个新的函数GetVersionEx, 如下所示：
BOOL GetVersionEx(POSVERSIONINFOEX pVersionlnformation)；
这个函数要求我们在自己的应用程序中分配一个OSVERSIONINFOEX结构，并把此结构 的地址传给GetVersionEx<, OSVERSIONINFOEX结构如下所示：
typedef struct {
DWORD dwOSVersionlnfoSize；
DWORD dwMajorVersion；
DWORD dwMinorVersion；
DWORD dwBuiIdNumber；
DWORD dwPlatformld;
TCHAR szCSDVersion[128];
WORD wServicePackMajor；
WORD wServicePackMinor；
WORD wSuiteMask;
BYTE wProductType;
BYTE wReserved；
} OSVERSIONINFOEX, *POSVERSIONINFOEX;
OSVERSIONINFOEX结构从Windows 2000开始就一直存在。Windows系统的其他版 本使用的是较老的 OSVERSIONINFO 结构，后者没有 wServicePackMajor, wSuiteMask, wProductType 和 wReservedMembers 成员。
第4章进程
注意，此结构为系统版本号的每一个组成部分都提供了不同的成员。这样做是避免程序员 过于麻烦地去提取低位字、高位字、低位字节和高位字节，使应用程序更容易将希望的版 本号与主机系统的版本号进行对比。表4-4描述了 OSVERSIONINFOEX结构的成员。
表4-4 OSVERSIONINFOEX结构的成员
成员	描述
dwOS VersionlnfoSize	调用 GetVersionEx 前，必须设为 sizeoROSVERSIONINFO)或 sizeof (OSVERSIONINFOEX)
dwMajorVersion	主机系统的主版本号
dwMinorVersion	主机系统的次版本号
dwBuildNumber	当前系统的构建版本号
dwPlatformld	标识当前系统支持的套件(suite)。值可以是VER_PLATFORM_WIN32s(Win32s), VER_PLATFORM_WIN32_WINDOWS(Windows 95/Windows 98)或 VER_ PLATFORM_ WIN32_NT(Windows NT/Windows 2000 , Windows XP , Windows Server 2003 以及 Windows Vista)
szCSDVersion	此字段包含额外的文本，提供了与已安装的操作系统有关的更多的信息
wServicePackMajor	最新安装的Service Pack的主版本号
wServicePackMinor	最新安装的Service Pack的次版本号
wSuiteMask	标识当前系统上可用的suite(s),包括VER_SUITE_SMALLBUSINESS, VER SUITE ENTERPRISE, VER SUITE BACKOFHCE , VER SUITE COMMUNICATIONS, VERJSUTTE_TERMINAL, VER_SUTIE_SMALLBUSINESS_ RESTRICTED, VER__SUITE_EMBEDDEDNT, VER_SUITE_ DATACENTER, VER_SUITE_SINGLEUSERTS(每个用户一个终端服务会话)， VER_SUITE_PERSONAL(用来区别 Vista 的 Home 版本和 Professional 版)本， VER SUITE BLADE, VER SUITE EMBEDDED RESTRICTED, VER SUITE SECURITY_APPLIANCE, VER_SUITE__STORAGE_SERVER 和 VER_SUITE_ COMPUTE SERVER
wProductType	指出安装的是以下操作系统产品中的哪一个：VER NT WORKSTATION, VER_NT_SERVER 或 VER NT DOMAIN CONTROLLER
wReserved	保留，供将来使用
MSDN 网站的 “Getting the System VersionM 网页(http://msdn2.microsoft.com/en-gb/library/ ms724429.aspx)提供了一个详细的代码示例，展示了如何解读OSVERSIONINFOEX结构 的每一个字段。
为了进一步简化编程，Windows Vista还提供了 VerifyVersionlnfo函数，它能比较主机系 统的版本和应用程序要求的版本，如下所示：
■^^dows核心编程(第5版)
BOOL VerifyVersionlnfo(
POSVERSIONINFOEX pVersionlnformacion, DWORD dwTypeMask,
DWORDLONG dwlConditionMask);
要使用此函数，必须分配一个OSVERSIONINFOEX结构，将它的dwOSVersionlnfoSize 成员初始化为结构的大小，然后初始化结构中其他需要检查的任何成员。调用 VerifyVersionlnfo时，dwTypeMask参数指出我们初始化了此结构中的哪些成员。 dwTypeMask参数是以下任何标志通过按位或起来的结果：VER_MINORVERSION, VER_MAJORVERSION , VER_BUILDNUMBER , VER__PLATFORMID , VER__ SERVICEPACKMINOR , VER SERVICEPACKMAJOR , VER SUITENAME 和 VER_PRODUCT__TYPEo 最后一个参数是 dwlConditionMask,它是一个 64 位值，决定 着函数如何将系统的版本信息与我们希望的版本信息进行比较。
dwlConditionMask使用一套复杂的位组合对比较方式进行了描述。为了创建恰当的位组 合，可以使用 VER_SET_CONDITION 宏：
VER_SET_CONDITION（
DWORDLONG dwlConditionMask,
ULONG dwTypeBitMask,
ULONG dwConditionMask）
第一个参数dwlConditionMask表示我们正在对哪个变量的位进行操作。注意，不要传入 这个变量的地址，因为VER_SET_CONDITION是一个宏，而不是一个函数。 dwTypeBitMask参数指出想要比较OSVERSIONINFOEX结构中的一个成员。为了比较多 个成员，必须多次调用VER_SET_CONDITION, 一个成员都调用一次。我们传给 VerifyVersionlnfo 的 dwTypeMask 的标志（VER_MINORVERSION 和 VER_ BUILDNUMBER 等）与传给 VER_SET_CONDITION 的 dwTypeBitMask 参数的标志是一 样的。
VER_SET_CONDITION的最后一个参数是dwConditionMask,它指出我们想如何进行比 较。它可以是下面这些值之一：VER_EQUAL , VER_GREATER , VER_GREATER_EQUAL , VER_LESS 或 VER_LESS_EQUAL。注意,在比较 VER_PRODUCT_TYPE信息的时候，可以使用这些值。例如，VER_NT_WORKSTATION 小于VER_NT_SERVER。不过，对于VER_SUITENAME信息，就不能执行这种测试。 相反，必须使用VER_AND（所有套件产品都必须安装）或VER_OR（至少安装了其中的一个 套件产品）。
建立了一组条件之后，就可以调用VerifyVersionlnfoo如果成功住机系统满足我们的应用 程序的所有要求），它将返回一个非零的值。如果VerifyVersioiiInfo返回0,就表明主机系 统不符合要求，或者表明调用函数的方式不正确。可以通过调用GetLastError来判断函数 为什么返回0。如果GetLastError返回ERROR_OLD_WIN_VERSION,表明函数调用是 正确的，但系统不符合应用程序的要求。
第4章进程
下面的例子展示了如何测试主机系统是不是Windows Vista：
// Prepare the OSVERSIONINFOEX structure to indicate Windows Vista. OSVERSIONINFOEX osver = { 0 };
osver.dwOSVersionlnfoSize = sizeof(osver);
osver.dwMaj orVersion = 6;
osver.dwMinorVersion = 0;
osver.dwPlat formld = VER_PLATFORM_WIN32_NT；
// Prepare the condition mask.
DWORDLONG dwlConditionMask = 0;// You MUST initialize this to 0. VER_SET_CONDITION(dwlCondit ionMask, VER_MAJORVERSION, VER_EQUAL); VER_SET_CONDITION(dwlConditionMask, VER_MINORVERSION, VER_EQUAL); VER_SET_CONDITION(dwlCondit ionMask, VER_PLATFORMID, VER_EQUAL);
// Perform the version test.
if (VerifyVersionInfo(&osver, VER_MAJORVERSION I VER_MINORVERSION I VER_PLATFORMID, dwlCondi t ionMask))(
// The host system is Windows Vista exactly.
} else (
// The host system is NOT Windows Vista.
4.2	CreateProcess 函数
我们用CreateProcess函数来创建一个进程，如下所示：
BOOL CreateProcess(
PCTSTR pszApplicationName,
PTSTR pszCommandLine,
PSECURITY_ATTRIBUTES psaProcess,
PSECURITY_ATTRIBUTES psaThread,
BOOL blnheritHandles,
DWORD fdwCreate,
PVOID pvEnvironment,
PCTSTR pszCurDir,
PSTARTUPINFO psiStartlnfo,
PPROCESS_INFORMATION ppiProcInfo);
一个线程调用CreateProcess时，系统将创建一个进程内核对象，其初始使用计数为1。进 程内核对象不是进程本身，而是操作系统用来管理这个进程的一个小型数据结构——可以 把进程内核对象想象成由进程统计信息构成的一个小型数据结构。然后，系统为新进程创 建一个虚拟地址空间，并将可执行文件(和所有必要的DLL)的代码及数据加载到进程的地 址空间。
然后，系统为新进程的主线程创建一个线程内核对象(其使用计数为1)。和进程内核对象一 样，线程内核对象也是一个小型数据结构，操作系统用它来管理这个线程。这个主线程一 开始就会执行C/C"运行时的启动例程，它是由链接器设为应用程序入口的，最终会调用 应用程序WinMain, wWinMain, main或wmain函数。如果系统成功创建了新进程和主 线程，CreateProcess 将返回 TRUE*
说明 CreateProcess在进程完全初始化好之前就返回TRUE。这意味着操作系统加载程 序(loader)尚未尝试定位所有必要的DLL。如果一个DLL找不到或者不能正确初始 化，进程就会终止。因为CreateProcess返回TRUE,所以父进程不会注意到任何 初始化问题。
I^^dows核心编程(第5版)
OK,前面只是泛泛而谈，下面将分小节逐一讨论CreateProcess的参数。
4.2.1	pszApplicationName 和 pszCommandLine 参数
pszApplicationName和pszCommandLine参数分别指定新进程要使用的可执行文件的名 称，以及要传给新进程的命令行字符串。先来谈谈pszCommandLine参数。
注意，在函数原型中，pszCommandLine参数的类型为PTSTR。这意味着CreateProces 期望我们传入的是一个非“常量字符串”的地址。在内部，CreateProcess实际上会修改我 们传给它的命令行字符串。但在CreateProcess返回之前，它会将这个字符串还原为原来的 形式。
这是很重要的，因为如果命令行字符串包含在文件映像的只读部分，就会引起访问违规(违 例)。例如，以下代码就会导致访问违规，因为Microsoft的C/C++编译器把“NOTEPAD”字 符串放在只读内存中：
STARTUPINFO si = ( sizeof(si) }；
PROCESS_INFORMATION pi;
CreateProcess(NULL, TEXT("NOTEPAD"), NULL, NULL,
FALSE, 0, NULL, NULL, &si, &pi);
CreateProcess试图修改字符串时,会引起一个访问违规(Microsoft C/C++编译器的早期版本 把字符串放在可读/写内存中。所以对CreateProcess函数的调用不会引起访问违规)。
解决这个问题的最佳方式是在调用CreateProcess之前,把常量字符串复制到一个临时缓冲 区，如下所示：
STARTUPINFO si = ( sizeof(si) };
PROCESS_INFORMATION pi;
TCHAR szCommandLine[] = TEXT("NOTEPAD");
CreateProcess(NULL, szCommandLine, NULL, NULL,
FALSE, 0, NULL, NULL, &si, &pi);
我们可能还要注意对Microsoft C++的/Gf和/GF编译器开关的使用，它们可以消除重复的 字符串，并判断是否将那些字符串放在一个只读的区域。(还要注意/ZI开关，它允许使用 Visual Studio的“编辑并继续”(Edit & Continue)调试功能，它包含/GF开关的功能。)最佳 做法是使用/GF编译器开关和一个临时缓冲区。目前，Microsoft最应该做的一件事情就是 修正CreateProcess,使它自己能创建字符串的一个临时副本，从而使我们得到解放。 Windows未来的版本或许会对此进行修复。
顺便提一下，如果在Windows Vista中调用CreateProcess函数的ANSI版本，是不会发生 访问违规的，因为它会为命令行字符串创建一个临时副本(详情参见第2章)。
可以使用pszCommandLine参数来指定一•个完整的命令行，供CreateProcess用于创建新 进程。当CreateProcess解析pszCommandLine字符串时，它会检查字符串中的第一个标 记(token),并假定此标记是我们想运行的可执行文件的名称。如果可执行文件的名称没有
第4章进程
扩展名，就会默认是.exe扩展名。CreateProcess还会按照以下顺序搜索可执行文件。
(1)	主调进程.EXE文件所在的目录。
(2)	主调进程的当前目录。
(3)	Windows 系统目录，即 GetSystemDirectory 返回的 System32 子文件夹。
(4)	Windows 目录。
(5)	PATH环境变量中列出的目录。
当然，假如文件名包含一个完整路径，系统就会利用这个完整路径来查找可执行文件，而 不会搜索目录。如果系统找到了可执行文件，就创建一个新进程，并将可执行文件的代码 和数据映射到新进程的地址空间。然后，系统调用由链接器设为应用程序入口点的C/C++ 运行时启动例程。如前所述，C/C++运行时启动例程会检查进程的命令行，将可执行文件 名之后的第一个实参的地址传给(w)WinMain的pszCmdLine参数。
只要pszApplicationName参数为NULL(99%以上的情况都是如此)，就会发生上述情况。 但是，也可以不在pszApplicationName中传递NULL,而是传递一个字符串地址，并在字 符串中包含想要运行的可执行文件的名称。但在这种情况下，必须指定文件扩展名，系统 不会自动假定文件名有一个.exe扩展名。CreateProcess假定文件位于当前目录，除非文件 名前有一个路径。如果没有在当前目录中找到文件，CreateProcess不会在其他任何目录查 找文件——调用会以失败而告终。
然而，即使在pszApplicationName参数中指定了文件名，CreateProcess也会将 pszCommandLine参数中的内容作为新进程的命令行传给它。例如，假设像下面这样调用 CreateProcess：
// Make sure that the path is in a read/write section of memory.
TCHAR szPath[) = TEXT("WORDPAD README.TXT");
// Spawn the new process.
CreateProcess(TEXT("C:\\WINDOWS\\SYSTEM32\\NOTEPAD.EXE"),szPath,...);
系统会调用记事本应用程序，但记事本应用程序的命令行是WORDPAD README.TXTo 虽然这看起来有点儿怪，但CreateProcess的工作机制就是这样的。之所以让我们能为 CreateProcess 添加 pszApplicationName 参数，实际是为了支持 Windows 的 POSIX 子系统。
4.2.2	psaProcess, psaThread 和 blnheritHandles 参数
为了创建一个新的进程，系统必须创建一个进程内核对象和一个线程内核对象(用于进程的 主线程)。由于这些都是内核对象，所以父进程有机会将安全属性关联到这两个对象上。可 以根据自己需要分别使用psaProcess和psaThread参数来为进程对象和线程对象指定安全 性。可以为这两个参数传递NULL；在这种情况下，系统将为这两个内核对象指定默认的 安全描述符。也可以分配并初始化两个SECURITY_ATTRIBUTES结构，以便创建安全权 限，并将它们分配给进程对象和线程对象。
lows核心编程（第5版）
为psaProcess和psaThread参数使用SECURITY_ATTRIBUTES结构的另一个原因是： 这两个对象句柄可由父进程将来生成的任何子进程继承（第3章讨论了内核对象句柄的继承 机制）。
下面展示的Inheritxpp是一个简单的程序，它演示了内核对象句柄的继承。假设现在由进 程 A来创建进程B ,它调用CreateProcess ,并为psaProcess参数传入一个 SECURITY_ATTRIBUTES结构的地址（在这个结构中，blnheritHandle成员被设为 TRUE）。在同一个调用中，psaThread参数指向另一个SECURITY_ATTRIBUTES结构， 该结构的blnheritHandle成员被设为FALSEo
系统创建进程B时，会同时分配一个进程内核对象和一个线程内核对象，并在ppiProdnfo 参数指向的一个结构中，将句柄返回给进程A。ppiProdnfo参数的详情将在稍后讨论。现 在，利用返回的这些句柄，进程A就可以操纵新建的进程对象和线程对象。 __________
91-92
现在，假视进程A再次调用CreateProcess来创建进程C。进程A可以决定是否允许进程 C操纵进程A能访问的一些内核对象。blnheritHandles参数便是针对这个用途而提供的。 如果blnheritHandles设为TRUE,进程C将继承进程A中的所有可继承的句柄。在本例 中，进程B的进程对象句柄是可继承的。进程B的主线程对象的句柄则是不可继承的，不 管传给CreateProcess的blnheritHandles参数值是多少。另外，如果进程A调用 CreateProcess,并为blnheritHandles参数传入FALSE,则进程C不会继承进程A当前所 用的任何一个句柄。
Inherit*cpp /***************************•*****************★************** Module name： Inherit.cpp
Notices: Copyright (c) 2008 Jeffrey Richter & Christophe Nasarre
#include <Windows.h>
int WINAPI _tWinMain (HINSTANCE hlnstanceExe, HINSTANCE, PTSTR pszCmdLine, int nCmdShow) {
// Prepare a STARTUPINFO structure for spawning processes. STARTUPINFO si = ( sizeof(si) };
SECURITY_^ATTRIBUTES saProcess, saThread; PROCESS^INFORMATION piProcessB, piProcessC; TCHAR szPath[MAX_PATH];
// Prepare to spawn Process B from // The handle identifying the new // object should be inheritable. saProcess.nLength = sizeof(saProcess)； saProcess.IpSecurityDescriptor = NULL； saProcess.blnheritHandle = TRUE；
,，舟

// The handle identifying the new thread // object should NOT be inheritable. saThread.nLength = sizeof(saThread)； saThread.IpSecurityDescriptor = NULL； saThread.blnheritHandle = FALSE;
r-.	<：. , .A.. '
// Spawn Process B.
_tcscpy_s(szPath, _countof(szPath), TEXT(■ProcessB■))；
第4章进程
CreateProcess(NULL, szPath, &saProcess, &saThread,
FALSE, 0, NULL, NULL, &si, &piProcessB);
// The pi structure contains two handles
// relative to Process A：
// hProcess, which identifies Process B's process
// object and is inheritable; and hThread, which identifies
// Process B's primary thread object and is NOT inheritable.
/ Prepare to spawn Process C from Process A.	出*
// Since NULL is passed for the psaProcess and psaThread
// parameters/ the handles to Process C*s process and
// primary thread objects default to "noninheritable."	愆
// If Process A were to spawn another process, this new
// process would NOT inherit handles to Process C's process
// and thread objects.
// Because TRUE is passed for the blnheritHandles parameter,
// Process C will inherit the handle that identifies Process
// B,s process object but will not inherit a handle to
// Process B*s primary thread object.
_tcscpy_s (szPath, __coxmtof (szPath) , TEXT (■ ProcessC")); CreateProcess(NULL, szPath, NULL, NULL,
TRUE, 0, NULL, NULL, &si, &piProcessC);
return (0>K
HEM
92~93 粉
4.2.3	fdwCreate 参数
fdwCreate参数标识了影响新进程创建方式的标志(flag)。多个标志可以使用按位或起来， 以便同时指定多个标志组合。可用的标志如下。
•	DEBUG_PROCESS标志向系统表明父进程希望调试子进程以及子进程将来生成的 所有进程。该标志向系统表明，在任何一个子进程(现在的身份是被调试程序，或 者说debugee)中发生特定的事件时，要通知父进程(现在的身份是调试器，或者说 debugger) o
•	DEBUG_ONLY_THIS_PROCESS 标志类似于 DEBUG_PROCESS,但是，只有在 关系最近的子进程中发生特定事件时，父进程才会得到通知。如果子进程又生成了 新的进程，那么在这些新进程中发生特定事件时，调试器是不会得到通知的。要进 一步了解如何利用这两个标志来写一个调试器，并获取被调试应用程序中的DLL 和线程的信息，请阅读MSDN的一篇文章：aEscape from DLL Hell with Custom Debugging and Instrumentation Tools and Utilities, Part 2 ”，网址是 http://msdn.microsoft.eom/msdnmag/issues/02/08/EscapefroniDLLHell/o
•	CREATE_SUSPENDED标志让系统在创建新进程的同时挂起其主线程。这样一来， 父进程就可以修改子进程地址空间中的内存，更改子进程的主线程的优先级，或者 在进程执行任何代码之前，将此进程添加到一个作业(job)中。父进程修改好子进程 之后，可以调用ResumeThread函数来允许子进程执行代码。欲知这个函数的详情， 请参见第7章。
•	DETACHED_PROCESS标志阻止一个基于CUI(控制台用户界面)的进程访问其父 进程的控制台窗口，并告诉系统将它的输出发送到一个新的控制台窗口，如果一个
yindows核心编程（第5版）	.
基于CUI的进程是由另一个基于CUI的进程创建的，那么在默认情况下，新进程 将使用父进程的控制台窗口。（在命令提示符中运行C++编译器的时候，编译器并 不会新建一个控制台窗口，而是将输出附加到现有控制台窗口的底部。）通过指定 这个标志，新进程如果需要将输出发送到一个新的控制台窗口，就必须调用 AllocConsole函数来创建它自己的控制台。
•	CREATE_NEW_CONSOLE标志指示系统为新进程创建一个新的控制台窗口。如
果同时指定 CREATE_NEW_CONSOLE 和 DETACHED_PROCESS 标志，会导致 一个错误。	一
•	CREATE_NO_WINDOW标志指示系统不要为应用程序创建任何控制台窗口。可 以使用这个标志来执行没有用户界面的控制台应用程序。
•	CREATE_NEW_PROCESS_GROUP 标志修改用户按 Ctrl+C 或 Ctrl+Break 时获得 通知的进程列表。按下这些组合键时，假如有多个CUI进程正在运行，系统将通知 一个进程组中的所有进程，告诉它们用户打算中断当前操作。在创建一个新的CUI 进程时，假如指定了这个标志，就会创建一个新的进程组。组中的一个进程处于活 动状态时，一旦用户按下组合键Ctrl+C或Ctrl+Break,系统就只是向这个组的进程 发出通知。
•	CREATE_DEFAULT_ERROR_MODE标志向系统表明新进程不会继承父进程所 用的错误模式。（本章前面已经讨论了 SetErrorMode函数。）
•	CREATE_SEPARATE_WOW_VDM标志只有在运行16位Windows应用程序时才 有用。它指示系统创建一个单独的虚拟DOS机（Virtual DOS Machine, VDM）,并 在这个VDM上运行16位Windows应用程序。默认情况下，所有16位Windows 应用程序都在一个共享的VDM中执行。在独立的VDM中运行的好处是，假如应 用程序崩溃，它只需要“杀死”这个VDM,在其他VDM中运行的其他程序仍然 能正常工作。另外，在独立的VDM中运行的16位Windows应用程序有独立的输 入队列。这意味着假如一个应用程序暂时挂起，独立VDM中运行的应用程序仍然 能接收输入。运行多个VDM的缺点在于，每个VDM都要消耗较多的物理内存。 Windows 98在单独一个虚拟机中运行所有16位Windows应用程序——这个行为不 能覆盖。
•	CREATE_SHARED_WOW_VDM标志只有在运行16位Windows应用程序时才有用。 默认情况下，所有16位Windows应用程序都在单独一个VDM中运行的，除非指定 了 CREATE_SEPARATE_WOW_VDM标志。不过，也可以覆盖这个默认行为。办 法是在注册表中将 HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\WOW 下 DefaultSeparateVDM 的值设为yes o在此之后，如果设置 CREATE_SHARED_WOW_VDM标志，16位Windows应用程序就会在系统的共 享VDM中运行。（修改了这个注册表设置后，必须重启电脑。）注意，为了检测在 64位操作系统下运行的32位进程，我们可以调用IsWow64Process函数。它的第 一个参数是我们要检测的进程的句柄，第二个参数则是指向一个布尔值的指针；如 果是一个32位进程在64位操作系统下运行，这个值就会被设为TRUE；否则会设 为 FALSEo
第4章进程
•	CREATE_UNICODE_ENVIRONMENT标志告诉系统子进程的环境块应包含 Unicode字符。进程的环境块默认包含的是ANSI字符串。
•	CREATE_FORCEDOS标志强制系统运行一个嵌入在16位OS/2应用程序中的 MS-DOS应用程序。
•	CREATE_BREAKAWAY_FROM_JOB标志允许一个作业中的进程生成一个和作 业无关的进程。(详情参见第5章。)
•	EXTENDED_STARTUPINFO_PRESENT 标志向操作系统表明传给 psiStartlnfo 参 数的是一个STARTUPINFOEX结构。
■O 93-95
fdwCreate参数还允许我们指定一个优先级类(priority class)o不过，这样做没有多大必要, 而且对于大多数应用程序，都不应该这样做——系统会为新进程分配一个默认的优先级类。 表4.5展示了可能的优先级类。
表4-5 fdwCreate参数设置的优先级类
优先级类	标志
低(Idle)	IDLE PRIORITY CLASS
低于标准(Below normal)	BELOW NORMAL PRIORITY CLASS
标准(Normal)	NORMAL PRIORITY CLASS
高于标准(Above normal)	ABOVE NORMAL PRIORITY CLASS
高(High)	H1GH PRIORITY CLASS
实时(Realtime)	REALT1ME PRIORITY CLASS
这些优先级类决定了相对于其他进程的线程，这个进程中的线程的调度方式，详情参见7.9 节“从抽象角度看优先级”。
4.2.4	pvEnvironment 参数
pvEnvironment参数指向一块内存，其中包含新进程要使用的环境字符串。大多数时候， 为这个参数传入的值都是NULL,这将导致子进程继承其父进程使用的一组环境字符串。
另外，还可以使用GetEnvironmentStrings函数：
PVOID GetEnvironmentStrings();
此函数获取主调进程正在使用的环境字符串数据块的地址。可以将这个函数返回的地 址用作CreateProcess函数的pvEnvironment参数的值。如果为pvEnvironment参数 传入NULL值，CreateProcess函数就会这样做。不再需要这块内存的时候，应该调用 FreeEnvironmentStrings 函数来释放它：
BOOL FreeEnvironmentStrings(PTSTR pszEnvironmentBlock)；
lows核心编程(第5版)
4.2.5	pszCurDir 参数
pszCurDir参数允许父进程设置子进程的当前驱动器和目录。如果这个参数为NULL,则 新进程的工作目录与生成新进程的应用程序一样。如果这个参数不为NULL,则pszCurDir 必须指向一个用0为终止符的字符串，其中包含我们想要的工作驱动器和目录。注意，必 须在路径中指定一个驱动器号。
95
4.2.6	psiStartlnfo 参数
psiStartlnfo 参数指向一个 STARTUPINFO 结构或 STARTUPINFOEX 结构：
typedef struct _STARTUPINFO (
DWORD cb;
PSTR IpReserved；
PSTR IpDesktop;
PSTR lpTitle；
DWORD dwX;
DWORD dwY;
DWORD dwXSize；
DWORD dwYSize；
DWORD dwXCountChars;
DWORD dwYCountChars;
DWORD dwFi11Attribute；
DWORD dwFlags；
WORD wShowWindow；
WORD cbReserved2;
PBYTE lpReserved2；
HANDLE hStdlnput;
HANDLE hStdOutput;
HANDLE hStdError；
} STARTUPINFO, *LPSTARTUPINFO;
typedef struct —STARTUPINFOEX (
STARTUPINFO Startupinfo;
Struct _PROC_THREAD_ATTRIBUTE_LIST *lpAttributeList;
} STARTUPINFOEX, *LPSTARTUPINFOEX;
Windows在创建新进程的时候使用这个结构的成员。大多数应用程序都希望生成的应用程 序只是使用默认值。最起码要将此结构中的所有成员初始化为0,并将cb成员设为此结构 的大小，如下所示：
STARTUPINFO si = ( sizeof(si) }；
CreateProcess(..., &si,...)；
如果没有把结构的内容清零，则成员将包含主调线程的栈上的垃圾数据。把这种垃圾数据 传给CreateProcess,会造成新进程有时能创建，有时则不能，具体取决于垃圾数据的内容。 因此，必须将这个结构中的未使用的成员清零，确保CreateProcess始终都能正常地工作。 这是很容易犯的一个错误，许多开发人员都忘记了做这个工作。
现在，如果想初始化此结构中的某些成员，只需在调用CreateProcess之前完成这些初始化
第4章进程
即可。我们将依次讨论每一个成员。一些成员仅在子应用程序创建了一个重叠窗口时才有 意义；另一些成员仅在子应用程序执行CUT输入和输出时才有意义。表4.6描述了每个成 员的用途。
表 4-6 STARTUPINFO 和 STARTUPINFOEX 结构的成员
成员	窗口，控制 台，或两者	用途
cb	两者	包含STARTUPINFO结构中的字节数。充当版本控制，以备Microsoft 未来扩展这个结构之用（就像STARTUPINFOEX那样）。应用程序必须 将 cb 初始化为 sizeof（STARTUPINFO）或 sizeof（STARTUPINFOEX）
IpReserved	两者	保留。必须初始化为NULL
IpDesktop	两者	标识一个名称，表明要在哪个桌面上启动应用程序。如果桌面已经存 在，则新进程会与指定的桌面关联。如果桌面不存在，则用指定的名 称和默认的属性为新进程创建一个桌面。如果IpDesktop为NULL（这 是最为常见的），进程就会与当前桌面关联
IpTitle	控制台	指定控制台窗曰的窗口标题。如果IpTitle被设置为NULL,就将可 执行文件的名称作为窗口标题
dwX dwY	两者	指定应用程序窗口在屏幕上的位置（即x和y坐标，以像素为单位）。 只有在子过程用CW_USEDEFAULT作为CreateWindow函数的x 参数来创建其第一个重叠窗口的时候，才会用到这些坐标。对于创建 控制台窗口的应用程序，这些成员指定的是控制台窗口的左上角位置
dwXSize dwYSize	两者	指定应用程序窗口的宽度和高度（以像素为单位）。只有在子进程将 CW_USEDEFAULT 作为 CreateWindow 函数的 nWidth 参数来创建 其第一个重叠窗口的时候，才会用到这些值。对于创建控制台窗1」的 应用程序，这些成员指定的是控制台窗口的宽度和高度
dwXCountChars dwYCountChars	控制台	指定子进程的控制台窗口的宽度和高度（用字符数来表示）
dwFillAttribute	控制台	指定子进程的控制台窗口所用的文本和背景色
dwFlags	两者	参见下一小节和表4-7
wShowWindow	窗口	指定应用程序的主窗口如何显示。在第一个ShowWindow调用中， 将使用wShowWindow的值，并忽略ShowWindow的nCmdShow参 数。在后续的ShowWindow调用中，只有在将SW_SHOWDEFAULT 传给ShowWindow函数的前提下，才会使用wShowWindow的值。 注意，除非 dwFhgs 指定了 STARTFJUSESHOWWINDOW 标志， 否则wShowWindow会被忽略
cbReservedl	两者	保留。必须被初始化为0
lows核心编程（第5版）
续表
成员	窗口，控制 台，或两者	用途
lpReserved2	两者	保留。必须被初始化为NULLo cbReservedl和IpReservedZ供C运 行时使用，C运行时使用_dospawn来启动一个应用程序的时候，将用 它们来传递信息。要了解实现细节，请参见Visual Studio目录下的 VC\crt\src\子目录中的 dospawn.c 和 ioinit.c 文件
hStdlnput hStdOutput hStdError	控制台	指定到控制台输入缓冲区的句柄和输出缓冲区的句柄。默认情况下， hStdlnput标识一个键盘缓冲区，hStdOutput和hStdError标识一个 控制台窗口的缓冲区。这些字段用于重定向子进程的输入/输出，详情 参见 MSDN 文章 “How to spawn console processes with redirected standard handles v » 网址是 http://support.microsoft.com/kb/!90351
97-98
为了履行前面的承诺，现在让我们讨论一下dwFlags成员。这个成员包含一组标志，用于 修改子进程的创建方式。大多数标志都只是告诉CreateProcess函数：PSTARTUPINFO结 构中的其他成员是否包含有用的信息，或者是否应该忽略一些成员。表4.7展示了可能的 标志及其含义。
表4-7 dwFlags的标志
标志	含义
STARTF USESIZE	使用dwXSize和dwYSize成员
STARTF USESHOWWINDOW	使用wShowWindow成员
STARTF USEPOSITION	使用dwX和dwY成员
STARTF USECOUNTCHARS	使用 dwXCountChars 和 dwYCountChars 成员
STARTF USEFILLATTRIBUTE	使用 dwFillAttribute 成员
STARTF USESTDHANDLES	使用 hStdlnput* hStdOutput 和 hStdError 成员
STARTF RUNFULLSCREEN	使x86计算机上运行的一个控制台应用程序以全屏模式'启动
另外还有两个标志，即 STARTF_FORCEONFEEDBACK 和 STARTF_FORCEOFFFEEDBACK, 它们可以在启动一个新进程时控制鼠标指针。由于Windows支持真正的抢占多任务处理， 所以我们可以启动（或“唤出”，即invoke）一个应用程序，并在新的进程还在初承化时使用 另一个程序。为了向用户提供视觉反馈，CreateProcess临时将系统的鼠标指针（光标）改为 如下所示的特殊形状：
这个光标指出我们既可以等待某件事情的发生，也可以继续使用系统。CreateProcess 函数允许我们在调用另一个进程时对光标进行更多的控制。如果指定
第4章进程
STARTF_FORCEOFFFEEDBACK标志，CreateProcess就不会把指针改为上述特殊的 形状。
STARTF_FORCEONFEEDBACK会令CreateProcess监视新进程的初始化过程，并根据 结果更改光标形状。如果调用CreateProcess时设置了这个标志，指针就会更改为上述特殊 的形状。在两秒之后，如果新进程并没有执行任何GUI调用，CreateProcess就会将光标重 置为普通的箭头形状。
如果进程在两秒内执行了一个GUI调用，则CreateProcess函数会等待应用程序显示一个 窗口。这必须在进程执行了 GUI调用之后的5秒钟之内发生。如果没有显示窗口， CreateProcess会重置光标。如果显示了窗口，CreateProcess会继续保持特殊形状的光标 5秒钟。在任何时候，一旦应用程序调用了 GetMessage函数(表明已初始化完毕)， CreateProcess就会立即重置光标，并停止监视新进程。
可以把wShowWindow成员初始化为传给(w)WinMain函数最后一个参数nCmdShow的 值。这个成员指出我们想传给新进程的(w)WinMain函数的最后一个参数nCmdShow的值。 它是可以传给ShowWindow函数的标识符之一。通常，nCmdShow的值要么是 SW_SHOWNORMAL,要么是SW_SHOWMINNOACTIVE。不过，它有时也可能是 SW_SHOWDEFAULTo
从Windows资源管理器启动一个应用程序的时候，此应用程序W(w)WinMain函数会被调 用，SW_SHOWNORMAL会作为nCmdShow参数的值传入。如果为应用程序创建一个快 捷方式，可以在快捷方式的属性页中，告诉系统应用程序的窗口最初应该如何显示。图4.3 显示了一个快捷方式的属性页，此快捷方式用于启动记事本程序。注意，可以通过Run(运 行)选项的组合框来指定如何显示记事本程序的窗口。
图4-3属性对话框——记事本应用程序的快捷方式
在Windows资源管理器中启动这个快捷方式时，Windows资源管理器将正确准备
idows核心编程(第5版)
STARTUPINFO结构，并调用CreateProcess0记事本应用程序将执行，其(w)WinMain函 数的nCmdShow参数中传入的是SW_SHOWMINNOACTIVE。
通过这种方式，用户就可以轻松启动一个应用程序，指定以常规状态、最小化状态或者最 大化状态显示其主窗口。
在结束本小节的讨论之前，我想强调一下STARTUPINFOEX结构的角色。自Win32问世 以来，CreateProcess的签名一直没有变过。Microsoft的策略是在保持函数签名不变的同时 提供更多的扩展，并避免专门创建一个CreateProcessEx ,再专门创建一个 CreateProcess!……以此类推•所以，除了预期的Startuplnfo字段之外,STARTUPINFOEX 结构另外只有一个字段，即IpAttributeList,后者用于传递额外的称为“属性"(attribute) 的参数：
typedef struct —STARTUPINFOEXA (
STARTUPINFOA Startupinfo;
struct _PROC_THREAD_ATTRIBUTE_LIST *IpAttributeList;
} STARTUPINFOEXA, *LPSTARTUPINFOEXA;
typedef struct .STARTUPINFOEXW (
STARTUPINFOW Startupinfo；
struct _PROC_THREAD_ATTRIBUTE_L1ST *lpAttributeList;
} STARTUPINFOEXW, *LPSTARTUPINFOEXW;
在属性列表中，包含了一系列键/值对，每个属性都有一对键/值。目前，仅有两个属性键值 被写入文档：
•	PROC_THREAD_ATTRIBUTE_HANDLE_LIST 这个属性键告诉 CreateProcess 子进程究竟应该继承哪一些内核对象句柄。这些对象句柄在创建时必须指定成“可 继承”(在 SECURITY_ATTRIBUTES 结构中包含一个设为 TRUE 的 blnheritHandle 字段，详情参见前面的 4.2.2 节“psaProcess, psaThread 和 blnheritHandles 参数 不过，并非一定要为CreateProcess函数的blnheritHandles参数传入TRUE。使用 这个属性，子进程只能继承一组选定的句柄，而不是继承所有可继承的句柄。假如 一个进程要在不同的安全上下文中创建多个子进程，这一点就尤其重要。在这种情 况下，不能让每个子进程都继承父进程的全部句柄，否则会导致安全问题。
•	PROC_THRE AD_ATTRIBUTE_PARENT_PROCESS 这个属性键预期的值是一 个进程句柄。指定的进程(而不是当前调用CreateProcess的进程)将成为正在创建 的这个进程的父进程。从指定进程继承的属性包括可继承的句柄、处理器关联性、 优先级类、配额(quota)＞用户令牌(usertoken)以及关联的作业。注意，以这种改变 父进程后，不会改变调试器进程(debugger)和被调试进程(debuggee)的关系。换言之， 创建被调试进程的调试器进程仍然负责接收调试通知，并管理被调试进程的生存 期。在本章后面4.5.4节“枚举系统中正在运行的进程”，给出了一个TooIHelp API, 这些函数将指定此属性的进程作为被创建进程的父进程来显示。
由于属性列表是不透明的，所以要调用以下函数两次，才能创建一个空白的属性列表：
第4章进程
BOOL InitializeProcThreadAttributeList(
PPROC_THREAD_ATTRIBUTE_LIST pAttributeList,
DWORD dwAttributecount,
DWORD dwFlags,
PSIZE_T pSize);
注意，dwFlags参数是保留的，而且我们始终都应该为这个参数传入0。第一个调用的目的 是知道Windows用来保存属性的内存块的大小］
SIZE_T cbAttributeListSize = 0；
BOOL bReturn = InitializeProcThreadAttributeList(
NULL, 1, 0, &cbAttributeListSize);
// bReturn is FALSE but GetLastError() returns ERROR_INSUFFICIENT_BUFFER
pSize指向的SIZE_T变量将接收内存块的大小值，这个内存块是根据dwAttributeCount 所指定的属性的数目来分配的：
PAttributeList = (PPROC_THREAD_ATTRIBUTE_LIST)
HeapAlloc(GetProcessHeap(), 0, cbAttributeListSize)；
为属性列表分配了内存之后，要再次调用InitializeProcThreadAttributeList来初始化它的 内容(这些内容是“不透明”的)：
bReturn = InitializeProcThreadAttributeList(
pAttributeList, 1, 0, &cbAttributeListSize)；
分配并初始化好属性列表之后，就可以根据自己的需要，用下面的函数来添加键/值对：
BOOL UpdateProcThreadAttribute(
PPROC_THREAD_ATTRIBUTE_LIST pAttributeList,
DWORD dwFlags,
DWORD_PTR Attribute,
PVOID pValue,
SIZE_T cbSize,
PVOID pPreviousValue,
PSIZE_T pReturnSize);
pAttributeList参数是之前分配并初始化的attribute列表，函数将在其中添加一个新的键/ 值对。Attribute参数是其中的键部分，它要么接收PROC_THREAD_ATTRIBUTE_ PARENT_PROCESS,要么接收 PROC_THREAD_ATTRIBUTE_HANDLE_LIST 值。如 果是前者，pValue参数必须指向一个变量，该变量包含了新的父进程的句柄，而cbSize 应该用sizeof(HANDLE)来作为它的值；如果是后者，pValue参数必须指向一个数组的起 始位置，该数组包含了允许子进程访问的、可继承的内核对象句柄，而cbSize应该等于 sizeof(HANDLE)乘以句柄数。dwFlags, pPreviousValue 和 pReturnSize 参数是保留参数， 必须分别设为0, NULL和NULL.
警告 如果需要同时传入两个属性，一定要保证在与PROC THREAD ATTRIBUTE PARENT PROCESS 关联的新的父进程中，与 PROC THREAD ATTRIBUTE HANDLE_LIST关联的句柄必须是有效的，因为这些句柄将从指定的新的父进程继 承，而不是从调用CreateProcess函数的当前进程继承。
调用 CreateProcess 函数时，如果要在 dwCreationFlags 中指定 EXTENDED_STARTUPINFO_
Endows核心编程（第5版）
PRESENT,那么我们需要在调用CreateProcess之前先定义好一个STARTUPINFOEX变量 （并将pAttributeList字段设为刚才己初始化的属性列表），此变量将用作pStartupInfo参数： STARTUPINFOEX esi = { sizeof（STARTUPINFOEX） ）;
esi.IpAttributeList = pAttributeList;
bReturn = CreateProcess（
...,EXTENDED_STARTUPINFO_PRESENT,
&esi.Startupinfo, ...）;
不再需要参数的时候，需要在释放已分配的内存之前，先用以下方法来清除不透明的属性 列表：
VOID DeleteProcThreadAttributeList（
PPROC_THREAD_ATTRIBUTE_LIST pAttributeList）;
最后，应用程序可以调用下面的函数来获得STARTUPINFO结构的一个副本，此结构是 由父进程初始化的。子进程可以检查这个结构，并根据结构成员的值来更改其行为，如下 所示：
VOID GetStartupInfo（LPSTARTUPINFO pStartupInfo）;	'
这个函数填充的总是一个STARTUPINFO结构——即使在调用CreateProcess来创建当前 子进程时，传递的是一个STARTUPINFOEX结构——属性只有在父进程地址空间才有意 义，因为属性列表的内存是在那里分配的。所以，正如以前解释过的那样，我们需要通过 另一种方式来传递已继承的句柄的值，比如通过命令行。
4.2.7	ppiProcInfo 参数
ppiProcInfo参数指向一个PROCESS_INFORMATION 结构（由我们负责分配），
CreateProcess函数在返回之前，会初始化这个结构的成员。该结构如下所示：
typedef struct _PROCESS_INFORMATION （
HANDLE hProcess；
HANDLE hThread;
DWORD dwProcessId;
DWORD dwThreadld;
} PROCESS.INFORMATION;
如前所述，创建一个新的进程，会导致系统创建一个进程内核对象和一个线程内核对象。 在创建时，系统会为每个对象指定一个初始的使用计数1。然后，就在CreateProcess返回 之前，它会使用完全访问权限来打开进程对象和线程对象，并将各自的与进程相关联的句 柄放入 PROCESS_INFORMATION 结构的 hProcess 和 h Th read 成员中。当 CreateProcess 在内部打开这些对象时，每个对象的使用计数就变为2。
这意味着系统要想释放进程对象，进程必须终止（使用计数递减1）,而且父进程必须调用 CloseHandle（使用计数再次递减1,变成0）。类似地，要想释放线程对象，线程必须终止， 而且父进程必须关闭到线程对象的句柄（要想进一步了解如何释放线程对象，请参见4.4节 “子进程”）。

第4章进程
说明 应用程序运行期间，必须关闭到子进程及其主线程的句柄，以避免资源泄漏。当然， 系统会在应用程序的进程终止后自动清理这种泄漏。但是，如果是一个编写炳妙的 软件，肯定会在进程不再需要访问一个子进程及其主线程的时候，显式地调用 CloseHandle来关闭这些句柄。忘记关闭这些句柄是开发人员最容易犯的错误之一。 不知道为什么，许多开发人员都有这样的一个误解：关闭到一个进程或线程的句柄， 会强迫系统“杀死”此进程或线程。但这是大谬不然的。关闭句柄只是告诉系统我 们对进程或线程的统计数据不再感兴趣了。进程或线程会继续执行，直至自行终止。
创建一个进程内核对象时，系统会为此对象分配一个独一无二的标识符，系统中没有别的 进程内核对象会有相同的ID编号。这同样适用于线程内核对象。创建一个线程内核对象时， 此对象会被分配一个独一无二的、系统级别的ID编号。进程ID和线程ID分享同一个号 码池。这意味着线程和进程不可能有相同的IDo此外，一个对象分配到的ID绝对不会是0o 注意，Windows任务管理器将进程ID 0与“System Idle Process”（系统空闲进程）关联，如 下图所示。但是，实际上并没有System Idle Process这样的东西。任务管理器创建这个虚构 进程的目的是将其作为Idle线程的占位符；在没有别的线程正在运行时，系统就运行这个 Idle进程。System Idle Process中的线程数量始终等于计算机的CPU的数量。所以，它始终 代表未被真实进程使用的CPU使用率。
		
	Op^wMt Viy	Hdp
, r	Processes	|ServteB | Performan
	Image Name	Vid
	System Ide Process	0
	System	4
CreateProcess返回之前，它会将这些ID填充到PROCESSJNFORMATION结构的 dwProcessId和dwThreadld成员中。ID使我们很容易识别系统中的进程和线程。ID主要 由工具程序（比如任务管理器）使用，用于提高生产力的应用程序很少用到它。因此，大多 数应用程序都会忽略ID。
如果应用程序要使用ID来跟踪进程和线程，那么必须注意这一点：进程和线程ID会被系 统立即重用。例如，假定在创建一个进程之后，系统初始化了一个进程对象，并将ID值
124分配给它。如果再创建一个新的进程对象，系统不会将同一个ID编号分配给它。但是,
如果第一个进程对象巳经释放，系统就可以将124分配给下一个创建的进程对象。请务必 牢记这一点，以免自己的代码引用不正确的进程或线程对象。进程ID很容易获得，也很容 易保存。但就像前面所说的那样，我们刚刚保存好一个ID,与它对应的进程就可能己被释
放了。所以，系统在创建下一个新进程的时候，会将这个ID分配给它。一旦我们使用保存 的进程ID,操纵的就是新进程，而不是原先那个进程。
可以使用GetCurrentProcessId来得到当前进程的ID,使用GetCuiTentThreadld来获得 当前正在运行的线程的ID。另外，还可以使用GetProcessId来获得与指定句柄对应的一个 进程的ID，使用GetThreadld来获得与指定句柄对应的一个线程的ID。最后，根据一个
indows核心编程（第5版）
线程句柄，我们可以调用GetProcessIdOfThread来获得其所在进程的ID。
个别情况下，我们的应用程序可能想确定它的父进程。但是，首先应该知道的是，只有在 一个子进程生成的那一瞬间，才存在一个父•子关系。到子进程开始执行代码之前的那一刻, Windows就已经不认为存在任何父•子关系了。ToolHelp函数允许进程通过 PROCESSENTRY32结构查询其父进程。在此结构内部有一个th32ParentProcessID成员， MSDN文档声称，此结构内部的th32ParentProcessID成员能返回父进程的ID。
系统确实会记住每个进程的父进程的ID,但由于ID会被立即重用，所以等我们获得父进 程的ID的时候，那个ID标识的可能已经是系统中运行的一个完全不同的进程。我们的父 进程也许已经终止了。如果应用程序需要与它的“创建者”通信，最好不要使用ID。应该 定义一个更持久的通信机制，比如内核对象、窗口句柄等。
要保证一个进程或线程ID不被重用，唯一的办法就是保证进程或线程对象不被销毁。为此, 在创建了一个新进程或线程之后，不关闭到这些对象的句柄即可。等到应用程序不再使用 ID的时候，再调用CIoseHandle来释放内核对象。但是，一旦调用了 CloseHandle,再使 用或依赖进程ID就不安全了。这一点务必牢记。对于子进程，除非父进程复制了自己的进 程或线程对象句柄，并允许子进程继承这些句柄（参见3.3.5节），否则它无法确保父进程的 进程ID或线程ID的有效性。
4.3终止进程
进程可以通过以下4种方式终止：
•	主线程的入口点函数返回（强烈推荐的方式）
•	进程中的一个线程调用ExitProcess函数（要避免这种方式）
•	另一个进程中的线程调用TerminateProcess函数（要避免这种方式）
•	进程中的所有线程都“自然死亡”（这种情况几乎从来不会发生）
本节将讨论所有这4种方法，并描述进程终止时实际发生的情况。
4.3.1主线程的入口点函数返回
设计一个应用程序时，应该保证只有在主线程的入口点函数返回之后，这个应用程序的进 程才终止。只有这样，才能保证主线程的所有资源都被正确清理。
让主线程的入口点函数返回，可以保证以下操作会被执行。	•
•	该线程创建的任何C++对象都将由这些对象的析构函数正确销毁。
•	操作系统将正确释放线程栈使用的内存。
•	系统将进程的退出代码（在进程内核对象中维护）设为入口点函数的返回值。
•	系统递减进程内核对象的使用计数。

第4章进程
4.3.2	ExitProcess 函数
进程会在该进程中的一个线程调用ExitProcess函数时终止：
VOID ExitProcess(UINT fuExitCode)；
该函数将终止进程，并将进程的退出代码设为fuExitCodeo ExitProcess不会返回值，因为 进程已经终止了。如果ExitProcess之后还有别的代码，那些代码永远不会执行。
当主线程的入口点函数(WinMain, wWinMain> main或wmain)返回时，会返回到C/C++ 运行库启动代码，后者将正确清理进程使用的全部C运行时资源。释放了C运行时资源之 后，C运行时启动代码将显式调用ExitProcess,并将入口点函数返回的值传给它。这便解 释了为什么只需从主线程的入口点函数返回，就会终止整个进程。注意，进程中运行的其 他任何线程都会随进程一起终止。
Windows Platform SDK文档指出，一个进程在其所有线程都终止之后才会终止。从操作系 统的角度出发，这种说法是正确的。不过，C/C++运行库为应用程序采取了一个不同的策 略：不管进程中是否还有其他线程在运行，只要应用程序的主线程从它的入口点函数返回， C/C++运行库就会调用ExitProcess来终止进程。不过，如果在入口点函数中调用的是 ExitThread,而不是调用ExitProcess或者入口点函数直接返回，应用程序的主线程将停止 执行，但只要进程中还有其他线程正在运行，进程就不会终止。
注意，调用ExitProcess或ExitThread会导致进程或线程直接终止运行 再也不会返回 当前函数调用。就操作系统而言，这样做是没有什么问题的，进程或线程的所有操作系统 资源都会被正确清理。不过，C/C++应用程序应避免调用这些函数，因为C/C++运行库也 许不能执行正确清理工作。下面来看看以下代码：
#include 〈windows.h>
#include <stdio.h>
class CSomeObj (
public:
CSomeObj() { printf("Constructor \r\n")； )
-CSomeObj() ( printf("Destructor \r\n")； )
);
CSomeObj g_GlobalObj;
void main () (
CSomeObj LocalObj；
ExitProcess(0)； // This shouldn't be here
// At the end of this function, the compiler automatically added
// the code necessary to call LocalObj's destructor.
// ExitProess prevents it from executing.
}
105-106
执行上述代码，会显示以下结果:
indows核心编程（第5版）
Constructor
Constructor
它构造了两个对象，一个是全局对象，另一个是本地对象。“Destructor”字样永远都不会 显示。C++对象没有被正确析构，因为ExitProcess造成进程“当场终止运行” ：C/C++运 行时没有机会执行清理工作。
就像我说的那样，任何时候都不要显式地调用ExitProcesso在前面的代码中删除对 ExitProcess函数的调用，再运行这个程序就会得到以下结果：
Constructor
Constructor
Destructor
Destructor
只需从主线程的入口点函数返回，C/C++运行时就能执行其清理工作，并正确析构所有C++ 对象。顺便提一下，这里的讨论并不只适用于C++对象。C/C++运行袖代表进程做了许多 事情；最好允许运行时正确地完成清理工作。
说明 许多应用程序之所以无法正确清理自己，是因为显式调用了 ExitProcess和 ExitThread。在ExitThread的情况下，进程会继续运行，但可能泄漏内存或其他资源。
4.3.3	TerminateProcess 函数
调用TerminateProcess也可以终止一个进程，如下所示：
BOOL TerminateProcess（
HANDLE hProcess,
UINT fuExitCode）;
此函数与ExitProcess函数有一个明显的区别：任何线程都可以调用TerminateProcess来 终止另一个进程或者它自己的进程。hProcess参数指定了要终止的进程的句柄。进程终止 时，其退出代码的值就是传给fuExitCode参数的值。
只有在无法通过其他方法来强制进程退出时，才应使用TerminateProcess。被终止的进程 得不到自己要被终止的通知——应用程序不能正确清理，也不能阻止它自己被强行终止（除 非通过正常的安全机制）。例如，在这种情况下，进程无法将它在内存中的任何信息刷（flush） 到磁盘上。
虽然进程没有机会执行自己的清理工作，但操作系统会在进程终止之后彻底进行清理，确 保不会泄漏任何操作系统资源。这意味着进程使用的所有内存都会被释放，所有打开的 文件都会被关闭，所有内核对象的使用计数都将递减，所有的用户对象和GDI对象都会被 销毁。
一旦进程终止（不管是如何终止的），系统会保证不留它的任何部分。绝对没有任何办法知 道那个进程是否运行过。进程在终止后绝对不会泄漏任何东西。希望大家都己经明确这一 点了。
第4章迸程
说明 TerminateProcess函数是异步的-换言之，它告诉系统我们希望进程终止，但到函
数返回的时候，系统并不能保证进程已经被强行终止了。所以，为了确定进程是否 已经终止，应该调用WaitForSingleObject(详见第9章)或者一个类似的函数，并将进 程的句柄传给它。
4.3.4当进程中的所有线程终止时
如果一个进程中的所有线程都终止了(要么是因为它们都调用了 ExitThread,要么是因为它 们都用TerminateThread来终止了)，操作系统就认为没有任何理由再保持进程的地址空 间。这是非常合理的，因为没有线程在执行地址空间中的任何代码。一旦系统检测到一个 进程中没有任何线程在运行，就会终止这个进程。进程的退出代码会被设为最后一个终止 的那个线程的退出代码。
4.3.5当进程终止运行时
一个进程终止时，系统会依次执行以下操作。
(1)	终止进程中遗留的任何线程。
(2)	释放进程分配的所有用户对象和GDI对象，关闭所有内核对象(如果没有其他进程打开 这些内核对象的句柄，那么它们也会被销毁。不过，如果其他进程打开了它们的句柄, 那么它们就不会被销毁)。
(3)	进程的退出代码从STILL ACTIVE变为传给ExitProcess或TerminateProcess函数的 代码。
(4)	进程内核对象的状态变成已触发状态，(关于信号机制的详情，请参见第9章)。这就 是为什么系统中的其他线程可以挂起它们自己，直至另一个进程终止运行。
(5)	进程内核对象的使用计数递减1。
注意，进程内核对象的生命期至少能像进程本身一样长。但是，进程内核对象存活的时间 也许比进程本身存活的时间更久。一个进程终止时，系统会自动递减其内核对象的使用计 数。如果计数减至0,表明没有其他进程打开了这个对象的句柄，所以在进程被销毁时， 对象也会被销毁。
『07
但是，当一个进程终止的时候如果系统中还有另一个进程打开了这个进程的内核对象的句 柄，那么进程内核对象的使用计数就不会变成0。当父进程忘记关闭到它的一个子进程的 句柄时，往往会发生这种情况。这是Windows的一个特性(或功能)，而不是bug。记住， 进程内核对象会维护与进程有关的统计信息。即使是在进程终止之后，这些信息也可能有 用。例如，我们可能想知道一个进程需要多少CPU时间。或者，一个更有可能的原因是， 我们想通过调用GetExitCodeProcess来获得己经终止的一个进程的退出代码：
WS核心编程（第5版）
BOOL GetExitCodeProcess( HANDLE hProcess, PDWORD pdwExitCode);
该函数会查找进程内核对象（由hProcess参数标识），并从内核对象的数据结构中提取用于 标识进程退出代码的成员。退出代码的值在pdwExitCode参数指向的一个DWORD中 返回。
任何时候都可以调用这个函数。如果在调用GetExitCodeProcess的时候进程还没有终止， 函数将用STILL_ACTIVE标识符（定义为0x103）来填充DWORDo如果进程已经终止，就 返回实际的退出代码值。
有人可能会想，我是不是可以编写代码，定期调用GetExitCodeProcess并检查退出代码， 从而判断一个进程是否终止？虽然这在很多情况下都是行得通的，但其效率不敢恭维。下 一节将介绍如何通过正确的方式来判断进程是在什么时候终止的。
再次重申，应该调用CloseHandle来告诉操作系统我们巳经对进程中的统计数据不感兴趣 了。如果进程已经终止，CloseHandle函数将递减内核对象的使用计数，并释放它。
4.4子进程
设计一个应用程序时，我们可能想用另一段代码来执行工作。为此，我们总是调用函数或 子程序来分配这样的工作。调用一个函数时，除非函数返回，否则我们的代码不能继续处 理。在很多情况下，都需要这种单任务同步机制。为了让另一段代码来执行工作的另一个 方法是在进程内新建一个线程，让它帮助我们进行处理。这样一来，当另一个线程执行我 们指定的工作时，我们的代码可以继续处理。虽然这种方法很有用，但如果我们的线程需 要查看新线程的结果时，就会遇到同步问题。
另一个办法是生成一个新的进程来寿助我们完成工作，新的进程称为子进程（child process）o 例如，假定我们现在要做的工作非常复杂。为了完成工作，我们在同一个进程中创建了一 个新的线程。我们写了一些代码，测试后无法得到正确的结果。究其原因，也许是算法有 误，也许是对某些数据进行了错误的解引（dereference）操作，不慎改写了地址空间中的重要 数据。为了在处理工作期间保护地址空间，一个办法是让一个新进程来执行工作。然后， 既可以在新进程终止之后，才继续我们自己的工作，也可以在新进程运行期间继续自己 的工作。
遗憾的是，新进程可能需要操作我们的地址空间中的数据。在这种情况下，最好让进程在 它自己的地址空间中运行，并只允许它访问父进程地址空间中与它的工作有关的数据，从 而保护与正在进行的处理无关的其他数据。Windows提供了几种方式在不同进程之间传递 数据，其中包括动态数据交换（Dynamic Data Exchange, DDE）, OLE,管道，邮件槽等。 共享数据最方便的方式之一就是使用内存映射文件（有关这方面的详细讨论，请参见第 17 章）。
第4章进程
如果希望创建一个新线程，让它执行一些工作，然后等候结果，则可以像下面这样编码:
PROCESS_INFORMATION pi;
DWORD dwExitCode;
// Spawn the child process.
BOOL fSuccess = CreateProcess(..., &pi);
if (fSuccess) (
// Close the thread handle as soon as it is no longer needed!
CloseHandle(pi.hThread);
// Suspend our execution until the child has terminated. WaitForSingleObject(pi.hProcess, INFINITE)；
// The child process terminated； get its exit code. GetExitCodeProcess(pi.hProcess, &dwExitCode)；
// Close the process handle as soon as it is no longer needed. CloseHandle(pi.hProcess)；
}
在上述代码段中，我们创建了新进程；如果创建成功，就调用WaitForSingleObject函数: DWORD WaitForSingleObject(HANDLE hObject, DWORD dwTimeout);
第9章将全面讨论WaitForSingleObject函数。现在，只需要知道此函数会一直等待，直 至hObject参数所标识的对象变为已触发。进程对象在终止的时候，就会变为己触发。所 以，对WaitForSingleObject函数的调用将暂停执行父进程的线程，直至子进程终止。
WaitForSingleObject返回后，可以调用GetExitCodeProcess来获得子进程的退出代码。
在前面这段代码中，对CloseHandle函数的调用导致系统将线程和进程对象的使用计数递 减至0,使对象占用的内存可以被释放。
注意，在上述代码中，我们在CreateProcess返回之后，立即关闭了到子进程的主线程内核 对象的句柄。这不会导致子进程的主线程终止，它只是递减了子进程的主线程内核对象的 使用计数。下面解释了为什么说这是一个良好的编程习惯：假定子进程的主线程生成另一 个线程，然后主线程终止。此时，系统就可以从内存中释放子进程的主线程对象——前提 是父进程没有打开到这个线程对象的句柄。但是，假如父进程打开了到子进程的主线程对 象的一个句柄，系统就不会释放这个对象，除非父进程关闭这个句柄。
109
运行独立的子进程
大多数时候，应用程序将另一个进程作为独立的进程(detached process)来启动。这意味着一 旦进程创建并开始执行，父进程就不再与新进程通信，或者不用等它完成工作之后才继续 自己的工作。Windows资源管理器就是这样工作的。当Windows资源管理器为用户创建了 一个新的进程之后，就不再关心这个进程是否继续存在，也不关心用户是否要终止它。
为了断绝与子进程的所有联系，Windows资源管理器必须调用CloseHandle来关闭新进程 及其主线程的句柄。以下代码示例展示了如何新建一个进程，然后让它独立运行：
mdows核心编程(第5版)
PROCESS.INFORMATION pi;
// Spawn the child process.
BOOL fSuccess = CreateProcess(..., &pi);
if (fSuccess) {
// Allow the system to destroy the process & thread kernel
// objects as soon as the child process terminates.
CloseHandle(pi.hThread)； CloseHandle(pi.hProcess);
)
4.5管理员以标准用户权限运行时
感谢一系列新技术，Windows Vista为最终用户提高了安全水准。对于应用程序开发人员， 影响最大的技术当属用户帐户控制(User Account Control, UAC)O '
Microsoft注意到这样一个事实：大多数用户都用一个管理员(Administrator)帐户来登录 Windowso利用这个帐户，用户几乎能没有任何限制地访问重要的系统资源，因为该帐户 被授予了很高的权限。一旦用户用这样的一个特权帐户来登录Vista之前的某个Windows 操作系统，就会创建一个安全令牌(security token)0每当有代码试图一个受保护的安全资源 时时，操作系统就会使用(出示)这个安全令牌。从包括Windows资源管理器在内的第一个 进程开始，这个令牌会与新建的所有进程关联。Windows资源管理器会将令牌传给它的所 有子进程，并以此类推。在这样的配置中，如果从Internet下载的一个恶意程序开始运行， 或者电子邮件中的一个恶意脚本开始运行，就会继承管理员帐户的高特权(因为它们的宿主 应用程序正在这个帐户下运行)——因而可以肆意更改机器上的任何内容，甚至可以启动另 一个同样继承高特权的进程。
相反，在Windows Vista中，如果用户使用管理员这样的一个被授予高特权的帐户登录， 那么除了与这个帐户对应的安全令牌之外，还会创建一个经过筛选的令牌(filtered token), 后者将只被授予标准用户(Standard User)的权限。以后，从包括Windows资源管理器在内 的第一个进程开始，这个筛选后的令牌会与系统代表最终用户启动的所有新进程关联。有 人可能马上会对此提出疑问：既然所有•应用程序都只有标准用户的权限集，那么它们如何 访问受限制的资源呢？比较简短的一个回答是:权限受限的进程无法访问需要更高权限才 能访问的安全资源。下而将给出较为详尽的回答。另外，在本节剩余的部分，将集中讨论 开发者如何利用UAC。
首先，我们可以要求操作系统提升权限，但只能在进程边界上提升。这是什么意思呢？默 认情况下，一个进程启动时，它会与当前登录用户的筛选后的令牌关联起来。要为进程授 予更多的权限，我们(开发人员)需要指示Windows做这样一件事情：在进程启动之前，先 友好地征得最终用户(对于提升权限)的同意。作为最终用户，可以使用快捷菜单中的Run as administrator以管理员身份运行)命令(在Windows资源管理器中右击一个应用程序，即可 打开如下图所示的菜单)。
第4章进程
Open
电 Run as administrator
Share...
Pin to Start Menu
Add to Quick Launch
Restore previous versions
Send To
Cut
Copy
Create Shortcut
Delete
Rename
Properties
如果用户本身就是以管理员身份登录的，那么J旦选择Run as administrator,系统就会在一 个“安全Windows桌面”中显示一个确认对话框，要求用户批准将权限提升到未筛选的安 全令牌的级别。选择Run as administrator之后，最终用户可能看到三种类型的对话框。下 面将分别进行解释。
如果应用程序是系统的一部分，就会显示下图所示的安全确认对话框，上面是一个蓝色的 横幅。
如果应用程序进行了签名，对话框中将显示一个灰色横幅（如下图所示），表明Windows没 有足够的把握来确定应用程序是否安全。
最后，如果应用程序没有签名，系统会在对话框中显示一个橙色的横幅（如下图所示），并 要求用户谨慎回答。
Mows核心编程（第5版）
注意，如果用户当前以一个标准用户的身份登录，系统会弹出另一个对话框（见下图），要 求我们提供一个提升了权限的帐户的登录凭据。采用这个设计，管理员就可以帮助登录到 这台计算机的标准用户执行需要更高权限才能执行的任务。这称为over.the.shoulder登录①。
说明 很多人会问，为什么Windows Vista不是只问一次，然后把安全数据保存到系统中， 并让用户随意以管理员的身份来运行应用程序呢？这样一来，就不必每次都弹出一 个UAC对话框来打扰用户了。Windows Vista之所以不提供这个功能，是因为如果 这样，它就必须将数据保存到某个地方（比如保存到注册表中或者其他某个文件中）。 一旦这个存储区域被成功入侵，恶意程序就可以修改这个存储区域，使其总是以提 升的权限来运行，而不会向用户进行任何提示。
除了 Windows资源管理器快捷菜单中的Run as Administrator以管理员身份运行）命令，大 家肯定还注意到了一个新的盾牌图标。这个图标会出现在负责执行Windows Vista管理任 务的一些链接旁边或者按钮上面。这个新的界面元素向用户清楚地表明：一旦单击这个链
①译注：事实匕此刻我们只能在座位上傻傻地等若管理员，任其越过我们的肩动手符助我们登录。很形象吧!
第4章进程
接或按钮，就会弹出一个权限提升确认对话框。在应用程序的按钮上显示这个盾牌图标非 常容易，本章最后提供的Process Information示例代码对此进行了展示。
下面来看一•个简单的例子。右击任务栏，从弹出菜单中选择Task Manager（任务管理器）。 在其Process（进程）选项卡底部，可以清楚地看到Show Proesses From All Users（显示所有用 户的进程）按钮上的盾牌图标，如下图所示。
winiogon.exe
csrss.exe
■show	4 usefs
Processes: 44 CPU Usage: 8%
单击这个按钮之前，先看看任务管理器的进程ID（也就是taskmgr.exe的PID）。在确认了权 限提升之后，任务管理器将短暂地消失，但随后它会重新出现，不过一个复选框代替了盾 牌按钮，如下图所示。
Iwinfogon.exe
WmiPrv5E.exe
回 Show processes from all users
Processes: 47 CPU Usage: 7%
再检查一下任务管理器的PID,我们会注意到它与提升权限前的PID不一样。这是否意味 着任务管理器必须生成它自己的另一个实例，才能获得权限提升呢？是的，答案是肯定的。 如前所述，Windows只允许在进程边界上进行权限提升。一旦进程启动，再要求更多的权 限就已经退了。不过，一个未提升权限的进程可以生成另一个提升了权限的进程，后者将 包含一个COM服务器，这个新进程将保持活动状态。这样一来，未提升权限的进程就可 以向已经提升了权限的新进程发出IPC调用，而不必为了提升权限而启动一个新实例再终 止它自身。
说明 Mark Russinovich在一段视频和一份Microsoft Office PowerPoint演示文稿中（网址为 http://www.microsoflcom/ emea/spotlight/sessionh.aspx?videoid=360）＜1 详细介绍了 UAC 的内部机制，比如Windows的系统资源虚拟化技术，它使那些在设计时没有考虑到 新的管理员特权限制的应用程序能够更好地兼容新的操作系统。
4.5.1自动提升进程的权限
如果我们的应用程序一直都需要管理员权限，比如如果它是安装程序的-•部分，那么操作 系统可以在每次调用（invoke）应用程序时，自动提示用户提升权限。每当一个新进程生成时, Windows的UAC组件如何判断应该采取什么操作呢？
113联
WS核心编程（第5版）
假如应用程序的可执行文件已经中嵌入了一种特殊的资源（RT_MANIFEST）,系统就会检 S＜trustlnfo＞段，并解析其内容。下面摘录了一个示例清单文件中的vtrustlnfo＞段：
<trustlnfo xmlns="urn：schemas-microsoft-com:asm.v2"> <security>
<requestedPrivileges> <requestedExecut ionLevel levels"requireAdministrator" />
</requestedPrivileges>
</security>
</trustInfo>
level属性可能有3个不同的值，如表4・8所示。
表4-8 level属性的值	
值	描述
requireAdministrator	应用程序必须以管理员权限启动；否则不会运行
highestAvailable	•应用程序以当前可用的最高权限运行 •如果用户使用管理员帐户登录，就会出现一个要求批准提升权限的对话框 •如果用户使用普通用户帐户登录，应用程序就用这些标准权限来启动（不 会提示用户提升权限）
aslnvoker	应用程序使用与主调应用程序一样的权限来启动
也可以选择不将清单嵌入可执行文件的资源中。相反，可以将清单保存到可执行文件所在 的目录中，名称和可执行文件相同，但扩展名使用.manifesto
但是，外部清单文件也许不会立即被操作系统发现，尤其是我们在清单文件就位之前就己 经启动了可执行文件。在这种情况下，我们需要先注销再重新登录，才能使Windows注意 到外部的清单文件。在任何情况下，只要可执行文件中嵌入了一个清单，外部的清单文件 就会被忽略。
除了通过XML清单来明确设置所需的权限，操作系统还会根据一系列特定的兼容性规则 来“智能”地判断一个程序是不是安装程序。因为在这种情况下，系统需要自动显示一个 提升权限对话框。对于其他应用程序，假如没有发现任何清单，也没有发现它具有安装程 序的行为，那么最终用户可以自行决定是否以管理员身份启动进程。具体的办法是在可执 行文件的属性对话框的Compatibitlity（兼容性）选项卡中选中对应的复选框，如下图所示。
Pirvitege Level
® Run this program as an adnvnirijaUx
第4章进程
说明 虽然与应用程序兼容性相关的主题不在本书讨论范围内，但可以访问以下网址来了解 详情，这是有关如何在Windows Vista中开发相容于UAC的应用程序的一份白皮书： http://www.microsoft.com/downloads/details.aspx?FamilyID=ba73bl69-a648-49af-bc5e-a2eebb74c 16b&Display Lang=en
4.5.2手动提升进程的权限
如果仔细阅读过本章前面对CreateProcess函数的描述，肯定已经注意到它没有专门提供什 么标记或参数来指定对这种权限提升的需求。相反，我们需要调用ShellExecuteEx函数：
IpVerb； IpFile；
IpParameters；
IpDirectory ；
BOOL ShellExecuteEx(LPSHELLEXECUTEINFO pExecInfo); typedef struct _SHELLEXECUTEINFO (
DWORD cbSize;
ULONG fMask;
HWND hwnd;
PCTSTR
PCTSTR
PCTSTR
PCTSTR
int nShow；
HINSTANCE hlnstApp;
PVOID IpIDList;
PCTSTR IpClass；
HKEY hkeyClass；
DWORD dwHotKey; union {
HANDLE hlcon； HANDLE hMonitor；
} DUMMYUNIONNAME;
HANDLE hProcess;
} SHELLEXECUTEINFO, "LPSHELLEXECUTEINFO;
SHELLEXECUTEINFO结构中唯一有趣的字段是IpVerb和IpFileo前者必须被设为 “runas” ,后者必须包含使用提升后的权限来启动的一个可执行文件的路径，如以下代码 所示：
// Initialize the structure.
SHELLEXECUTEINFO sei = { sizeof(SHELLEXECUTEINFO) };
// Ask for privileges elevation.
sei.IpVerb = TEXT(*runas")；
// Create a Command Prompt from which you will be able to start
// other elevated applications.
sei.IpFile = TEXT(•cmd.exe")；
// Don't forget this parameter； otherwise, the window will be hidden.
sei.nShow = SW_SHOWNORMAL；
if (1ShellExecuteEx(&sei)) (
DWORD dwStatus = GetLastError()；
if (dwStatus == ERROR_CANCELLED) (
// The user refused to allow privileges elevation.
}
else	"■
if (dwStatus == ERROR_FILE_NOT_FOUND)(
// The file defined by IpFile was not found and
//an error message popped up.
} .：
115-116
ndows核心编程（第5版）
如果用户拒绝提升权限，ShellExecuteEx将返回FALSE, GetLastError通过使用一个 ERROR_CANCELLED值来指出这个情况。
注意，当一个进程使用提升后的权限启动时，它每次用CreateProcess来生成另一个进程时， 子进程都会获得和它的父进程一样的提升后的权限，在这种情况下，不需要调用 ShellExecuteExo假如一个应用程序是用一个筛选后的令牌来运行的，那么一旦试图调用 CreateProcess来生成一个要求提升权限的可执行文件，这个调用就会失败，GetLastError 会返回 ERROR_ELEVATION__REQUIREDo
总之，要想成为Windows Vista中的“好公民”，我们的应用程序大多数时候都应该以“标 准用户”的身份运行。另外，在某项任务要求更多权限的时候，用户界面应该在与该管理 任务对应的用户界面元素（按钮、链接或菜单项）旁边明确显示一个盾牌图标（本章稍后的 Process Information示例程序给出了一•个例子）。由于管理任务必须由另一个进程或者另一 个进程中的COM服务器来执行，所以我们应该将需要管理员权限的所有任务集中到另一 个应用程序中，并通过调用ShellExecuteEx（为IpVerb传递“runas”）来提升它的权限。然 后，具体要执行的特权操作应该作为新进程的命令行上的一个参数来传递。这个参数是通 过 SHELLEXECUTEINFO 的 IpParameters 字段来传递的。
提示 对经过权限提升/筛选的进程进行调试可能比较麻烦。但仍有一条非常简单的黄金法 则可以遵循：希望被调试的进程继承什么权限，就以那种权限来启动Visual Studio0 如果需要调试的是一个以标准用户身份运行的已筛选的进程，就必须以标准用户的 身份来启动Visual Studio.每次单击它的默认快捷方式（或者通过「开始」菜单来启 动）时，都是以标准用户的身份来启动它的。否则，被调试的进程会从以管理员身份 启动的一个Visual Studio实例中继承提升后的权限，这并不是我们所期望的。 如果需要调试的进程要求以管理员身份运行（例如，根据那个进程的清单中的描述， 它可能必须以管理员身份运行），那么Visual Studio必须同样以管理员身份启动。否 则会显示一条错误消息，指出uthe requested operation requires elevation*, （请求的操 作需要提升权限），而且被调试的进程根本不会启动。
4.5.3何为当前权限上下文
前面描述过任务管理器的例子，它在Processes（进程）选项卡的底部要么显示一个盾牌图标, 要么显示一个复选框，具体取决于它是如何生成的。稍加思索，我们应该想到两个问题： 如何判断应用程序是否是以管理员身份运行；更重要的是，如何判断它是以提升的权限来 启动的，还是正在使用筛选的令牌运行。
下面这个名为GetProcessElevation的辅助函数能返回提升类型和一个指出进程是否正在以 管理员身份运行的布尔值。
第4章进程
BOOL GetProcessElevation(TOKEN_ELEVATION_TYPE* pElevationType, BOOL* pIsAdmin) ( HANDLE hToken = NULL;
DWORD dwSize;
// Get current process token	*
if (JOpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) return(FALSE);
BOOL bResult = FALSE;
// Retrieve elevation type information
if (GetTokenlnformation(hToken, TokenElevationTypez pElevationType, sizeof(TOKEN_ELEVATION_TYPE)f &dwSize)) ( // Create the SID corresponding to the Administrators group BYTE adminSID[SECURITYJHAX_SID_SIZE]; dwSize = sizeof(adminSID); CreateWellKnownSid(WinBuiltinAdministratorsSid, NULL, &adminSID, &dwSize);
if (*pElevationType == TokenElevationTypeLimited) (
// Get handle to linked token (will have one if we are lua) HANDLE hUnfi11eredToken = NULL;
GetTokenlnformation(hToken, TokenLinkedTokenf (VOID*)
&hUnfi11eredToken, sizeof(HANDLE)r &dwSize);	•
// Check if this original token contains admin SID
if (CheckTokenMembership(hUnfiIteredToken/ &adminSID, pIsAdmin)) ( bResult = TRUE;
}
// Don't forget to close the unfiltered token
CloseHandle(hUnfilteredToken)；
} else (	•
*plsAdmin = IsUserAnAdmin()； bResult = TRUE;
}
}
// Don*t forget to close the process token
CloseHandle(hToken);
return(bResult);
} "•-
注意，GetTokenlnfbrmation使用与进程关联的安全令牌和TokenElevationType参数来获得 提升类型，提升类型的值由TOKEN_ELEVATION_TYPE枚举类型来定义，如表4.9所示。
表 4-9 TOKEN_ELEVATION_TYPE 的值
值	描述
TokenElevationTypeDefault	进程以默认用户运行，或者UAC被禁用
TokenElevationTypeFull	进程的权限被成功提升，而且令牌没有被筛选过
T okenElevationT ypeLimited	进程以受限的权限运行，它对应于一个筛选过的令牌
根据这些值，我们可以知道进程在运行时使用的令牌是否被筛选过。下一步是判断用户是 不是管理员。如果令牌没有被筛选过，那么为了知道进程是否正在以管理员的身份运行， IsUserAnAdmin函数最理想。在令牌已被筛选的情况下，我们需要获取未筛选的令牌(把 TokenLinkedToken传给 GetTokenlnformation),然后判断其中是否包含一个管理员

画dows核心编程（第5版）
SID（借助于 CreateWellKnownSid 和 CheckTokenMembership）。
举个例子来说，下一小节将详细介绍的Process Information示例程序就在 WMJNITDIALOG消息处理代码中使用了这个辅助函数，目的是为对话框的标题添加前 缀来表明权限提升的详细信息，并显示或隐藏一个盾牌图标。
提示 注意，Button SetElevationRequiredState宏（在CommCtrl.h中定义）用于在按钮中 显示或隐藏盾牌图标。也可以调用SHGetStocklconlnfo,并在参数中传入 SIID_SHIELD,从而直接获取盾牌图标；两者都在shellapi.h中定义。要了解其 他还有哪些类型的控件支持盾牌图标，请查阅MSDN联机帮助，网址为 http://msdn2.microsoft.com/en-us/library/aa480150.aspXo
4.5.4枚举系统中正在运行的进程
许多软件开发人员在为Windows编写工具或实用程序时，都曾遇到过需要枚举正在运行的 进程的情况。Windows API最初并没有函数能枚举正在运行的进程。不过，Windows NT 有一个不断更新的数据库，称为“性能数据” （Performance Data）数据库。该数据库包含海 量信息，这些信息可以通过注册表函数来访问，例如RegQueryValueEx（把注册表的根项设 为KEY_PERFORMANCE_DATA）。由于以下原因，几乎很少有Windows程序员知道这个 性能数据库：
•	它没有自己专门的函数，使用的是现成的注册表函数
•	它在Windows 95和Windows 98上不可用
•	数据库中的信息布局非常复杂，许多开发人员都怕用它，这妨碍了它的流行
为了更方便地使用这个数据库，Microsoft创建了一套Performance Data Helper函数（包含在 PDH.dll中）。要想进一步了解这个函数库，请在Platform SDK文档中搜索Performance Data Helpero
正如刚才提到的那样，Windows 95和Windows 98没有提供这个性能数据库。它们有自己 的一套函数可用来枚举进程及相关信息。这些函数在ToolHelp API中。欲知详情，请在 Platform SDK 文档中搜索 Process32First 和 Process32Next 函数。
有趣的是,Windows NT开发团队不喜欢ToolHelp函数,所以没有把它们加入Windows NT。 相反，他们自行开发了 Process Status函数（包含在PSAPI.dll中）来枚举进程。欲知详情，请 在Platform SDK文档中搜索EnumProcesses函数.
虽然从表面上看,Microsoft也许是想为工具和实用程序的开发人员增加难度，但从Windows 2000开始，Tool Help函数终于在Windows操作系统中现身了。现在，开发人员终于可以 使用一套通用的源代码为Windows 95、Windows 98.直至Windows Vista写出适用性更
强的工具和实用程序。
第4章进程
4.5.5	Process Information 示例程序
Processlnfb应用程序（04-Processlnfb.exe）展示了如何利用各种ToolHelp函数来写一个非常 有用的实用程序。这个应用程序的源代码和资源文件可以在本书配套网页的04-ProcessInfb 目录中找到。启动该程序后，将显示图4V所示的窗口。
图4-4运行中的Processinfo
Processinfo首先枚举目前正在运行的所有进程，将每个进程的名称和ID添加到顶部的组合 框内。然后，选中第一个进程并在下方的只读编辑框中显示与这个进程有关的信息。可以 看出所见，程序显示了进程ID、命令行、所有者、父进程ID、进程的优先级类（PriorityClass） 以及在此进程的上下文中运行的线程数。虽然大多数信息都超出了本章的范围，但我们会 在后续的各章中陆续讨论。
查看进程列表时，可以使用VMMap菜单（查看模块信息时，这个菜单是禁用的）。选择 VMMap菜单，会运行VMMap示例程序（将在第14章讨论）。这个程序将遍历所选进程的 地址空间。
在模块信息（Module Information）g域，列出了映射到进程地址空间的模块（可执行文件和 DLL）。所谓Fixed（固定）模块，是指在进程初始化时隐式载入的模块。对于显式载入的DLL, 会显示其使用计数。第二列显示的是模块映射到的内存地址。如果模块没有映射到它首选 的基地址，则首选基地址会在圆括号中显示。第三列显示模块大小（以KB为单位）。最后一 列显示的是模块的完整路径名。在线程信息（Thread Information）区域，显示了当前在此进程 上下文中运行的所有线程，每个线程的ID和优先级都在此显示。
除了线程信息，还可以选择Modules!菜单项。这将使Processlnfb在整个系统中枚举目前已 载入的所有模块，并将每个模块的名称添加到顶部的组合框中。然后，Processinfo选中第
Windows核心编程(第5版)
一个模块并显示其相关信息，如图4.5所示。
Processed Modulesl VMMapI
Pathnau: C:\Vindovs\systeM32\PSAPI.DLL

Process Infor®ation:
PID
000006D0
00000A84
000007E0
0000026C
000009CC
00000970
00000EB8
BoscAdciT 76420000 76420000 76420000 76420000 76420000 76420000 76420000
explorer. exe MSASCui.exe sidebar.exe
unsecapp.exe
04 Processinfo.exes


图4-5 Processinfo显示了进程地址空间内加载了 Psapi.dll的所有进程
以这种方式使用Processinfo实用程序时，可以很容易地判断出哪些进程正在使用一个特定 的模块。模块的完整路径显示在顶部。在下方的Process Information(进程信息)区域，显示 了包含此模块的所有进程的一个列表。除了每个进程的ID和名称，还显示了模块加载到每 个进程的什么地址。
简单地说,Processinfo应用程序显示的所有信息都是通过调用各种ToolHelp函数来生成的。 为了使ToolHelp函数更易于使用，我创建了一个名为Ctoolhelp的C廿类(包含在Toolhelp.h 文件中)。这个C++类对生成的ToolHelp快照进行封装，并简化了对其他ToolHelp函数的 调用。
Processinfb.cpp 中的 GetModulePreferredBaseAddr 函数特别有意思：
PVOID GetModulePreferredBaseAddr(
DWORD dwProcessId,
PVOID pvModu1eRemot e)；
此函数接受一个进程ID以及这个进程内的一个模块的地址作为参数。然后，它会查看那个 进程的地址空间，定位那个模块，然后读取模块的文件头信息以确定这个模块的首选基地 址。模块应该始终加载到它的首选基地址；否则，使用此模块的应用程序在初始化的时候 就需要更多的内存，导致其性能受到影响。因为这是一个比较糟糕的情形，所以我特地添 加了这个函数，这样一来，当一个模块未能在首选基地址加载的时候，程序就可以将这种 情况显示出来。第20章将进一步介绍首选基地址及其对时间和内存性能的影响。
C..	器
进程的命令行不能直接获得。正如MSDN Magazine题为“Escape from DLL Hell with Custom Debugging and Instrumentation Tools and Utilities, Part 2” 的一篇文章(网址为 http://msdn.microsoft.com/msdnmag/issues/02/08/EscapefromDLLHell/)所解释的那样，要找到 命令行，需要深入研究远程进程的“进程环境块”(Process Environment Block, PEB)。不 过，自Windows XP起发生了两个重要的变化，我们需要对此专门解释一下。
首先，在 WinDbg(可从 http://www.microsoft.com/whdc/devtools/debugging/default.mspx 下载) 中，用于获得一个内核风格的PEB结构相关详情的命令已经发生了变化。现在不再使用
第4章进程
kdex2x86扩展所实现的“strct”。相反，我们只需调用“dt”命令。例如，执行“dtnt! PEB”, 将列出以下PEB定义：
+0x000 InheritedAddressSpace : UChar
+0x001 ReadlmageFi1eExecOptions : UChar
+0x002 BeingDebugged : UChar
+0x003 BitField : UChar
+0x003 ImageUsesLargePages : Pos 0, 1 Bit
+0x003 IsProtectedProcess : Pos 1, 1 Bit
+0x003 IsLegacyProcess : Pos 2, 1 Bit
+0x003 IsImageDynamica1lyRelocated : Pos 3, 1 Bit
+0x003 SpareBits : Pos 4, 4 Bits
+0x004 Mutant : Ptr32 Void
+0x008 ImageBaseAddress : Ptr32 Void
+0x00c Ldr : Ptr32 _PEB_LDR_DATA
♦0x010 ProcessParanetara : Ptr32 JRTL_USKI<_PROCBSS_PARAMBTERS
+0x014 SubSystemData : Ptr32 Void
,+0x018 ProcessHeap : Ptr32 Void
RTL_USER_PROCESS_PARAMETERS 结构的定义如下，这是由 WinDbg 中的。dt nt!_RTL_USER_PROCESS_PARAMETERS ” 命令所列出的：
+0x000 MaximumLength : Uint4B
+0x004 Length : Uint4B
+0x008 Flags : Uint4B
+0x00c DebugFlags : Uint4B
+0x010 ConsoleHandle : Ptr32 Void
+0x014 ConsoleFlags : Uint4B
+0x018 Standardinput : Ptr32 Void
+0x01c Standardoutput : Ptr32 Void
+0x020 StandardError : Ptr32 Void
+0x024 CurrentDirectory : _CURDIR
+0x030 DllPath : _UNICODE_STRING
+0x038 ImagePathName : _UNICODE_STRING
*0x040 Comna&dLine t _U»ICODE_STRING
+0x048 Environment : Ptr32 Void
这样一来，就可以对以下内部结构进行计算，从而帮助我们“挖掘”出命令行:
typedef struct
(
DWORD Filler[4]；
DWORD InfoBlockAddress;
} _PEB;
typedef struct
(
DWORD Filler(17];
DWORD wszCmdLineAddress;
} _INFOBLOCK;
其次，如同第14章要讲到的那样，在Windows Vista中，系统会将DLL载入进程地址空间 中的随机地址。所以，不要像在Windows XP中那样将PEB的地址硬编码为0x7fWfD00。
相反，我们需要调用NtQuerylnformationProcess ,并在第二个参数中传入 ProcessBasicInformationo别忘了，在一个版本的Windows中发现的未公开的细节可能在下 一个版本中发生改变，PEB的地址就是一例。
最后但同样很重要的一点，在使用Process Information应用程序时，我们会注意到某些进程
ows核心编程(第5版)
己在组合框中列出，但它没有显示已加载的DLL之类的详细信息。例如， audiodg.exe(Windows Audio Device Graph Isolation)就是一个受保护的进程。这种新的进 程类型是从Windows Vista开始引入的。例如，可以用它为DRM(数字权限保护)应用 程序提供更大程度的隔离。另外，理所当然地，远程进程访问受保护进程的虚拟内存 的权限也被取消了。由于这个权限是列出已加载的DLL所必须的，所以ToolHelp API 自然无法返回这些细节了。可从以下网址下载受保护进程的白皮书： http://www.microsoft.com/whdc/system/vista/process_Vista.mspxo
Process Information应用程序之所以不能获取一个正在运行的进程的所有详情，还可能是由 于另一个原因。如果这个工具是在未提升权限的情况下启动的，那么它就可能不能访问(自 然也不能修改)以提升的权限来启动的进程。事实上，其限制远远不止在程序的用户界面上 显示的那么单纯。Windows Vista还实现了另一个安全机制，即“Windows完整性机制” (Windows Integrity Mechanism),以前称为“强制完整性控制”(Mandatory Integrity Control)o 除了众所周知的安全描述符(SID)和访l'可控制列表(access control list, ACL),系统还通过在 系统访问控制列表(SACL)中新增一个名为强制标签的访问控制项(access control entry, ACE) 来为受保护的资源分配一个所谓的完整性级别(integrity level)。凡是没有这个ACE的安全 对象，操作系统将默认其拥有“中” (Medium)完整性级别。另外，每个进程都有一个基于 其安全令牌的完整性级别，它与系统授予的一个信任级别是对应的，如表4.10所示。
表4-10信任级别	
级别	应用程序示例
低	保护模式中的Internet Explorer是以“低”信任级别来运行的，目的在于拒绝从网上卜载的 代码修改其他应用程序和Windows环境
中	默认情况下，所有应用程序都以“中”信任级别来启动，并使用一个筛选过的令牌来运行
高	如果应用程序以提升后的权限来启动，则以“高”信任级别来运行
系统	只有以Local System或Local Service的身份运行的进程，才能获得这个信任级别
122
代码试图访问一个内核对象时，系统会将主调进程的完整性级别与内核对象的完整性级别 进行比较。如果后者高于前者，系统将拒绝它执行修改和删除操作。注意，这个比较是在 检查ACL之前就完成的。所以，即便进程拥有访问资源的权限，但由于它在运行时使用的 完整性级别低于资源所要求的完整性级别，所以访问仍会被拒绝。假如一个应用程序要运 行从网上下载的代码或脚本，这个设计就尤其重要。在Windows Vista上运行的Internet Explorer 7正是利用了这个机制，以“低”完整性级别来运行。这样一来，下载的代码就不 能更改其他任何应用程序的状态，因为那些应用程序的进程默认是以“中”完整性级别来 运行的。
提利用 Sysintemals 免费提供的 Process Explorer 工具(网址为 http://www.microsoft.com/ technet/sysintemals/ProcessesAndThreads/ProcessExplorer.mspx),可以查看进程的完
第4章进程
整性级别。为此，请在Select Columns对话框的uProcess Image”选项卡中选中 "Integrity Level"(见下图)。
源代码中的GetProcessIntegrityLevel函数演示了如何以编程方式来获取同样的细 节及其他更多的内容。利用Sysintemals免费提供的控制台工具AccessChk(网址为 http://www.microsoft.com/technet/sysintemals/utilities/accesschk.mspx), 可以 列 出 访 问 文件、文件夹和注册表项等各种资源时所需的完整性级别(使用-i或・e命令行开关 即可)。最后但同时也是最重要的一点，Windows Vista的控制台实用程序icacls.exe 提供了一个/setintegritylevel命令行开关，它可以设置一个文件系统资源的完整性 级别。	，
一旦知道了一个进程的令牌的完整性级别，以及它要访问的一个内核对象的完整性级别， 系统就可以根据令牌和资源中都存储有的代码策略来核实具体能执行什么操作。首先，示 例程序会调用GetToken In formation并传入TokenMandatoryPolicy和进程的安全令牌句 柄oGetTokenlnformation返回的是一个DWORD值，其中包含了一个位掩码(bitwise mask), 后者详细描述了适用的策略。表4.11列出了可能的策略。
表4・11代码策略
WinNT.h 中的 TOKEN MANDATORY* 常量	描述
POLICY_NO_WRITE_UP	在这个安全令牌下运行的代码不能向具有更高完整性级别的 资源写入
POLICY_NEW_PROCESS_MIN	在这个安全令牌下运行的代码启动一个新的进程时，子进程将 检查父进程和清单中描述的优先级，并从中选择最低的•个优 先级。如果没有清单的话，就假定清单中的优先级为“中”
Endows核心编程(第5版)
利用己经定义好的另外两个常量，可以轻松地判断要么没有策略 (TOKEN_MANDATORY_POLICY_OFF 定义为 0), 要么有一个位掩码 (TOKEN__MANDATORY_POLICY_VALID_MASK),以便我们对一个策略值进行验证(参 见Processlnfb.cpp中的源代码)。
其次，示例程序将根据与内核对象美联的ACE标签的位掩码来设置资源策略(参见 Processlnfb.cpp中的GetProcessIntegrityLevel函数来查看实现细廿)。为了决定允许或拒绝 在资源上进行哪种访问，我们可以使用两个资源策略。默认的资源策略是 SYSTEM_MANDATORY_LABEL_NO_WRITE_UP,它指出一个较低完整性级别的进程 可以读取但不能写入或删除一个较高完整性的资源。SYSTEM_MANDATORY_ LABEL_NO_READ_UP资源策略的限制性更强"因为它不允许较低完整性级别的进程读 取较高完整性的资源。
说明 对于一个高完整性级别的进程内核对象，即使已经设置了 “No・Read・Up”，另一个 完整姓级别较低的进程也能在完整性级别较高的地址空间中读取——只要该进程被 授予了 Debug权限。这解释了为什么以管理员身份运行Process Information X具时， 它能读取具有System完整性级别的那些进程(比如一个服务进程)的命令行，因为以 管理员身份运行能够获得Debug权限。
除了在进程之间提供内核对象的访问保护，窗口系统还利用完整性级别来拒绝低完整性级 别的进程访问/更新高完整性级别的进程的用户界面。这个机制称为用户界面特权隔离(User Interface Privilege Isolation, UIPI)。为了防止一个完整性级别较低的进程获取另一个完整级 别较高的进程中的信息，或向完整性级别较高的进程注入虚假输入，操作系统将阻止完整 性级别较低的进程通过PostMessage向完整性级别较高的进程发送Windows消息，或通过 SendMessage发送的Windows消息或通过Windows挂钩来拦截完整性级别较高的进程的 Windows消息。为了更好地体会这一点，我们可以使用WindowDump这个实用程序来做实验 (http://download.microsoft.eom/download/8/3/f783f69587-47fl -48e2-86a6-aab 14fD 1 fl fe/Escape FromDLLHell.exe)o为了获得一个列表框的每一项所显示的文本，WindowDump调用 SendMessage函数，并将LB.GETCOUNT作为参数来传递，这样可以获得要读取文本内 容的元素的数量。随后，我们调用SendMessage,并将LB_GETTEXT作为参数来获取文 本内容。然而，假如WindowDump进程运行时使用的完整性级别低于列表框所在的进程， 那么第一个SendMessage调用虽然能成功，但它返回的元素数量将为0。以“中”完整性 级别来启动Spy++并用它获取一个窗口的消息时，如果那个窗口是由一个较高完整性级别 的进程创建的，我们将观察到相同的行为：即操作会失败。
124
.V
我们经常都需要将一组进程当作单个实体来处理。例如，我们用Visual Studio来构建一个 C++项目的时候，它会生成Cl.exe,后者可能必须生成更多的进程(比如编译器每次对源文 件进行扫描的时候。①)。但是，如果用户希望提前停止构建过程，Visual Studio必须能够以 某种方式终止Cl.exe及其所有子进程。虽然这是一个简单而常见的问题，但在Microsoft Windows中解决起来非常难，这是由于Windows没有维护进程之间的父/子关系。具体地 说，即使父进程已经终止运行，子进程仍在继续运行。
设计一个服务器时，也必须把一组进程当作一个单独的组来处理。例如，一个客户端也许 会请求服务器执行一个应用程序并将结果返回给客户端(该应用程序也许会生成自己的子 进程)。由于许多客户端都可能连接到此服务器，所以服务器应该以某种方式限制客户端能 请求的东西，避免任何一个客户端独占其所有资源。这些限制包括可以分配给客户端请求 的最大CPU时间；最小工作集(working set)和最大工作集大小、禁止客户端应用程序关闭 计算机以及安全限制。
Windows提供了一个作业(job)内核对象，它允许我们将进程组合在一起并创建一个“沙箱” 来限制进程能够做什么。最好将作业对象想象成一个进程容器。但是，创建只包含一个进 程的作业同样非常有用，因为这样可以对进程施加平时不能施加的限制。
下面是我编写的StartRestrictedProcess函数，该函数将一个进程放入一个作业中，以限制 此进程具体能够做哪些事情，如下所示：
void StartRestrictedProcess() {
// Check if we are not already associated with a job.
// If this is the case, there is no way to switch to
①译注：在每次扫描过程中，都对源程序或源程序的中间结果从头到尾扫描一次，并进行相关的加工处理，从而生成新的中 间结果或目标程序。
I^^dows核心编程（第5版）
// another job.
BOOL binjob = FALSE;
IsProcessInJob(GetCurrentProcess(), NULL, &bInJob);
if (binjob)(
MessageBox(NULL, TEXT("Process already in a job"), TEXT	MB_I CON IN FORMAT I ON I MB_OK);
return；
}
// Create a job kernel object.
HANDLE hjob = CreateJobObject(NULL,
TEXT("Wintellect_RestrictedProcessJobM));
// Place some restrictions on processes in the job.
// First, set some basic restrictions.
JOBOBJECT_BASIC_LIMIT_INFORMATION jobli = { 0 };
// The process always runs in the idle priority class.
jobli.Priorityclass = IDLE_PRIORITY_CLASS;
// The job cannot use more than 1 second of CPU time.
jobli.PerJobUserTimeLimit.QuadPart = 10000; // 1 sec in 100-ns intervals
// These are the only 2 restrictions I want placed on the job (process). jobli.LimitFlags = JOB_OBJECT_LIMIT_PRIORITY_CLASS
. I JOB_OBJECT_LIMIT_JOB_TIME;
SetInformationJobObject(hjob, JobObjectBasicLimitInformation, &jobli, sizeof(jobli))；
// Second, set some UI restrictions.
JOBOBJECT_BASIC_UI_RESTRICTIONS jobuir； jobuir.UIRestrictionsClass = JOB_OBJECT_UILIMIT_NONE; // A fancy zero
// The process can't log off the system. jobuir.UIRestrictionsClass I= JOB_OBJECT_UILIMIT_EXITWINDOWS;
// The process can't access USER objects (such as other windows)
// in the system.
jobuir.UIRestrictionsClass I= JOB_OBJECT_UILIMIT_HANDLES;
SetInformationJobObject(hjob, JobObjectBasicUIRestrictions, &jobuirz sizeof(jobuir))；
// Spawn the process that is to be in the job.
// Note： You must first spawn the process and then place Che process in //	the job. This means that the process" thread must be initially
//	suspended so that it can't execute any code outside of the job's
//	restrictions.
STARTUPINFO si = ( sizeof(si) )；
PROCESS_INFORMATION pi;
TCHAR szCmdLine[8]；
_tcscpy_s(szCmdLine, _countof(szCmdLine), TEXT("CMD，));
BOOL bResult =
CreateProcess(
NULL, szCmdLine, NULL, NULL, FALSE,
CREATE_SUSPENDED I CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi);
// Place the process in the job.
// Note： If this process spawns any children, the children are
//	automatically part of the same job.
AssignProcessToJobObject(hjob, pi.hProcess);
// Now we can allow the child process' thread to execute code. ResumeThread(pi.hThread)；
CloseHandle(pi.hThread);
// Wait for the process to terminate or
// for all the job's allotted CPU time to be used.
第5章作业
HANDLE h[2];
h[0] = pi.hProcess；
h ⑴=hjob;
DWORD dw = WaitForMultipieObjects(2, h, FALSE, INFINITE);
switch (dw - WAIT_OBJECT_0) (
case 0:
// The process has terminated...
break；
case 1:
// All of the job's allotted CPU time was used... break；
}
CreationTime； ExitTime； KernelTime； UserTime；
FILETIME
FILETIME
FILETIME
FILETIME
TCHAR SZlnfo[MAX_PATH];
GetProcessTimes(pi.hProcess, &CreationTime, &ExitTime,
ScKernelTime, &UserTime);
StringCchPrintf(szlnfo, _countof(szlnfo), TEXT("Kernel = %u I User = %u\n"), KernelTime.dwLowDateTime / 10000, UserTime.dwLowDateTime / 10000);
MessageBox(GetActivewindow(), szlnfo, TEXT("Restricted Process times"), MB_ICON工NFORMATION I MB_OK);
// Clean up properly. CloseHandle(pi.hProcess); CloseHandle(hjob);
:瀚 26~127 "
现在来解释StartRestrictedProcess的工作方式。首先，函数将NULL作为第二个参数传给 以下函数，验证当前进程是否在一个现有的作业控制之下运行：
BOOL IsProcessInJobf HANDLE hProcess, HANDLE hJob, PBOOL pblnJob);
如果进程已与一个作业关联，就无法将当前进程或者它的任何子进程从作业中去除。这个 安全特性可以确保进程无法摆脱对它施加的限制。
127
警告 默认情况下，在Windows Vista中通过Windows资源管理器来启动一个应用程序时， 进程会自动同一个专用的作业关联，此作业的名称使用了“PCA”字符串前缀。正如 本章稍后的“作业通知” 一节要讲述的那样，作业中的一个进程退出时，我们是可 以接收到一个通知的。所以，一旦通过Windows资源管理器启动的一个老版本的应 用程序①出现问题，就会触发Program Compatibility Assistant］程序兼容性助手)。 如果应用程序需要创建像本章最后展示的Job Lab程序那样的一个作业，只能说我们 运气不太好。这个创建注定会失败，因为进程已经关联了带“PCA”前缀的作业对象。 Windows Vista提供这个特性的目的纯粹是为了检测兼容性问题。所以，如果我们已 经像第4章描述的那样为应用程序定义了一个清单(manifest), Windows资源管理器 就不会将我们的进程同带“PCA”前缀的作业关联，它会假定我们已经解决了任何可
① 译注：即不是为Windows Vista开发的应用程序。
lows核心编程(第5版)
能出现的兼容性问题。
但是，在需要调试应用程序的时候，如果调试器是从Windows资源管理器启动的， 即使我们的应用程序有一个清单(mainifest),它也会从调试器继承带”PCA”前缀的作 业。一个简单的解决方案是从命令行而不是Windows资源管理器中启动调试器。在 这种情况下，我们的进程就不会与作业关联。
然后，我通过以下调用来创建一个新的作业内核对象：
HANDLE CreateJobObject(
PSECURITY_ATTRIBUTES psa,
PCTSTR pszName);
和所有内核对象一样，第一个参数将安全信息与新的作业对象关联，然后告诉系统，是否 希望返回的句柄可被继承。最后一个参数对此作业对象进行命名，使其能够由另一个进程 通过OpenJobObject函数(详见本章后文)进行访问，如下所示：
HANDLE OpenJobObject(
DWORD dwDesiredAccess,
BOOL blnheritHandle,
PCTSTR pszName)；
和往常一样，如果确定在自己的代码中不再访问作业对象，就必须调用CloseHandle来关 闭它的句柄。这一点在前面的StartRestrictedProcess函数的末尾有所体现。务必记住，关 闭一个作业对象，不会迫使作业中的所有进程都终止运行。作业对象实际只是加了一个删 除标记，只有在作业中的所有进程都巳终止运行之后，才会自动销毁。
注意，关闭作业的句柄会导致所有进程都不可访问此作业，即使这个作业仍然存在。如以 下代码所示：
// Create a named job object.
HANDLE hJob = CreateJobObject(NULL, TEXT(-Jeff"));
// Put our own process in the job.
AssignProcessToJobObject(hJob, GetCurrentProcess());
// Closing the job does not kill our process or the job.
// But the name ("Jeff") is immediately disassociated with Che job.
CloseHandle(hJob)；
// Try to open the existing job.
hJob = OpenJobObject(JOB_OBJECT_ALL_ACCESS, FALSE, TEXT("Jeff"));
// OpenJobObject fails and returns NULL here because Che name ("Jeff")
// was disassociated from the job when CloseHandle was called.
// There is no way to get a handle to Chis job now.	___
5.1对作业中的进程施加限制
创建好一个作业之后，接着一般会根据作业中的进程能够执行哪些操作来建立一个沙箱(即 施加限制①)。可以向作业应用以下几种类型的限制：
•	基本限额和扩展基本限额，用于防止作业中的进程独占系统资源。
①译注：原著中用了 restrition和limit两个词来表示限制(约束)，这里前者译为限制，后者译为限额，以示区分。
第5章作业
基本的UI限制，用于防止作业内的进程更改用户界面。
安全限额，用于防止作业内的进程访问安全资源（文件、注册表子项等）。
可以通过调用以下函数向作业施加限制：
BOOL SetInformationJobObject（
HANDLE hJob,
JOBOBJECTINFOCLASS JobObjec11nformationClass,
PVOID pJobObjectInformation,
DWORD cbJobObjectinformationSize）;
第一个参数指定要限制的作业。第二个参数是一个枚举类型，指定了要施加的限制的类型。 第三个参数是一个数据结构的地址，该数据结构中包含具体的限制设置。第四个参数指出 此数据结构的大小（用于版本控制）。表5.1总结了如何设置这些限制。
表5・1限制类型
限制类型	第二个参数的值	第三个参数所对应的数据结构
基本限额	JobObjectBasicLimitlnfbrmation	JOBOBJECT BASIC LIMIT INFORMATION
扩展后的 基本限额	JobObjectExtendedLimitlnfbrmation	JOBOBJECT_EXTENDED_LIMIT_INFORMATION
基本的UI 限制	JobObjectBasicUI Restrictions	JOBOBJECT_BASIC_UI_RESTRICTIONS
安全限额	JobObjectSecurityLimitInfbrmation	JOBOBJECT SECURITY LIMIT INFORMATION
在我编写的StartRestrictedProcess函数中，只对作业设置了一些基本的限制。我分配了一 个JOBOBJECT_BASIC_LIMIT_INFORMATION结构，对它进行初始化，然后调用 SetlnformationJobObject。JOBOBJECT_BASIC_LIMIT_INFORMATION 结构如下所示:
typedef Struct _JOBOBJECT_BASIC_LIMIT_INFORMATION (
LARGE_INTEGER
PerProcessUserTimeLimit；
LARGE_INTEGER
PerJobUserTimeLimit；
DWORD LimitFlags；
DWORD	MinimumWorkingSetSize;
DWORD	MaximumWorkingSetSi ze ；
DWORD	ActiveProcessLimit；
DWORD_PTR
DWORD
DWORD
Affinity；
Priorityclass；
SchedulingClass;
) JOBOBJECT_BASIC_LIMIT_INFORMATION, *PJOBOBJECT_BASIC_LIMIT_INFORMATION;
-*129-130
表5・2简要描述了这些成员。
表 5-2 JOBOBJECT_BASIC_LIMIT_INFORMATION 成员
成员	描述	备注
PerProcessUserTimeLimit	指定分配给每个 进程的最大用户 模式时间（时间 间隔为100纳秒）	对丁•占用时间超过其分配时间的任何进程，系统将自动 终止它的运行。要设置这个限额，请在LimitFlags成员 中指定 JOB_OBJECT_LIMIT_PROCESS_TIME 标志
四dows核心编程（第5版）
续表
成员	描述	备注
PerJobUserTimeLimit	限制分配给作业 对象的最大用户 模式时间（时间 间隔为100纳秒）	默认情况下，在达到该时间限额时，系统将自动终止所 有进程的运行。可以在作业运行时定期改变这个值。要 设置这个限额，请在LimitFlags成员中指定 JOB OBJECT LIMIT JOB TIME 标志
LimitFlags	指定将哪些限制 应用于作业	详细说明参见后文
MinimumWorkingSetSize Maximum WorkingSetSize	指定每个进程 （并不是作业中 的所有进程）的 最小工作集和最 大工作集	正常情况下，进程的工作集能扩展至最大值以上；设置 了 MaximumWorkingSetSize后，就可以对其设置硬性 的限额。一旦进程的工作集抵达这个限额，进程就会开 始进行换页操作。除非进程只是尝试清空它的工作集， 否则一个单独的进程对SetProcessWorkingSetSize的 调用会被忽略。要设置该限额，清在LimitFlags成员 中指定 JOB OBJECT LIMIT WORKINGSET 标志
ActiveProcessLimit	指定作业中能并 发运行的进程的 最大数量	超过此限额的任何尝试都会导致新进程终止，并报告一 个“配额不足”错误。要设置这个限额，请在LimitFlags 成员中指定 JOB_OBJECT_LIMIT_ACTIVE_PROCESS 标志
Affinity	指定能够运行进 程的CPU子集	单.独的进程可以进一步对此进行限定。要设置这 个限额，请在LimitFlags成员中指定JOB_ OBJECT LIMIT AFFINITY 标志
PriorityClass	指定关联的所有 进程的优先级类 （priority class）	如果一个进程调用SetPriorityClass函数，即使该函数 调用失败，也会成功返回。如果进程调用 GetPriorityClass函数，该函数将返回进程已经设置的 优先级类，尽管这可能并不是进程实际的优先级类。此 夕卜，SetThreadPriority无法将线程的优先级提高到 Normal以上，但是可以用它降低线程的优先级。要设 置这个限额，请在LimitFlags成员中指定 JOB OBJECT LIMIT PRIORITY CLASS 标志
SchedulingClass	为作业中的线程 指定一个相对时 间量差（relative time quantum difference）	值可以在0〜9之间（包括0和9）,默认是5。详细说明参 见后文。要设置这个限额，请在LimitFlags成员中指定 JOB_OBJECT_LIMIT_SCHEDULING_CLASS 标志
关于这个结构，我认为Platform SDK文档中解释得不够清楚，所以这里要稍微多说几句。在 LimitFlags成员中，可以设置标志位来指定希望应用于此作业的限制条件。例如，在我编写 的 StartRestrictedProcess 函数中，我设置了 JOB_OBJECT_LIMTT_PRIORITY_CLASS 和
第5章作业
JOB_OBJECT_LIMIT_JOB_TIME这两个标志位。这意味着我只对作业施加了两个限制。 至于CPU Affinity(CPU关联性，即限制进程能用什么CPU来运行)、工作集大小、每个进 程的CPU时间等，我没有进行任何限制。
作业运行过程中，它会维护一些统计信息，比如作业中的进程使用了多少CPU时间。每次 使用JOB_OBJECT_LIMIT_JOB_TIME标志来设置基本限额的时候，作业都会扣除已终 止运行的进程的CPU时间统计信息，从而显示当前活动的进程使用了多少CPU时间。但 是，假如我们想改变作业的CPU关联性，同时不想重置CPU时间统计信息，又该怎么办 呢？为此，我们必须使用JOB_OBJECT_LIMIT_AFFINITY标志设置一个新的基本限额， 同时必须取消设置JOB_OBJECT_LIMIT__JOB_TIME标志。但是，这样做相当于告诉作 业我们不再希望对CPU时间施加限制。而这并不是我们希望的。
现在，我们希望既更改关联性限制，又保留现有的CPU时间限制；只是不希望扣除已终止 进程的CPU时间统计信息。为了解决这个问题，请使用一个特殊的标志，即 JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME。这个标志和 JOB_OBJECT_ LIMIT__JOB_TIME 标志是互斥的。JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME 标 志指出我们希望在改变限制条件的同时，不扣除已终止运行的那些进程的CPU时间统计 信息。
接下来研究一下 JOBOBJECT_BASIC_LIMIT_INFORMATION 结构的 SchedulingClass 成员。设想现在有两个作业正在运行，而且我们将这两个作业的优先级类(priority class)都 设为NORMAL_PRIORITY_CLASSo但是，我们还希望一个作业中的进程能够比另一个 作业中的进程获得更多的CPU时间。为此，可以使用SchedulingClass成员来更改“优先 级类”相同的各个作业的相对调度优先级(relative scheduling of job)o我们可以设置0〜9(含 0和9)的任何一个值，默认值是5。在Windows Vista中，这个值越大，表明系统要为特定 作业中的进程中的线程分配一个更长的时间量(timequantum)；值越小，表明线程的时间量 越小。
例如，假定现在有两个Normal优先级类的作业。每个作业都有一个进程，而且每个进程都 只有一个(Normal优先级)线程。正常情况下，这两个线程以轮(round-robin)方式调度，各 自获得相同的时间量。但是，如果将第一个作业的SchedulingClass成员设置为3,那么为 这个作业中的线程调度CPU时间时，它们的时间量将少于第二个作业中的线程。
使用SchedulingClass成员时，应避免使用很大的数字(进而造成很大的时间量)。这是由于 时间量变得越大，系统中的其他作业、进程以及线程的反应会变得越来越迟钝。
值得注 意的最 后一个 限额是 JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_ EXCEPTION限额标志。这个限额会导致系统关闭与作业关联的每一个进程的“未处理备 异常”对话框。为此，系统会为作业中的每个进程调用SetErrorMode函数，并向它传递 SEM_NOGPFAULTERRORBOX标志。作业中的一个进程在引发一个未处理的异常后，会 立即终止运行，不会显示任何用户界面。对于服务和其他面向批处理任务的作业，这是相
indows核心编程（第5版）
当有价值的一个限额标志。如果不设置这个标志，作业中的进程就能抛出异常，而目.永远 不会终止运行①，从而造成系统资源的浪费。
除了基本限额外，还可以使用JOBOBJECT_EXTENDED_LIMIT_INFORMATION结构对作 业应用扩展限额：
typedef struct _JOBOBJECT_EXTENDED_LIMIT_INFORMATION （
JOBOBJECT_BAS工C_LIMIT_INFORMATION BasicLimitlnformaCion;
IO_COUNTERS lolnfo；
SIZE_T ProcessMemoryLimit;
SIZE_T JobMemoryLimit;
SIZE_T PeakProcessMemoryUsed；
SIZE_T PeakJobMemoryUsed;
} JOBOBJECT_EXTENDED_LIMIT_INFORMATION, *PJOBOBJECT_EXTENDED_LIMIT_INFORMATION;
町以看出，该结构包含一个JOBOBJECT_BASIC_LIMITJNFORMATION结构，这就使 它成为基本限制的一个超集。该结构有点诡异，因为它包含了与限制作业无关的成员。首 先，lolnfo是保留成员，不应以任何方式访问它。本章稍后将讨论如何查询I/O计数器信 息。此外，PeakProcessMemoryUsed和PeakJobMemoryUsed成员是只读的，分别告诉我 们已调拨给作业中的任何一个进程所需的存储空间的峰值，以及已调拨给作业中全部进程 所需的存储空间的峰值。
其余两个成员ProcessMemoryLimit和JobMemoryLimit分别限制着作业中的任何一个进程或全 部进程所使用的己调拨的存储空间。为了设置这样的限制，需要在LimitFlags成员中分别指定 JOB OBJECT LIMIT JOB MEMORY 和 JOB OBJECT LIMIT PROCESS MEMORY
再来看看能对作业施加的其他限制。JOBOBJECT_BASIC_UI_RESTRICTIONS结构如 下所示：
typedef struct _JOBOBJECT_BASIC_UI_RESTRICTIONS {
DWORD UIRestrictionsClass；
} JOBOBJECT_BASIC_UI_RESTRICTIONS, *PJOBOBJECT_BASIC_UI_RESTRICTIONS;
< 132-133
该结构只有一个数据成员，即UIRestrictionsClass,它容纳着表5.3所示的标志位集合。
表5・3针对作业对象基本用户界面限制的标志位
标志	描述
JOB_OBJECT_UILIMIT_EXITWINDOWS	阻止进程通过ExitWindowsEx函数注销、关机、垂 启或断开系统电源
JOB OBJECT UILIMIT READCLIPBOARD	阻止进程读取剪贴板中的内容
JOB OBJECT UILIMIT WRITECLIPBOARD	阻止进程清除剪贴板中的内容
JOB_OBJECT_UILIMIT_	阻止进程通过SystemParametersInfo函数更改
SYSTEMPARAMETERS	系统参数
①在没有人去关闭“未处理的异常”对话框的情况下。
第5章作业
	续表
标志	描述
JOB OBJECT UILIMIT DISPLAYSETTINGS	阻止进程通过ChangeDispiay Settings函数更改显示设置
JOB_OBJECT_UILIMIT_GLOBALATOMS	为作业指定其专有的全局原于表，并限定作业中的进 程只能访问此作业的表
JOB_OBJECT_UILIMIT_DESKTOP	阻止进程使用CreateDesktop或SwitchDesktop函数来 创建或切换桌面
JOB_OBJECT_UILIMIT_HANDLES	阻止作业中的进程使用同一个作业外部的进程所创建 的用户对象（比如HWND）
最后一个标志JOB_OBJECT_UILIMIT_HANDLES特别有意思。该限制意味着作业中的 任何一个进程都不能访问作业外部的进程所创建的用户对象。所以，如果试图在一个作业 内运行Microsoft Spy++,就只能看到Spy++自己创建的窗口，看不到其他任何窗口。图5・1 展示了己打开两个MDI子窗口的Spy-H-程序。
□	的 X!ng aist


图5-1在一个限制了对UI句柄的访问的作业中运行的Microsoft Spy++
注意，Threads 1窗口包含系统中的线程的一个列表。在这些线程中，只有一个线程 00000AA8 SPYXX似乎已经创建了窗口。这是因为我让Spy"在它自己的作业中运行，并 限制了它对UI句柄的使用。在同一个窗口中，可以看到EXPLORER和DEVENV线程， 但它看上去并没有创建任何窗口。但我可以肯定这些线程已创建了窗口，只是Spy++不能 访问它们。在右侧，可以看到Windows 1窗口。在这个窗口中，Spy"显示了桌面上现有 的所有窗口的一个层次结构。注意其中只有一项，即00000000。Spy"只是把它作为占位 符使用。
133
■^^dows核心编程(第5版)
注意，这个UI限制只是单向的。也就是说，作业外部的进程可以看到作业内部的进程所 创建的用户对象。例如，假如我在一个作业内部运行记事本程序，在一个作业外部运行 Spy++程序，那么Spy++是可以看到记事本程序的窗口的，即使记事本程序所在的那个 作业指定了 JOB_OBJECT_UILIMIT_HANDLES标志。另外，如果Spy++在它自己的 作业中，那么也可以话到记事本程序的窗口，除非作业己经指定了 JOB_OBJECT_UILIMIT__HANDLES 标志。
要为作业中的进程创建一个真正安全的沙箱，对UI句柄进行限制是十分强大的一个能力。 不过，有时仍然需要让作业内部的一个进程同作业外部的一个进程通信。
为了做到这一点，一个简单的办法是使用窗口消息。但是，如果作业中的进程不能访问UI 句柄，那么作业内部的进程就不能向作业外部的进程创建的一个窗口发送或发布窗口消息。 幸运的是，可以用另一个函数来解决这个问题，如下所示：
BOOL UserHandleGrantAccess(
HANDLE hUserObj,
HANDLE hJob, BOOL bGrant);
hUserObj参数指定一个用户对象，我们想允许或拒绝作业内部的进程访问此对象。这几乎 总是一个窗口句柄，但它也可能是其他用户对象，比如桌面、挂钩(hook)、,图标或菜单。 最后两个参数hJob和bGrant指出我们要授权哪个作业访问或拒绝哪个作业访问。注意， 如果从hJob所标识的作业内的一个进程内调用这个函数，函数调用会失败——这样可以防 止作业内部的一个进程自己向自己授予一个对象的访问权。
我们可以向作业施加的最后一•种限制与安全性有关。注意，一旦应用，安全限制就不能撤 销。JOBOBJECT_SECURITY_LIMIT_INFORMATION 结构如下所示：
typedef struct _JOBOBJECT_SECURITY_LIMIT_INFORMATION (
DWORD SecurityLimitFlags;
HANDLE JobToken;
PTOKEN.GROUPS SidsToDisable；
PTOKEN_PRIVILEGES PrivilegesToDelete； PTOKEN_GROUPS RestrictedSids;
} JOBOBJECT_SECURITY_LIMIT_INFORMATION, *PJOBOBJECT_SECURITY_LIMIT_INFORMATION;
表5・4简要描述了其成员。
表 5-4 JOBOBJECT_SECURITY_LIMIT_INFORMATION 结构的成员
成员	描述
Security LimitFlags	指明是否不允许管理员访问，不允许无限制的令牌访问，强制使用特定的访问令 牌，或者禁止特定的安全标识符(security idetifier, SID)和特权
JobToken	由作业中所有进程使用的访问令牌
SidsToDisable	指定要禁止对哪些SID进行访问访问检查
PrivilegesToDelete	指定要从访问令牌中删除哪些特权
RestrictedSids	指定将一组只能拒绝的SID(这些SID中添加到访问令牌中)
第5章作业
既然已对作业施加限制，自然会联想到查询这些限制。通过调用以下函数，很容易实现这 一占.
八、、•
BOOL QuerylnformationJobObject（
HANDLE hJob,
JOBOBJECTINFOCLASS JobObjectlnformationClass,
PVOID pvJobObjectInformaCion,
DWORD cbJobObjectInformationSize,
PDWORD pdwReturnSize）;
需要传给此函数的参数有：作业的句柄（这类似于SetlnformationJobObject函数--------这是
一个枚举类型，指出我们希望有哪些限制信息；由此函数初始化的数据结构的地址；包含 该数据结构的数据块的大小。最后一个参数是pdwReturnSize,它指向由此函数来填充的 一个DWORD,指出缓冲区中已填充了多少个字节。如果对这个信息不感兴趣，可以（通常 也会）为此参数传递一个NULL值。
说明 作业中的进程可以调用QuerylnformationJobObject获得其所属作业的相关信息（为作 业句柄参数传递NULL值）。这个技术很有用，因为它使进程能看到自己被施加了哪 些限制。不过，如果为作业句柄参数传递NULL值，SetlnformationJobObject函数调 用会失败——目的是防止进程删除施加于自己身上的限制。
5.2将进程放入作业中
好了，关于设置和查询限制的讨论到此为止。现在回过头来讨论我编写的 StartRestrictedProcess函数。在对作业施加了某些限制之后，我通过调用CreateProcess 来生成打算放到作业中的进程。但请注意，调用CreateProcess时，我使用的是 CREATE_SUSPENDED标志。这样虽然会创建新进程，但是不允许它执行任何代码。由 于StartRestrictedProcess函数是从不属于作业一部分的进程中执行的，所以子进程也不是 作业的一部分。如果我允许子进程立即开始执行代码，它会“逃离”我的沙箱，成功地做 一些我想禁止它做的事情。所以，在我创建此子进程之后且在允许它运行之前，必须调用 以下函数，将进程显式地放入我新建的作业中：
BOOL AssignProcessToJobObject（
HANDLE hJob,
HANDLE hProcess）;
这个函数向系统表明将此进程（由hProcess标识）当作现有作业（由hJob标识）的一部分。注 意，这个函数只允许将尚未分配给任何作业的一个进程分配给一个作业，你可以使用 IsProcessInJob函数对此进行检查。一旦进程己经属于作业的一部分，它就不能再移动到 另一个作业中，也不能成为所谓“无业的”。还要注意，当作业中的一个进程生成了另一 个进程的时候，新进程将自动成为父进程所属于的作业的一部分。但可以通过以下方式改 变这种行为。
•打开 JOBOBJECT_BASIC_LIMITJNFORMATION 的 LimitFlags 成员的
西dows核心编程(第5版)	.
/k
JOB_OBJECT_LIMIT_BREAKAWAY_OK标志，告诉系统新生成的进程可以在 作显外部执行。为此，必须在商用CreateProcess函数时指定新的 CREATE_BREAKAWAY_FROM_JOB标志。如果这样做了，但作业并没有打开 JOB_OBJECT_LIMIT_BREAKAWAY_OK 限额标志，CreateProcess 调用就会失 败。商果希望亩新生成函进程来控制作显，这就是非常有用的一个机制。
•打开 JOBOBJECT_BASIC_LIMIT_INFORMATION 的 LimitFlags 成员的 JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK 标志。此标志也告诉系统新 生成函子进程不应该是店业的一尿分。但是，现在就没有必要向CreateProcess函数 传递任何额外的标志。事实上，此标志会强制新进程脱离当前作业。如果进程在设 计之初对作业对象一无所知，这个标志就相当有用。
至于我所写的 StartRestrictedProcess 函数，在调用了 AssignProcessToJobObject 之后，新 进程就成为我的受限制的作业的一部分。然后，我调用ResumeThread，使进程的线程可 以在作业的限制下执行代码。与此同时，我还关闭了到线程的句柄，因为我不再需要它了。
5.3终止作业中的所有线程
对于作业，我们经常想做的一件事情就是“杀死”作业中的所有进程。本章伊始，我提到 Visual Studio没有一个简单的办法来停止正在进行中的构建(build),因为它必须知道哪些 进程是从它生成的第一个进程生成的。(这非常难。我在Microsoft Systems Journal 1998年6 月期的Win 32 Q&A专栏讨论过Developer Studio是如何做到这一点的，可以通过以下网址 找到这篇文章：http://www.microsoft.com/msj/0698/win320698.aspxo )也许 Visual Studio 未 来的版本会转而使用作业，因为这样一来，代码的编写会变得更容易，而且可以用作业来 做更多的事情。
要“杀死”作业内部的所有进程，只需调用以下代码：
BOOL TerminateJobobject(
HANDLE hJob,
UINT uExitCode);
这类似于为作业内的每一个进程调用TerminateProcess,将所有退出代码设为uExitCode0
查询作业统计信息
前面讨论了如何使用QuerylnformationJobObject函数来查询作业当前的限制。此外，我 们还可以用它来获得作业的统计信息。例如，要获得基本的统计信息，我们可以调用函数 Query Information JobObject» 向第 2 个参数传递 JobObjectBasicAccountinglnfonnatioii 和一个 JOBOBJECT_BASIC_ACCOUNTING_INFORMATION 结构的地址：
typedef struct _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {
LARGE_INTEGER TotalUserTime;
LARGE_INTEGER TotalKernelTime；
第5章作业
LARGE_INTEGER ThisPeriodTotalUserTime;
LARGE_INTEGER ThisPeriodTotalKernelTime；
DWORD TotalPageFaultCount;
DWORD TotalProcesses;
DWORD ActiveProcesses；
DWORD TotalTerminatedProcesses；
} JOBOBJECT_BASIC_ACCOUNTING_INFORMATION, *PJOBOBJECT_BASIC_ACCOUNTING_INFORMATION;
表5-5简要描述了该结构的成员。
表 5-5 JOBOBJECT_BASIC_ACCOUNTING_INFORMATION 结构的成员
成员	描述
TotalUserTime	指出作业中的进程已使用了多少用户模式的CPU时间
TotalKernelTime	指出作业中的进程已使用了多少内核模式的CPU时间
ThisPeriodTotalUserTime	与 TotalUserTime 一样，不同的是，如果调用 SetlnfbrmationJobOMect 来更改基本限额信息，同时没有使用JOB_OBJECT_LIMIT_ PRESERVEJOB TIME限额标志，这个值被重置为0
ThisPeriodTotalKernelTime	与ThisPeriodTotalUserTime 一样，不同的是，这个值显示的是内核 模式CPU时间
TotalPageFaultCount	指出作业中的进程产生的页面错误总数
TotalProcesses	指出曾经属于作业一部分的所有进程的总数
ActiveProcesses	指定作业的当前进程的总数
T otalT erminatedProcesses	指出因为已超过预定CPU时间限额而被“杀死”的进程数
137-138 >
从StartRestrictedProcess函数实现的末尾可以看出，通过调用GetProcessTimes函数我们 可以获得任何一个进程的CPU占用时间信息，即使此进程不属于任何一个作业，详情请参 见第7章。
除了查询基本的统计信息，还可以执行一个调用来同时查询基本统计信息和1/0（输入/输出） 统计信息。为此，要向第2个参数传递JobObjectBasicAndloAccountinglnformation和一 个 JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION 结构的地址：
typedef Struct JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION { JOBOBJECT_BASIC_ACCOUNTING_INFORMATION Basiclnfo； lO^COUNTERS lolnfo;
} JOBOBJ ECT_BASIC_AND_IO^ACCOUNTING_INFORMATION, *PJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION;
可以看出，这个结构返回了 JOBOBJECT_BASIC_ACCOUNTING_INFORMATION 和一 个 IO_COUNTERS 结构：
typedef struct _IO_COUNTERS {
ULONGLONG ULONGLONG ULONGLONG ULONGLONG ULONGLONG
ReadOperationCount； WriteOperationCount； OtherOperat ionCount； ReadTrans ferCounc； WriteTransferCount；
I^^idows核心编程(第5版)
ULONGLONG OtherTransferCount；
} IO_COUNTERS, *PIO_COUNTERS;
这个结构指出已由作业中的进程执行过的读操作、写以及非读/写操作的次数(以及这些操作 期间传输的字节总数)。顺便说一句，对于那些不属于任何作业的进程，我们可以使用 GetProcessIoCounters函数来获得未放入作业的那些进程的信息，如下所示：
BOOL GetProcessIoCounters(
HANDLE hProcess, PIO_COUNTERS ploCounters);
任何时候都可以调用Query Information JobObject,获得作业中当前正在运行的所有 进程的进程ID集。为此，必须首先估算一下作业中有多少个进程，然后，分配一个 足够大的内存块来容纳由这些进程ID构成的一个数组，另加一个
JOBOBJECT_BASIC_PROCESS_ID_LIST 结构的大小：
typedef struct _JOBOBJECT_BASIC_PROCESS_ID_LIST {
DWORD NumberOfAssignedProcesses;
DWORD NumberOfProcessIdsInList;
DWORD ProcessIdList(1);
} JOBOBJECT_BAS IC_PROCESS_ID_LI ST, * P JOBOB JECT_BAS I C_PROCESS_I D_L I ST;
所以，为了获得作业中当前的进程ID集，必须执行以下类似的代码：
void EnumProcessIdsInJob(HANDLE hjob)(
// I assume that there will never be more
// than 10 processes in this job.
#define MAX_PROCESS_IDS 10
// Calculate the number of bytes needed for structure & process IDs.
DWORD cb = si zeof(JOBOBJECT_BASIC_PROCESS_ID_LIST) +
(MAX_PROCESS_IDS - 1) * sizeof(DWORD);
// Allocate the block of memory.
PJOBOBJECT_BASIC_PROCESS_ID_LIST pjobpil =
(PJOBOBJECT_BASIC_PROCESS_ID_LIST)_a11oca(cb);
// Tell the function the maximum number of processes
// that we allocated space for. pjobpil->NumberOfAssignedProcesses = MAX_PROCESS_IDS;
// Request the current set of process IDs.
QueryInformationJobObject(hjob, JobObjectBasicProcessIdList, pjobpil, cb, &cb);
// Enumerate the process IDs.
for (DWORD x = 0； x < pjobpil->NumberOfProcessIdsInList; x++) (
// Use pjobpil->ProcessIdList[x]...
}
// Since _alloca was used to allocate the memory,
//we don't need to free it here.
}
这就是使用这些函数所能获得的所有信息。但是，操作系统实际保存着与作业相关 的更多的信息。这是通过性能计数器来实现的，可以使用性能数据助手(Performance
Data Helper)函数库(PDH.dl 1)中的函数来获取这些信息。还可以使用管理工具中的 可靠性和性能监视器(Reliability and Performance Monitor)来查看作业信息。但是，
第5章作业
这样只能看到全局命名的作业对象。不过，利用Sysinternals的Process Explorer （http://www.microsoft.com/technet/sysintemals/ProcessesAndThreads/ProcessExplorer.mspx）, 可以很好地观察作业。默认情况下，作业限制下的所有进程都用棕色来突出显示。
这个软件一个更出色的设计是，对于作业的进程，其属性对话框的Job选项卡会列出作业 名称及其限额（如果有的话），如图5-2所示。
如39腺,
图5-2 Process Explorer的Job选项卡报告了详细的限制条件
警告 "User CPU Limit”显示有误，它的单位应该是ms,而不是s。但这很快会在 ProcessExplorer下一次更新的时候得以纠正。
5.4作业通知
现在，我们已经掌握了作业对象的基本知识，作业通知是最后要讨论的主题。例如，我们 很想知道作业中的所有进程在何时终止执行，或者所有已分配的CPU时间是否已经到期。 还想知道作业内部何时生成了一个新的进程，或者作业中的进程何时终止执行？如果不关 心这些通知（大多数应用程序其实对此并不关心），那么就像前面描述的那样使用作业吧。 如果关心这些事件通知，我们还需要多学一些东西。
如果只是关心所有已分配的CPU时间是否已经到期，那么可以非常简单地获得这个通 知。作业中的进程如果尚未用完已分配的CPU时间，作业对象就处于未触发状态的。一 旦作业用完所有已分配的CPU时间，Windows就会强行“杀死”作业中的所有进程并触 发作业对象。通过调用WaitForSingleObject（或者一个类似的函数），我们可以轻松捕捉
画dows核心编程（第5版）
到这个事件。顺便提一句，之后我们还可以把作业对象重置为未触发状态，只需调用 SetlnformationJobObject并授予作业更多的CPU时间即可。
我首次接触“作业”的时候，一度认为当作业对象中没有任何进程运行的时候，作业的状 态就应该是触发状态。毕竟，进程和线程对象会在停止运行时被触发，所以我认为，作业 也应该在它停止运行时被触发。这样一来，就可以轻松判断作业什么时候结束运行。但是, Microsoft选择在已分配的CPU时间到期时，才将作业的状态变成已触发，因为那意味着一 个错误条件（error cpndition）o在许多作业中，都会有一个父进程一直在运行，直至其所有子 进程全部结束。所以，我们可以只等待父进程的句柄，借此得知整个作业何时结束。在我 编写的StartRestrictedProcess函数中，展示了如何判断分配给作业的CPU时间何时到期， 或者作业中的父进程何时终止。
前面描述了如何获得一些简单的通知，但没有解释如何获得一些更“高级”的通知（比如进 程创建/终止运行）。要获得这些额外的通知，必须在自己的应用程序中建立更多的基础结构。 具体来讲，我们必须创建一个I/O完成端口（completion port）内核对象，并将我们的作业对 象与完成端口关联。然后，我们必须有一个或者多个线程等待作业通知到达完成端口，以 便对它们进行处理。
一旦创建了 I/O完成端口，就可以调用SetlnformationJobObject将它与一个作业关联起来， 如下所示：
JOBOBJECT_ASSOCIATE_COMPLETION_PORT joacp;
joacp.CompletionKey = 1； // Any value to uniquely identify this job
joacp.CompletionPort = hlOCP； // Handle of completion port that
// receives notifications
SetlnformationJobObject（hJob, JobObjectAssociateCompletionPortInformation,
&joacp, sizeof（jaocp））；
执行上述代码后，系统将监视作业，只要有事件发生，就会把它们投递到I/O完成端口（顺 便提一句，我们可以调用QuerylnformationJobObject来获取完成键和完成端口句柄，但 很少有必要这样做）。线程通过调用GetQueuedCompletionStatus来监视完成端口：
BOOL GetQueuedCompletionStatus（
HANDLE hlOCP,
PDWORD pNumBytesTransferred,
PULONG_PTR pCompletionKey, POVERLAPPED *pOverlapped, DWORD dwMilliseconds）；
当这个函数返回一个作业事件通知的时候，在pCompletionKey中，将包含完成键的值。 这个值是在调用SetlnformationJobObject将作业与完成端口关联时设置的。这样一来，我 们就可以知道哪个作业有事件发生。pNumBytesTransferred的值指出具体发生了什么事件 （参见表5.6）。根据事件的不同，pOverlapped的值所表示的数据类型也不同。在作业事件 通知中，它表示的是一个对应的进程ID（而不是地址）。
,4骸
第5章作业
表5书作业事件通知，系统可以将它们发送给与作业相关联的完成端口
事件	描述
JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO	作业中没有进程在运行时，就投递通知
JOB_OBJECT_MSG_END_OF_PROCESS_TIME	进程己分配的CPU时间到期时，就投递通知。进程 将终止运行，并给出进程ID
JOB_OBJECT_MSG_ACTIVE_PROCESS_LIMIT	试图超过作业中的活动进程数时，就投递通知
JOB_OBJECT_MSG_PROCESS_MEMORY_LIMIT	进程试图调拨的存储超过进程的限额时，就投递通 知。同时给出进程ID
JOB_OBJECT_MSG_JOB_MEMORY_LIMIT	进程调拨的存储超过作业的限额时，就投递通知。 同时给出进程ID
JOB_OBJECT_MSG_NEW_PROCESS	••个进程添加到一个作业时，就投递通知。同时给 出进程ID
JOB_OBJECT_MSG_EXIT_PROCESS	一个进程终止运行时，就投递通知。同时给出进程 ID
JOB_OBJECT_MSG_ABNORMAL_EXIT_PROCESS	一个进程由于未处理的异常而终止运行时，就投递 通知。同时给出进程ID
JOB_OBJECT_MSG_END_OFJOB_TIME	作业分配的CPU时间到期时，就投递通知。但其中 的进程不会自动终止。我们可以允许进程继续运行， 可以设置一个新的时间限额，还可以自己调用 TerminateJobObject
最后要注意的是，在默认情况下，作业对象是这样配置的：当分配作业的CPU时间到期时, 它的所有进程都会自动终止，而且不会投递JOB_OBJECT_MSG_END_OF_JOB_TIME 通知。如果想阻止作业对象“杀死”进程，只是简单地通知我们CPU时间到期，必须执行 以下类似代码：
// Create a JOBOBJECT_END_OF_JOB_TIME_INFORMATION structure
// and initialize its only member.
JOBOBJECT_END_OF_JOB_TIME_INFORMATION j oeojti;
joeojti.EndOfJobTimeAction = JOB_OBJECT_POST_AT_END_OF_JOB;
// Tell the job object what we want it to do when the job time is
// exceeded.
SetInformationJobObject(hJob, JobObjectEndOfJobTimelnformation,
&joeojti, sizeof(joeojti))；
针对 EndODobTimeAction 成员，唯一能指定的另一个值是 JOB_OBJECT_TERMINATE_ AT_END_OF_JOB,这是创建作业时的默认值。
列142融
Endows核心编程（第5版）
5.5	Job Lab示例程序
我们可以通过Job Lab应用程序（05-JobLab.exe）来轻松体验“作业”。此应用程序的源代码 和资源文件都在本书配套网页的05-JobLab目录中。启动该程序时，将出现如图5.3所示的 窗口。
Job Lab
Basic and Extended Limits
Per-pfoce« umm time frnit (m$): Mb workinfl set size (MB): Active process &nit Priofity class:
Max commit Imit for job (MB):
i Chid processes can breakaway from the job [J T erminate processes on unhanded exceptions
Pec-iob user lime fonit (ms):
Max working set size (MB):
Affinity ma$k (decimal)

Scheduling class:
Max commit limit per process (MB):
! Child processes do bred<away from the iob
I Preserve Job time when applying Smits

Restrict Ul access
i. i TooUside USER objects
! Reacfing from the clipboard
Writing to the clipboard
□ Exiting Windows
Q Changing system parametefs O To creating/switching desktops
L j To changing di$pl^> settings [.]To global atoms
图5・3 Job Lab示例程序
进程初始化时，它会创建一个作业对象。为便于我们使用“性能监视器” MMC管理单元 来查看它，并监视其性能，这个作业对象命名为JobLabo应用程序还创建了一个I/O完成 端口，并把作业对象与它关联。这样一来，就可以监视来自作业的通知，并在窗口底部的 列表框中显示。
最开始，作业中是没有进程的，也没有添加任何限额或限制。顶部的框用于设置作业对象 的基本限额和扩展限额。我们只需在文本框中输入有效的值，并单击Apply limits按钮。如 果有一个框留空不填，就不会应用那个限额。除了基本限额和扩展限额外，还可以打开和 关闭各种UI限制。注意，Preserve Job Time When Applying Limits复选框不是用来设置限 额的；它允许我们在查询基本统计信息的时候更改作业的限额，同时不必重置 ThisPeriodTotalUserTime 和 ThisPeriodTotalKemelTime 成员。如果应用了一个 “perjob time limit”，这个复选框会被禁用。利用其他按钮，我们可以以其他方式操纵作业。Terminate Processes按钮用于“杀死”作业中的所有进程。Spawn CMD In Job按钮用于生成一个与此 作业关联的CMD.exe（命令提示符）进程。在命令提示窗口中，我们可以生成更多的子进程,
第5章作业
并观察它们作为作业的一部分是如何工作的。出于实验性研究的目的，我认为这是一个非 常有用的设计。最后一个按钮是PutPID In Job,将将一个现有的、没有与任何作业关联的 进程与这个作业关联。
窗口底部的列表框用于显示最新的作业状态信息。每隔10秒，这个窗口就会显示基本信息 和I/O统计信息以及进程/作业的内存使用峰值。作业中的每个进程的进程ID和完整路径 名也会显示出来。
警告 我们 可能很想使用psapi.h中的函数(比如 GetModuleFileNameEx和 GetProcessImageFileName),以根据进程ID来获得进程的完整路径名称。但是, 当作业收到通知，得知一个新进程是在它的限制下创建时，前一个函数调用会失败。 因为在这个时候，地址空间尚未完全初始化：模块尚未与它建立映射。 GetProcessImageFileName则很有意思，因为即使在那种极端情况下，它也能获取完 整路径名。但是，路径名的格式近似于我们在内核模式(而不是用户模式)中看到的 格式。例如，是\Device\HarddiskVolume 1 \Windows\System32\notepad.exe,而不是 C:\Windows\System32\notepad.exe。 这就是我们应该依赖于新的 QueryFullProcessImageName函数的原因。该函数在任何情况下都会返回我们预期 的完整路径名。
除了所有这些统计信息，列表框还显示了从作业到应用程序I/O完成端口的所有通知。只 要有通知被发送到这个列表框，就会立即更新当时的状态信息。
最后提醒一句，如果我们修改源代码，并创建一个没有命名的作业内核对象，就可以在同 一台计算机上运行此应用程序的多个副本并创建两个甚至更多的作业对象，从而进行更 多的试验。
就源代码本身而言，这里没有任何特别的地方值得讨论，因为源代码中已经有很好的注释。 不过，我的确创建了一个Job.h文件，并在其中定义了一个CJob C++类，此类封装了操作 系统的作业对象。这样一来，我的编程就变得更简单了，因为不需要到处传递作业的句柄。 同时，这个类还减少了类型转换的工作量，因为在调用QuerylnformatiouJobObject和 SetlnformationJobObject函数时，这样的事情本来是不可避免的。
144
本章内容
、C
、、9
第6章线程基础

*
2、 ALT 海］
a
6.1
O
6.3
6.4
6.5
6.6
6.7
6.8
何时创建线程 何时不应该创建线程 编写第一个线程函数 CreateThread 函数 终止运行线程
线程内幕
C/C++运行库注意事项 了解自己的身份
理解线程是至关重要的，因为每个进程至少都有一个线程。在本章，我们将讲述线程更多 的细节。具体地说，我们将解释线程和进程有何区别，它们各自有何职责。同时，还要解 释系统如何使用线程内核对象来管理线程。就像进程内核对象一样，线程内核对象也拥有 属性，我们将探讨用于查询和更改这些属性的函数。此外，还要介绍可在进程中创建和生 成更多线程的函数。
在第4章，我们讨论了进程实际上有两个组成部分：一个进程内核对象和一个地址空间。 类似地，线程也有两个组成部分：
•	一个是线程的内核对象，操作系统用它管理线程。系统还用内核对象来存放线程统 计信息的地方。
•	一个线程栈，用于维护线程执行时所需的所有函数参数和局部变量。（在第16章中， 将详细讨论系统如何管理线程栈。）
第4章讲过，进程是有惰性的。进程从来不执行任何东西，它只是一个线程的容器。线程 必然是在某个进程的上下文中创建的，而且会在这个进程内部“终其一生”。这意味着线 程要在其进程的地址空间内执行代码和处理数据。所以，假如一个进程上下文中有两个以 上的线程运行，这些线程将共享同一个地址空间。这些线程可以执行同样的代码，可以处 理相同的数据。此外，这些线程还共享内核对象句柄，因为句柄表是针对每一个进程的， 而不是针对每一个线程。
叮以看出，相较于线程，进程所使用的系统资源更多。其原因在于地址空间。为一个进程 创建一个虚拟的地址空间需要大量系统资源。系统中会发生大量的记录活动，而这需要用 到大量内存。而且，由于.exe和.dll文件要加载到一个地址空间，所以还需要用到文件资源。 另一方面，线程使用的系统资源要少得多。事实上，线程只有一个内核对象和一个栈；几
第6章线程基础
乎不涉及记录活动，所以不需要占用多少内存。
由于线程需要的开销比进程少，所以建议你尽量使用额外的线程来解决编程问题，避免创 建新进程。但是，也不要把这个建议当作金科玉律。许多设计更适合用多个进程来实现。 应该知道如何权衡利弊，让经验来指导你进行编程。
在深入讨论线程之前，稍微花一点时间来讨论如何在应用程序的架构中正确地使用线程。
6.1何时创建线程
线程描述了进程内部的一条执行线路。每次初始化进程时，系统都会创建一个主线程。对 于用Microsoft C/C++编译器生成的应用程序，这个线程首先会执行C/C++运行库的启动代 码，后者调用入口点函数Ctmain ^_tWinMain）,并继续执行，直至入口点函数返回C/C++ 运行库的启动代码，后者最终将调ffl ExitProcesso对于许多应用程序来说，这个主线程是 应用程序唯一需要的线程。但是，进程也可以创建额外的线程来帮助它们完成自己的工作。
每个计算机都有一个特别强大的资源：CPUo让CPU闲着是没有任何道理的（假设我们不 考虑省电和散热问题）。为了让CPU保持“忙碌”，我们可以让它执行各种各样的任务。 下面列举了其中的少数几个例子。
• 操作系统的Windows Indexing Services（Windows索引服务）创建了一个低优先级的 线程，此线程定期醒来，并对硬盘上的特定区域的文件内容进行索引。Windows索 引服务极大改进了性能，因为一旦成功建立索引，就不必在每次搜索时都打开、扫 描和关闭硬盘上的每一个文件。配合这种索引服务，Microsoft Windows Vista提供 了一套高级的搜索功能。可以通过两种方式寻找文件。第--种方式是单击“开始” 按钮，在底部的搜索框中输入。在左侧的列表中，将根据索引显示与输入的文本匹 配的程序、文件和文件夹。如下图所示。
146
Vindows核心编程（第5版）
一. ■ 一.， 一 .
第二种方式是打开“搜索”窗口（右击“开始”按钮，从弹出菜单中选择“搜索”）。 然后，请在“搜索”文本框中输入搜索条件。只有选择了 “Location”组合框中的 "Indexed Locations" （ii是默认设置），才会在索引位置中搜索，如下图所示。
• 可以使用操作系统附带的磁盘碎片整理程序。通常，这类实用程序有许多普通用户 无法理解的管理选项，比如程序多久运行一次，在什么时间运行等等。如果使用低 优先级的线程，可以在系统空闲的时候，在后台运行这个实用程序并进行磁盘碎片 整理。
•	只要暂停输入，Microsoft Visual Studio IDE 就会自动编译 C#和 Microsoft Visual Basic .NET源代码文件。在编辑窗口中，无效的表达式将用下划线标识，鼠标滑过 这些表达式时，会显示相应的警告和错误信息。
•	电子表格软件可以在后台执行重新计算。
•	字处理软件可以在后台重新分页、拼写检查、语法检查以及打印。
•	文件可以在后台复制到其他存储介质。
•	Web浏览器可以在后台与其服务器进行通信。在当前网站的结果显示出来之前，用 户可以调整浏览器窗口的大小，或者转到其他网站。
对于这些例子，应该注意一个重点，即多线程简化了应用程序的用户界面的设计。例如， 如果你一结束输入，编译器就能开始生成应用程序，是不是就不必提供Build（生成）菜单项 了呢？又例如，既然始终能在后台执行拼写检查和语法检查，字处理器应用程序是不是就 不必提供相应的菜单项了呢？
在Web浏览器的例子中，由于使用了一个单独的线程来处理输入和输出（可能是网络、文 件或其他方面的输入和输出），所以应用程序的用户界面可以一直保持可响应的状态。来设 想这样的一个应用程序，它用于对数据库的记录进行排序，打印文档，或者复制文件。通 过为这种严重依赖于输入/输出的任务使用一个单独的线程，当操作进行时，用户可以随时 通过应用程序的界面来取消操作。
将一个应用程序设计成多线程的，可以使该应用程序更易于扩展。如下一章所述，每个线 程都被分配了一个CPU。所以，如果我计算机有两个CPU,而且应用程序有两个线程，那
第6章线程基础
么两个CPU都会很忙。其结果就是，只需花一个任务的时间，两个任务都可以完成。
因为每个进程内部至少有一个线程，所以即使我们不在应用程序中进行特殊处理，也能从 多线程操作系统获益。例如，可以同时生成应用程序和使用字处理软件（我经常这样做）。 如果计算机有两个CPU,那么生成过程将在一个处理器上进行，另一个处理器则负责处理 文档。换言之，用户感觉不到性能有所下降，而且在他进行输入的时候，用户界面也不会 无法响应。此外，如果编译器的一个缺陷导致其线程进入无限循环，其他进程仍可运行。 （16位Windows和MS-DOS应用程序并非如此。）
6.2何时不应该创建线程
到目前为止，我一直在为多线程应用程序高唱赞歌。尽管多线程应用程序好处多多，但仍 有一些不足之处。有些开发人员认为，任何问题都可以通过把它分解成线程来解决。但是, 这样想是大错特错的！
线程相当有用，而且占有重要地位，但在使用线程时，可能会在尝试解决旧问题时产生新 问题。例如，假定现在要开发一个字处理程序，并目.希望允许打印函数在它自己的线程中 运行。这听起来不错，因为只要开始打印文档，用户就可以立即返回并开始编辑文档。但 是，这意味着在打印文档期间，文档中的数据町能己经发生了改变。那么，也许最好的办 法是不让打印函数在自己的线程中运行？但这个“解决方案”似乎又有点儿极端了。假如 让用户编辑另一个文档但锁定正在打印的文档，使其在打印完成之后再进行修改，又如何 呢？或者说还有第三个办法：将文档复制到一个临时文件中，打印临时文件的内容，并允 许用户修改原件。临时文件打印完成后，删除临时文件。
由此可见，线程能解决一些问题，但又会产生新的问题。另一种常见的对线程的误用发生 在开发应用程序的用户界面时。在几乎所有应用程序中，所有用户界面组件（窗口）都应该 共享同一个线程。一个窗口的所有子窗口无疑应该由一个线程来创建。有时，也许需要在 不同的线程上创建不同的窗口，但这类情形相当少见。
通常，应用程序应该有一个用户界面线程，此线程负责创建所有窗口，另外还有一个 GetMessage循环。进程中的其他所有线程都是受计算能力的制约或者受1/0（输出/输出）限 制的工作线程，这些线程永远不会创建窗口。另外，用户界面线程的优先级通常高于工作 线程。这样一来，用户界面才能迅速响应用户的操作。
尽管很少需要在一个进程中包含多个用户界面线程，但有时确实需要这样做。例如， Windows资源管理器就为每个文件夹的窗口创建了一个独立的线程。这样一来，就口『以把 文件从一个文件夹复制到另一个文件夹，同时仍然可以查看系统上的其他文件夹。另外， 如果Windows资源管理器出现一个缺陷，正在操纵一个文件夹的线程就可能崩溃，但我们 仍然可以操纵其他文件夹一一除非我们做什么错事导致其他计算机也崩溃。
总之，上述例子的寓意是我们应该合理使用多线程。不要因为能用就盲目地用。即使只使
[Windows核心编程（第5版）
用进程的主线程，也能写出许多有用而且功能强大的应用程序。
6.3编写第一个线程函数
每个线程都必须有一个入口点函数，这是线程执行的起点。前面已讨论过主线程的入口点 函数：_tmain或_tWinMain。如果想在进程中创建辅助线程，它必须有自己的入口点函数, 形式如下：
DWORD WINAPI ThreadFunc（PVOID pvParam）（
DWORD dwResult = 0;
return(dwResult); }
线程函数可以执行我们希望它执行的任何任务。最终，线程函数将终止运行并返回。此时, 线程将终止运行，用于线程栈的内存也会被释放，线程内核对象的使用计数也会递减。如 果使用计数变成0,线程内核对象会被销毁。类似于进程内核对象，线程内核对象的寿命 至少可以达到它们相关联的线程那样长。不过，对象的寿命可能超过线程本身的寿命。
149
关于线程函数，要注意以下几点。
在默认情况下，主线程的入口点函数必须命名为main, wmain, WinMain或 wWinMain（除非我们用/ENTRY:链接器选项来指定另一个函数作为入口点函数）。
与此不同的是，线程函数可以任意命名。事实上，如果应用程序中有多个线程函数, 必须为它们指定不同的名称，否则编译器/链接器会认为你创建了一个函数的多个 实现。
因为主线程的入口点函数有字符串参数，所以它提供了 ANSI/Unicode版本供我们 选择：main/wmain和WinMain/wWinMain。相反，线程函数只有一个参数，而且 其意义由我们（而非操作系统）来定义。因此，我们不必担心ANSI/Unicode问题。
线程函数必须返回一个值，它会成为该线程的退出代码。这类似于C/C++运行库的 策略：令主线程的退出代码成为进程的退出代码。
线程函数（实际包括所有函数）应该尽可能使用函数参数和局部变量。使用静态变量 和全局变量时，多个线程可以同时访问这些变量，这样可能会破坏变量中保存的内 容。然而，由于函数的参数和局部变量是在线程栈上创建的。因此，不太可能被其 他线程破坏。
在知道了如何实现线程函数之后，下面要讨论如何让操作系统实际创建一个线程来执行我 们的线程函数。
6.4 CreateThread 函数
我们已经讨论了在调用CreateProcess时，进程的主线程是如何从无到有的。如果想创建一 个或多个辅助线程，只需让一个正在运行的线程调用CreateThread：
第6章线程基础
HANDLE CreateThread（
PSECURITY_ATTRIBUTES psa,
DWORD cbStackSize,
PTHREAD_START_ROUTINE pfnStartAddr,
PVOID pvParam,
DWORD dwCreateFlags,
PDWORD pdwThreadID）;
调用CreateThread时，系统会创建一个线程内核对象。这个线程内核对象不是线程本身， 而是一个较小的数据结构，操作系统用这个结构来管理线程。可以把线程内核对象想象为 一个由线程统计信息构成的小型数据结构。这与进程和进程内核对象之间的关系是相同的。
系统从进程的地址空间中分配内存给线程栈使用。新线程在与负责创建的那个线程在相同 的进程上下文中运行。因此，新线程可以访问进程内核对象的所有句柄、进程中的所有内 存以及同一个进程中其他所有线程的栈。这样一来，同一个进程中的多个线程可以很容易 地互相通信。
说明 CreateThread函数是用于创建线程的Windows函数。不过，如果写的是C/C++代 码，就绝对不要调用CreateThread。相反，正确的选择是使用Microsoft C++运行库 函M_beginthreadexo如果使用的不是Microsoft C++编译器，你的编译器的提供商 应该提供类似的函数来替代CreateThread.不管这个替代函数是什么，都必须使用 它。本章稍后将解释 beginthreadex函数的用途及其重要性。
0K,大致情况就介绍到这里，下面将详细解释CreateThread的每一个参数。
6.4.1	psa 参数
psa参数是一个指向SECURITV_ATTRIBUTES结构的指针。如果想使用线程内核对象的 默认安全属性，可以向此参数传入NULL（一般都会这样做）。如果希望所有子进程都能继 承到这个线程对象的句柄，必须指定一个SECURITY_ATTRIBUTES结构，并将该结构的 blnheritHandle成员初始化为TRUE。详情参见第3章。
6.4.2	cbStackSize 参数
cbStackSize参数指定线程可以为其线程栈使用多少地址空间。每个线程都拥有自己的栈。 当CreateProcess函数开始一个进程的时候，它会在内部调用CreateThread来初始化进程 的主线程。对于cbStackSize参数，CreateProcess使用了保存在可执行文件内部的一个值。 可以使用链接器的/STACK开关来控制这个值，如下所示：
/STACK:[reserve] [,commit]
reserve参数用于设置系统将为线程栈预留多少地址空间，默认是1 MB（在Itanium芯片组 上，默认大小为4MB）O commit参数指定最初应为栈预留的地址空间区域调拨多少物理存
mdows核心编程（第5版）
储空间，默认是1个页面。随着线程中的代码开始执行，需要的存储空间可能不止1个页 面。如果线程溢出它的栈，会产生异常。（有关线程栈和栈溢出异常的详情，请参见第16 章。有关常见异常处理的详情，请参见第23章。）系统将捕获这种异常，并为已预订的空 间区域调拨另一个页面（或者在commit参数中指定的任何大小）。这样一来，线程栈就可以 根据需要动态地增大。
调用CreateThread时，如果传入非0值，函数会为线程栈预订空间并为之调拨所需的所有 存储空间。由于所有存储器都已经事先调拨完毕，所以可以保证线程有指定的栈存储器可 用。预订空间的大小要么由/STACK链接器开关来指定，要么由cbStackSize的值来指定, 取其中较大的那一个。调拨的存储空间大小与传递的csStack Size参数值匹配。如果为 cbStack Size参数传入0值，CreateThread函数就会预订一个区域，并根据由/STACK链接 器开关指定的存储量（这个值由链接器嵌入.exe文件中）来调拨存储器。
预订的地址空间的容量设定了栈空间的上限，这样才能捕获代码中的无穷递归bug。例如， 假设写一个函数以递归方式调用其自身。而且这个函数存在一个bug,会导致无穷递归。 每次此函数调用自身时，都会在内存栈上创建一个新的栈帧。如果系统没有设定栈空间的 上限，这个递归调用的函数就永远不会终止调用自身。系统会将进程的所有地址空间分配 殆尽，并为线程栈调拨大量物理存储。通过设置栈空间的上限，不仅可以防止应用程序耗 尽物理内存区域，而旦还可以尽早察觉程序中的bug（第16章的Summation示例程序展示 了如何捕获和处理栈溢出）。
151-152
6.4.3	pfnStartAddr 和 pvParam 参数
pfnStartAddr参数指定希望新线程执行的线程函数的地址。线程函数的pvParam参数与最 初传给CreateThread函数的pvParam参数是一样的。CreateThread不用这个参数做别的 事情，只是在线程开始执行时将其传给线程函数。通过这个参数，可以将一个初始值传给 线程函数。这个初始值可以是一个数值，也可以是指向一个数据结构（其中包含额外的信息） 的指针。
创建多个线程时，可以让它们使用同一个函数地址作为起点。这样做完全合法，而且非常 有用。例如，我们可以这样实现一个Web服务器，令其为每个客户端请求创建一个新的线 程，并分别对各个请求进行处理。每个线程都知道自己正在处理哪个客户端的请求，因为 在创建每个线程的时候，都向其传递了不同的pvParam值。
记住，Windows是一个抢占式的多线程系统（preemptive multithreading system）o这意味着新 的线程和调用CreateThread函数的线程可以同时执行。因为两个线程是同时运行的，所以 可能出现问题。下面来观察如下所示的代码：
DWORD WINAPI FirstThread（PVOID pvParam） （
// Initialize a stack-based variable
int x = 0；
第6章线程基础
DWORD dwThreadID；
// Create a new thread.
HANDLE hThread = CreateThread(NULL, 0, SecondThread, (PVOID) &x,
0, &dwThreadID)；
//We don't reference the // so close our handle to CloseHandle(hThread);
new thread anymore, it.
// Our thread is done.
// BUG： our stack will be destroyed, but
// SecondThread might try to access it. return(0);
)
DWORD WINAPI SecondThread(PVOID pvParam) (
// Do some lengthy processing here.
// Attempt to access the variable on FirstThread,s stack.
// NOTE: This may cause an access violation - it depends on timing!
* ((int *) pvParam) = 5； ... return(0);
)
<152
在上述代码中，FirstThread 口J能会在SecondThread函数将5赋给FirstThread函数的x 之前完成任务。如果发生这种情况，SecondThread不知道FirstThread己经不存在了，所 以会试图更改现已无效的一个地址的内容。这会导致SecondThread产生访问违规，因为 FirstThread的栈已在FirstThread终止运行的时候被销毁。解决这个问题的一种方法是将 x声明为一个静态变量，使编译器能在应用程序的数据section（而不是线程栈）中为x创建一 个存储区域。
但是，这会使函数不可重入。换言之，不能创建两个线程来执行同一个函数，因为这两个 线程将共享同一个静态变量。为了解决这个问题（以及它的其他更复杂的变化形式），另一 个办法是使用正确的线程同步技术（详情参见第8章和第9章）。
6.4.4	dwCreateFlags
dwCreateFlags参数指定额外的标志来控制线程的创建。它可以是两个值之一。如果值为0, 线程创建之后立即就可以进行调度。如果值为CREATE_SUSPENDED,系统将创建并初 始化线程，但是会暂停该线程的运行，这样它就无法进行调度。
在线程有机会执行执行任何代码之前，应用程序可以利用CREATE_SUSPENDED标志来 更改线程的一些属性。由于很少有必要这样做，所以该标志并不常用。5.6节的Job Lab应 用程序演示了该标志的正确用法。
6.4.5	pdwThreadID
CreateThread函数的最后一个参数是pdwThreadID,它必须是DWORD的一个有效地址。
CreateThread函数用它来存储系统分配给新线程的ID（进程和线程ID的详情参见第4章）。
匝dows核心编程（第5版）
可以为这个参数传递NULL（一般都是这样做的），它告诉函数我们对线程ID没有兴趣。
6.5终止运行线程
线程可以通过以下4种方法来终止运行。
•	线程函数返回（这是强烈推荐的）。
•	线程通过调用ExitThread函数“杀死”自己（要避免使用这种方法）。
•	同一个进程或另一个进程中的线程调用TerminateThread函数（要避免使用这种 方法）。
•	包含线程的进程终止运行（这种方法避免使用）。
下面将讨论终止线程运行的这4种方法，并描述线程终止运行时会有哪些情况发生。
6.5.1线程函数返回
设计线程函数时，应该确保在我们希望线程终止运行时，就让它们返回。这是保证线程的 所有资源都被正确清理的唯一方式。
让线程函数返回，可以确保以下正确的应用程序清理工作都得以执行。
•	线程函数中创建的所有C++对象都通过其析构函数被正确销毁。
•	操作系统正确释放线程栈使用的内存。
•	操作系统把线程的退出代码（在线程的内核对象中维护）设为线程函数的返回值。
•	系统递减少线程的内核对象的使用计数。
6.5.2	ExitThread 函数
为了强迫线程终止运行，可以让它调用ExitThread：
VOID ExitThread（DWORD dwExitCode）;
该函数将终止线程的运行，并导致操作系统清理该线程使用的所有操作系统资源。但是， 你的C/C++资源（如C++类对象）不会被销毁。有■鉴于此，更好的做法是直接从线程函数返 回，不要自己调用ExitThread函数（详情参见4.3.2节uExitProcess函数"）。
当然，可以使用ExitThread的dwExitCode参数来告诉系统将线程的退出代码设为什么。 ExitThread函数没有返回值，因为线程已终止，而且不能执行更多的代码。
说明 终止线程运行的推荐方法是让它的线.程函数返回（如上一节所述）.但是，如果使用 本节描述的方法，务必注意ExitThread函数是用于“杀死”线程的Windows函数。 如果要写C/C++代码，就绝对不要调用ExitThread。相反，应该使用C++运行库函
第6章线程基础
数_endthreadex。如果使用的不是Microsoft的C+4■编译器，那么编译器供应商应该 提供它们自己的ExitThread替代函数。不管这个替代函数是什么，都必须使用它。 本章稍后将具体解#endthreadex的用途及其重要性。
6.5.3	TerminateThread 函数
调用TerminateThread函数也可以“杀死” 一个线程，如下所示：
BOOL TerminateThread(
HANDLE hThread,
DWORD dwExitCode);
■
不同于ExitThread总是“杀死”主调线程(calling thread), TerminateThread能“杀死”任 何线程。hThread参数标识了要终止的那个线程的句柄。线程终止运行时，其退出代码将 变成你作为dwExitCode参数传递的值。同时，线程的内核对象的使用计数会递减。
说明 TerminateThread函数是异步的。也就是说，它告诉系统你想终止线程，但在函数返 回时，并不保证线程已经终止了。如果需要确定线程已终止运行，还需要调用 WaitForSingleObject(详情参见第9章)或类似的函数，并向其传递线程的句柄。
一个设计良好的应用程序决不会使用这个函数，因为被终止运行的线程收不到它被“杀死” 的通知。线程无法正确清理，而且不能阻止自己被终止运行。
说明 如果通过返回或调用ExitThread函数的方式来终止一个线程的运行，该线程的堆栈 也会被销毁。但是，如果使用的是TerminateThread,那么除非拥有此线程的进程终 止运行，否则系统不会销毁这个线程的堆栈。Microsoft故意以这种方式来实现 TerminateThreado否则，假如其他还在运行的线程要引用被“杀死/的那个线程 的堆栈上的值，就会引起访问违规。让被“杀死”的线程的堆栈保留在内存中，其 他的线程就可以继续正常运行。
此外，动态链接库(dynamic-link library, DLL)通常会在线程终止运行时收到通知。 不过，如果线程是用TerminateThread强行“杀死”的，则DLL不会收到这个通 知，其结果是不能执行正常的清理工作(详情请参见第20章)。
6.5.4进程终止运行时
第4章介绍的两个函数ExitProcess和TerminateProcess也可用于终止线程的运行。区别 在于，这些函数会使终止运行的进程中的所有线程全部终止。同时，由于整个进程都会关 闭，所以它所使用的所有资源肯定都会被清理。其中必然包括所有线程的堆栈。这两个函 数会导致进程中剩余的所有线程被强行“杀死”，这就好像是我们为剩余的每个线程都调 用了 TerminateThreado显然，这意味着正确的应用程序清理工作不会执行：C++对象的
I^^dows核心编程(第5版)	.
析构函数不会被调用，数据不会回写到磁盘……正如我在本章开始就解释的一样，当应用 程序的入口点函数返回时，C/C+运行库的启动代码将调用ExitProcesSo因此，如果应用程 序中并发运行着多个线程，需要在主线程返回之前，明确处理好每个线程的终止过程。否 贝U，其他所有正在运行的线程都会在毫无预警的前提下突然“死亡” o
6.5.5线程终止运行时
线程终止运行时，会发生下面这些事情。
•	线程拥有的所有用户对象句柄会被释放。在Windows中，大多数对象都是由包含了
“创建这些对象的线程”的进程拥有的。但一个线程有两个用户对象：窗□ (window) 和挂钩(hook)o 一个线程终止运行时，系统会自动销毁由线程创建或安装的任何窗 口，并卸载由线程创建或安装的任何挂钩。其他对象只有在拥有线程的进程终止时 才被销毁。
•	线程的退出代码从S1ILL_ACTIVE变成传给ExitThread或TerminateThread的 代码。
•	线程内核对象的状态变为触发状态。
•	如果线程是进程中的最后一个活动线程，系统认为进程也终止了。
•	线程内核对象的使用计数递减lo
线程终止运行时，其关联的线程对象不会自动释放，除非对这个对象的所有未结束的引用 都被关闭了。
一旦线程不再运行，系统中就没有别的线程再用该线程的句柄了。但是，其他线程可以调 用GetExitCodeThread来检查hThread所标识的那个线程是否已终止运行；如果已终止运 行，可判断其退出代码是什么：
BOOL GetExitCodeThread(
HANDLE hThread, PDWORD pdwExitCode);
退出代码的值通过pdwExitCode指向的DWORD来返回。如果在调用GetExitCodeThread 时，线程尚未终止，函数就用STILL_ACTIVE标识符(被定义为0x103)来填充DWORD。
如果函数调用成功，就返回TRUE(要想进一步了解如何使用线程的句柄来判断线程是在什 么时候终止运行的，请参见第9章)。
6.6“线程内幕
前面解释了如何实现一个线程函数，以及如何让系统创建一个线程来执行此线程函数。在 本小节，我们要研究系统具体是如何实现这一点的。图6-1展示了系统是通过哪些必不可 少的步骤来创建和初始化一个线程的。
第6章线程基础
线程内核对象
上下文
其他特性和 统计信息
Exit code = STILL ACTIVE
Signaled = FALSE
线程栈
高位地址
低位地址
VOID RtlUserThreadStart(・・・)(
• • •
}
图6-1如何创建和初始化一个线程
156
仔细看看这幅图，了解究竟发生了什么。对CreateThread函数的一个调用导致系统创建一 个线程内核对象。该对象最初的使用计数为2。（除非线程终止，而且从CreateThread返回 的句柄关闭，否则线程内核对象不会被销毁。）该线程内核对象的其他属性也被初始化：暂 停计数被设为1,退出代码被设为STILL_ACTIVE （0x103）,而且对象被设为未触发状态 状态。
一旦创建了内核对象，系统就分配内存，供线程的堆栈使用。此内存是从进程的地址空间 内分配的，因为线程没有自己的地址空间。然后，系统将两个值写入新线程堆栈的最上端。 （线程堆栈始终是从高位内存地址向低位内存地址构建的。）写入线程堆栈的第一个值是传 给CreateThread函数的pvParam参数的值。紧接在它下方的是传给CreateThread函数的 pfnStartAddr 值。
每个线程都有其自己的一组CPU寄存器，称为线程的上下文（context）o ±下文反映了当线 程上一次执行时，线程的CPU寄存器的状态。线程的CPU寄存器全部保存在一个 CONTEXT结构（在WinNT.h头文件中定义）oCONTEXT结构本身保存在线程内核对象中。
指令指针寄存器和栈指针寄存器是线程上下文中最重要的两个寄存器。记住，线程始终在 进程的上下文中运行。所以，这两个地址标识的内存都位于线程所在进程的地址空间中。
当线程的内核对象被初始化的时候，CONTEXT结构的堆栈指针寄存器被设为 pfnStartAddr在线程堆栈中的地址。而指令指针寄存器被设为RtlUserThreadStart函数（该 函数未见于正式文档）的地址，此函数是NTDLL.dll模块导出的。图6・1对此进行了演示。
RtlUserThreadStart函数执行的操作基本如下：
VOID RtlUserThreadStart(PTHREAD_START_ROUTINE pfnStartAddr, PVOID pvParam) (
_try {
ExitThread((pfnStartAddr)(pvParam))；
)

Vindows核心编程(第5版)
_except(UnhandledExceptionFiIter(GetExceptioninformation())) ( ExitProcess(GetExceptionCode());
}
// NOTE： We never get here.
线程完全初始化好之后，系统将检查CREATE_SUSPENDED标志是否已被传给 CreateThread函数。如果此标记没有传递，系统将如的挂起计数递减至0；随后，线程 就可以调度给一个处理器去执行。然后，系统在实际的CPU寄存器中加载上一次在线程上 下文中保存的值。现在，线程可以在其进程的地址空间中执行代码并处理数据了。
因为新线程的指令指针被设为RtlUserThreadStart,所以这个函数实际就是线程开始执行 的地方。观察RtlUserThreadStart的原型，你会以为它接收了两个参数，但这就暗示着该 函数是从另一个函数调用的，而实情并非如此。新线程只是在此处产生并且开始执行。之 所以能能访问这两个参数，是由于操作系统将值显式地写入线程堆栈(参数通常就是这样传 给函数的)。注意，有的CPU构架使用CPU寄存器而不是堆栈来传递参数。对于这种架构, 系统会在允许线程执行RtlUserThreadStart函数之前正确初始化恰当的寄存器。
新线程执行RtlUserThreadStart函数的时候，将发生以下事情。
•	围绕线程函数，会设置一个结构化异常处理(Structured Exception Handling, SEH) 帧。这样一来，线程执行期间所产生的任何异常都能得到系统的默认处理。(有关 结构化异常处理的详情，请参见第23章、第24章和第25章)。
•	系统调用线程函数，把传给CreateThread函数的pvParam参数传给它。
•	线程函数返回时，RtlUserThreadStart调用ExitThread,将你的线程函数的返回值 传给它。线程内核对象的使用计数递减，而后线程停止执行。
•	如果线程产生了一个未被处理的异常，RtlUserThreadStart函数所设置的SEH帧 会处理这个异常。通常，这意味着系统会向用户显示一个消息框，而且当用户关闭 此消息框时，RtlUserThreadStart会调用ExitProcess来终止整个进程，而不只是 终止有问题的线程。
注意，在RtlUserThreadStart内，线程会调用ExitThread或者ExitProcesso这意味着线 程永远不能退出此函数；它始终在其内部“消亡”。这就是为什么RtlUserThreadStart函 数原型的返回类型VOID的原因，因为它永远都不会返回。
此外，因为有了 RtlUserThreadStart函数，所以线程函数可以在完成它的工作之后返回。 当RtlUserThreadStart调用你的线程函数时，它会将线程函数的返回地址压入堆栈，使线 程函数知道应在何处返回。但是，RtlUserThreadStart函数是不允许返回的。如果它没有 在强行“杀死”线程的前提下尝试返回，几乎肯定会引起访问违规，因为线程堆栈上没有 函数返回地址，RtlUserThreadStart将尝试返回某个随机的内存位置。
一个进程的主线程初始化时，其指令指针会被设为同一个未文档化的函数 RtlUserThreadStart o
当RtlUserThreadStart开始执行时，它会调用C/C++运行库的启动代码，后者初始化继而 调用你的Jmain ^_tWinMain函数。你的入口点函数返回时，C/C++运行时启动代码会调
第6章线程基础
用ExitProcesso所以对于C/C++应用程序来说，主线程永远不会返回到RtlUserThreadStart 函数。
158
6.7	C/C++运行库注意事项
Visual Studio附带了 4个C/C++运行库用于本机代码的开发，还有2个库面向Microsoft .NET 的托管环境。注意，所有这些库都支持多线程开发：不再有•单独的一个C/C++库专门针对 单线程开发。表6.1对这些库进行了描述。
表 6-1 Microsoft Visual Studio 附带的 C/C++库
库名称	描述
LibCMLlib	库的静态链接发行版本
LibCMtD.lib	库的静态链接调试版木
MSVCRtlib	导入库，用于动态链接MSVCR80.dll库的发行版本（这是新建项目时的默认库）
MSVCRtD.lib	导入库，用于动态链接MSVCR80D.dll库的调试版本
MSVCMRt.lib	导入库，用于托管/本机代码混合
MSVCURt.lib	导入库，编洋成百分之百的纯MSIL代码
实现任何类型的项目时，都必须先知道这个项目要链接哪个库。可以通过如下图所示的项 目属性对话框来选择库。打开 Configuration Properties | C/C++ | Code Generationo 在 Runtime Library类别中，从Use Run-Time Library组合框中选择这4个可用的选项之一。
159
让我们简单回顾一下历史。很早以前，是一个库用于单线程应用程序，另一个库用于多线
indows核心编程(第5版)
程应用程序。之所以采用这个设计，是由于标准C运行库是在1970年左右发明的，这比 任何一个操作系统提供对线程的支持都还要早得多。要在很久很久之后，才会在操作系统 上出现线程的概念。标准c运行库的发明者根本没寺•考虑到为多线程应用程序使用C运行 库的问题。让我们用一个例子来了解可能遇到的问题。
以标准C运行库的全局变量errn。为例。有的函数会在出错时设置该变量。假定现在有这 样的一个代码段：
BOOL fFailure = (system("NOTEPAD.EXE README.TXT") == -1);
if (fFailure) (
switch (errno) (
case E2BIG： // Argument list or environment too big
break;
case ENOENT: // Command interpreter cannot be found
break；
case ENOEXEC: // Command interpreter has bad format
break;
case ENOMEM: // Insufficient memory to run command
break；
}
)
假设在调用了 system函数之后，并在执行if语句之前，执行上述代码的线程被中断了。另 外还假设，这个线程被中断后，同一个进程中的另一个线程开始执行，而且这个新线程将 执行另一个C运行库函数，后者设置了全局变量errnoo当CPU后来被分配回第一个线程 时，对于上述代码中的system函数调用，errno反映的就不再是正确的错误码。为了解决 这个问题，每个线程都需要它自己的ernw变量。此外，必须有某种机制能够让一个线程 引用它自己的errno变量，同时不能让它去修改另一个线程的errno变量。
这仅仅是证明了 “标准C/C++运行库最初不是为多线程应用程序而设计”的众多例子中的 一个。在多线程环境中会出问题的C/C_h■运行库变量和函数有errno, _doserrno, strtok,
_wcstok, strerror, strerror, tmpnam, tmpfile* asctime» _wasctime, gmthne, ecvt 和_fcvt等。
为了保证C和C++多线程应用程序正常运行，必须创建一个数据结构，并使之与使用了 C/C++运行库函数的每个线程关联。然后，在调用C/C廿运行库函数时，那些函数必须知 道去查找主调线程的数据块，从而避免影响到其他线程。
那么，系统在创建新的线程时，是如何知道要分配这个数据块的呢？答案是它并不知道。 系统并不知道应用程序是用C/C++来写的，不知道你调用的函数并非天生就是线程安全的。 保证线程安全是程序员的责任。创建新线程时，一定不要调用操作系统的CreateThread函 数。相反，必须调用C/C++运行库函＞__beginthreadeX：
unsigned long _beginthreadex(
void *security,
unsigned stack_size,
unsigned (*start_address)(void *),
void *arglist,
第6章线程基础
unsigned initflag, unsigned *thrdaddr)；
/ 160-161 '
_beginthreadex函数的参数列表与CreateThread函数的一样，但是参数名称和类型并不完 全一样。这是因为Microsoft的C/C++运行库开发组认为，C/C++运行库函数不应该对 Windows数据类型有任何依赖。_beginthreadex函数也会返回新建线程的句柄，就像 CreateThread那样。所以，如果已经在自己的源代码中调用了 CreateThread函数，可以 非常方便地用_beginthreadex来全局替换所有CreateThread。但是，由于数据类型并不完 相同，所以可能还必须执行一些类型转换，以便顺利地通过编译。为了简化这个工作，我 创建了一个名为chBEGINTHREADEX的宏，并在自己的源代码中使用：
typedef unsigned (_stdcall *PTHREAD_START) (void *);
#define chBEGINTHREADEX(psa, cbStack, pfnStartAddr,	\
pvParam, fdwCreate, pdwThreadID)	\
((HANDLE) _beginthreadex(	\
(void *) (psa),	\
(unsigned) (cbStackSize),	\
(PTHREAD_START) (pfnStartAddr),	\
(void *) (pvParam),	\
(unsigned) (dwCreateFlags),	\
(unsigned *) (pdwThreadID)))
因为Microsoft为C/C++运行库提供了源代码，所以我们很容易看出_beginthreadex到底做 了哪些CreateThread不能做的事情。事实上，在搜索了 Visual Studio安装文件夹后，我在 Program Files\Microsoft Visual Studio 8\VC\crt\src\Threadex.c 中找到了_beginthreadex 的源 代码。为节省篇幅，这里没有全部照抄一遍。相反，我在这里提供了该函数的伪代码版本, 强调了其中最有意思的地方：
uintptr_t _cdecl _beginthreadex (
void *psa,
unsigned cbStackSize,
unsigned (_stdcall * pfnStartAddr) (void *), void * pvParam,
unsigned dwCreateFlags, unsigned *pdwThreadID) (
_ptiddata ptd；	// Pointer to thread's data block
uintptr_t thdl；	// Thread's handle
// Allocate data block for the new thread.
if ((ptd = (_ptiddata)_calloc_crt(1, sizeof(struct _tiddata))) == NULL)
goto error_return；
// Initialize the data block, initptd(ptd)；	.
// Save the desired thread function and the parameter
//we want it to get in the data block. ptd->_initaddr = (void *) pfnStartAddr； ptd->_initarg = pvParam； ptd->_thandle = (uintptr_t)(-1);
// Create the new thread.
thdl = (uintptr_t) CreateThread((LPSECURITY_ATTRIBUTES)psa, cbStackSize, _threadstartex, (PVOID) ptd, dwCreateFlagsz pdwThreadID)；
if (thdl == 0) (
// Thread couldn1t be created, cleanup and return failure.
goto error_return；
indows核心编程（第5版）
)
// Thread created OK, return the handle as unsigned long, return(thdl);
error_return：
// Error： data block or thread couldn't be created.
// GetLastError() is mapped into errno corresponding values // if something wrong happened in CreateThread.
_free_crt(ptd);
return((uintptr_t)OL);
)
161-162
对于_beginthreadex函数，需要重点关注以卜•几点。
•	每个线程都有自己的专用Jiddata内存块，它们是从C/C++运行库的堆（heap）上分 配的。
•	传给_beginthreadex的线程函数的地址保存在_tiddata内存块中。（_tiddata结构在 Mtdll.h文件的C++源代码中。）纯粹是为了增加趣味性，我在下面重现了这个结构。 要传入_beginthreadex函数的参数也保存在这个数据块中。
struct _tiddata (
unsigned long
/* thread ID */
/* thread handle */
unsigned long
,t handle；
int _terrno；		
unsigned	long	_tdoserrno；
unsigned	int	_fpds；
unsigned	long	_holdrand；
char*		_token；
wchar__t *		_wtoken；
unsigned	char*	_mtoken；
/* errno value */
_doserrno value ♦/
Floating Point data segment rand() seed value */ ptr to strtok() token */ ptr to wcstok() token */ per to _mbstok() token ♦/
/* following pointers get malloc'd at
char*	_errmsg;	/*
wchar_t*	_werrmsg；	/*
char*	_namebuf0；	/*
wchar_t*	_wnamebuf0；	/*
char*	_namebuf1;	/*
wchar_t*	_wnamebuf1；	/*
char*	_asctimebuf；	/*
wchar_t*	_wasctimebuf;	/*
void*	_gmtimebuf；	/*
char*	_cvtbuf；	/*
runtime */
ptr to strerror()/_strerror() buff * ptr to _wcserror()/_wcserror() buff ptr Co tmpnam() buffer */
ptr to _wtmpnam() buffer ★/ ptr to tmpfilef) buffer ♦/ ptr to _wtmpfile() buffer ♦/ ptr to asctime() buffer */ ptr to _wasctime() buffer */ ptr to gmtime() structure */ ptr to ecvt()/fcvt buffer */
unsigned char _con_ch_buf[MB_LEN_MAX]； /* per to putch() buffer ♦/
unsigned short _ch_buf_used;	/* if the _con_ch_buf is used */
/* following fields are needed by void* _initaddr； /* void* _initarg； /*'
_beginthread code */ initial user thread address */ initial user thread argument */
/* following three fields are needed void* _pxcptacttab; /* void* _tpxcptinfoptrs； /* int _t fpecode； /*
to support signal handling and runtime errors */ ptr to exception-action table */ ptr to exception info pointers */ float point exception code */
/* pointer to the copy of the multibyte character information used by the thread */ pthreadmbcinfo ptmbcinfo；
第6章线程基础
/* pointer to the copy of the locale information used by the thread */ pthreadlocinfo ptlocinfo；
int _ownlocale;	/* if 1, this thread owns its own locale */
/* following field is needed by NLG routines */ unsigned long _NLG_dwCode；
Per-Thread data needed by C++ Exception Handling
void* void* void* void* void* void* int void*	..terminate；	/* terminate () routine */ —unexpected;	/* unexpected() routine */ .translator；	/* S. E. translator */ _purecall；	/* called when pure virtual happens */ _curexception;	/* current exception */ _curcontext；	/* current exception context */ _ProcessingThrow； /* for uncaught_exception */ _curexcspec；	/* for handling exceptions thrown fran std：:unexpected */
#if defined void* void* void*	(_M_IA64) 1 I defined (_M_AMD64) .jjExitContext; _pUnwindContext； _pFraineInfoChain;
unsigned _int64 _ImageBase；
#if defined (_M_IA64)
unsigned _int64 _TargetGp； #endif /* defined (_M_IA64) */
unsigned _int64 _ThrowImageBase;
void* _pForeignException；
#elif defined (_M_IX86)
void* _pFrameInfoChain；•
#endif /* defined (_M_IX86) */
_setloc_struct _setloc_data；
void*	_encode_ptr；	/* EncodePointer() routine */
void*	_decode_ptr；	/* DecodePointer() routine */
void*	_reservedl;	/*	nothing	*/
void*	_reserved2；	/*	nothing	*/
void*	_reserved3；	/*	nothing	*/
int _	cxxReThrow；	/*	Set to True	if it' s a rethrown C++ Exception */
unsigned long _initDomain；	/* initial domain used by _beginthread[ex] for managed
function */
};
typedef struct _tiddata * _ptiddata；
•	_beginthreadex确实会在内部调用CreateThread,因为操作系统只知道用这种方式 来创建一个新线程。
•	CreateThread函数被调用时，传给它的函数地址是_threadstartex（而非 pfnStartAddr）o另外，参数地址是_tiddata结构的地址，而非pvParamo
•	如果一切顺利，会返回线程的句柄，就像CreateThread那样。任何操作失败，会 返回Oo
为新线程分配并初始化_tiddata结构之后，接着应该知道这个结构是如何与线程关联的。 来看看_threadstartex函数（它也在C/C++运行库的Threadex.c文件中）。下面是我为这个函 数及其辅助函数_callthreadstartex编写的伪代码版本：

indows核心编程（第5版）
static unsigned long WINAPI _threadstartex (void* ptd) (
// Note： ptd is the address of this thread's tiddata block.
// Associate the tiddata block with this thread so
// _getptd() will be able to find it in _ca11threadstartex. TlsSetValue(_tlsindex, ptd)；
// Save this thread ID in the _tiddata block.
((_ptiddata) ptd)->_tid = GetCurrentThreadld()；
// Initialize floating-point support (code not shown).
// call helper function.
_callthreadstartex()；
// We never get here； the thread dies in _cal1threadstartex. return(OL)；
}
static void _callthreadstartex(void) (
_ptiddata ptd； /* pointer to thread's _tiddata struct */
// get the pointer to thread data from TLS
ptd = _getptd()；
// Wrap desired thread function in SEH frame to
// handle run-time errors and signal support.
_try {
// Call desired thread function, passing it the desired parameter.
// Pass thread's exit code value to _endthreadex.
_endthreadex(
((unsigned (WINAPI *)(void *))(((_ptiddata)ptd)->_initaddr))
(((_ptiddata)ptd)->_initarg ))；
)
_except(_XcptFilter(GetExceptionCode(), GetExceptionlnformation()))(
// The C run-time's exception handler deals with run-time errors
// and signal support； we should never get it here.
..exit (GetExceptionCode ());
}
)
关于__threadstartex函数，要注意以下几大重点。
•	新的线程首先执行RtlUserThreadStart(在NTDLL.dll文件中)，然后再跳转到
_threadstartexo
•	_threadstartex唯一的参数就是新线程的Jiddata内存块的地址。
•	TlsSetValue是一个操作系统函数，它将一个值与主调线程关联起来。这就是所谓的 线程局部存储(Thread Local Storage, TLS),详情参见第21章。_threadstartex函数 将_tiddata内存块与新建线程关联起来。
•	在无参数的辅助函数^callthreadstartex中，有一个SEH帧，它将预期要执行的线 程函数包围起来。这个帧处理着与运行库有关的许多事情——比如运行时错误(如抛 出未被捕捉的C++异常)——和C/C++运行库的signal函数。这一点相当重要。如果 用CreateThread函数新建了一个线程，然后调用C/C++运行库的signal函数，那 么signal函数不能正常工作。
•	预期要执行的线程函数会被调用，并向其传递预期的参数。前面讲过，函数的地址 和参数由_beginthreadex保存在TLS的_tiddata数据块中：并会在_callthreadstartex 中从TLS中获取。
第6章线程基础
• 线程函数的返回值被认为是线程的退出代码。
注意 callthreadstartex不是简单地返回到 threadstartex,继而到 RtlUserThreadStart；
■—-
如果是那样的话，线程会终止运行，其退出代码也会被正确设置，但线程的Jiddata 内存块不会被销毁。这会导致应用程序出现内存泄漏。为防止出现这个问题， _threadstartex调用了_endthreadex（也是一个C/C++运行库函数），并向其传递退 出代码。
1 虾 166
最后一个需要关注的函数是_endthreadex(也在C运行库的Threadex.c文件中)。下面是我编
写的该函数的伪代码版本：
void _cdecl _endthreadex (unsigned retcode) (
_ptiddata ptd; // Pointer co thread's data block
// Clean up floating-point support (code not shown).
// Get the address of this thread's tiddata block.
ptd = _getptd_noexit ();
// Free the tiddata block, if (ptd != NULL)
_freeptd(ptd);
II Terminate the thread.
ExitThread（retcode）；
）
对于_endthreadex函数，要注意以下几点。
•	C运行库的_getptd_noexit函数在内部调用操作系统的TlsGetValue函数，后者获 取主调线程的tiddata内存块的地址。
•	然后，__endthreadex将此数据块释放，并调用操作系统的ExitThread函数来实际 地销毁线程。当然，它会传递并正确设置退出代码。
在本章早些时候，我曾建议大家应该避免使用ExitThread函数。这是千真万确的，而且我 在这里并不打算自相矛盾。前面说过，此函数会“杀死”主调线程，而且不允许它从当前 执行的函数返回。由于函数没有返回，所以构造的任何C++对象都不会被析构。现在，我 们又有了不调用ExitThread函数的另一个理由：它会阻止线程的_tiddata内存块被释放， 使应用程序出现内存泄漏（直到整个进程终止）。
Microsoft的C++开发团队也意识到，总有一些开发人员喜欢调用ExitThreado所以，他们 必须使这成为可能，同时尽可能避免应用程序出现内存泄漏的情况。如果真的想要强行“杀 死”自己的线程，可以让它调用_endthreadex（而不是ExitThread）来释放线程的Jiddata块 并退出。不过，我并不鼓励调用_endthreadexo
现在，应该理解了 C/C++运行库函数为什么要为每一个新线程准备一个独立的数据块，而 且应该理解了_beginthreadex如何分配和初始化此数据块，并将它与新线程关联起来。另 外，还应理解了_endthreadex函数在线程终止运行时是如何释放该数据块的。
Endows核心编程(第5版)
一旦这个数据块被初始化并与线程关联，线程调用的任何需要“每线程实例数据”的C/C++ 运行库函数都可以轻易获取主调线程的数据块的地址(通过TlsGetValue),并操纵线程的数 据。这对函数来说是没有问题的。但是，对于ermo之类的全局变量，它又是如何工作的呢？ errno是在标准C头文件中定义的，如下所示：
_CRTIMP extern int * _cdecl _errno(void);
#define errno (*_errno())
int* _cdecl _errno(void) (
_ptiddata ptd = _getptd_noexit();
if (!ptd) (
return &ErrnoNoMem;
} else (
return	errno);
)
} 一一一 • , 166-167 祉
这样一来，任何时候引用errno,实际都是在调用内部的C/C++运行库函数_errnoc该函数 将地址返回给“与主调线程关联的数据块”中的errno数据成员。注意，errno宏被定义为 获取该地址的内容。这个定义是必要的，因为很可能写出下面这样的代码：
int *p = &errno；
if (*p == ENOMEM) (
}
如果内部函&errno只是返回errno的值，上述代码将不能通过编译。
C/C++运行库还围绕特定的函数放置了同步对象(synchronization primitive)o例如，如果两 个线程同时调用malloc,堆就会损坏。C/C++运行库函数不允许两个线程同时从内存堆中 分配内存。具体的办法是让第2个线程等待，直至第1个线程从malloc函数返回。然后， 才允许第2个线程进入。(线程同步将在第8章和第9章详细讨论。)显然，所有这些额外 的工作影响了多线程版本的C/C++运行库的性能。
C/C++运行库函数的动态链接版本被写得更通用，如此一来，对正在运行的应用程序和DLL 来说，所有使用了 C/C++运行库函数的所有运行的应用程序和DLL都可以共享同一个运行 库。因此，运行库的DLL版只有一个多线程版本。由于C/C+4•运行库是在一个DLL中提 供的，所以应用程序(.exe文件)和DLL不需要包含C/C++运行库函数的代码，所以可以更 小一些。另外，如果Microsoft修复了 C/C++运行库DLL的任何bug,应用程序将自动获得 修复O
就像我们期望的一样，C/C++运行库的启动代码为应用程序的主线程分配并初始化了一个 数据块。这样一来，主线程就可以安全地调用任何C/C++运行库函数。当主线程从其入口 点函数返回的时候，C/C++运行库函数会释放关联的数据块。此外，启动代码设置了正确 的结构化异常处理代码，使主线程能成功调用C/C++运行库的signal函数。
167
①译注：如果是静态版本的C/C++运行库，必须重新琳译应用程序。
第6章线程基础
6.7.1	用_beginthreadex 而不要用 CreateThread 创建线程
读者可能会好奇，假如调用CreateThread而不是C/C++运行库的__beginthreadex来创建新 线程，会发生什么呢？当一个线程调用一个需要_tiddata结构的C/C++运行库函数时，会 发生下面的情况。（大多数C/C++运行库函数都是线程安全的，不需要这个结构。）首先， C/C++运行库函数尝试取得线程数据块的地址（通过调用TlsGetValue）o如果NULL被作为 Jiddata块的地址返回，表明主调线程没有与之关联的Jiddata块。在这个时候，C/C++运 行库函数会为主调线程分配并初始化一个^tiddata块。然后，这个块会与线程关联（通过 TIsSetValue）,而且只要线程还在运行，这个块就会一直存在并与线程关联。现在，C/C++ 运行库函数可以使用线程的_tiddata块，以后调用的任何C/C++运行库函数也都可以使用。
当然，这是相当诱人的，因为线程（几乎）可以顺畅运行。但事实上，问题还是有的。第一 个问题是，假如线程使用了 C/C++运行库的signal函数，则整个进程都会终止，因为结构 化异常处理（SEH）帧没有就绪。第二个问题是，假如线程不是通过调用_endthreadex来终止 的，数据块就不能被销毁，从而导致内存泄漏。（对于一个用CreateThread函数来创建的 线程，谁会调用_endthreadex呢？）
说明 当模块链接到C/C++运行库的DLL版本时，这个库会在线.程终止时收到一个 DLL_THREAD_DETACH通知，并会释放_tiddata块（如果已分配的话）。虽然这可 以防止_tiddata块的泄漏，但仍然强烈建议使用__beginthreadex来创建线程，而不要 用 CreateThread。
6.7.2绝对不应该调用的C/C++运行库函数
C/C++运行库还包括以下两个函数：
unsigned long _beginthread（
void （_cdecl *start_address）（void *）,
unsigned stack_size,
void *arglist）;
void _endthread（void）；
新的_beginthreadex和_endthreadex函数已经取代了这两个传统的函数。可以看出， _beginthread函数的参数较少，所以和全功能的^beginthreadex函数相比，它的局限性较 大。例如，使用_beginthread函数，不能创建具有安全属性的线程，不能创建让线程立即 挂起，也不能获得线程ID值。_endthread函数的情况与此类似：它是无参数的，这意味 着线程的退出代码被硬编码为0。
168
__endthread函数还存在另一个鲜为人知的问题。^endthread函数在调用ExitThread前， 会调用CloseHandle,向其传入新线程的句柄。为了理解这为什么会成为一个问题，来看
^^^dows核心编程(第5版)	-
看以下代码：
DWORD dwExitCode；
HANDLE hThread = _beginthread(...);
GetExitCodeThread(hThread, &dwExitCode)；
CloseHandle(hThread);
在第一个线程调用GetExitCodeThread之前，新建的线程就可能已经执行，返回，并终止 运行了。如果发生上述情况，hThread就是无效的，因为_endthread已关闭了新线程的句 柄。不用说，对CloseHandle函数的调用也会因为相同的原因而失败。
新的_endthreadex函数不会关闭线程的句柄。所以，用_beginthreadex函数调用来替换 _beginthread函数调用，上述代码片断就没有bug 了。记住，线程函数返回时,_beginthreadex 函数调用的是_endthreadex,而_beginthread调用的是_endthread函数。
6.8	了解自己的身份
线程执行时，经常希望调用能改变执行环境的Windows函数。例如，一个线程也许希望更 改它或者它的进程的优先级(优先级将在第7章详细讨论)。由于线程经常要改变它(或其进 程)的环境，所以Windows提供了一些函数来方便线程引用它的进程内核对象或者它自己 的线程内核对象：
HANDLE GetCurrentProcess()；
HANDLE GetCurrentThread();
这两个函数都返回到主调线程的进程内核对象或线程内核对象的一个伪句柄 (pseudohandle)o它们不会在主调进程的句柄表中新建句柄。而且，调用这两个函数，不会 影响进程内核对象或线程内核对象的使用计数。如果调用CloseHandle,将一个伪句柄作 为参数传入，CloseHandle只是简单地忽略此调用，并返回FALSE。在这种情况下， GetLastError 将返回 ERRORJNVALID^HANDLEo
调用一个Windows函数时，如果此函数需要一个进程句柄或线程句柄，那么可以传递一个 伪句柄，这将导致函数在主调进程或线程上执行它的操作。例如，通过像下面这样调用 GetProcessTimes函数，一个线程可以查询其所在进程的使用时间：
FILETIME ftCreationTime, ftExitTime, ftKernelTime, ftUserTime;
GetProcessTimes(GetCurrentProcess(),
&ftCreationTime, &ftEx让Time, &ftKernelTime, &ftUserTime)；
类似地，通过调用GetThreadTimes, 一个线程可以查询自己的线程时间：
FILETIME ftCreationTime, ftExitTime, ftKernelTime, ftUserTime； GetThreadTimes(GetCurrentThread(),
&ftCreationTimez &ftExitTime, &ftKernelTime, &fCUserTime)；
有几个Windows函数可以让我们用进程或线程唯一的系统级ID来标识它。线程可以通过 以下函数来查询其进程的唯一 ID或它自己的唯- ID：
DWORD GetCurrentProcessId();
DWORD GetCurrentThreadld()；
第6章线程基础
这两个函数通常都不如返回伪句柄的那些函数有用，但在个别情况下，它们更方便。
将伪句柄转换为真正的句柄
有时或许需要一个真正的线程句柄，而不是一个伪句柄。所谓“真正的句柄”，指的是能 明确、无歧义地标识一个线程的句柄。来仔细分析下面的代码：
DWORD WINAPI ParentThread(PVOID pvParam) {
HANDLE hThreadParent = GetCurrentThread();
CreateThread(NULL, 0, ChildThread, (PVOID) hThreadParent, 0, NULL); // Function continues...
)
DWORD WINAPI Chi1dThread(PVOID pvParam) (
HANDLE hThreadParent = (HANDLE) pvParam；
FILETIME fcCreationTime, fCExitTime, ftKernelTime, ftUserTime； GetThreadTimes(hThreadParent,
&ftCreationTime, &ftExitTime, &ftKernelTime, &ftUserTime);
// Function continues...
能看出这个代码段的问题吗？其意图是让父线程向子线程传递一个可以标识父线程的句 柄。但是，父线程传递的是一个伪句柄，而不是一个真正的句柄。子线程开始执行时，它 把这个伪句柄传给GetThreadTimes函数，这将导致子线程得到的是它自己的CPU计时数 据，而不是父线程的。之所以会发生这种情况，是因为线程的伪句柄是一个指向当前线程 的句柄：换言之，指向的是发出函数调用的那个线程。
为了修正这段代码，必须将伪句柄转换为一个真正的句柄。DuplicateHandle函数(详见第3 章的讨论)可以执行这个转换：
BOOL DuplicateHandle(
HANDLE hSourceProcess,
HANDLE hSource,
HANDLE hTargetProcess, PHANDLE phTarget,
DWORD dwDesiredAccess, BOOL blnheritHandle, DWORD dwOptions);
正常情况下，利用这个函数，你可以根据与进程A相关的一个内核对象句柄来创建一个新 句柄，并让它同进程B相关。但是，我们可以采取一种特殊的方式来使用它，以纠正前面 代码中的错误。纠正过后的代码如下：
DWORD WINAPI ParentThread(PVOID pvParam) (
HANDLE hThreadParent;
DuplicateHandle( GetCurrentProcess(),
GetCurrentThread(), GetCurrentProcess(),
&hThreadParent,
0,
// Handle of process that thread
// pseudohandle is relative to
// Parent thread's pseudohandle
// Handle of process that the new, real,
// thread handle is relative to
// Will receive Che new, real, handle
// identifying the parent thread
// Ignored due to DU PLICATE_SAME_ACC ESS
lows核心编程（第5版）
FALSE, DUPLICATE_SAME_ACCESS);
New thread handle is not inheritable New thread handle has sanie access as pseudohandle
CreateThread(NULL, 0, ChildThread, (PVOID) hThreadParent, 0, NULL)； // Function continues...
}
DWORD WINAPI ChildThread(PVOID pvParam)(
HANDLE hThreadParent = (HANDLE) pvParam；
FILETIME ftCreationTime, ftExitTime, ftKernelTime, fCUserTime； GetThreadTimes(hThreadParent,
&ftCreationTimez &fCExitTime, &ftKernelTime, &ftUserTime); CloseHandle(hThreadParent);
II Function continues...
现在，当父线程执行时，它会把标识父线程的有歧义的伪句柄转换为一个新的、真正的句 柄，后者明确、无歧义地标识了父线程。然后，它将这个真正的句柄传给CreateThreado 当了线程开始执行时，其pvParam参数就会包含这个真正的线程句柄。在调用任何函数时, 只要传入这个句柄，影响的就将是父线程，而非子线程。
因为DuplicateHandle递增了指定内核对象的使用计数，所以在用完复制的对象句柄后， 有必要把bl标句柄传给CloseHandle,以递减对象的使用计数。前面的代码体现了这一点。 调用GetThreadTimes之后，「线程紧接着调用CloseHandle来递减父线程对象的使用计 数。在这段代码中，我假设子线程不会用这个句柄调用其他任何函数。如果还要在调用其 他函数时传入父线程的句柄，那么只TF在子线程完全不需要此句柄的时候，才能调用
CloseHandle。
还要强调一点，DuplicateHandle函数可•用于把进程的伪句柄转换为真正的进程句柄，如下
HANDLE hProcess;
DuplicateHandle(
GetCurrentProcess(),
GetCurrentProcess() / GetCurrentProcess(),
&hProcess,
0,
FALSE, DUPLICATE_SAME_ACCESS);
Handle of process that the process pseudohandle is relative to
Process' pseudohandle
Handle of process that the new, real, process handle is relative to
Will receive the new, real handle identifying the process
Ignored because of DUPLICATE_SAME_ACCESS
New process handle is not inheritable New process handle has same access as pseudohandle
172
5©,
城线程调度、优先级和关联瑚危
7.2
7.4
线程的挂起和恢复
进程和恢复
睡雾
切换到另一个线程
7.5在超线程CPU上切换到另一个线程
7.6线程的执行时间
7.7	在实际上下文中谈CONTEXT结构
7.8经程优先级
7.9从抽象角度看优先级
7.10优先级编程
7.11关联，性
抢占式操作系统必须使用某种算法确定对何时应对哪些线程进行调度，时间又为多长。本 章将讲述Microsoft Windows Vista使用的调度算法。
第6章讨论了每个线程都有一个上下文(CONTEXT),后者保存在线程的内核对象中。这个 上下文反映了线程上一次执行时CPU寄存器的状态。大约每隔20 ms(GetSystemTimeAdjustment函数第二个参数的返回值)，Windows都会查看所有当前存 在的线程内核对象。在这些对象中，只有一些被认为是可调度的。Windows在可调度的线 程内核对象中选择一个，并将上次保存在线程上下文中的值载入CPU寄存器。这一操作被
称为上下文切换(context switch)o Windows实际上会记录每个线程运行的次数。使用
Microsoft Spy++这样的工具可以看到这一点。下图显示了一个线程的属性。请注意，这个
线程已经调度了 182 524次。
Module	|D€VENV		
TVwtAllD	OOOOOOAO	QmntRmr	to
PrucMt 10	coooc心	BmPtorty	8
Thread SUt«	Wat	SMAMvm	00000000
WMRewn	Umt	UmtPC	1996295988
CPUS	0W:24 434	ContsdSKchM	1I2W4
□MrTme	0:00 06.031		
Pnvi^dTinw	000:18453		
Bapoedg	33 388013		
Oom | FWrWi | Synchronze j
173
indows核心编程（第5版）
图中，线程正在执行代码，并在进程的地址空间中操作数据。又过了大约20 ms, Windows 将CPU寄存器存回线程的上下文，线程不再运行。系统再次检查剩下的可调度线程内核对 象，选择另一个线程的内核对象，将该线程的上下文载入CPU寄存器，然后继续。载入线 程上下文、让线程运行、保存上下文并重复的操作在系统启动的时候就开始，然后这样的 操作会不断重复，直至系统关闭。
简单地说，这就是系统调度多个线程的方式。我们稍后会更详细地讨论，但基本过程就是 如此。很简单，对不对？ Windows之所以被称为抢占式多线程操作系统（preemptive multithreaded operating system）,是因为系统nJ以在任何时刻停止一个线程而另行调度另一 个线程。正如稍后所述，我们对此可以进行一些控制，但是余地不大。现在只需记住几点： 我们无法保证线程总在运行，线程会获得整个处理器，系统将不允许运行其他线程等。
说明经常有开发人员问我，怎样才能保证自己的线程在某个事件的某个时间段开始运行 ——比如，怎样确保某个线程在数据到达串行端口来的1 ms之内开始运行？答案很 简单：办不到。
实时操作系统可以满足这些要求，但是Windows并不是实时操作系统。实时操作系 统需要对底层硬件有清楚的了解，从而知道硬盘控制器、键盘等的延时。微软给 Windows设定的目标是运行在广泛的硬件之上：各种不同的CPU、不同的驱动器、 不同的网络....句话，Windows并不想设计成实时操作系统，即使Vista上现在
有了新的扩展机制 比如线程排序服务（可以通过http://msdn2.microsoft.com/ en-us/library/ms686752.aspx 了 解）或者用于 Windows Media Player 11 这样的多媒体应 用 的 多媒体类调度程序服务（可以通过 http://msdn2.microsoft.com/ en・us/library/ms686752.aspx 了 解）。
我要强调这一点，系统只调度可调度的线程，但是事实上，系统中大多数线程都不是可调 度的。例如有些线程对象的挂起计数大于0,这意味着该线程已被挂起，不应该给它调度 任何CPU时间。可以通过调用 CreateProcess或者 CreateThread函数并传入 CREATE_SUSPENDED标志来创建一个被挂起的线程。（本章稍后将讨论SuspendThread 和ResumeThread这两个函数。）
除了被挂起的线程之外，还有其他很多线程无法调度，因为它们都在等待某种事件发生。 例如，如果运行Notepad程序，但是并不输入任何东西，Notepad线程将什么都不做。系统 不会给没有任务的线程分配任何CPU时间。当我们移动Notepad（记事本应用程序）的窗口 时，或者其窗口需要重绘内容时，或者我们在其中输入时，系统将自动使其线程变为可调 度。这并不意味着Notepad线程将立即获得CPU时间。只不过Notepad线程有任务了，系 统会在某个时刻抽时间调度它——当然，我们希望越快越好。
7.1线程的挂起和恢复
在线程内核对象中有一个值表示线程的挂起计数。调用CreateProcess或者CreateThread
第7章线程调度、优先级和关联性
时，系统将创建线程内核对象，并把挂起计数初始化为lo这样，就不会给这个线程调度 CPU 了。这正是我们所希望的，因为线程初始化需要时间，我们当然不想在线程准备好之 前就开始执行它。
在线程初始化之后，CreateProcess或者CreateThread函数将查看是否有 CREATE_SUSPENDED标志传入。如果有，函数会返回并让新的线程处于挂起状态。如 果没有，函数会将线程的挂起计数递减为0。当线程的挂起计数为0时，线程就成为可调 度的了，除非它还在等待某个事件发生（例如键盘输入）。
通过创建一个处于挂起状态的线程，我们可以在线程执行任何代码之前改变它的环境（比如 本章稍后将讨论的优先级）。改变了线程的环境之后，必须使其变为可调度的。这可以通过 调用ResumeThread函数，传入调用CreateThread时所返回的线程句柄（或者传给 CreateProcess的ppiProdnfo参数所指向的结构中的线程句柄）予以实现：
DWORD ResumeThread（HANDLE hThread）；
如果ResumeThread函数成功，它将返回线程的前一个挂起计数；否则，它将返回 OxFFFFFFFFo
一个线程可以被多次挂起。如果一个线程被挂起三次，则在它有资格让系统为它分配CPU 之前必须恢复三次。除了在创建线程时使用CREATE. SUSPENDED标志外，还可以通过 调用SuspendThread来挂起线程：
DWORD SuspendThread（HANDLE hThread）；
任何线程都可以调用这个函数挂起另一个线程（只要有线程的句柄）。显然，线程可以将自 己挂起，但是它无法自己恢复。与ResumeThread -样，SuspendThread返回线程之前的 挂起计数。一个线程最多可以挂起M AXIMUM_SUSPEND_COUNT（ WinNT.h中定义为127） 次。请注意，就内核模式下面执行情况而言，SuspendThread是异步的，但在线程恢复之 前，它是无法在用户模式下执行的。
实际开发中，应用程序在调用SuspendThread时必须小心，因为试图挂起一个线程时，我 们不知道线程在做什么。例如，如果线程正在分配堆中的内存，线程将锁定堆。当其他线 程要访问堆的时候，它们的执行将被中止，直到第一个线程恢复。只有在确切知道目标线 程是哪个（或者它在做什么），而且采取完备措施避免出现因挂起线程而引起的问题或者死 锁的时候，调用SuspendThread才是安全的。（关于死锁和其他线程同步问题将在第8章、 第9章和第10章讨论。）
7.2进程的挂起和恢复
其实，Windows中不存在挂起和恢复进程的概念，因为系统从来不会给进程调度CPU时 间。但是，我被问过无数次，怎样挂起一个进程中的所有线程。在一个特殊情况下，即 调试器处理WaitForDebugEvent返回的调试事件时，Windows将冻结被调试进程中的所
lows核心编程(第5版)
有线程，直至调试器调用ContinueDebugEvento还可以使用来自Sysintemals公司 Process Explorer 的 "Suspend Process功有自(http://www.microsoR.com/technet/sysintemals/ ProcessesAndThread/ProcessExplorer.mspx)实现同样的任务：挂起进程中的所有线程。
Windows没有提供其他方式挂起进程中的所有线程，因为存在竞态条件问题。例如，在线 程被挂起时，可能创建一个新的进程。系统必须想方设法挂起这个时间段中任何新的线程。 Microsoft己经将这一功能集成到系统的调试机制中了。
虽然我们没有十全十美的SuspendProcess函数，但是我们可以创建一个适用于许多情况的 版本。这是我实现的SuspendProcess函数：
VOID SuspendProcess(DWORD dwProcessID, BOOL fSuspend) (
// Get the list of threads in the system.
HANDLE hSnapshot = CreateToolhelp32Snapshot(
TH32CS_SNAPTHREAD, dwProcessID);
if (hSnapshot != INVALID_HANDLE_VALUE) (
// Walk the list of threads.
THREADENTRY32 te = ( sizeof(te) }；
BOOL fOk = Thread32First(hSnapshot, &te)；
for (； fOk； fOk = Thread32Next(hSnapshot, &te)) {
// Is this thread in the desired process?
if (te.th320wnerProcessID == dwProcessID) (
// Attempt to convert the thread ID into a handle.
HANDLE hThread = OpenThread(THREAD_SUSPEND_RESUME,
FALSE, te.th32ThreadID);
if (hThread != NULL)(
// Suspend or resume the thread, if (fSuspend)
SuspendThread(hThread)； else
ResumeThread(hThread)；
}
CloseHandle(hThread);
}
}
CloseHandle(hSnapshot)；
)
}
这个SuspendProcess函数使用ToolHelp函数(参见第4章)来枚举系统中的线程列表。一旦 找到属于某个进程的线程，我便调用OpenThread：
HANDLE OpenThread(
DWORD dwDesiredAccess,
BOOL blnheritHandle,
DWORD dwThreadID)；
①洋注：现在已经足微软公司的一部分。
第7章线程调度、优先级和关联性
这个函数将找到线程ID匹配的线程内核对象，并使内核对象的使用计数递增1,然后返回 对象的句柄。有了这个句柄，就可以调用SuspendThread（或者ResumeThread）To
我们不难理解为什么SuspendProcess不能随时随地使用，因为在枚举线程集合的时候，会 有新的线程被创建，也可能有线程被销毁。因此在调用CreateToolhelp32Snapshot 了之后， 目标进程中可能会出现新的线程，我的函数无法对其实施挂起操作。然后，在调用 SuspendProcess恢复线程时，它会恢复一个从未挂起过的线程。更糟糕的是，在枚举线程 ID时，可能会销毁一个己有线程，创建一个新的线程，而这两个线程恰好ID相同。这样 的话，函数将挂起任意一个线程（可能属于目标进程之外的进程）。
当然，这种情况是不太可能出现的，而且，如果我们能够充分了解目标进程的运行情况， 这些问题可能根本不是问题了。我虽然提供了这个函数，但请慎用具体使用时出现的问题, 恕不负责。
7.3睡眠
线程还可以告诉系统，在一段时间内自己不需要调度了。这可以通过调用Sleep实现：
VOID Sleep（DWORD dwMilliseconds）;
这个函数将使线程自己挂起dwMillisecoiids长的时间。关于Sleep,有以下几点重要的事项 需要注意。
•	调用Sleep函数，将使线程自愿放弃属于它的时间片中剩下的部分。
•	系统设置线程不可调度的时间只是“近似于”所设定的毫秒数。没错，如果告诉系 统想睡眠100 ms,那么线程将睡眠差不多这么长时间，但是可能会长达数秒甚至数 分钟。别忘了，Windows不是实时操作系统。我们的线程可能准时醒来，但是实际 情况取决于系统中其他线程的运行情况。
•	可以调用Sleep并给dwMs参数传入INFINITEo这是在告诉系统，永远不要调度 这个进程。这样做没有什么用处。让线程退出并将其栈和内核对象返还给系统，要 好得多。
•	可以给Sleep传入0。这是在告诉系统，主调线程放弃了时间片的剩余部分，它强 制系统调度其他线程。但是系统有可能重新调度刚刚调用了 Sleep的那个线程。如 果没有相同或者较高优先级的可调度线程时，就会发生这样的事情。
7.4切换到另一个线程
系统提供了一个名为SwitchToThread的函数，如果存在另一个可调度线程，那么系统会 让此线程运行：
BOOL SwitchToThread();
J^^dows核心编程(第5版)
调用这个函数时，系统查看是否存在正急需CPU时间的饥饿线程。如果没有， SwitchToThread立即返回。如果存在，SwitchToThread将调度该线程(其优先级可能比 SwitchToThread的主调线程低)。饥饿线程可以运行一个时间量，然后系统调度程序恢复 正常运行。
通过这个函数，需要某个资源的线程可以强制一个可能拥有该资源的低优先级的线程放弃 资源。如果在调用SwitchToThread时没有其他线程可以运行，则函数将返回FALSE；否 '则，函数将返回一个非零值。
调用SwitchToThread与调用Sleep类似，传入0 ms超时即可。区别在于，SwitchToThread 允许执行低优先级线程，Sleep会立即重新调度主调线程，即使低优先级线程还处于饥饿 状态。
7.5在超线程CPU上切换到另一个线程
超线程(hype.threading)是Xeon, Pentium 4和更新的CPU支持的一种技术。超线程处理器 芯片有多个“逻辑”CPU,每个都可以运行一个线程。每个线程都有•自己的体系结构状态(一 组寄存器)，但是所有线程共享主要的执行资源，比如CPU高速缓存。当一个线程中止时, CPU自动执行另一个线程，无需操作系统干预。只有在缓存未命中、分支预测错误和需要 等待前一个指令的结果"等情况下，CPU才会暂停。英特尔(Intel)报告称，超线程CPU对 吞吐量的改进达10%〜30%,具体数值取决于应用程序本身及其使用内存的方式。有关超 线程CPU的更多信息，请参考以下网址： http://www.microsoft.com/whdc/system/CEC/HT-Windows.mspx
在超线程CPU上执行旋转循环(spin loop)时，需要我们强制当前线程暂停，使另一个线程 可以访问芯片的资源。x86体系结构支持一个名为PAUSE的汇编语言指令。PAUSE指令 可以确保避免内存顺序违规，从而改进性能。此外，该指令还可以通过在非常耗电、密集 的循环中增加间歇(hiccup)性的空操作，以减少能源消耗。在x86上，PAUSE指令等价于 REPNOP指令，这样就能够兼容更早的不支持超线程的IA-32 CPUo PAUSE会导致一定的 延时(有些CPU上为0)o在Win32 API中，x86 PAUSE指令是通过调用WinNT.h中定义的 YieldProcessor宏发出的。有了这个宏，我们就可以编写与CPU体系结构无关的代码了。 而且，使用宏将扩展出内联代码，避免了函数调用的开销。
7.6线程的执行时间
有时候，我们需要计算一个线程执行某项任务需要消耗多长时间。关于这一点，许多人的 做法是编写如下代码，代码中利用了新的GetTickCoiint64函数：
①译注：即所谓的数据依赖。
第7章线程调度、优先级和关联性
// Get the current time (start time).
ULONGLONG qwStartTime = GetTickCount64();
// Perform complex algorithm here.
// Subtract start time from current time to get duration.
ULONGLONG qwElapsedTime = GetTickCount64() - qwStartTime；
这段代码有一个简单的前提：即代码的执行不会被中断。但是，在抢占式操作系统中，我 们不可能知道线程什么时候会获得CPU时间。当线程失去CPU时间时，为线程执行的各 种任务进行计时就更困难了。我们需要的是一个能够返回线程已获得的CPU时间量的函 数。值得庆幸的是，在Windows Vista之前，就有一个函数能够返回这种信息了，即 GetThreadTimes,如下所示：
BOOL GetThreadTimes(
HANDLE hThread,
PFILETIME pftCreationTime,
PFILETIME pftExitTime,
PFILETIME pftKernelTime,
PFILETIME pftUserTime);
GetThreadTimes返回4个不同的时间值，如表7-1所示。
表7-1 GetThreadTime返回的时间值详情
时间值	含义
创建时间	一个用来表示线程创建时间的绝对值，用100 ns为单位，从格林尼治时间1601年1月1 日子夜开始计算创建的时间
退出时间	用100 ns为单位表示，从格林尼治时间1601年1月1日子夜开始计算，一个用来表示线 程退出时间的绝对值。如果线程仍然运行，退出时间是没有定义的
内核时间	一个用来表示线程执行内核模式下的操作系统代码所用时间的绝对值，用100 ns为单位 表示
用户时间	一个用来表示线程执行应用代码所用时间的绝对值，用100 ns为单位表示
	
使用这个函数，便可以确定执行一个复杂算法所需的时间，具体代码如下。
_int64 Fi1eTimeToQuadWord (PFILETIME pft) {
return(Int64ShllMod32(pft->dwHighDateTime, 32) I pft->dwLowDateTime);
void PerformLongOperation () (
FILETIME ftKernelTimeStart, fCKernelTimeEnd;
FILETIME ftUserTimeStart,	ftUserTimeEnd;
FILETIME ftDummy;
一int64 qwKernelTimeElapsed, qwUserTimeElapsed, qwTotalTimeElapsed；
// Get starting times.
GetThreadTimes(GetCurrentThread(), &ftDummy, &ftDununy, &ftKernelTimeStart, &ftUserTimeStart)；
lows核心编程（第5版）
// Perform complex algorithm here.
// Get ending times.
GetThreadTimes(GetCurrentThread(), &ftDummy»	tDummy,
& ftKerneiTimeEnd/ &ftUserTimeEnd);
// Get the elapsed kernel and user times by converting the start
// and end times from FILETIMEs to quad words, and then subtract
// the start times from the end times.
qwKernelTimeElapsed = FileTimeToQuadWord(&ftKernelTimeEnd) -
FileTimeToQuadWord(&ftKernelTimeStart);
qwUserTimeElapsed = FileTimeToQuadWord(&ftUserTimeEnd)-
FileTimeToQuadWord(&ftUserTimeStart)；
// Get total time duration by adding the kernel and user times. qwTotalTimeElapsed = qwKernelTimeElapsed + qwUserTimeElapsed;
// The total elapsed time is in qwTotalTimeElapsed.
)
请注意GetProcessTimes,这个函数类似于GetThreadTimes,可以用于进程中的所有线程:
BOOL GetProcessTimes(
HANDLE hProcess,
PFILETIME pftCreationTime,
PFILETIME pftExitTime,
PFILETIME pftKernelTime, PFILETIME pftUserTime);
GetProcessTimes返回的时间适用于一个指定进程中的所有线程(即使线程已经终止)。例 如，所返回的内核时间是所有线程在内核模式下所耗时间的总和。
在Windows Vista中，系统为线程分配CPU时间的方式发生了改变。操作系统不再依赖约 10〜15 ms的间隔时钟计时器(有关计时器和用来测量它的ClockRes工具的更多细节，请参 考 http://www.microsoft.com/technet/sysintemals/infbrmation/highresolutiontimers.mspx),而是 改用处理器的64位时间戳计时器(Time Stamp Counter, TSC),它计算的是机器启动以来 的时钟周期数。对于我们数G频率的计算机来说，可以想象一下这个值与ms相比精度所 提高的程度。
当线程被调度程序暂停时，将计算此时TSC值与线程开始其执行时间量时的TSC值之差, 并在线程执行时间上加上这个差值，不计中断时间，这与Windows Vista之前的版本相同。 QueryThreadCycleTime和QueryProcessCydeThne函数分别返回给定线程或者给定进程 的所有线程所用的时钟周期数。如果想在代码中用更精确的函数替代GetTickCount64 , 应该调用WinNT.h中定义的ReadTimeStampCounter宏获取当前TSC值，这个宏被定义 为C++编译器提供的内部函数_rdtsco
要进行高精度的性能分析，GetThreadTimes函数仍然不够。Windows提供了如下高精度 性能函数：
bool QueryPerformanceFrequency(LARGE_INTEGER* pliFrequency);
BOOL QueryPerformanceCounter(LARGE_INTEGER* pliCount);
够
第7章线程调度、优先级和关联性
这些函数假设正在执行的线程不会被抢占，但是大多数高精度性能分析都是针对生命期很 短的代码块。为了简化这些函数的使用，我创建了以下C++类：
class CStopwatch ( public：
CStopwatch()
( QueryPerformanceFrequencyPerfFreq); Start(); }
void Start()
( QueryPerformanceCounter(&m_liPerfStart)； )
_int64 Now()
LARGE_INTEGER liPerfNow；
QueryPerformanceCounter(&liPerfNow)；
return(((liPerfNow.QuadPart - m_liPerfStart.QuadPart) * 1000) / m_li Per fFreq.QuadPart)；
_int64 NowInMicro() const {	// Returns # of microseconds
// since Start was called LARGE_INTEGER liPerfNow;
QueryPerformanceCounter(&liPerfNow)； return(((1i Per fNow.QuadPart / m_liPerfFreq.QuadPart);
}
m_liPerfStart.QuadPart) * 1000000)
private：
LARGE_INTEGER m_liPerfFreq; //
LARGE_INTEGER m_liPerfStart;	//
Counts per second
Starting count
这个类的用法如下:
// Create a stopwatch timer (which CStopwatch
stopwatch；
defaults to the current time).
}
// Execute
the code I want to profile here.
much time has elapsed up to now.
// Get how
_int64 qwElapsedTime = stopwatch.Now()；
// qwElapsedTime indicates how long the profiled code // executed in ms.
这个高精度的计时函数用来转换新的Get*CycleTime函数所返回的数值。因为所测得的周 期取决于处理器频率，所以需要知道频率值，才能将周期数转换为更有意义的计时值。例 如，对于2 GHz的处理器，2 000 000 000个周期相当于1 s, 800 000个周期相当于0.4 ms, 而在更慢的1 GHz的处理器上相当于0.8 mso GetCPUFrequencylnMHz函数的实现如下：
DWORD GetCPUFrequencylnMHz() (
// change the priority to ensure the thread will have more chances
// to be scheduled when Sleep() ends int currentPriority = GetThreadPriority(GetCurrentThread())；
SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_HIGHEST) ;
§，兀A 金	::
:'飞 "•次心世.•心:•项次
tune).如阳聂
// keep track of the elapsed time with the other timer _int64 elapsedTime
=0;
// Create a stopwatch timer (which defaults to the current CStopwatch stopwatch;
—int64 perfCountstart = stopwatch.NowInMicro()；
// get the current number of cycles unsigned _int64 cyclesOnStart
=ReadTimeStampCounter()；
Endows核心编程（第5版）
// wait for ~1 second Sleep(lOOO);
.
// get the number of cycles after -1 second
unsigned _int64 numberOfCycles = ReadTimeStampCounter() - cyclesOnStart;
// Get how much time has elapsed with greater precision elapsedTime = stopwatch.NowInMicro() - perfCountStart;
// Restore the thread priority
SetThreadPriority(GetCurrentThread(), currentPriority);
// Compute the frequency in MHz
DWORD dwCPUFrequency = (DWORD)(numberOfCycles / elapsedTime); return(dwCPUFrequency);
}
需要QueryProcessCycleTime所返回的周期数对应的毫秒值时，我们只需将周期数除以 GetCPUFrequencylnMHz再乘上100即可。虽然计算很简单，但是结果可能完全不正确。 处理器的频率栏随时间而不断变化的，具体值取决于终端用户选择的设置，以及计算机是 否接上了电源七最后要说的是，在多处理器计算机上，可以给线程分配频率有差异的不同 处理器。
7.7	在实际上下文中谈CONTEXT结构
结合前面的描述，CONTEXT结构在线程调度中所起的重要作用已经昭然若揭。系统使用 CONTEXT结构记住线程的状态，这样线程在下一次获得CPU可以运行时，就可以从上次 停止处继续。
行读者可能会很吃惊，Platform SDK文档中竟然记载了如此底层的数据结构。但是，如果 查看文档中对CONTEXT结构的描述，看到的无非是：
"CONTEXT结构中保存着特定于处理器寄存器的数据。系统使用CONTEXT 结构执行各种内部操作。要了解这些结构的定义，请参考WinNT.h头文件。”
文档并没有给出结构的成员，也没有对成员进行任何说明，因为成员的具体情况取决于 Windows运行在什么CPU上。事实上，在Windows定义的所有数据结构中，CONTEXT 结构是唯一一个特定于CPU的。
那么,CONTEXT结构中到底有什么呢？ CPU±的每个寄存器它都有一个对应的数据成员。 在x86计算机上，数据成员就是Eax, Ebx, Ecx, Edx等。下面这段代码给出了 x86 CPU的 完整CONTEXT结构：
typedef struct _CONTEXT （
//
①译注：这种情况主要发生在笔记本电脑中。当没有外接电源时，CPU可以降频运行以延长电池的使用时间。
第7章线程调度、优先级和关联性
// The flag values within this flag control the contents of
// a CONTEXT record.
//
// If the context record is used as an input parameter, then
// for each portion of the context record controlled by a flag
// whose value is set, it is assumed that that portion of the
// context record contains valid context. If the context record
// is being used to modify a thread's context, only that
// portion of the thread's context will be modified.
//
// If the context record is used as an IN OUT parameter to capture
// the context of a thread, only those portions of the thread's
// context corresponding to set flags will be returned.
//
// The context record is never used as an OUT only parameter.
//
DWORD ContextFlags；
//
// This section is specified/returned if CONTEXT_DEBUG_REGISTERS is
// set in ContextFlags. Note that CONTEXT_DEBUG_REGISTERS is NOT // included in CONTEXT_FULL.
//
DWORD DWORD DWORD DWORD DWORD DWORD
DrO; Drl; Dr2; Dr3; Dr6; Dr7；
//
// This section is specified/returned if the
// ContextFlags word contains the flag CONTEXT_FLOATING_POINT. //
FLOATING_SAVE_AREA FloaCSave；
//
// This section is specified/returned if the
// ContextFlags word contains the flag CONTEXT_SEGMENTS. //
DWORD SegGs;
DWORD SegFs；
DWORD SegEs;
DWORD SegDs;
//
// This section is specified/returned if the
// ContextFlags word contains the flag CONTEXT__INTEGER. //
DWORD Edi;
DWORD Esi;
DWORD Ebx；
DWORD Edx;
DWORD Ecx;
DWORD Eax;
//
// This section is specified/returned if the
// ContextFlags word contains the flag CONTEXT_CONTROL. //
DWORD Ebp;
DWORD Eip;
DWORD SegCs；	// MUST BE SANITIZED
DWORD EFlags; •	// MUST BE SANITIZED
DWORD Esp;
DWORD SegSs;
//
// This section is specified/returned if the ContextFlags word
// contains the flag CONTEXT_EXTENDED_REGISTERS.
// The format and contexts are processor specific
//
BYTE ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSIONJ;	.
} CONTEXT;	____
CONTEXT结构分为几部分。CONTEXT_CONTROL包含CPU的控制寄存器，比如指令 指针、栈指针、标志和函数返回地址。CONTEXTJNTEGER标识CPU的整数寄存器； CONTEXT_FLOATING_POINT 标识 CPU 的浮点寄存器；CONTEXT_SEGMENTS 标识 CPU 的段寄存器；CONTEXT_DEBUG_REGISTERS标识CPU 的调试寄存器； CONTEXT_EXTENDED_REGISTERS 标识 CPU 的扩展寄存器；
Windows实际上允许我们查看线程的内核对象的内部，并获取当前CPU寄存器状态的集 合。为此，只需调用GetThreadContext:
BOOL GetThreadContext(
HANDLE hThread,
PCONTEXT pContext)；
要调用这个函数，需分配一个CONTEXT结构，初始化一些标志(结构的ContextFlags成 员)以表示要获取那些寄存器，然后再将结构的地址传给GetThreadContexto函数随后会 在结构中填入我们请求的成员。
在调用GetThreadContext前应该先调用SuspendThread；否则，系统可能正好获得调度此 线程，这样一来，线程的上下文与所获取的信息就不一致了。一个线程实际上有两个上下 文：用户模式和内核模式。GetThreadContext °能返回线程的用户模式上下文。如果调用 SuspendThread暂停一个线程，但是该线程正在内核模式执行，那么它的用户模式上下文 保持不变，即使SuspendThread实际上还没有暂停线程。但是，线程恢复之前，不能再执行 任何用户模式的代码，因此，我们完全可以认为线程已经暂停，这时调用GetThreadContext 是非常安全的。
CONTEXT结构的ContextFlags成员与任何CPU寄存器都不对应。这个成员的作用是告 诉GetThreadContext函数，应该获取哪些寄存器。例如，如果想获得线程的控制寄存器， 可以写如下代码：
// Create a CONTEXT structure.
CONTEXT Context;
// Tell the system that we are interested in only the
// control registers.
Context.ContextFlags = CONTEXT_CONTROL;
// Tell the system to get the registers associated with a thread.
第7章线程调度、优先级和关联性
GetThreadContext(hThread, ^Context)；
// The control register members in the CONTEXT structure
// reflect the thread's control registers. The other members
// are undefined.
请注意，在调用GetThreadContext前，必须首先初始化CONTEXT结构的ContextFlags 成员。如果想获取线程的控制寄存器和整数寄存器，应该像下面这样初始化ContextFlags： // Tell the system that we are interested
// in the control and integer registers.
Context.ContextFlags = CONTEXT_CONTROL I CONTEXT_INTEGER;	.
要获得线程的所有重要的寄存器(也就是微软认为最常用的寄存器)，可以用下面的标识符：
// Tell the system we are interested in the important registers.
Context.ContextFlags = CONTEXT_FULL;
CONTEXT_FULL 在 WinNTh 头文件中被定义为 CONTEXT__CONTROL | CONTEXTJNTEGER | CONTEXT_ SEGMENTS o
当GetThreadContext返回时，可以很容易地查看线程的任何寄存器值，但是要记住，这样 编写的是依赖于CPU的代码。例如，对于x86 CPU, Eip字段存储的是指令指针，而Esp 字段存储的是栈指针。
看看，Windows为程序员提供了多么惊人的控制力啊。觉得很酷？还有更好的呢：Windows 还允许我们通过调用SetThreadContext来改变结构中的成员，并把新的寄存器值放回线程 的内核对象中：
BOOL SetThreadContext(
HANDLE hThread,
CONST CONTEXT *pContext);
同样，如果要改变哪个线程的上下文，应该先暂停该线程，否则结果无法预料。
在调用SetThreadContext前，必须再次初始化CONTEXT的ContextFlags成员，如下 所示：
CONTEXT Context;
// Stop the thread from running.
SuspendThread(hThread)；
// Get the thread's context registers.
Context.ContextFlags = CONTEXT_CONTROL;
GetThreadContext(hThread, &Context)；
// Make the instruction pointer point to the address of your choice.
// Here I've arbitrarily set the address instruction pointer to
// 0x00010000.
Context.Eip = 0x00010000；
// Set the thread * s registers to reflect the changed values.
// It's not really necessary to reset the ContextFlags member
// because it was set earlier.
Context.ContextFlags = CONTEXT_CONTROL;
SetThreadContext(hThread, &Context)；
indows核心编程（第5版）
// Resuming the thread will cause it to begin execution
// at address 0x00010000.
ResumeThread（hThread）;
这可能会造成远程线程的访问违规L系统会先向用户显示一个未处理的异常消息框，然后 终止远程进程。没错一一被终止的是远程进程，而不是我们的进程。在我们自己继续正常 执行的同时，可以成功地使另一个进程崩溃！
GetThreadContext和SetThreadContext函数为我们提供了对线程许多控制办法，但是需 要小心使用。事实上，很少有应用程序会调用这些函数。虽然增加这些函数的目的是帮助 调试器和其他工具实现Set Next Statement（设置下一个语句）这样的高级特性。但是任何应用 程序都可以调用它们。
第24章将进一步讨论CONTEXT结构。
7.8线程优先级
在本章的开始，曾经解释过，在调度程序给另一个可调度线程分配CPU之前，CPU可以运 行一个线程大约20 mso这是所有线程优先级都相同时的情况，而实际上，各个线程有很 多不同的优先级，这将影响调度程序如何选择下一个要运行的线程。
每个线程都被赋予0（最低）〜31（最高）的优先级数。当系统确定给哪个线程分配CPU时，它 会首先查看优先级为31的线程，并以循环（round-robin）的方式进行调度。如果有优先级为 31的线程可供调度，那么系统就会将CPU分配给该线程。在该线段的时间片结束时，系 统查看是否还存在另一个优先级为31的线程可以运行，如果存在，它将获得CPU。
只要有优先级为31的线程可供调度，系统就不会给优先级0〜30的线程分配CPU。这种 情况称为饥饿（starvation）o当较高优先级的线程占用了 CPU时间，致使较低优先级的线程 无法运行时，我们就称这种情况为饥饿。在多处理器机器上饥饿发生的可能性要小得多， 因为这种机器上优先级为31的线程和优先级为30的线程可以同时运行。系统总是保持各 CPU处于忙碌状态，只有没有线程可供调度的时候，CPU才会空闲下来。
这么看起来，这样设计的系统里，较低优先级的线程好像永远没有机会运行了。但是，正 如我前面指出的，任何时刻系统中大多数线程都是不可调度的。例如，如果进程的主线程 调用了 GetMessage，而系统看到并没有消息等待处理，它就会暂停这个线程，取消这个线 程当前时间片的剩余时间，并立即将CPU分配给另一个等待中的线程。
如果没有消息出现，供GetMessage获取，进程的主线程将一直被暂停，得不到CPU。但 是，一旦消息进入线程的队列，系统会知道主线程不应该暂停了，如果没有较高优先级的 线程需要执行，系统将给它分配CPU。
①译注：这很可能是因为修改了寄存器的值,从而导致线程访问了不应该访问的内存地址。
第7章线程调度、优先级和关联性
还有另外一个问题需要指出。较高优先级的线程总是会抢占较低优先级的线程，无论较低 优先级的线程是否正在执行。例如，如果有一个优先级为5的线程在运行，而系统确定有 较高优先级的线程已准备好可以运行，它会立即暂停较低优先级的线程(即使后者的时间片 还没有用完)，并将CPU分配给较高优先级的线程，该线程获得一个完整的时间片。
顺便说一下，系统启动时，将创建一个名为页面清零线程(zero page thread)的特殊线程。这 个线程的优先级定为0,而且是整个系统中唯一一个优先级为0的线程。页面清零线程负 责在没有其他进程需要执行的时候，将系统内存中的所有闲置页面清零。
7.9从抽象角度看优先级
Microsoft的开发人员们设计线程调度程序时已经意识到，不可能完全满足各种需求。他们 还认识到，计算机的用途会随时间而变化。za Windows NT刚刚问世时，人们刚刚开始编 写OLE(object linking and embedding,对象链接与嵌入)应用程序。而现在，OLE应用程序 己经是司空见惯的事情了。游戏和多媒体软件更是无处不在。而在Windows早期，肯定很 少考虑到Interneto
调度算法对用户运行的各种应用程序都有显著的影响。Microsoft的开发人员从一开始就认 识到，需要随系统用途的改变不断修改调度算法。但是，软件开发人员今天编写的系统， Microsoft却能保证这些软件同样能在其操作系统的未来版本上运行。Microsoft是如何改变 系统的工作方式，保证用户软件正常运行的呢？原因如下。
•	Microsoft没有在文档中完整描述调度程序的行为。
•	Microsoft不允许应用程序充分利用调度程序的特性。
•	Microsoft明确告知用户，调度算法会发生变化，使应用软件程序员知道应该防御性 地编程。
Windows API在系统的调度程序之上提供了一个抽象层，因此我们不会直接调用调度程序。 相反，调用的是Windows函数，它们会根据底层操作系统的版本来“解释”参数。因此， 本章中我们需要讲一讲这个抽象层。
我们设计一个应用程序的时候，应该考虑用户可能会同时运行其他什么程序。然后需要根 据应用程序中线程的响应性选择一个优先级类。我知道这听上去很模糊，但这是有意为之。 Microsoft可不想做出什么未来可能影响我们代码的承诺。
Windows 支持 6 个优先级类(priority class)： idle, below normal, normal, above normal, high 和 real-timeo当然，normal是最常用的优先级类，为99%的应用程序所使用。表7.2描述了优 先级。
188
Sows核心编程（第5版）
表7・2进程优先级类
优先级	描述
real-time（实时①）	此进程中的线程必须立即响应事件，执行实时任务。此进程中的线程还会 抢占操作系统的组件的CPU时间。使用该优先级类需要极为小心
high（高）	此进程中的线程必须立即响应事件，执行实时任务。任务管理器运行在这 一级，因此用户可以通过它结束失控的进程
above normal（高于标准）	此进程中的线程运行在normal和high优先级类之间
normal（标准）	此进程中的线程无需特殊的调度
below normal（低于标准）	此进程中的线程运行在normal和idle优先级类之间
idle（低）	此进程中的线程在系统空闲时运行。屏幕保护程序、后台实用程序和统计 数据收集软件通常使用该进程
idle优先级类非常适合只在系统什么都不做的时候运行的应用程序。没有用户交互使用的 计算机仍然可能在忙碌（比如用作文件服务器），不应该去和屏幕保护程序争CPU时间。统 计数据收集程序周期性地更新系统的状态数据，一般也不应该干扰更重要的任务。
只有在绝对必要的时候才使用high优先级类。应该尽可能避免使用real-time优先级类。事 实上，虽然Windows NT 3.1早期的beta版本已经支持这一优先级类，但它没有将其开放给 应用程序使用。real-time优先级级别最高，可以影响操作系统的任务，因为大多数操作系 统线程在执行时所用的优先级类都比它低。因此，real-time线程甚至可以阻止必需的磁盘 I/O和网络通信。而旦，键盘和鼠标输入也无法及时得到处理，用户可能会认为系统死机了。 基本上，只有充分的理由，才能使用real-time优先级——例如需要响应延时很短的硬件事 件，或者执行一些不能中断的非常短命的任务。
说明 进程不能运行在real-time优先级类，除非用户有Increase Scheduling Priority（提高计 划优先级）特权。默认情况下，隶属于管理员或者高级用户组的用户都具有这一 权限。
当然，大多数进程都是normal优先级类的。在Windows 2000中，Microsoft又增加了两个 优先级类：below normal和above normal,因为有些公司抱怨已有的优先级类灵活性不够。
选择了优先级后，我们就不需要考虑应用程序与其他应用程序的关系了，应该转而关注自 己应用程序里的线程。Windows支持7个相对线程优先级:idle, lowest, below normal, normal, above normal, highest和time.critical。这些优先级是相对于进程优先级的。同样，大多数线 程使用normal线程优先级。表7.3说明了相对线程优先级。
①译注：括号里给出的是Windows中文版上的中文。
第7章线程调度、优先级和关联性
表7-3相对线程优先级
相对线程优先级	描述
time-critical	对于real-time优先级类，线程运行在31 ±；所有其他优先级运行在15
highest	线程运行在高于normal之上两个级别
above normal	线程运行在高于normal之上一个级别
normal	线程运行在进程normal级别上
below normal	线程运行在低于normal之下一个级别
lowest	线程运行在低于normal之下两个级别
idle	对于real-time优先级类，线程运行在16；所有其他优先级运行在1
概括起来，进程都属于某个优先级类，另外可以指定进程中线程的相对线程优先级。有的 读者可能已经注意到，我没有提及0〜31优先级。应用程序的开发人员无需处理优先级， 而是由系统将进程的优先级类和线程的相对优先级映射到一个优先级值。这个映射正是 Microsoft不想做什么承诺的地方。事实上，这个映射在操作系统的不同版本中已经发生了 变化。
表7V说明了 Windows Vista上这种映射的具体情况，但是要注意的是，Windows NT的早 期版本（还有Windows 95和Windows 98）上映射会有一些不同。还要注意，Windows的未 来版本映射还将变化。
表7V进程优先级和相对线程优先级与优先级值的映射
相对线程优先级	进程优先级类					
	idle	below normal	normal	above normal	high	real-time
time-critical	15	15	15	15	15	31
highest	6	8	10	12	15	26
above normal	5	7	9	11	14	25
normal	4	6	8	10	13	24
below normal	3	5	7	9	12	23
lowest	2	4	6	8	11	22
idle	1	1	1	1	1	16
例如，一个normal进程中normal线程的优先级值将被指派为8。因为大多数进程都是normal 优先级的，而大多数线程都是normal线程优先级的，所以系统中大多数线程的优先级值都 是8。
如果是high优先级进程中的normal线程，线程的优先级值为13。如果将进程的优先级改 为idle,则线程的优先级值将变为4。请记住，线程优先级是相对于进程优先级的。如果改 变进程优先级，线程的相对优先级不变，但是优先级值将变化。
"ndows核心编程(第5版)
请注意，表7.4中线程优先级值没有为0的。这是因为0优先级保留给页面清零线程了， 系统不允许其他任何线程的优先级为0。而且，应用程序也无法获得以下优先级：17, 18, 19, 20, 21, 27, 28, 29,或者30。当然，如果编写的是运行在内核模式的设备驱动程序, 那么我们可以获得这些优先级；用户模式的应用程序是不能获得这些优先级的。还要注意, real-time优先级类的线程，其优先级值不能低于16。同理，非real-time优先级线程的优先 级值不能高于15。
说明 进程优先级的概念容易引起一些混淆。人们可能认为这意味着进程能够进行调度. 实际上，进程永远无法调度，能调度的是线程。进程优先级是Microsoft提出的一个 •抽象概念，有助于用户无需了解调度程序的内部工作机理，别无他意。
说明 一般而言，有较高优先级的线程大多数时候都应是不可调度的。当这种线程要执行什 么任务时，彳良决就能得到CPU时间。这时，线程应该尽可能少地执彳亍CPU指令，并 重新进入睡眠，等待再次被调度。相反，优先级低的可以保持为可调度状态，执行大 量CPU指令以完成其任务。如果遵循这些规则，整个操作系统就能够很好地响应用户。
7.10优先级编程
那么，怎样给进程指派优先级呢？调用CreateProcess St,可以在fdwCreate参数中传入需 要的优先级。表7.5给出了优先级标识符。
表7・5进程优先级类
优先级	标识符
real-time	REALTIME PRIORITY CLASS
high	HIGH PRIORITY CLASS
above normal	ABOVE NORMAL PRIORITY CLASS
normal	NORMAL PRIORITY CLASS
below normal	BELOW NORMAL PRIORITY CLASS
idle	IDLE PRIORITY CLASS
创建子进程的进程会选择子进程运行的优先级，这听起来有些奇怪。举个例子，让我们考 虑Windows资源管理器。使用Windows资源管理器运行一个程序时，新的进程将运行在 normal优先级。Windows资源管理器并不知道进程在做什么，或者它的线程多久会被调度 一次。但是，一旦进程运行，便可以通过调用SetPriorityClass来改变自己的优先级：
BOOL SetPriorityClass(
HANDLE hProcess,	.
DWORD fdwPriority);
第7章线程调度、优先级和关联性
这个函数将hProcess表示的优先级修改为参数fdwPriority所指定的值。fdwPriority参数 可以是表7.5中的任何一个标识符。因为该函数有一个参数是进程句柄，所以只要有•它的 句柄和足够的访问权限，我们就可以改变系统中的任何进程的优先级。
191
通常，进程都会尝试改变自己的优先级。下面是让进程将自己的优先级设为idle的例子:
BOOL SetPriorityClass(
GetCurrentProcess(),
IDLE_PRIORITY_CLASS);
用来获取进程优先级的相应函数如下：
DWORD GetPriorityClass(HANDLE hProcess);
可以想像，这个函数将返回表7-5列出的标识符之一。
通过命令行界面调用程序时，程序的起始优先级是normal。但是，如果使用START命令 调用程序，可以使用一个开关指定程序的起始优先级。例如，在命令行界面输入以下命令, 系统将调用计算器，并在idle优先级起始运行：
C:\>START /LOW CALC.EXE
START 命令还有/BELOWNORMAL , /NORMAL , /ABOVENORMAL , /HIGH 和 /REALTIME开关，可以以对应优先级执行应用程序。当然，程序一旦开始运行，就可以 调用SetPriorityClass任意修改优先级。
Windows任务管理器可以用来改变进程的优先级。下图显示了任务管理器的Processes选项 卡，其中显示了正在运行的进程。Base Pri显示了每个进程的优先级。要改变一个进程的优 称级类,只需选择一个进程，然后从上下文菜单的Set Priority子菜单中选择相应选项。
当线程最开始创建时，它的线程优先级总是设置为normaL我一直很奇怪,CreateThread函 数没有为调用者提供设置新线程相对优先级的办法。为了设置和获取线程的相对优先级， 必须调用以下这些函数：
lows核心编程(第5版)
BOOL SetThreadPriority(
HANDLE hThread, int nPriority)；
当然，hThread参数表示要改变哪个线程的优先级，而nPriority参数是表7.6中7个标识 符之一。
表乙6相对线程优先级
相对线程优先级	符号常数
time-critical	THREAD PRIORITY TIME CRITICAL
highest	THREAD PRIORITY HIGHEST
above normal	THREAD PRIORITY ABOVE NORMAL
normal	THREAD PRIORITY NORMAL
below normal	THREAD PRIORITY BELOW NORMAL
lowest	THREAD PRIORITY LOWEST
idle	THREAD PRIORITY IDLE
相应地，获取线程的相对优先级的函数是：
int GetThreadPriority(HANDLE hThread);
这个函数会返回表7-6列出的一个标识符。
要创建一个相对线程优先级为idle的线程，执行以下代码：
DWORD dwThreadID；
HANDLE hThread = CreateThread(NULL, 0, ThreadFunc, NULL,
CREATE_SUSPENDED, &dwThreadID);
SetThreadPriority(hThread, THREAD_PRIORITY_IDLE);
ResumeThread(hThread)；
CloseHandle(hThread);
请注意，CreateThread总是创建相对线程优先级为normal的新线程。要使线程以idle优 先级执行，我们需要在调用CreateThread时传入CREATE_SUSPENDED标志，这将阻 止线程执行任何代码。然后我们调用SetThreadPriority将线程改为idle相对线程优先级。
接着调用ResumeThread,线程就成为可调度的了。我们不知道什么时候线程可以获得CPU 时间，但是调度程序在调度的时候会考虑这个线程具有idle线程优先级。最后，关闭新线 程的句柄，这样一来，一旦线程终止时，系统就可以销毁内核对象。
说明 Windows并没有提供返回线程优先级的函数。这一遗漏是Microsoft故意的。请记住 Microsoft保留了任何时候改变调度算法的权利。我们设计的应用程序不应该了解调 度算法具体细节。如果我们始终使用进程优先级类和相对线程优先级，那么我们的 应用程序在现在和在操作系统的未来版本都可以运行得很好。
193
第7章线程调度、优先级和关联性
7.10.1动态提升线程优先级
系统通过线程的相对优先级加上线程所属进程的优先级来确定线程的优先级值。有时候， 这也被称为线程的基本优先级值(base priority level)o偶尔，系统也会提升一个线程的优先 级——通常是为了响应某种I/O事件比如窗口消息或者磁盘读取。
例如，high优先级进程中的一个线程优先级为normal的线程，其基本优先级值为13。如果 用户敲一个键，系统会在线程的队列中放入一个WM_KEYDOWN消息。因为有消息出现 在线程的队列中，线程就成为可调度的了。而且，键崟设备驱动程序将使系统临时提升线 程的优先级。因此线程的优先级可能会提升2,从而使当前的优先级达到15。
线程在优先级为15时分得一个时间片。在该时间片结束之后，系统将线程的优先级值减1, 所以下一个时间片中线程的优先级将为14o线程的第三个时间片以优先级13执行。以后 的时间片将保持在13,即线程的基本优先级。
注意，线程的当前优先级不会低于线程的基本优先级。而且使线程可调度的设备驱动程序 能够决定提升的幅度。同样，Microsoft也没有在文档中记录任何一个设备驱动程序能够将 线程的优先级提升多少。因此，Microsoft可以不断地微调动态提升，以确定最佳的总体响 应性。
系统只提升优先级值在1〜15的线程。事实匕正因为如此，这个范围被称为动态优先级 范围(dynamic priority range)o而且，系统不会把线程的优先级提升到实时范围(高于15)。 因为实时范围内的线程执行了大多数操作系统功能，对提升设置上限，可以防止应用程序 影响操作系统。而且，系统不能动态提升实时范围(16〜31)的线程。
有些开发人员抱怨系统的动态提升功能对他们的线程性能有不利影响，因此Microsoft增加 了以下两个函数，允许我们禁止系统对线程优先级进行动态提升：
BOOL SetProcessPriorityBoost(
HANDLE hProcess,
BOOL bDisablePriorityBoost)；
BOOL SetThreadPriorityBoost(
HANDLE hThread,
BOOL bDisablePriorityBoost);
SetProcessPriorityBoost允许或禁止系统提升一个进程中所有■线程的优先级；而 SetThreadPriorityBoost则允许或禁止提升某个线程的优先级。这两个函数都有对应的函 数，用来判断当前是否启用优先级提升：
BOOL GetProcessPriorityBoost(
HANDLE hProcess,
PBOOL pbDisablePriorityBoost);
BOOL GetThreadPriorityBoost(
HANDLE hThread,
PBOOL pbDisablePriorityBoost)；
调用这些函数时，只需传入待查询进程或者线程的句柄和一个布尔值的地址，函数会把返
Endows核心编程（第5版）
回结果写入这个地址。
另一种情况也会导致系统动态提升线程的优先级。想象一下一个优先级为4的线程，它已 经准备好运行了，但是由于有一个优先级为8的线程一直处于可调度状态，因此它无法运 行。这种情况下，优先级为4的线程处于CPU时间饥饿状态。当系统检测到有线程已经处 于饥饿状态3到4秒时，它会动态将饥饿线程的优先级提升为15,并允许该线程运行两个 时间片。当两个时间片结束时，线程的优先级立即恢复到基本优先级。
7.10.2为前台进程微调调度程序
如果用户需要使用某个进程的窗口，这个进程就称为前台进程（foregroundprocess）,而所有 其他的进程称为后台进程（background process）o显然,用户肯定愿意自己在使用的进程比后 台进程的响应更快。为了改进前台进程的响应性，Windows会为前台进程中的线程微调调 度算法。系统给前台进程的线程分配比一般情况下更多的时间片。这种微调只在前台进程 是normal优先级时才进行。如果处于其他优先级，则不会进行微调。
Windows Vista实际上允许用户对这种微调进行配置。在下图所示System Properties（系统属 性）对话框的Advanced（高级）选项卡中，单击Perfbrmance（性能）部分的Settings（设置）按钮， 会弹出Performance Options（性能选项）对话框，最后选择Advanced（高级）选项卡。
如果用户选择优化程序的性能（这是Windows Vista ±的默认值），系统将进行微调。如果用 户选择优化后台服务的性能，则不会进行微调。
195
7.10.3调度I/O请求优先级
设置线程优先级将影响系统如何给线程分配CPU资源。但是，线程还要执行I/O请求，以
第7章线程调度、优先级和关联性
对磁盘文件读写数据。如果一个低优先级线程获得CPU时间，它可以很轻易地在很短时间 内将成百甚至成千个I/O请求入列。因为I/O请求一般都需要时间进行处理，可能低优先 级线程会挂起高优先级的线程，使它们无法完成任务，从而显著影响系统的响应性。因此， 我们可以看到，在执行一些运行时间较长的低优先级服务比如磁盘碎片整理程序、病毒扫 描程序、内容索引程序等的时候，机器的响应性会变得很差。
从Windows Vista开始，线程可以在进行I/O请求时设置优先级了。我们可以通过调用 SetThreadPriority 并传入 THREAD_MODE_BACKGROUND_BEGIN 来告诉 Windows, 线程应该发送低优先级的I/O请求。锂意，旻也将降低线程的CPU调度优先级。我们口J以 通过调用 SetThreadPriority,并传入 THREAD. MODE_BACKGROUND_END,让线程 进行normal优先级I/O的请求（以及normal CPU调度优先级）。调用SetThreadPriority并 传入上面两个标志之一时，还必须传入主调线程的句柄（通过调用GetCurrentTHREAD返 回）。系统不允许线程改变另一个线程的I/O优先级。
如果想让进程中的所有线程都进行低优先级的I/O请求和低CPU调度，那么我们可以调用 SetPriorityClass,传入 PROCESS_MODE_BACKGROUND_BEGIN 标志。相反的操作可 以通过调用 SetPriorityClass 并传入 PROCESS_MODE_BACKGROUND_END 标志。调 用SetPriorityClass,传入上面两个标志之一时，必须还传入主调进程的句柄（通过调用 GetCurrentProcess返回）。系统不允许线程改变另一个进程中线程的I/O优先级。
在更细的粒度上，normal优先级线程还可以执行对某个文件执行后台优先级I/O,如下面 这段代码所示：
FILE_IO_PRIORITY_HINT_INFO phi;
phi.PriorityHint = loPriorityHintLow；
SetFilelnformationByHandle（
hFile, FileloPriorityHintlnfo, &phi, sizeof（PriorityHint））;
SetFilelnformationByHandle设置的优先级将覆盖进程的优先级或者线程，即分别通过 SetPriorityClass 或者 SetThreadPriority 设置的优先级。
作为开发人员，我们有责任使用这些新的后台优先级，使前台应用程序有更好的响应性， 同时尽量避免优先级逆转（priority inversion）o存在密集的normal优先级I/O时，运行在后 台优先级的线程可以在获得I/O请求的结果之前可能会延迟几秒。如果一个low优先级线 程获得了 normal优先级线程等待的锁，则normal优先级线程可以在低优先级I/O请求完成 之前运行，不等待后台优先级线程。后台优先级线程甚至不再进行I/O,以免出现问题。因 此，应该尽量减少在normal和后台优先级线程之间使用共享同步对象（如果有可能，尽量 不共享），以避免normal-优先级线程因为后台优先级线程拥有的锁而被阻塞，导致优先级 逆转。
196
说明 请注意SuperFetch利用了这些新的后台优先级。关于优先级I/O的更多详情，请参 考 http://www.microsoft.com/whdc/driver/priorityio.mspx 上的白皮书。
垓心编程（第5版）
7.10.4 Scheduling Lab 示例程序
使用Scheduling Lab程序07-SchedLab.exe（源代码在后面列出），可以试验一下进程优先级 和相对线程优先级，看看它们对系统总性能的影响。该示例程序的源代码和资源文件都可 以在本书配套网页的07-SchedLab目录下找到。启动程序时，会显示下图所示的窗口。
最开始，主线程总是很忙碌，因此CPU使用率立即跳到了 100%o主线程不断递增一个数 字，并将其添加到右边的列表框中。这个数字没有任何意义一一只是说明线程在忙碌。要 想切实感受一下线程调度对系统的影响，我建议大家同时运行这个示例程序的两个实例， 看看改变一个实例的优先级是怎样影响其他实例的。还可以运行任务管理器来监视所有实 例的CPU使用情况。
.
进行这些测试时，CPU的使用开始是100%,这个程序的所有实例获得相等的CPU时间。 （所有实例在任务管理器中显示CPU使用率相同。）如果将一个实例的优先级改变为above normal或者high,可以看到它获得了大量的CPU时间。而其他实例的数字则变得没有规 律。但是，其他实例不会完全停止运行，因为系统会对饥饿线程进行动态提升。我们可以 试验改变优先级和相对线程优先级，看看它们是怎样影响其他实例的。在编写Scheduling Lab示例程序时，故意设置了不允许读者将进程设为realtime优先级，因为这样会使操作 系统线程无法正常执行。如果想试验real-time优先级，必须自己修改源代码。
可以使用Sleep字段使主线程无法调度达若干亳秒（0〜9999）。试验一下，看看传入一个1 ms 的Sleep值时，恢复了多少CPU处理时间。在我的2.2 GHz Pentium笔记本电脑上，得到 了 99% 真不少！
单击Suspend按钮会使主线程生成一个辅助线程。这个辅助线程会使主线程挂起，并显示 如下的消息框。
显示这个消息框时，主线程完全被挂起，不使用CPU时间。而辅助线程也没有使用任何 CPU时间，因为它在等待用户执行操作。显示消息框时，可以将它移动过应用程序的主窗
第7章线程调度、优先级和关联性
口，然后再移开，让主窗口又显示出来。因为主线程被挂起，所以主窗口无法处理任何窗 口消息（包括WM_PAINT）。这充分证明了线程己经被挂起。关闭消息框后，主线程恢复执 行，CPU使用率又回到100%o
我们再来试验一下，打开前一节讨论过的Performance Options（性能选项）对话框，改变设置, 从Application改为Background Services,或者反过来。然后运行SchedLab程序的多个实例， 将它们都设为normal优先级并激活其中一个，使它成为前台进程。可以看到性能设置对前 台/后台进程所产生的影响。
#include #include #include #include #include
chSETDLGICONS(hWnd, IDI_SCHEDLAB);
int n = ComboBox_AddString(hWndCtlr TEXT("High"))； ComboBo^_SetItemData(hWndCtl, n, HIGH_PRIORITY_CLASS)/
//To avoid deadlock, call EnableWindow after ResumeThread.
EnableWindow(
GetDlgItem(FindWindow(NULL, TEXT("Scheduling Lab*)), IDC_SUSPEND), TRUE);
return(0):
SchedLab.cpp
/*******★***********************
Module: SchedLab.cpp
Notices： Copyright (c) 2008 Jeffrey Richter & Christophe Nasarre
// Save our current priority class
DWORD dwpc = GetPriorityClass(GetCurrentProcess())；
■.. \CommonFLles\CmnHdr.h*1 <windowsx.h> <tchar.h> •Resource.h" <StrSafe.h>
HANDLE hThreadPrimary = (HANDLE) pvParam;
SuspendThread(hThreadPrimary);
chMB(
"The Primary thread is suspended.\n"
"It no longer responds to input and produces no output.\n"
■Press OK to resume the primary thread & exit this secondary thread.\n"); ResumeThread(hThreadPrimary)； CloseHandle(hThreadPrimary)；
///////////////////////////////////////////////////////////////////////////////
DWORD WINAPI ThreadFunc(PVOID pvParam) (
///////////////////////////////////////////////////////////////////////////////
BOOL Dlg_OnInitDialog (HWND hWnd, HWND hWndFocua, LPARAM IP&ram) (
// Initialize process priority classes HWND hWndCtl = GetDlgItem(hWnd, IDC^PROCESSPRIORITYCLASS);
indows核心编程（第5版）
if (SetPriorityClass(GetCurrentProcess(), BELOW_NORMAL_PRIORITY_CLASS)) (
// This system supports the BELOW_NORMAL_PRIORITY_CLASS class
// Restore our original priority class
SetPriorityClass(GetCurrentProcess(), dwpc)；
// Add the Above Normal priority class
n = ComboBox_AddString(hWndCtl, TEXT("Above normal")); ComboBox_SetItemData(hWndCtlz n, ABOVE_NORMAL_PRIORITY_CLASS);
dwpc = 0; // Remember that this system supports below normal
}
int nNormal = n = ComboBox_AddString(hWndCtl, TEXT("Normal■)); ComboBox_SetItemData(hWndCtl, n, NORMAL_PRIORITY_CLASS);
if (dwpc == 0) (
// This system supports the BELOW_NORMAL_PRIORITY_CLASS class
// Add the Below Normal priority class
n = ComboBox^AddString(hWndCtl, TEXT("Below normal"))； ComboBox_SetItemData(hWndCtl, n, BELOW_NORMAL_PRIORITY_CLASS);
}
n = ComboBox_AddString(hWndCtl, TEXT("Idle"))；
ComboBox_SetItemData(hWndCtl, n, IDLE_PRIORITY_CLASS);
ComboBox_SetCurSel(hWndCtl, nNormal)；
// Initialize thread relative priorities
hWndCtl = GetDlgltemChWnd, IDC_THREADRELATIVEPRIORITY);
n = ComboBox_AddString(hWndCtl, TEXT("Time critical")); ComboBox_SetItemData(hWndCtl, n, THREAD_PRIORITY_TIME_CRITICAL);
n = ComboBox_AddString(hWndCtl, TEXT("Highest"))； ComboBox_SetItemData(hWndCtlf n, THREAD_PRIORITY_HIGHEST);
n = ComboBox_-AddString(hWndCtl, TEXT("Above normal■))； ComboBox_SetItemData(hWndCtl, n, THREAD_PRIORITY_ABOVE_NORMAL);
nNormal = n = ComboBox_AddString(hWndCtl, TEXT("Normal"))； ComboBox_SetItemData(hWndCtl, n, THREAD_PRIORITY_NORMAL);
n = ComboBox_AddString(hWndCtl, TEXT("Below normal■)); ComboBox_SetItemData(hWndCtlr n, THREAD_PRIORITY_BELOW__NORMAL);
n = ComboBox.JkddString(hWndCtl, TEXT(■Lowest"))； ComboBox_SetItemData(hWndCtlz n, THREAD_PRIORITY_LOWEST);
n = ComboBox__AddString (hWndCtl, TEXT ( "Idle"))； ComboBox_SetItemData(hWndCtl, n, THREAD_PRIORITY_IDLE);
ComboBox_SetCurSel(hWndCtl, nNormal)；
Edit^LimitText(GetDlgItem(hWnd, IDC_SLEEPTIME), 4)； // Maximum of 9999 return(TRUE)；
}
///////////////////////////////////////////////////////////////////////////////
void Dlg_OnCommand (HWND hWnd, int id, HWND hWndCtl, UINT ccxleNotify) (
第7章 线程调度、优先级和关联性
switch (id) (
case IDCANCEL:
PostQuitMessage(0);
break；
case IDC_PROCESSPRIORITYCLASS:
if (codeNotify == CBN_SELCHANGE) (
SetPriorityClass(GetCurrent Process(), (DWORD)
ComboBox_Ge111emData(hWndCtl, ComboBox_GetCurSel(hWndCtl)))； } break；
case IDC_THREADRELATIVEPRIORITY:
if (codeNotify == CBN_SELCHANGE) (
SetThreadPriority(GetCurrentThreadf), (DWORD)
ComboBox_GetitemData(hWndCtl, ComboBox__GetCurSel(hWndCtl)))； } break;
case IDC_SUSPEND:
//To avoid deadlock, call EnableWindow before creating
// the thread that calls SuspendThread.
EnableWindow(hWndCtl, FALSE)；
HANDLE hThreadPrimary;
DuplicateHandle(GetCurrentProcess(), GetCurrentThread(), GetCurrentProcess(), &hThreadPrimary r
THREAD_SUSPEND_RESUMEr FALSE, DUPLICATE_SAME_ACCESS);
DWORD dwThreadID;
CloseHandle(chBEGINTHREADEX(NULL, 0, ThreadFunc, hThreadPrimary# 0, &dwThreadID));
break；
}
}
///////////////////////////////////////////////////////////////////////////////
INT_PTR WINAPI Dlg_Proc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM 1Param) ( switch (uMsg) (
chHANDLE_DLGMSG(hWnd, WM_INITDIALOG, Dlg_OnInitDialog); chHANDLE_DLGMSG(hWnd, WM_COMMAND, Dlg_OnCommand);
}
return(FALSE)；
}
///////////////////////////////////////////////////////////////////////////////
class CStopwatch (
public：
CStopwatch() { QueryPerformanceFrequency(&m_liPerfFreq)； Start()； )
void Start() ( QueryPerformanceCounter(&m_liPerfStart)； }
_int64 Now() const ( // Returns # of milliseconds since Start was called LARGE.INTEGER liPerfNow;
QueryPerformanceCounter(&liPerfNow)；
return(((liPerfNow.QuadPart - m_liPerfStart.QuadPart) * 1000)
/ nuliPerfFreq.QuadPart);
}	驷■R#
private:
Endows核心编程(第5版)
LARGE_INTEGER m_liPerfFreq； // Counts per second
LARGE_INTEGER ituliPerfStart; // Starting count
);
_int64 FileTimeToQuadWord (PFILETIME pft) {
return(Int64ShllMod32(pft->dwHighDateTimer 32) I pft->dwLowDateTime); }
int WINAPI _tWinMain(HINSTANCE hlnstExe, HINSTANCE, PTSTR pszCmdLine, int) (
HWND hWnd =
CreateDialog(hlnstExe, MAKEINTRESOURCE(IDD_SCHEDLAB), NULL, Dlg_Proc); BOOL fQuit = FALSE;
while (!fQuit) (
MSG msg;
if (PeekMessage(&msgz NULL, 0, 0, PH_REMOVE)) (
// IsDialogMessage allows keyboard navigation to work properly.
if (!IsDialogMessage(hWnd, &msg)) (
if (msg.message == WM_QUIT) (
fQuit = TRUE; // For WM__QUIT, terminate the loop.
} else (
// Not a WM__QUIT message. Translate it and dispatch it. TranslateMessage(&msg);
DispatchMessage(&msg);
}
} // if (!IsDialogMessage())
} else (
// Add a number to the listbox
static int s_n = -1；
TCHAR sz[20];
StringCChPrintf(sz, _countof(sz) z TEXT(・％u・)，++s_n);
HWND hWndWork = GetDlgltem(hWnd, IDC_WORK)；
ListBox_SetCurSel(hWndWork, ListBox^JkddString(hWndWork, sz))；
// Remove some strings if there are too many entries
while (ListBox__GetCount (hWndWork) > 100) ListBox_DeleteString(hWndWork, 0);
// How long should the thread sleep
int nSleep = GetDlgltemint(hWnd, IDC_SLEEPTIME, NULL, FALSE);
if (chINRANGE(l, nSleep, 9999))
Sleep(nSleep)；
)
DestroyWindow(hWnd); return(0)；
}
//////////////////////////////// End of File //////////////////////////////////
198-202
7.11关联性
默认情况下，Windows Vista在给线程分配处理器时，使用软关联(soft affinity)o意思是如
第7章线程调度、优先级和关联性
果其他因素都一样，系统将使线程在上一次运行的处理器上运行。让线程始终在同一个处 理器上运行有助于重用仍在处理器高速缓存中的数据。
有一种称为NUMA (Non-Unifbrm Memory Access,非统一内存访问)的计算机体系结构，结 构的计算机由多个系统板(board)组成，每个系统板都有自己的CPU和内存板块。下图显示 了一台有三个系统板的计算机，每个系统板有4个CPU,因此共有12个CPU,任何线程 都可以在这些CPU中任何一个上运行。
NUMA系统在CPU只访问自己所在系统板上的内存时，可达到最佳性能。如果CPU需要 访问其他系统板上的内存，性能会下降得很厉害。在这种环境中，应该让一个进程中的线 程运行在CPU 0到3,另一个进程中的线程运行在CPU 4到7,以此类推。为了支持这种 体系结构，Windows Vista允许我们设置进程和线程的关联性(affinity)o也就是说，我们可 以控制CPU让哪些CPU运行特定的线程。这称为硬关联(hard affinity)。
系统在启动时将确定计算机中存在多少个CPU。应用程序可以通过调用GetSystemInfo(参 见第14章)来查询机器上CPU的数量。默认情况下，系统可以将任何CPU调度给任何线 程使用。如果要限制某些线程只在可用CPU的一个子集上运行，则可以调用 SetProcessAfYinityMask:
BOOL SetProcessAffinityMask( HANDLE hProcess,
DWORD_PTR dwProcessAffinityMask)；
第一个参数hProcess代表要设置的进程。第二个参数dwProcessAninityMask是一个位掩 码,代表线程可以在哪些CPU±运行。例如，传入0x00000005意味着这个进程中的线程 可以在CPU 0和CPU 2上运行，但是不能在CPU 1和CPU 3〜31上运行。
请注意，子进程将继承进程关联性。因此，如果一个进程的关联性掩码为0x00000005,它 的所有子进程中的任何线程也将有相同的掩码，并与它共用同一组CPUo此外，我们还可 以使用作业内核对象(第5章讨论)来限制一组进程只在一组CPU上运行。
205204
当然，还有一个函数可以返回进程的关联性掩码，即GetProcessAffinityMask：
BOOL GetProcessAffinityMask( HANDLE hProcess,
PDWORD_PTR pdwProcessAffinityMask, PDWORD_PTR pdwSystemAffinityMask)；
lows核心编程(第5版)
这里可以传入一个进程句柄，表示需要知道哪个进程的关联性掩码，函数会将掩码写在 pdwProcessAffinityMask所指向的变量里。这个函数还能返回系统的关联性掩码(存在 pdwSystemAffinityMask指向的变量中)。系统的关联性掩码表示系统中哪个CPU可以运行 这些线程。进程的关联性掩码总是系统的关联性掩码的一个真子集①。
前面我们己经讨论了如何限制一个进程的线程只在一组CPU上运行。有时候，我们还需要 限制进程中的一个线程只在一组CPU上运行。例如，需要让一个有4个线程的进程运行在 一台有4个CPU的机器上。如果这些线程中有一个线程总在执行重要任务，需要尽量使它 总是获得CPU,就需要限制其他三个线程不能在CPU 0上运行，只能在CPU 1, CPU2和 CPU3上运行。
可以通过调用SetThreadAffinityMask分别设置各线程的关联性掩码：
DWORD_PTR SetThreadAffinityMask(
HANDLE hThread,
DWORD_PTR dw Thread AffinityMask)；
hThread参数表示要对哪个线程进行限制，而dwTh read Affinity Mask表示线程可以在哪 些CPU上运行。dwThreadAffinityMask必须是进程关联性掩码的真子集。返回值是线程 之前的关联性掩码。因此，要限制三个线程只运行在CPU1, CPU2和CPU3 ±,可以像下 面这样做：
// Thread 0 can only run on CPU 0.
SetThreadAffinityMask(hThreadO, 0x00000001);
// Threads 1, 2, 3 run on CPUs I, 2, 3.
SetThreadAffinityMask(hThreadlz OxOOOOOOOE)；
SetThreadAffinityMask(hThread2z OxOOOOOOOE)；
SetThreadAffinityMask(hThread3, OxOOOOOOOE)；
当一个x86系统启动时，系统将执行代码，检查主机上的哪个CPU存在著名的Pentium浮 点bug。系统必须对每个CPU做这项检查。检查的方法是，将一个线程的关联性设置为该 CPU,执行可能会出错的除法操作，然后比较结果是否与已知正确的结果相符。随后再采 用同样的步骤检查下一个CPU,以此类推。
说明 为了更高效地使用CPU时间，调度程序可能会在多个CPU之间迁移线程。在大多 数环境里，改变线程的关联性，将妨碍调度程序的这种能力。下面给出了一个例子。
线程	优先级	关联性掩码	结果
A	4	0x00000001	CPU0
B	8	0x00000003	CPU 1
C	6	0x00000002	无法运行
①译注：如果集合A是B的子集，而旦B中除了包含A的元素之外，还有其他元素，则称A是B的真子集(proper set)o
第7章线程调度、优先级和关联性
当线程A被唤醒时，调度程序看到该线程可以在CPU 0之上运行，所以就将CPUO 分配给线程A。然后线程B唤醒，调度程序看到该线程可以在CPU 0或者1之上运 行，但是因为CPU 0已经使用，调度程序就将CPU 1分配给B。现在还一切正常。 然后线程C唤醒了，调度程序看到它只能在CPU 1之上运行，但是CPU 1已经被 优先级为8的线程B使用了。因为线程C的优先级是6,所以它无法抢占线程B, 它本来可以抢占优先级为4的线程A,但是因为线程C不能在CPUO上运行，所以 调度程序也不能抢占线程A。
这说明设置线程的硬关联将影响调度程序的调度方案。
有时候强制一个线程只使用特定的某个CPU并不是什么好主意。例如，可能有三个线程都 只能使用CPUO,而CPU 1, CPU 2和CPU 3却无所事事。如果能够告诉系统，我们想让 一个线程运行在一个CPU上，但系统允许将它移到另一个空闲的CPU,那就更好了。
要给线程设置一个理想的CPU,可以调用SetThreadldealProcessor：
DWORD SetThreadldealProcessor(
HANDLE hThread,
DWORD dwldealProcessor)；
hThread参数表示要设置CPU的线程。但是，与所有前面讨论过的函数不一样的是， dwIdealProcessor不是位掩码，它是一个0到31/63之间的整数,表示线程希望设置的CPU。 可以传入一个MAXIMUM_PROCESSORS值(WinNT.h中定义，在32位操作系统中定义 为32, 64位操作系统中定义为64),表示线程没有理想CPUo函数返回之前的理想CPU, 如果线程没有设置理想CPU,则返回MAXIMUM_PROCESSORS。
我们还可以在可执行文件的头部设置处理器关联性。奇怪的是，似乎没有哪个链接器开关允 许我们这样做，但我们可以使用与下面类似的代码，它利用了 ImageHlp.h中声明的一些函数: // Load the EXE into memory.
PLOADED_IMAGE pLoadedlmage = ImageLoad(szExeNamez NULL);
// Get the current load configuration information for the EXE. IMAGE_LOAD__CONFIG_DIRECTORY ilcd;
GetImageConfiglnformation(pLoadedlmage, &ilcd);
// Change the processor affinity mask.
ilcd.ProcessAffinityMask = 0x00000003; // I desire CPUs 0 and 1
// Save the new load configuration information.
SetImageConfiglnformation(pLoadedlmage, &ilcd);
// Unload the EXE from memory ImageUnload(pLoadedlmage);
在此不详细解释所有这些函数，如果有读者感兴趣，可以查看Platform SDK文档。
最后还要说的是，Windows任务管理器允许我们更改进程的CPU关联性。具体做法是先选 择一个进程，然后在其上下文菜单进行更改。如果系统是在一台多处理器计算机上运行， 可以看到Set Affinity菜单项(在单处理器计算机上没有)。选择这个菜单项后，可以看到下 图所示的对话框，在其中可以选择已选进程中的线程可以在那个CPU上运行。
B^^dows核心编程（第5版）
当Windows Vista在x86计算机上启动时，我们可以限制系统将使用的CPU数量。在 启动过程中，系统将检查启动配置数据（boot configuration data, BCD）, BCD是一个 取代老的boot.ini文本文件的数据存库（data store）,它在计算机的硬件和固件之上提 供了 一个抽象层。关于BCD有一篇非常详细的白皮书，可以在 http://www.microsoft.com/whdc/system/platfbnn/firmware/bcd.mspx 访 问。
BCD的编程配置是通过WMI（Windows Management Instrumentation）实现的，但其大多数常 见的参数可以通过图形界面来访问。要限制Windows所用的CPU数量，需要打开控制面 板，在 Administrative Tools（管理工具）中选择 System Configuration（系统配置）。在 Boot（启 动）选项卡中，单击Advanced（高级）按钮，可以选中Number of Processor（处理器数目）复选 框，选择所需的数量即可。
第8章用户模式下的线程同步
—_.一二_ …一 _七 _ _ ：二—二一 二一 •. 一 __
本章内容
8.1原子访问：Interlocked系列函数
8.2	高速缓存
粉"篱疝楠
8.4	关键段
8.5	Slim读/写锁
8.6条件变量
当所有的线程都能够独自运行而不需要相互通信的时候，Microsoft Windows将进入最佳运 行状态。但是，很少有线程能够总是独自运行。通常创建线程是为了处理某些任务，当任 务完成的时候，另一个线程可能想要得到通知。
系统中所有的线程必须访问系统资源，比如堆、串口、文件、窗口以及无数其他资源。如 果一个线程独占了对某个资源的访问，那么其他线程就无法完成它们的工作。另一方面， 我们也不能让任何线程在任何时刻都能访问任何资源。设想有一个线程正在写入一块内存, 而同时另一个线程正在从同一块内存中读取数据。这就好比是一个人在另一个人读书的时 候修改书中的文字一样，书中的内容将变得乱七八糟，毫无用处。
在以下两种基本情况下，线程之间需要相互通信。
•	需要让多个线程同时访问一个共享资源，同时不能破坏资源的完整性。
•	一个线程需要通知其他线程某项任务已经完成。
线程同步包括许多方面，我们会在下面的几章中进行讨论。好消息是Microsoft Windows 提供了许多基础设施，可以让线程同步变得容易。但坏消息是我们很难预见一堆线程在任 一时刻打算做什么。我们大脑的工作方式不是异步的，我们习惯一次一步地按次序考虑问 题，但这不是多线程环境的运作方式。
我最早开始使用多线程大概是在1992年。一开始，我在编写程序时犯了许多错误，甚至还 出版了一些书和杂志文章，其中不乏与线程同步有关的缺陷。现在，我已经比当时熟练得 多，虽然还谈不上完美，但我相信本书中的一切都不存在缺陷。想要熟练掌握线程同步， 唯一途径就是实际使用。在下面几章中，我们会解释系统的运作方式，并展示如何以正确 的方式在线程间进行同步。现在让我们面对现实，在积累经验的过程中我们会犯这样那样 的错误，但这并没有什么大不了的。
>207
Windows核心编程(第5版)
8.1原子访问：Interlocked系列函数
线程同步的一大部分与原子访问(atomic access)有关。所谓原子访问，指的是一个线程在访 问某个资源的同时能够保证没有其他线程会在同一时刻访问同一资源。现在让我们来看一 个简单的例子：
// Define a global variable, long g_x = 0;
DWORD WINAPI ThreadFuncl(PVOID pvParam) ( g_x++； return(0);
DWORD WINAPI ThreadFunc2(PVOID pvParam) g_x++;
return(0);
代码中声明了一个全局变量并将它初始化为0o现在假设我们创建了两个线程，一个 线程执行ThreadFuncl,另一个线程执行ThreadFunc2o这两个函数中的代码完全相同： 它们都把全局变Mg_x加1。因此当两个线程都停止运行的时候，我们可能认为g_x的值 会是2。但真的是这样吗？答案是有可能。根据代码的编写方式，我们无法确切地知道gjc 最终会等于几，下面就是原因。假设编洋器在编译将g_x递增的那行代码时，生成了下面 的汇编代码：
MOV EAX, [g_x] INC EAX
MOV [g_x], EAX
;Move the value in g_x into a register.
;Increment the value in the register.
;Store the new value back in g_x.
两个线程不太可能在完全相同的时刻执行上面的代码。因此如果一个线程先执行，另一个 线程随后执行，那么下面将是执行的结果：
MOV
INC
MOV
EAX, [g_x]
EAX
EAX
;Thread 1:
；Thread 1:
;Thread 1:
Move 0 into a register.
Increment the register to 1.
Store 1 back in g_x.
MOV
INC
MOV
EAX, [g_x]
EAX
[g_x], EAX
;Thread ;Thread
;Thread
2: Move 1 into a register.
2: Increment the register to 2.
2: Store 2 back in g_x.
当两个线程把g_x递增的操作完成后，g_x的值是2。这非常好，和我们预计的完全相同： 先等于0,然后加1两次，最终的答案是2。漂亮！但等一会儿，由于Windows是一个抢 占式的多线程环境，因此系统可能会在任一时刻暂停执行一个线程，切换到另一个线程并 让新的线程继续执行。因为这个原因，前面的代码可能不会严格按照前面显示的顺序执行, 而可能会按照下面的顺序执行：
MOV
INC
EAX, [g_x]
EAX
;Thread 1
;Thread 1
1: Move 0 into a register.
1: Increment the register to 1.
MOV
INC
MOV
EAX, [g_x] EAX
[g_x], EAX
;Thread
;Thread
;Thread
2:
2:
2:
Move 0 into a register.
Increment the register to Store 1 back in g_x.
第8章 用户模式下的线程同步
MOV [g_x], EAX
;Thread 1: Store 1 back in g_x.
礴 208 b
如果代码按照这种顺序来执行的话，那么g_x最终的值将是1——而不是我们预计的2!这 听起来非常吓人，尤其是我们几乎无法对线程调度器进行控制。事实上，如果我们有100 个线程，每个线程都执行类似的函数，那么当所有线程都结束运行后，g_x的值可能还是1! 显然，软件开发人员不能在这样的环境中开发。我们希望在所有的时候对0进行两次加1 操作的结果都是2。另外，我们不要忘记，编译器如何生成代码，代码在什么CPU上运行， 机器上装配了多少个CPU,所有这些都可能会导致不同的结果。这就是开发和运行环境， 我们无法对它们进行控制。但是，Windows也确实提供了一些函数，只要使用得当，就能 够保证得到我们预期的结果。
为了解决刚才的问题，我们需要一些简单的方案。我们需要有一种方法能够保证对一个值 的递增操作是原子操作——也就是说，不会被打断。Interlocked系列函数提供了我们需要 的解决方案。虽然这些Interlocked函数非常有用，也很容易理解，但大多数软件开发人员 对它们心存畏惧，并没有充分地利用它们。所有这些函数会以原子方式来操控一个值。让 我们来看看InterlockedExchangeAdd以及它用来对LONGLONG类型进行操控的兄弟函 数 InterlockedExchangeAdd64：
LONG InterlockedExchangeAdd(
PLONG volatile plAddend,
LONG 1Increment)；
LONGLONG InterlockedExchangeAdd64(
PLONGLONG volatile pl1Addend,
LONGLONG lllncrement)；
还有什么方法能比这更简单吗？只要调用这个函数，传一个长整型变量的地址和另一个增 量值，函数就会保证递增操作是以原子方式进行的。因此我们可以把前面的代码改写成下 面的代码：
// Define a global variable.
long g_x = 0;
DWORD WINAPI ThreadFuncl(PVOID pvParam) (
InterlockedExchangeAdd(&g_x, 1)；
return(0);
DWORD WINAPI ThreadFunc2(PVOID pvParam) (
InterlockedExchangeAdd(&g_x, 1)； return(0)；
经过这个微小的改动，对g_x的递增会以原子方式进行，我们也因此能够保证最终的 值将等于2o注意，如果只想以原子方式给一个值加1的话，也可以使用 Interlockedlncrement函数。现在是不是已经感觉好些了？要注意的是，所有线程都应该调 用这些函数来修改共享变量的值，任何一个线程都不应该使用简单的C++语句来修改共享 变量：
ows核心编程(第5版)
// The long variable shared by many threads
LONG g_x；...
// Incorrect way to increment the long
g_x++；...
// Correct way to increment Che long
InterlockedExchangeAdd(&g_x, 1)；
这些Interlocked函数又是如何工作的呢？答案取决于代码运行的CPU平台。如果是x86系 列CPU,那么Interlocked函数会在总线上维持一个硬件信号，这个信号会阻止其他CPU 访问同一个内存地址。
我们并不需要理解Interlocked函数具体是如何工作的。重要的是无论编译器如何生成代码, 无论机器上装配了多少个CPU,这些函数都能够保证对值的修改是以原子方式进行的。我 们必须确保传给这些函数的变量地址是经过对齐的，否则这些函数可能会失败。(我们会在 第13章中对此进行讨论。)
说明 C运行库提供了 一个_aligned_malloc函数，我们可以用这个函数来分配一块对齐过 的内存。下面是函数的原型：
void * _aligned_malloc(size_t size, size_t alignment);
参数size表示要分配的字节数，参数alignment表示要对齐到的字节边界。传给 alignment参数的值必须是2的整数篆次方。
关于Interlocked函数，我们需要知道的另一个要点就是它们执行得极快。调用一次 Interlocked函数通常只占用几个CPU周期(通常小于50),而且也不需要在用户模式和内核 模式之间进行切换(这个切换通常需要占用1000个周期以上)。
当然，我们也可以用InterlockedExchangeAdd来做减 ---------只要在第二个参数中传一个负
值就行了。InterlockedExchangeAdd 会返回*plAddend 中原来的值。
下面是其他3个Interlocked函数：
LONG InterlockedExchange(
PLONG volatile plTarget,
LONG lvalue);
LONGLONG InterlockedExchange64(
PLONGLONG volatile plTarget,
LONGLONG lvalue);
PVOID InterlockedExchangePointer(
PVOID* volatile ppvTarget,
PVOID pvValue);
InterlockedExchange和InterlockedExchangePointer会把第一个参数所指向的内存地址的 当前值，以原子方式替换为第二个参数指定的值。对32位应用程序来说，这两个函数都用 一个32位值替换另一个32位值，但对64位应用程序来说，InterlockedExchange替换的 是32位值，而InterlockedExchangePointer替换的是64位值。这两个函数都会返回原来
第8章用户模式下的线程同步
的值。在实现旋转锁(spinlock)的时候，InterlockedExchange极其有用：
// Global variable indicating whether a shared resource is in use or not
BOOL g_fResourceInUse = FALSE;...
void Func1() (
// Wait to access the resource.
while (InterlockedExchange (&g_fResourceInUse, TRUE) == TRUE) Sleep(O);
// Access the resource.
// We no longer need to access the resource.
InterlockedExchange(&g_fResourceInUse, FALSE)；
}
while循环不停地运行，把g^fResourcelnUse的值设为TRUE并检查原来的值是否为 TRUEo如果原来的值为FALSE,那说明资源尚未被使用，于是调用线程立刻就能将它设 成“使用中”，然后退出循环。如果原来的值是TRUE,那说明有其他的线程正在使用该 资源，于是while循环会继续执行。
如果另一个线程也执行类似的代码，那么它会一直执行while循环，直到g^fResourcelnUse 被改回FALSEo函数最后对InterlockedExchange的调用展示了如何将g_fResourceInUse 设回FALSE o
在使用这项技术的时候要极其小心，这是因为旋转锁会耗费CPU时间。CPU必须不断地比 较两个值，直到另一个线程“神奇地”改变了其中一个值为止。而且，这里的代码假定所 有使用旋转锁的线程都以相同的优先级运行。对那些用到旋转锁的线程来说，我们可能想 要(调用 SetProcessPriorityBoost 或 SetThreadPriorityBoost 来)禁用线程优先级提升(thread priority boosting) o
此外，我们必须确保锁变量和锁所保护的数据位于不同的高速缓存行(本章稍后会介绍)中。 如果锁变量和数据共享同一高速缓存行，那么使用资源的CPU就会与任何试图访问资源的 CPU发生争夺，而这会影响性能。
在单CPU的机器上应该避免使用旋转锁。如果一个线程不停地循环，那么这不仅会浪费宝 贵的CPU时间，而且会阻止其他线程改变锁的值。前面的代码在while循环中使用了 Sleep, 这在某种程度上改善了这一状况。如果使用Sleep,那么可以睡眠一段随机的时间，当每次 对资源的访问被拒绝的时候，可以进一步增加睡眠的时间。这可以避免让线程浪费CPU时 间。取决于实际情况，把Sleep调用完全去掉可能会更好。或者可以将之替换为对 SwitchToThread的调用。虽然我讨厌这么说，但反复试验可能是找到最优方案的最佳途径。
211
旋转锁假定被保护的资源始终只会被占用一小段时间。与切换到内核模式然后等待相比， 在这种情况下以循环的方式进行等待的效率会更高。许多开发人员会循环指定的次数(比如 4000),如果届时仍然无法访问资源，那么线程会切换到内核模式，并一直等到资源可供使 用为止(此时它不消耗CPU时间)。这就是关键段(critical section)的实现方式。
在多处理器的机器上旋转锁比较有用，这是因为当一个线程在一个CPU上运行的时候，另
indows核心编程(第5版)
一个线程可以在另一个CPU±循环等待。但是，即使在这种情况下，我们还是必须小心。 我们并不希望一个线程循环很长一段时间，不然会浪费更多的CPU时间。本章稍后我们还 会进一步讨论旋转锁。
下面是最后两个Interlocked交换函数：
PVOID InterlockedCompareExchange(
PLONG plDesCination,
LONG 1Exchange,
LONG 1Comparand);
PVOID InterlockedCompareExchangePointer(
PVOID* ppvDestination,
PVOID pvExchange,
PVOID pvComparand)；
这两个函数以原子方式执行一个测试和设置操作。对32位应用程序来说，这两个函数都对 32位值进行操作，但在64位应用程序中，InterlockedCompareExchange对32位值进行操 作ifij InterlockedCompareExchangePointer对64位值进行操作。下面的伪代码描述了 InterlockedCompareExchange 函数到底做了些什么：
LONG InterlockedCompareExchange(PLONG plDestination,
LONG 1Exchange, LONG IComparand) (
LONG IRet = *plDestination； // Original value
if (*plDestination == IComparand)
*plDestination = 1Exchange；
return(IRet)；
}
函数会将(参数plDestination指向的)当前值与参数IComparand的值进行比较。如果两个 值相同，那么函数会将*plDestination修改为［Exchange参数的值。如果*plDestination的 值不等于IComparand»那么*plDestination将保持不变。函数会返回*plDestination原来的 值。记住，所有这些操作是作为一个原子执行单元来完成的。注意现在这两个函数还有另 外一个版本，可以用来处理已对齐的64位值：
LONGLONG InterlockedCompareExchange64(
LONGLONG pllDestination,
LONGLONG 11Exchange,
LONGLONG 1IComparand);
O 没有哪个Interlocked函数可以仅用来读取一个值(但又不修改它)，这是因为这样的功能没 有必要。如果线程只需要读取一个值的内容，而这个值始终是通过Interlocked函数修改的, 那么读到的值不会有任何问题。虽然我们并不知道读到值的是原始值还是更新后的值，但 我们知道它肯定是其中之一。对大多数应用程序来说，这已经足够了。此外，当多个进程 需要对访问一个共享内存段(比如内存映射文件)中的值进行同步时，也可以使用Interlocked 函数。(第9章包括几个示例程序，展示了如何使用Interlocked函数。)
Windows还提供了其他一些Interlocked函数，但前面介绍的函数已经提供了其他函数能够 提供的所有功能，甚至还更多。下面是其他两个函数：
第8章用户模式下的线程同步
LONG Interlockedlncrement(PLONG plAddend);
LONG InterlockedDecrement(PLONG plAddend);
InterlockedExchangeAdd可以代替这两个旧函数。新函数可以加减任何值，而I日函数则只 能加减1。还有另一组基于InterlockedCompareExchange64的OR, AND和XOR辅助函 数可供我们使用。它们使用了我们在前面己经见到过的旋转锁，下面这段代码就是其中一 个函数的实现，所有这些函数的实现都可以在WinBase.h文件中找到：
LONGLONG InterlockedAnd64(
LONGLONG* Destination,
LONGLONG Value) (
LONGLONG Old;
do (
Old = *Destination;
} while (InterlockedCompareExchange64(Destinatior., Old & Value, Old) != Old)；
return Old；
}
从Windows XP开始，除了能对整数或布尔值进行这些原子操作外，我们还能使用一系列 其他的函数来对一种被称为Interlocked单向链表的栈进行操作。栈中的每个操作，比如入 栈或出栈，必定是以原子方式进行的。表8-1列出了 Interlocked单向链表提供的函数。
表8-1 Interlocked单向链表函数
函数	描述
InitializeSListHead	创建一个空栈
InterlockedPushEntrySList	在栈顶添加、个元素
InterlockedPopEntrySList	移除位于栈顶的元素并将它返回
InterlockedFlushSList	清空栈
QueryDepthSList	返回栈中元素的数量
213
8.2高速缓存行
如果想为装配有多处理器的机器构建高性能应用程序，那么应该注意高速缓存行。当CPU 从内存中读取一个字节的时候，它并不只是从内存中取回一个字节，而是取回一个高速缓 存行。高速缓存行可能包含32字节(老式CPU), 64字节，甚至是128字节(取决于CPU), 它们始终都对齐到32字节边界，64字节边界，或128字节边界。高速缓存行存在的1=1的 是为了提高性能。一般来说，应用程序会对一组相邻的字节进行操作。如果所有字节都在 高速缓存中，那么CPU就不必访问内存总线，后者耗费的时间比前者耗费的时间要多得多。
但是，在多处理器环境中，高速缓存线使得对内存的更新变得更加困难。我们可以从下面 的例子中体会到这一点。
|^^ndows核心编程(第5版)
(1)	CPU1读取一个字节，这使得该字节以及与它相邻的字节被读到CPU1的高速缓存行中。
(2)	CPU2读取同一个字节，这使得该字节被读到CPU2的高速缓存行中。
(3)	CPU1对内存中的这个字节进行修改，这使得该字节被写入到CPU1的高速缓存行中。 但这一信息还没有写回到内存。
(4)	CPU2再次读取同一个字节。由于该字节已经在CPU2的高速缓存行中，因此CPU2 不需要再访问内存。但CPU2将无法看到该字节在内存中新的值。
这种情形非常糟糕。当然，CPU芯片的设计者非常清楚这个问题，并做了专门的设计来对 它进行处理。明确地说，当一个CPU修改了高速缓存行中的一个字节时，机器中的其他 CPU会收到通知，并使自己的高速缓存行作废。因此在刚才的情形中，当CPU1修改该字 节的值时，CPU2的高速缓存就作废了。在第4步中，CPU1必须将它的高速缓存写回到内 存中，CPU2必须重新访问内存来填满它的高速缓存行。我们可以看到，虽然高速缓存行 能够提高性能，但在多处理器的机器上它们同样能够损伤性能。
这一切都意味着我们应该根据高速缓存行的大小来将应用程序的数据组织在一起，并将数 据与缓存行的边界对齐。这样做的目的是为了确保不同的CPU能够各自访问不同的内存地 址，而且这些地址不在同一个高速缓存行中。此外，我们应该把只读数据(或不经常读的数 据)与可读写数据分别存放。我们还应该把差不多会在同一时间访问的数据组织在一起。
下面这个例子是一个设计得非常糟糕的数据结构：
struct CUSTINFO (
DWORD dwCustomerlD； int nBalanceDue； wchar_t szName[100]； FILETIME ftLastOrderDate； )；
// Mostly read-only // Read-write
// Mostly read-only // Read-write
要想确定CPU高速缓存行的大小,最简单的方法是调用Win32的GetLogicalProcessorlnfbnnation 函数。这个函数会返回一个SYSTEM_LOGICAL_PROCESSOR_INFORMATION结构数 组。我们可以检查每个结构的Cache字段，该成员是一个CACHE__DESCRIPTOR结构， 其中的LineSize字段表示CPU的高速缓存行的大小。一旦有了这一信息，我们就可以使用 C/C++编译器的_declspec(align(#))^示符来对字段对齐加以控制。下面是前述结构经过改 进后的版本：
■define CACHE_ALIGN 64
// Force each structure to be in a different cache line, struct _declspec(align(CACHE_ALIGN)) CUSTINFO {
DWORD dwCustomerlD；	// Mostly read-only
wchar_t szName[100]；	// Mostly read-only
// Force the following members to be in a different cache line.
_declspec(align(CACHE_ALIGN))
int nBalanceDue；	// Read-write
FILETIME ftLastOrderDate；	// Read-write
}；
214-215
有关如何使用_declspec(align(#))指示符的详细信息，请参阅http://msdn2.microsoft.com/
第8章用户模式下的线程同步
en-us/library/83ythb65.aspxo
说明 最好是始终只让一个线程访问数据（函数参数和局部变量是确保这一点的最简单方 式），或者始终只让一个CPU访问数据（使用线程关系，即thread affinity）o只要能做 到其中任何一条，就可以完全避免高速缓存行的问题了。
8.3高级线程同步
如果只需要以原子方式修改一个值，那么Interlocked系列函数非常好用，我们当然应该优 先使用它们。但大多数实际的编程问题需要处理的数据结构往往要比一个简单的32位值或 64位值复杂得多。为了能够以“原子”方式来访问复杂数据结构，我们必须超越Interlocked 系列函数，转而使用Windows提供的一些其他特性。
前面一节强调了在配备单处理器的机器上不应该使用旋转锁，即使在配备多处理器的机器 上，在使用旋转锁的时候也应该谨慎。原因很简单，浪费CPU时间是件非常糟糕的事情。 因此，我们需要一种机制，它既能让线程等待共享资源的访问权，又不会浪费CPU时间。
当线程想要访问一个共享资源或者想要得到一些“特殊事件”的通知时，线程必须调用操 作系统的一个函数，并将线程正在等待的东西作为参数传入。如果操作系统检测到资源已 经可供使用了，或者特殊事件已经发生了，那么这个函数会立即返回，这样线程将仍然保 持可调度状态。（线程可能并不会立即运行，它是可调度的，系统会根据前一章中描述的规 则来给它分配CPU时间。）
如果无法取得对资源的访问权，或者特殊事件尚未发生，那么系统会将线程切换到等待状 态，使线程变得不可调度，从而避免了让线程浪费CPU时间。当线程在等待的时候，系统 会充当它的代理。系统会记住线程想要访问什么资源，当资源可供使用的时候，它会自动 将线程唤醒——线程的执行与特殊事件是同步的。
实际情况是，大多数线程在大部分情况下都处于等待状态。当系统检测到所有线程都已经 在等待状态中度过了好几分钟的时候，系统的电源管理器将会介入。
需要避免使用的一种方法
如果没有同步对象，如果操作系统不能对特殊事件进行监测，那么线程将不得不使用下面 介绍的技术来在自己和特殊事件之间进行同步。但是，由于操作系统内建了对线程同步的 支持，因此我们在任何时候都不应该使用这种方法。
在这种方法中，两个线程共享一个变量，其中一个线程不断地读取变量的值，直到另一个 线程完成它的任务为止。下面这段代码展示了这种方法：
volatile BOOL g_fFinishedCalculation = FALSE；
lows核心编程(第5版)
int WINAPI _tWinMain(...) (
CreateThread(..., RecalcFunc,...);
// Wait for the recalculation to complete. while (!g_fFinishedCalculation)
DWORD WINAPI RecalcFunc(PVOID pvParam) (
// Perform the recalculation.
... g_fFinishedCalculation = TRUE；
return(0)；
)
正如我们所看到的那样，当主线程(执行_tWinMain)M要等待RecalcFunc函数完成的时候, 它并没有让自己进入睡眠状态。由于主线程没有进入睡眠状态，因此CPU不断地给它调度 CPU时间，这就从其他线程手中夺走了宝贵的CPU时间。
刚才这段代码还存在另一个问题，即布尔变量g_fFinishedCalculation可能永远不会被设为 TRUE。如果主线程的优先级比RecalcFunc函数所在线程的优先级高，那么就可能发生这 种情况。在这种情况下，系统不会分配任何时间片给RecalcFunc所在线程，因此把 g_fFiiiishedCalculation设为TRUE的语句永远不会执行。如果_tWinMain函数所在线程 不进行轮询，而是进入睡眠，那么系统就不必给它调度时间，从而有机会把时间调度给低 优先级的线程(比如RecalcFunc所在线程)，让它们得以执行。
不可否认，轮循有时候还是非常方便的，毕竟旋转锁就是这么做的。但即便如此，也还是 有正确的方式和不正确的方式。一个通用的规则是，我们既不应该使用旋转锁，也不应该 进行轮循，而应该调用函数把线程切换到等待状态，直到线程想要访问的资源可供使用为 止。我们会在下一节对正确的方式进行介绍。
首先，还有一点必须指出：在刚才那段代码的顶部，我们可以注意到使用了 volatile关键字。 为了使前面这段代码能够正常工作，volatHe类型限定符是不可或缺的。它告诉编译器这个 变量可.能会被应用程序之外的其他东西修改，比如操作系统、硬件或者一个并发执行的线 程。确切地说，volatile限定符告诉编译器不要对这个变量进行任何形式的优化，而是始终 从变量在内存中的位置读取变量的值。现在假设编译器为刚才那段代码中的while循环生 成了下面的伪代码：
MOV RegO, (g_fFinishedCalculation]	； Copy the value into a register
Label: TEST RegO, 0	; Is the value 0?
JMP RegO == 0, Label	; The register is 0, try again
...	; The register is not 0 (end of loop)
^16-217
如果不给布尔变量加上volatHe限定符，编译器可能会对C++代码进行优化，就像这里显 示的那样。在这个优化中，编译器把布尔变量的值载入到CPU寄存器中，这个操作只需要 进行一次。然后它重复对CPU寄存器中的值进行测试。与每次都从变量所在的内存地址取 得变量的值并进行测试相比，这样做当然能够得到更好的性能。因此，一个编译器可能会 把代码优化成刚才显示的那样。但是，如果编译器进行此类优化，那么线程会陷入无限循 环。顺便提一下，给一个结构加volatile限定符等于给结构中所有的成员都加volatile限定
第8章 用户模式下的线程同步
符，这样可以确保任何一个成员始终都是从内存中读取的。
读者可能会感到迷惑，那么(在前面旋转锁代码中用到的)旋转锁变量&_fResourceInUse是 不是也应该声明为volatUe呢？回答是否定的。这是因为我们传给Interlocked函数的是变 量的地址，而不是变量的值。如果传一个变量的地址给函数，那么函数必须从内存中读取 它的值，编译器的优化程序不会对此产生影响。
8.4关键段
关键段(critical section)是一小段代码，它在执行之前需要独占对一些共享资源的访问权。这 种方式可以让多行代码以“原子方式”来对资源进行操控。这里的原子方式，指的是代码 知道除了当前线程之外，没有其他任何线程会同时访问该资源。当然，系统仍然可以暂停 当前线程去调度其他线程。但是，在当前线程离开关键段之前，系统是不会去调度任何想 要访问同一资源的其他线程的。
下面是一些有问题的代码，用来展示不使用关键段时会出现什么情况：
const int COUNT = 1000；
int g_nSum = 0;
DWORD WINAPI FirstThread(PVOID pvParam) (
g_nSum = 0;
for (int n = 1； n <= COUNT； n++) (
g_nSum += n;
}
return(g_nSum)；
DWORD WINAPI SecondThread(PVOID pvParam) {
g_nSum = 0;
for (int n = 1； n <= COUNT; n++) {
g_nSum += n；
)
return(g_nSum);
}
■
如果分开考虑，那么这两个线程函数都应该产生相同的结果(因为它们的代码完全相同)。 如果只运行FirstThread函数，那么它会累加0到COUNT之间的所有数值。如果只运行 SecondThread函数，那么它会执行完全相同的操作。但是，由于两个线程都要访问同一个 共享变量(g_nSum),因此如果两个线程在同一时刻执行(可能在不同的CPU ±),那么每个 线程都等于是在另一个线程背后修改g_nSum的值，从而导致不可预料的结果。
不可否认的是，这个例子有些牵强(特别是因为我们可以非常容易地使用g^nSum = COUNT * (COUNT+ 1)/2来计算总和，而不必使用循环)。要举一个更切合实际但又不需要好几页 源代码的例子是比较困难的。但是，我们可以看到这个问题如何能够扩展到实际的例子。 考虑一个管理链表的例子：如果对链表的访问没有同步，那么一个线程可能会在另一个线 程在链表中搜寻一个元素的同时向链表中添加一个元素：如果两个线程同时向链表中添加
♦Widows核心编程(第5版) .
元素，那么这种情况会变得更加混乱。通过使用关键段，我们可以确保各线程对链表数据 结构的访问是经过协调的。
现在我们已经看到了所有的问题，下面用关键段来修正刚才的代码：
const int COUNT = 10;
int g_nSum = 0；
CRITICAL_SECTION g_cs；
DWORD WINAPI FirstThreadfPVOID pvParam) (
EnterCriCicalSection(&g_cs);
g_nSum = 0；
for (int n = 1； n <= COUNT; n++) (
g_nSum += n;
}
LeaveCriticalSection(&g_cs);
return (g_nStiin);
DWORD WINAPI SecondThread(PVOID pvParam) (
EnterCriticalSection(&g_cs);
g_nSum = 0;
for (int n = 1; n <= COUNT; n++) (
g_nSum += n；
}
LeaveCriticalSection(&g_cs);
return(g_nSum)；
)
我们先在代码中定义一个名叫g_cs的CRITICAL_SECTION数据结构，然后把任何需要 访问共享资源(这里是g_nSum)的代码放在EnterCriticalSection和LeaveCriticalSection之 间。注意，在调用 EnterCriticalSection 和 LeaveCriticalSection 的时候，传入的是 g__cs 的 地址。
有哪些关键点需要记住？当我们有一个资源要让多个线程访问的时候，应该创建一个 CRITICAL_SECTION结构。因为我写到这里的时候正好在飞机上，所以请允许我做这样 --个比喻。一个CRITICAL_SECTION结构就像是飞机上的一个卫生间，而马桶则是我们 想要保护的数据。由于卫生间很小，因此在同一时刻只允许一个人(线程)在卫生间(关键段) 内使用马桶(被保护的资源)。
•"做暖航
如果有多个总是应该在一起使用的资源，那么我们可以把它们放到一个“卫生间”中：只 需创建一个CRITICAL_SECTION结构来保护所有这些资源。
如果有多个不总是在-起使用的资源——比如，线程1和线程2访问一个资源，而线程1 和线程3访问另一个资源——那么我们应该为每个资源分别创建一个“卫生间”，也就是 CRITICAL_SECTION 结构。
现在，无论哪里的代码要访问一个资源，我们都必须调用EnterCriticalSection,并传入一 个CRTHCAL_SECTION结构的地址，这个结构用来标识我们要访问的资源。这就好比是 当线程想要访问一个资源的时候，它必须先检查“卫生间”门上的占用标志。
CRITICAL_SECTION结构用来标识线程想要进入的“卫生间”，EnterCriticalSection是
第8章 用户模式下的线程同步
线程用来检查占用标志的函数。
如果EnterCriticalSection发现没有其他线程在“卫生间”中（门上显示为无人），那么它将 允许调用线程进入“卫生间”。如果EnterCriticalSection发现已经有另一个线程在“卫生 间”中，那么调用线程必须在“卫生间”门外等待，直到另一个线程离开“卫生间”为止。
当线程不再需要访问该资源的时候，应该调用LeaveCriticalSectiono线程通过这种方式来 告诉系统它己经离开了资源所在的“卫生间”。如果忘记调用LeaveCriticalSection,那么 系统会认为线程还在“卫生间”中，因此将不允许其他正在等待的线程进入。这相当于离 开卫生间却没有把门上的标志改回“无人”。
注意 最难记住的事情是,任何要访问共享资源的代码,都必须包含在EnterCriticalSection 和LeaveCriticalSection之间。如果忘了哪怕是一个地方，共享资源就有可能被破坏。
例如，如果我们在 FirstThread 中去掉调用 EnterCriticalSection 和 LeaveCriticalSection的代码，那么g__nSum变量就会被破坏。即使第二个线程仍然 在调用 EnterCriticalSection 和 LeaveCriticalSection,也会发生这种情况。
忘记调用EnterCriticalSection和LeaveCriticalSection就好像是未经许可就进入卫生间一 样。线程强行进入并对资源进行操控。正如我们想象的那样，只要有一个线程有这种粗暴 的行为，资源就会被破坏。
t
当不能用Interlocked函数解决同步问题的时候，我们应该试一试关键段。关键段的最大好 处在于它们非常容易使用，而且它们在内部也使用了 Interlocked函数，因此执行速度非常 快。关键段的最大缺点在于它们无法用来在多个进程之间对线程进行同步。
8.4.1关键段：细节
到目前为止，我们已经知道了关键段背后的理论——它们为什么有用以及它们如何允许对 共享资源进行“原子”访问。现在让我们进一步了解关键段是如何工作的。先从 CRITICAL_SECTION数据结构开始。如果在Platform SDK文档中查找这个结构，是找不 到任何东西的。为什么会这样？
这并不是因为CRITICAL_SECTION是个未公开的结构，而是因为Microsoft认为开发人 员并不需要理解这个结构的细节，仅此而已。对我们来说，这个结构是透明的——这个结 构有正式的文档记载，但结构中的成员变量却没有。当然，因为这只不过是一个数据结构, 所以我们可以在Windows的头文件中找到它和它的成员变量。（CRITICAL^SECTION在 WinBase.h 中被定义为 RTL_CRITICAL_SECTION,而 RTL_CRITICAL_SECTION 则在 WinNT.h中定义。）但是，我们绝对不应该在编写代码的时候用到这些成或。
为了对CRITICAL_SECTION结构进行操控，我们必须调用Windows函数，并传入结构 的地址。Windows函数知道如何对结构成员进行操控，也会保证让结构的状态始终保持一
indows核心编程（第5版）
致。现在就让我们来看看这些函数。
一般情况下，我们会将CRITICAL_SECTION结构作为全局变量来分配，这样进程中的所 有线程就能够非常方便地通过变量名来访问这些结构。但是，CRITICAL_SECTION也可 以作为局部变量来分配，或者从堆中动态地分配，另外将它们作为类的一个私有字段来分 配也是很常见的。在使用CRITICAL.SECTION的时候，只有两个必要条件。第一个条件 是所有想要访问资源的线程必须知道用来保护资源的CRITICAL_SECTION结构的地址。 我们可以通过自己喜欢的任何方式来把这个地址传给各个线程。第二个条件是在任何线程 试图访问被保护的资源之前，必须对CRITICAL_SECTION结构的内部成员进行初始化。 下面的函数用来对结构进行初始化：	-
VOID InitializeCriticalSection（PCRITICAL_SECTION pcs）;
这个函数对（pcs指向的）CRITICAL_SECTION结构的成员进行初始化。由于这个函数只不 过是设置一些成员变量，不可能失败，因此它返回的是VOIDo在调用EnterCriticalSection 之前必须调用这个函数。Platform SDK文档里面明确说明了如果线程试图进入一个未经初 始化的CRITICAL_SECTION,那么结果将不可预料。
当知道线程将不再需要访问共享资源的时候，我们应该调用下面的函数来清理 CRITICAL_SECTION 结构：
VOID DeleteCriticalSection（PCRITICAL_SECTION pcs）;
DeleteCriticalSection会重置结构中的成员变量。彳艮自然，如果还有线程正在使用一个关键 段，那么当然不应该删除它。再次重申，Platform SDK文档已经明确说明了这样做将会导 致不可预料的结果。
在对共享资源进行访问之前，必须在代码中先调用下面的函数：
VOID EnterCriticalSection（PCRITICAL_SECTION pcs）;
EnterCriticalSection会检查结构中的成员变量，这些变量表示是否有线程正在访问资源， 以及哪个线程正在访问资源。EnterCriticalSection会执行下面的测试。
•	如果没有线程正在访问资源，那么EnterCriticalSection会更新成员变量，以表示 调用线程己经获准对资源的访问，并立即返回，这样线程就可以继续执行（访问资 源）。
•	如果成员变量表示调用线程已经获准访问资源，那么EnterCriticalSection会更新 变量，以表示调用线程被获准访问的次数，并立即返回，这样线程就可以继续执行。 这种情况非常少见，只有当线程在调用LeaveCriticalSection之前连续调用 EnterCriticalSection两次以上才会发生。
•	如果成员变量表示有一个（调用线程之外的其他）线程己经获准访问资源，那么 EnterCriticalSection会使用一个事件内核对象（会在下一章中进行介绍）来把调用线 程切换到等待状态。这太棒了，因为等待中的线程不会浪费任何CPU时间！系统 会记住这个线程想要访问这个资源，一旦当前正在访问资源的线程调用了
第8章用户模式下的线程同步
LeaveCriticalSection,系统会自动更新CRITICAL__SECTION的成员变量并将等 待中的线程切换回可调度状态。
EnterCriticalSection的内部并不怎么复杂，它只不过是执行了一些简单的测试。这个函数 的价值在于它能够以原子方式执行所有这些测试。在一台装备了多处理器的机器上，如果 两个线程正好在同一时刻调用EnterCriticalSection,那么函数仍然能够正确地执行：一个 线程获准访问资源，另一个线程被切换到等待状态。
如果EnterCriHcalSection把一个线程切换到等待状态，那么在很长一段时间内系统可能不 会去调度这个线程。事实上，在一个编写得非常糟糕的应用程序中，系统可能再也不会给 这个线程调度CPU时间了。如果发生这种情况，我们说线程在挨饿(starved)o
说明 实际的情况是，等待关键段的线程是绝对不会挨饿的。对EnterCriticalSection的调 用最终会超时并引发异常。我们可以将一个调试器连到应用程序上，来检查哪里出 了问题。导致超时的时间长度由下面这个注册表子项中包含的 CriticalSectionTimeout 值决定：
HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager
这个值以秒为单位，它的默认值为2 592 000秒，也就是大约30天。不要把这个值 设得太低(比如小于3秒)，否则会影响到系统中等待关键段的时间通常超过3秒的 那些线程和其他应用程序。
我们也可以用下面的函数来代替EnterCriticalSection:
BOOL TryEnterCriticalSection(PCRITICAL_SECTION pcs);
TryEnterCriticalSection从来不会让调用线程进入等待状态。它会通过返回值来表示调用 线程是否获准访问资源。因此，如果TryEnterCriticalSection发现资源正在被其他线程访 问，那么它会返回FALSE。其他情况下，它会返回TRUEo
通过使用这个函数，线程可以快速地检查它是否能够访问某个共享资源。如果不能访问共 享资源，那么它可以继续做些其他的事情，而不用等待。如果TryEnterCriticalSection返 回TRUE,那么CRITICAL_SECTION的成员变量已经更新过了，以表示该线程正在访问 资源。因此，每个返回值为TRUE的TryEnterCriticalSection调用必须有一个对应的 LeaveCriticalSection。
在代码完成对共享资源的访问后，应该调用下面的函数：
.VOID LeaveCriticalSection(PCRITICAL_SECTION pcs);
LeaveCriticalSection会检查结构内部的成员变量并将计数器减1,该计数器用来表示调用 线程获准访问共享资源的次数。如果计数器大于0, LeaveCriticalSection会直接返回，不 执行任何其他操作。
如果计数器变成了 0, LeaveCriticalSection会更新成员变量，以表示没有任何线程正在访
■ndows核心编程(第5版) 
问被保护的资源。它同时会检查有没有其他线程由于调用了 EnterCriticalSection而处于等 待状态。如果至少有一个线程处于等待状态，那么函数会更新成员变量，把其中一个处于 等待状态的线程切换回可调度状态。与EnterCriticalSection相似，LeaveCriticalSection会 以原子方式执行所有的测试和更新操作。但是，LeaveCriticalSection从来不会把线程切换 到等待状态，它总是立即返回。
8.4.2关键段和旋转锁
当线程试图进入一个关键段，但这个关键段正被另一个线程占用的时候，函数会立即把调 用线程切换到等待状态。这意味着线程必须从用户模式切换到内核模式(大约1000个CPU 周期)，这个切换的开销非常大。在配有多处理器的机器上，当前占用资源的线程可能在另 一个处理器上运行，而且可能很快就会结束对资源的访问。事实上，在需要等待的线程完 全切换到内核模式之前，占用资源的线程可能就已经释放了资源。如果发生这种情况，那 会浪费大量的CPU时间。
为了提高关键段的性能，Microsoft把旋转锁合并到了关键段中。因此，当调用 EnterCriticalSection的时候，它会用一个旋转锁不断地循环，尝试在一段时间内获得对资 源的访问权。只有当尝试失败的时候，线程才会切换到内核模式并进入等待状态。
为了在使用关键段的时候同时使用旋转锁，我们必须调用下面的函数来初始化关键段：
BOOL InitializeCriticalSectionAndSpinCount(
PCRITICAL_SECTION pcs,
DWORD dwSpinCount);
与 InitializerriticalSection 相似,InitializeCriticalSectionAndSpinCount 的第一个参数是关 键段结构的地址。第二个参数dwSpinCount是我们希望旋转锁循环的次数。在把线程切换 到等待状态之前，函数会先尝试用旋转锁来获得对资源的访问权。这个值可以是从0到 OxOOFFFFFF之间的任何一个值。如果我们在单处理器的机器上调用这个函数，那么函数会 忽略dwSpinCount参数，因此次数总是为0。这样做是有好处的，因为在单处理器的机器 上设置循环次数毫无用处：如果一个线程正在循环，那么占用资源的线程将没有机会放弃 对资源的访问权。
222
我们可以调用下面的函数来改变关键段的旋转次数：
DWORD SetCriticalSectionSpinCount(
PCRITICAL_SECTION pcs,
DWORD dwSpinCount);
再次重申，如果主机只有一个处理器，函数会忽略dwSpinCount参数。
依我看来，我们应该总是在使用关键段的时候同时使用旋转锁，因为这样做不会损失任何 东西。难点在于如何确定传给dwSpinCount参数的值。为了得到最佳性能，最简单的方法 就是尝试各种数值，直到对性能感到满意为止。用来保护进程堆的关键段所使用的旋转次
第8章用户模式下的线程同步
数大约是4000,这可以作为我们的一个参考值。
8.4.3关键段和错误处理
有一种情况下InitializeCriticalSection函数会失败，不过这种可能性很小。Microsoft在最 初设计这个函数的时候并没有真正考虑到这个问题，这也是为什么函数返回的是VOIDo 这个函数可能会失败的原因是它会分配一块内存，这样系统就可以提供一些内部调试信息。 如果内存分配失败，那么函数会抛出STATUS_NO_MEMORY异常。我们可以使用结构 化异常（参见第23〜25章）来捕获这个异常。
我们可以使用InitializeCriticalSectionAndSpinCount函数来更容易地发现这个问题。这个 函数也会为调试信息分配一块内存，但如果内存分配不成功，它会返回FALSEo
在使用关键段的时候还可能产生另一个问题。如果有两个或两个以上线程在同一时刻争夺 同一个关键段，那么关键段会在内部使用一个事件内核对象。由于争夺现象很少发生，因 此只有当第一次要用到事件内核对象的时候，系统才会真正创建它。因为大多数关键段从 来都不会发生争夺现象，所以这样做可以节省大量的系统资源。顺便提一下，只有在调用 DeleteCriticalSection的时候，系统才会释放这个事件内核对象。因此，当用完关键段之后， 绝对不应该忘记调用DeleteCriticalSectiono
Windows XP之前，在内存不足的情况下，可能会发生争夺关键段的现象，这时系统可能无 法创建所需的事件内核对象。在这种时候EnterCriticalSection函数会抛出 EXCEPTIONJNVALID_HANDLE异常。由于这种错误是极其罕见的，因此大部分开发 人员会在代码中忽略这个潜在的错误，不进行任何特殊处理。但是，如果打算对这种情况 进行处理，那么我们有两种选择。
我们可以使用结构化异常处理来捕获错误。当错误发生的时候，我们既可以不访问受关键 段保护的资源，也可以等到有更多可用内存的时候再调用EnterCriticalSectiono
另一种选择是使用InitializeCriticalSectionAndSpinCount来创建关键段，并将 dwSpinCount参数的最高位设为1。当函数看到参数的最高位为1的时候，会在初始化时 就创建一个与关键段相关联的事件内核对象。如果无法创建事件内核对象，那么函数会返 回FALSE,我们可以在代码中更得体地对此进行处理。如果成功创建了事件内核对象，那 么我们就知道EnterCriticalSection将总是可以正常工作，绝不会抛出异常。（总是事先创 建事件内核对象可能会浪费系统资源。只有在以下三种情况下才应该这样做：第一，我们 不能接受调用EnterCriticalSection失败；第二，我们知道争夺现象一定会发生；第三，我 们预计进程会在内存不足的环境下运行。）
223*224
自从Windows XP开始，引入了新的有键事件（keyed event）类型的内核对象，用来帮 助解决在资源不足的情况下创建事件的问题。当操作系统创建进程的时候，总是会创 建一个有键事件，我们可以使用Sysintemals的Process Explorer工具
indows核心编程(第5版)
(http://www.microsoft.com/technet/sysintemals/utilities/ProcessExplorer.mspx)S 易地找至 U 这个 名叫\KemelObjects\CritSecOutOfMemoryEvent的实例。这个未公开的内核对象的行为与事 件内核对象相同，唯一的不同之处在于它的一个实例能够同步不同的线程组，每组由一个 指针大小的键值(key)来标识和阻挡。在关键段的情况中，当内存少到不足以创建一个事件 内核对象的时候，可以将关键段的地址当作键值来使用。通过将关键段的地址当作键值 来使用，系统可以对试图进入这个关键段的线程进行同步，并在必要的情况下将它们阻挡 在外。
8.5	Slim读/写锁
SRWLock的目的和关键段相同：对一个资源进行保护，不让其他线程访问它。但是，与 关键段不同的是，SRWLock允许我们区分那些想要读取资源的值的线程(读取者线程)和想 要更新资源的值的线程(写入者线程)。让所有的读取者线程在同一时刻访问共享资源应该 是可行的，这是因为仅仅读取资源的值并不存在破坏数据的风险。只有当写入者线程想要 对资源进行更新的时候才需要进行同步。在这种情况下，•写入者线程应该独占对资源的访 问权：任何其他线程，无论是读取者线程还是写入者线程，都不允许访问资源。这就是 SRWLock提供的全部功能，我们可以在代码中以一种非常清晰的方式来使用它。
首先，我们需要分配一个SRWLOCK结构并用InitializeSRWLock函数对它进行初始化：
VOID InitializeSRWLock(PSRWLOCK SRWLock);
SRWLOCK结构在WinBase.h中被定义为RTL_SRWLOCK。后者在 WinNT.h中定义， 它只包含一个指向其他东西的指针。但是，指针指向的东西是完全未公开的，因此我们不 能编写代码来访问它(这一点与CRITICAL_SECTION中的字段有所不同)。
typedef struct _RTL_SRWLOCK {
PVOID Ptr；
} RTL_SRWLOCK, *PRTL_SRWLOCK;
一旦SRWLock的初始化完成之后，写入者线程就可以调用AcquireSRWLockExclusive, 将SRWLOCK对象的地址作为参数传入，以尝试获得对被保护的资源的独占访问权。
VOID AcquireSRWLockExclusive(PSRWLOCK SRWLock);
完成对资源的更新之后，应该调用ReleaseSRWLockExclusive,并将SRWLOCK对象的 地址作为参数传入，这样就解除了对资源的锁定。
VOID ReleaseSRWLockExclusive(PSRWLOCK SRWLock)；
对读取者线程来说，同样有两个步骤，但调用的是下面两个新的函数：
VOID AcquireSRWLockShared(PSRWLOCK SRWLock)；
VOID ReleaseSRWLockShared(PSRWLOCK SRWLock);
仅此而已。不存在用来删除或销毁SRWLOCK的函数，系统会自动执行清理工作。
与关键段相比，SRWLock缺乏下面两个特性。
第8章 用户模式下的线程同步
•	不存在TryEnter(Shared/Exclusive)SRWLock之类的函数：如果锁已经被占用，那 么调用 AcquireSRWLock(Shared/Exclusive)会阻塞调用线程。
•	不能递归地获得SRWLOCKo也就是说，一个线程不能为了多次写入资源而多次 锁定资源，然后再多次调用ReleaseSRWLock*来释放对资源的锁定。
但是，如果可以接受这些限制，那么我们就可以用SRWLock来代替关键段，并获得实际 性能和可伸缩性的提升。如果读者需要可信服的数据来对比这两种同步机制之间的性能差 异，那么应该在多处理器的机器上运行本书配套网页中提供的08-UserSyncCompare程序。
这个简单的基准测试(benchmark)会产生1个、2个以及4个线程，这些线程会使用不同的 线程同步机制来重复执行相同的任务。我在自己的双处理器的机器上运行了每项任务，并 记录了所花费的时间。表8.2列出了所有结果。
表8-2同步机制的性能比较
线程' 微秒	Volatile 读取	Volatile 写入	Interlocked 递增	关键段	SRWLock 共享模式	SRWLock 独占模式	互斥量
1	8	8	35	66	66	67	1060
2	8	76	153	268	134	148	11082
4	9	145	361	768	244	307	23785
表8-2中每个单元格包含的是从线程开始运行，到最后一个线程结束，执行下面的任务 1 000 000次，总共花费的时间，以微秒为单位(用第7章介绍的Stopwatch测量得到)。
•	读取一个volatile长整型值：
LONG lvalue = gv_value；
Volatile读取非常快，这是因为不需要进行任何同步，它与CPU的高速缓存完全无关。 基本上，无论CPU或者线程的数量是多少，读取所需的时间始终不会有太大的变化。
•	写入一个volatile长整型值：
gv_value = 0;
单线程的时候，时间只有8微秒。读者可能会认为有两个线程的时候执行相同的操作 只不过是使时间加倍，但在一台双处理器的机器上实际结果比我们想象的要差得多(76 微秒)，这是因为CPU之间必须相互通信以维护高速缓存的一致性。使用4个线程使 时间加了一倍(145微秒)，原因很简单，因为所需的工作量翻了一番。但是，这里的时 间还不算太糟糕，这是因为只有两个CPU在对数据进行操作。如果我的机器有更多 CPU,那么性能还会下降，因为需要在更多的CPU之间进行通信来使所有CPU的高 速缓存保持一致。
•	使用Interlockedlncrement来安全地递增一个volatile长整型值：
Interlockedlncrement(&gv_value);
Interlockedlncrement比volatile读/写要慢，这是因为CPU必须锁定内存。因此，在 同一时刻只有一个CPU能够访问它。使用两个线程比使用一个线程要慢得多，这是因 为必须在两个CPU之间来回传输数据以维护高速缓存的一致性。4个线程更慢，这是
WS核心编程（第5版）
因为所需的工作量加倍了，但再次重申，我的机器只有2个CPUo在有4个CPU的 机器上，性能可能会更糟糕，因为必须在4个CPU之间来回传输数据。
•	使用关键段来读取volatile长整型值：
EnterCriticalSection（&g_cs）；
gv_value = 0;
LeaveCriticalSection（&g_cs）；
关键段比较慢，这是因为我们必须先进入再离开（两个操作）。此外，进入和离开关键 段需要修改CRITICAL_SECTION结构中的多个字段。从表18-2中我们可以看到， 当发生争夺现象的时候，关键段要比原来慢得多。例如，4个线程需要花费768微 秒，是268微秒（两个线程）的两倍还多，这是因为上下文切换增大了发生争夺现象的 可能性。
•	使用SRWLock来读取volatile长整型值：
AcquireSRWLockShared/Exclusive （&g_si7wLock）;
gv_value = 0；
ReleaseSRWLockShared/Exclus ive（&g_srwLock）;
当只有一个线程的时候，SRWLock执行读取和写入操作的时间几乎相同。当有两个 线程的时候，SRWLock执行读取操作的性能要优于执行写入操作的性能，这是因为 两个线程可以同时进行读取，而需要执行写入操作的线程之间是互斥的。当有4个线 程的时候，SRWLock执行读取操作的性能要优于执行写入操作，这是由于相同的原 因：允许多个线程同时执行读取操作。读者可能会认为结果应该比表8-2中显示得更 好，但这里的代码非常简单，在得到锁之后并没有做太多的事情。此外，由于多个线 程会不断地写入锁的字段以及它保护的数据，因此各CPU必须在它们的高速缓存之间 来回传输数据。
•	使用同步内核对象互斥量（参见第9章）来安全地读取volatile长整型值：
WaitForSingleObject（g_hMutex, INFINITE）；
gv_value = 0；
ReleaseMutex（g_hMutex）；
互斥量是到目前为止性能最差的，这是因为等待互斥量以及后来释放互斥量需要线程 每次都在用户模式和内核模式之间切换。这种切换的CPU时间开销非常大。当发生争 夺现象的时候（发生在两个线程或4个线程同时执行时），性能会急剧下降。
SRWLock的性能与关键段的性能差不多旗鼓相当。事实上，从上面的结果我们可以看到, 在许多测试中SRWLock的性能要胜过关键段。有鉴于此，我建议用SRWLock来代替关 键段。SRWLock不仅更快，而且允许多个线程同时读取，对那些只需要读取共享资源的 线程来说（在许多应用程序中很常见的情况），这提高了吞吐量和可伸缩性。
总结一下，如果希望在应用程序中得到最佳性能，那么首先应该尝试不要共享数据，然后 依次使用volatile读取，volatile写入，Interlocked API, SRWLock以及关键段。当且仅当 所有这些都不能满足要求的时候，再使用内核对象（下一章的主题）。
第8章 用户模式下的线程同步
8.6条件变量
我们已经看到，当想让写入者线程和读取者线程以独占模式或共享模式访问同一个资源的 时候，可以使用SRWLocko在这些情况下，如果读取者线程没有数据可以读取，那么它 应该将锁释放并等待，直到写入者线程产生了新的数据为止。如果用来接收写入者线程产 生的数据的数据结构已满，那么写入者线程同样应该释放SRWLock并进入睡眠状态，直 到读取者线程把数据结构清空为止。
有时我们想让线程以原子方式把锁释放并将自己阻塞，直到某一个条件成立为止。要实现 这样的线程同步是比较复杂的。Windows通过SleepConditionVariableCS或 SleepConditionVariableSRW函数，提供了一种条件变量，来帮助我们简化这种情形下所 需的工作。
BOOL SleepConditionVariableCS(
PCONDITION_VARIABLE pConditionVariable,
PCRITICAL.SECTION pCriticalSection,
DWORD dwMilliseconds);
BOOL SleepConditionVariableSRW(
PCONDITION_VARIABLE pConditionVariable,
PSRWLOCK pSRWLock,
DWORD dwMilliseconds,
ULONG Flags);
参数pConditionVariable指向一个己初始化的条件变量，调用线程正在等待该条件变量。 第二个参数是一个指向关键段或者SRWLock的指针，该关键段或SRWLock用来同步对 共享资源的访问。参数dwMilliseconds表示我们希望线程花多少时间(可以设成INFINITE) 来等待条件变量被触发。第二个函数中的Flags参数用来指定一旦条件变量被触发，我们 希望线程以何种方式来得到锁：对写入者线程来说，应该传入0,表示希望独占对资源的 访问；对读取者线程来说，应该传入CONDITION VARIABLE LOCKMODE SHARED, — —
表示希望共享对资源的访问。当指定的时间用完的时候，如果条件变量尚未被触发，函数 会返回FALSE,否则函数会返回TRUEo注意，当函数返回FALSE的时候，线程显然并 没有获得锁或关键段。	■.
当另一个线程检测到相应的条件己经满足的时候，比如存在一个元素可让读取者线程读取, 或者有足够的空间让写入者线程插入新的元素，它会调用WakeConditionVariable或 WakeAllConditionVariable,这样阻塞在Sleep*函数中的线程就会被唤醒。这两个触发函 数之间的区别并不明显：
VOID WakeConditionVariable(
PCONDITION_VARIABLE Conditionvariable);
VOID WakeAllConditionVariable(
PCONDITION_VARIABLE Conditionvariable)；
227-228
当我们调用 WakeConditionVariable 的时候，会使一个在 SleepConditionVariable*函数中
垓心编程(第5版)	.
等待同一个条件变量被触发的线程得到锁并返回。当这个线程释放同一个锁的时候，不会 唤醒其他正在等待同一个条件变量的线程。当调用WakeAllConditionVariable的时候，会 使一个或几个在SleepConditionVariable*函数中等待这个条件变量被触发的线程得到对 资源的访问权并返回。唤醒多个线程是可以的，这是因为我们确信如果我们请求独占对 资源的访问，那么在同一时刻必定只有一个写入者线程能得到锁，如果我们传给Flag参 数的是CONDITION_VARIABLE_LOCKMODE_SHARED,那么在同一时刻可以允许 多个读取者线程得到锁。因此，有时候所有的读取者线程会被一起唤醒，有时候会有一 个读取者线程先被唤醒，然后是另一个写入者线程，直到所有被阻塞的线程都得到锁为 止。如果读者使用过Microsoft .NET框架，那么会发现Monitor类和条件变量之间的共 同之处。两者都通过SleepConditionVariable / Wait来提供同步访问，两者都通过 Wake*ConditionVariable/PuIse(AU)来提供触发的特性。读者可以在MSDN相关的页面中 (http://msdn2.microsoft.com/en-us/library/hf5de04k.aspx),或者在另一本书 CLR via C#, Second Edition (Microsoft Press, 2006)①中，找到与Monitor类有关的详细信息。
8.6.1	Queue示例程序
条件变量总是和锁一起使用：既可以是关键段，也可以是SRWLock。Queue应用程序 (08-Queue.exe)使用了一个SRWLock和两个条件变量来对一个请求元素的队列进行控制。 应用程序的源代码和资源文件在本书配套网页的08-Queue目录中。运行应用程序并单击 Stop按钮，过一会儿会弹出下图所示的对话框。
ueue
threads
(0] Adding 1
[1]	Adding 1
[2]	Adding!
[3]	Adding 1
[0] Adding 2
⑴ Adding 2 (3)AddinQ2 ⑵ Adding 2
(0] Adding 3
[2)	Addrg3
(3]	Adding 3
(1] Adding 3
[OJ Adding 4
(1]	Adding 4
[3] Queue is full: impossible to add 4
(2]	Queue is full: impossible to add 4
12] bye bye
(3]	bye bye
[0] bye bye
Server threads
(0] Nothing to process [1] Processing 0:1
[0] Processing 0:2 [1 ] Processing 1:1
(0) Processing 1:2
(1) bye bye [Olbyebye
① 洋注：本I5中文版已由清华大学出版社出版，即《框架设计(第2版)》，ISBN 978-7-302-140l6^)o
第8章用户模式下的线程同步
当Queue应用程序初始化的时候，会创建4个客户线程(写入者)以及两个服务器线程(读取 者)。每个客户线程会在队列末尾添加一个请求元素，睡眠一段时间，然后再尝试添加一个 请求。当一个元素被添加到队列中的时候，Client threads列表框会更新。列表框中的每一 项代表是哪个客户线程把请求元素添加到队列中的，用线程ID表示。例如，列表框中的第 一项表示客户线程。添加了它的第一个请求。然后客户线程1、2和3添加了它们的第一个 请求，之后客户线程0添加了它的第二个请求，依此类推。
每个服务器线程负责对请求进行处理，线程0处理奇数号请求，线程1处理偶数号请求。 在元素被添加到队列中之前，两个线程都无事可做。当一个元素被添加到队列中的时候， 一个服务器线程会被唤醒来对请求进行处理。如果请求号是预期的奇数号或偶数号，那么 服务器线程会处理请求，将它标记为已读，然后通知客户线程可以向队列中添加新的请求, 最后继续睡眠，直到有下一个请求为止。如果没有需要自己处理的请求元素，那么服务器 线程会进入睡眠，直到有新的请求为止。
Server Threads列表框显示了服务器线程的状态。第一项显示服务器线程0试图在队列中寻 找一个偶数请求，但没有找到。第二项显示服务器线程1处理了客户线程0的第一个请求。 第三项显示服务器线程0处理了客户线程0的第二个请求，依此类推。由于已经单击了 Stop 按钮，因此各线程都得到通知停止进行各自的处理，并在对应的列表框中显示“bye bye”。 在这个例子中，服务器线程无法足够快地处理客户的请求，队列塞满了。程序在初始化队 列数据结构的时候，使它最多只能容纳10个元素，这样队列很快就会被塞满。加之，客户 线程有四个，而服务器线程只有两个。我们可以看到当客户线程3和2试图向队列中添加 它们的第四个请求时由于队列己满，因此两个操作都失败了。
1.队列的实现细节
好了，我们己经看到了应用程序是如何运行的，更有趣的是应用程序内部是如何工作的。 该应用程序通过一个Ci■类CQueue来管理队列：
class CQueue
(
public：
Struct ELEMENT (
int nujiThr eadNxun ；
int nunReques tNum ；
// Other element data should go here
｝；
typedef ELEMENT* PELEMENT;
private：
Struct INNER^ELEMENT (
int nunStamp； // 0 means en^)ty
ELEMENT n\_element;
｝；
typedef INNER^ELEMENT* PINNER_ELEMENT;
private:
PINNER__ELEMENT nupElements；	// Array of elements to be processed
int	n\_nMeixElements；	// Maximum * of elements in the array
int	nunCurrentStamp；	// Keep track of the- # of added elements
private：
l^dows核心编程(第5版)	.
int GetFreeSlot();	•
int GetNextSlot(int nThreadNum)；
public:
CQueue(int nMaxElements);
~CQueue();
BOOL IsFull();
BOOL IsEmpty(int nThreadNum)；
void AddElement(ELEMENT e);
BOOL GetNewElement(int nThreadNum, ELEMENTS e);
);
229-230
这个类中的公有ELEMENT结构定义了队列数据元素，元素的实际内容并不重要。在这个 示例程序中，客户线程把它们的线程号和它们的请求号放在这个请求元素中，这样当服务 器对奇数号或偶数号的请求元素进行处理的时候，就能够把这些信息也显示在服务器线程 的列表框中。一个真实的应用程序通常不需要这些信息。INNER_ELEMENT结构对 ELEMENT结构进行了封装(wrap),这样就可以通过m_nStamp字段来记录插入的顺序， 在每次添加一个元素的时候这个字段的值会递增。
在其他的私有成员中，有一个mjpElements成员，它指向一个INNER_ELEMENT结构的 数组，数组的长度是固定的。这就是需要保护的数据，不能让多个客户/服务器线程同时访 问。m nMaxEIements成员表示当CQueue对象构造的时候，数组的初始长度是多少。下 一个成员m_nCurrentStamp是一个整数，每当有新元素添加到队列中的时候会递增。私 有成员函数GetFreeSlot返回mjpElements中第一个m_nStamp为0(表示其中的内容已经 被读取或内容为空)的INNER_ELEMENT结构的索弓如果不存在这样的元素，那么函数 会返回-1。
int CQueue：:GetFreeSlot() (
// Look for the first element with a 0 stamp
for (int current = 0; current < m_nMaxElements; current++) (
if (nupElements[current] .m__nStamp == 0) return(current);
)
//No free slot was found
return(-1)；
}
230
私有成员函数GetNextSlot是一个辅助函数，它会返回m_pElements中m nStamp的值最 小(表示最早添加)但不为0(表示闲置或已经读取完毕)的那个INNER_ ELEMENT的索引。 如果所有元素都己读取完毕(它们的m_nStamp等于0),那么函数会返回-1。
int CQueue：:GetNextSlot(int nThreadNum) (
// By default, there is no slot for this thread
int firstSlot = -1；
// The element can't have a stamp higher than the last added 。
int firstStamp = nunCurrentStamp+1;
// Look for the even (thread 0) / odd (thread 1) element that is not free
第8章用户模式下的线程同步
for (int current = 0； current < nupMaxElements； current++) {
// Keep track of the first added (lowest stamp) in the queue
// --> so that "first in first out" behavior is ensured
if ((nL_pElements [current] .m_jiStamp ! = 0) && // free element
((m__pElements[current] .n\_elenient .nunRequestNum % 2) == nThreadNum) && (nupElements [current] .itL.nStamp < firstStamp)) {
firstStamp = irupElements[current] .nL_nStamp； firstSlot = current;
} ,
}
return(firstSlot);
}
理解CQueue的构造函数、析构函数、IsFull以及IsEmpty成员函数对读者来说应该不成 问题，因此我们下面来关注一下AddElement函数，客户线程调用这个函数来把请求元素 添加到队列中去：
void CQueue::AddElement(ELEMENT e) (
// Do nothing if the queue is full
int nFreeSlot = GetFreeSlot()；
if (nFreeSlot == -1)
return；
// Copy the content of the element
nkjpElements [nFreeSlot] .nuelement = e；
// Mark the element with the new stamp m_pElements [nFreeSlot] .ircnStamp = ++nt_nCurrentStainp;
}
如果mjElements中有一个空位，那么函数会用它来存放传入的ELEMENT参数，为了 把新添加的请求元素统计在内，函数还会把当前m_nStamp的值递增。当服务器线程想要 处理一个请求的时候，会调用GetNewElement,传入线程号(0或1)以及一个ELEMENT 结构，函数会把相应的新请求的详细信息填入到这个结构中：
BOOL CQueue：:GetNewElement(int nThreadNum, ELEMENTS e) (
int nNewSlot = GetNextSlot(nThreadNum);
if (nNewSlot == -1)
return(FALSE);	•
// Copy the content of the element
e = irupElements [nNewSlot] .nuelement;
// Mark the element as read	.
nupElements [nNewSlot] .ntJiStainp « 0;	j- -1 > : %
re turn (TRUE)；	,	L —	、•；
GetNextSlot辅助函数的主要工作是寻找第一个对应于指定读取者线程的元素。如果队列中 有这样的元素，那么GetNewElement会把该请求的详细信息复制到传入的ELEMENT结 构中，然后把m_nStamp的值设为0表示读取完毕。
231-232
这里并没有什么特别复杂的东西，读者肯定会认为CQueue并不具备线程安全性。事实的


indows核心编程（第5版）
确如此。在第9章，我们会介绍如何使用其他同步内核对象来构建一个具备线程安全性的 队列。但是，在08-Queue.exe应用程序中，由客户线程和服务器线程来负责对它们访问的 全局队列进行同步：
CQueue	g_q(10)；	// The shared queue
在08-Queue.exe应用程序中，用了三个全局变量来让客户(写入者)线程和服务器(读取者) 线程协调工作，避免破坏队列：
SRWLOCK	g_srwLock；	//	Reader/writer lock to	protect the queue
CONDITION_VARIABLE	g_cvReadyToConsume;	//	Signaled by writers
CONDITION_VARIABLE	g_cvReadyToProduce；	//	Signaled by readers
每当一个线程想要访问队列的时候，它必须获得SRWLock,这既可以是服务器(读取者) 线程使用的共享模式，也可以是客户(写入者)线程使用的独占模式。
2.客户线程是WriterThread
让我们来看一下客户线程的实现：
DWORD WINAPI WriterThread(PVOID pvParam) (
int nThreadNum = PtrToUlong (pvParciin)；
HWND hWndLB = GetDlgltem(g^hWnd, IDC^CLIENTS);
for (int nRequestNum = 1; !g_fShutdown； nRequestNxun++) {
CQueue::ELEMENT e = { nThreadNum, nRequestNum }；
// Require access for writing
AcquireSRWLockExclusive(&g_srwLock);
// If the queue is full, fall asleep as long as the condition variable
// is not signaled	、
// Note： During the wait for acquiring the lock,
// a stop might have been received
if (g__q.IsFull () & !g_f Shut down) {
//No more room in the queue
AddText(hWndLB, TEXT("[%d] Queue is full: impossible to add %dB), nThreadNum, nRequestNum)；
// --> Need to wait for a reader to empty a slot before acquiring
// the lock again	.
S1eepConditionVariableSRW(&g__cvReadyToProduce, &g_srwLock, INFINITE, 0);
}
// Other writer threads might still be blocked on the lock
// --> Release the lock and notify the remaining writer threads to quit if (g_fShutdown) (
// Show that the current thread is exiting
AddText(hWndLB, TEXT("[%d] bye bye"), nThreadNum)；
//No need to keep the lock any longer
ReleaseSRWLockExclusive(&g_srwLock);
// Signal other blocked writer threads that it is time to exit WakeAllConditionVariable(&g_cvReadyToProduce);
// Bye bye
return(0)；
} else {
第8章用户模式下的线程同步
// Add the new ELEMENT into the queue
g_q.AddElement(e);
// Show result of processing element
AddText(hWndLB, TEXT("[%d] Adding %d"), nThreadNum, nRequestNum);
//No need to keep the lock any longer ReleaseSRWLockExclus ive(&g_srwLock);
// Signal reader threads that there is an element to consume WakeAllConditionVariable(&g_cvReadyToConsume);
// Wait before adding a new element
Sleep(1500);
}
// Show that the current thread is exiting
AddText(hWndLBr TEXT("[%d] bye bye■), nThreadNum);
return(0);
}
役 232-233 A
代码中的for循环把线程产生的请求序号递增，如果发现g^fShutdown布尔变量为TRUE 就停止循环，这可能是用户关闭了应用程序的主窗口，也可能是用户单击了 Stop按钮。稍 后我们会讨论一些牵涉到从用户界面线程来停止后台的客户/服务器线程的问题，届时我们 将再次回到这个话题。
在试图添加新的请求元素之前，程序会调用AcquireSRWLockExclusive来以独占模式获得 SRWLocko如果锁已经被别的线程占用，那么无论占用锁的线程是服务器线程还是客户线 程，当前线程都会阻塞在AcquireSRWLockExclusive中，直到锁被释放。当 AcquireSRWLockExclusive函数返回的时候，我们己经获得了锁，但此时还需要满足另一 个条件才能向队列中添加请求——那就是队列必须还没有满。如果队列己满，那么我们必 须睡眠，直到读取者线程读取掉一个请求为止，这时就会腾出一个空位来容纳我们的请求 元素。但在进行睡眠之前我们必须先把锁释放，否则会进入死循环：由于锁仍然被占用， 因此任何读取者线程都不能获得对资源的访问权，从而无法清空队列。这正是 SleepConditionVariableSRW所做的：它把作为参数传入的g_srwLock释放，然后将调用 线程切换到睡眠状态，直到服务器线程发现有一个空位可用并调用WakeConditionVariable 来触发g_cvReadyToProduce条件变量为止。
当SleepConditionVariableSRW返回的时候，两个条件都已经满足：当前线程己经重新获 得了锁，而且另一个线程已经触发了条件变量来让客户线程知道队列中有空位可用。这时, 线程就可以把新的请求元素添加到队列中去了。但是，它会首先检查用户有没有在它睡眠 期间要求结束处理。如果没有要求结束处理，那么它会把新的请求元素添加到队列中，发 送一个消息给客户列表框来显示处理状态，并调用ReleaseSRWLockExclusive来把锁释放。 在进入下一次循环之前，客尸线程会调用 WakeAllConditionVariable ,将 &g_cvReadyToConsume作为参数传入，来通知服务器线程有数据需要它们处理。
indows核心编程（第5版）
3.服务器线程处理请求
程序用同一个回调函数创建了两个服务器线程。每个线程通过调用ConsumeElement函数 来分别处理奇数请求元素或偶数请求元素，并不停地循环直到g_fShutdown等于TRUE为 止。这个辅助函数在完成对请求的处理后会返回TRUE,如果函数检测到g_fShutdown为 TRUE,那么它会返回FALSEo
BOOL ConsumeElement(int nThreadNum, int nRequestNum, HWND hWndLB) (
// Get access to the queue to consume a new element AcquireSRWLockShared(&g_srwLock)；
// Fall asleep until there is something to read.
// Check if, while it was asleep,
// it was not decided that the thread should stop
while (g_q.IsEmpty(nThreadNum) && !g_fShutdown) (
// There was not a readable element
AddText(hWndLB, TEXT(■[%d] Nothing to process"), nThreadNum);
// The queue is empty
// --> Wait until a writer adds a new element to read
// and come back with the lock acquired in shared mode SleepConditionVariableSRW(&g_cvReadyToConsume/ &g_srwLock, INFINITE, CONDITION-VARIABLE_LOCKMODE_SHARED);
}
// When thread is exiting, the lock should be released for writer
// and readers should be signaled through the condition variable if (g_fShutdown) (	.
// Show that the current thread is exiting
AddText(hWndLB, TEXT(■[%d] bye bye"), nThreadNum);
// Another writer thread might still be blocked on the lock
// --> release it before exiting
ReleaseSRWLockShared(&g_srwLock)；
// Notify other readers that it is time to exit
// --> release readers
WakeCondit ionVariable(&g_cvReadyToConsume)；
return(FALSE);
// Get the first new element CQueue::ELEMENT e;
// Note: No need to test the return value since IsEmpty
// returned FALSE
g_q.GetNewElement(nThreadNum, e);
// No need to keep the lock any longer	: i：
ReleaseSRWLockShared(&g_srwLock) ；	一.;「二"
\	, —J * .. li • i. -•*" .? •, **wv^5* I «	•
• » * *.	•• • ,*!• mN'.,撰怠、、
// Show result of consuming the element
AddText (hWndLB, TEXTC [%d] Processing	,
nThreadNum, e.nt_nThreadNum, e.nt_nReque$tNum)君潇为 己 值
•：?:.	' • • ■	咔"飘怒E沁:津点技#：煎了：3 e 翌?
// A free slot is now available for writer
// --> wake up a writer thread
WakeConditionVariable(&g_cvReadyToProduce);
return (TRUE) ；	/; , "	•砂•.*;网疹烫莲笛
}
第8章用户模式下的线程同步
DWORD WINAPI ReaderThread(PVOID pvParam) {	'
int nThreadNum = PtrToUlong(pvParam);
HWND hWndLB = GetDlgltemCgJiWnd, IDC_SERVERS);
for (int nRequestNum = 1; *!g_fShutdown; nRequestNum++) (
if (IConsumeElement(nThreadNum, nRequestNum, hWndLB)) return(0)；
Sleep(2500)；	// Wait before reading another element
)
// g—fShutdown has been set during Sleep
//	> Show that the current thread is exiting
AddText(hWndLB, TEXT(•[%d] bye bye，)， nThreadNum);
return(0);
}
在处理请求之前，线程会调用AcquireSRWLockShared来以共享模式获得srwLocko如果 锁已经被客户线程以独占模式获得，那么函数调用会阻塞。如果锁已经被另一个服务器线 程以共享模式获得，那么函数调用会立即返回，允许对请求进行处理。即使线程获得了锁, 队列中可能并不包含任何与之相对应的新的请求元素——例如，队列中有一个奇数号的请 求，而服务器线程0要找的却是偶数号的请求。在这种情况下，代码会给服务器列表框发 送一个消息，然后线程会阻塞在SlecpConditionVariableSRW函数中，直到一个客户线程 因为有新的请求元素需要处理而触发g__cvReadyToConsume条件变量为止。当 SlecpConditionVariableSRW返回的时候，线程已经得到了 g_srwLock锁，队列中也有了 新的请求元素。但请求号可能仍然不正确：这也正是为什么要在循环中调用 SleepConditionVariableSRW并检查是否存在待处理元素的原因。注意，我们也可以使用 两个条件变量来代替这里仅有的一个cvReadyToConsume： 一个用于奇数号请求，另一个 用于偶数号请求。这样做可以避免在新的请求号不正确的情况下，去唤醒服务器线程却又 让它无事可做。在当前的实现中，即使调用GetNewElement会把请求元素的m nStamp 字段设为0来表示该请求已读取完毕，从而改变队列的内容，每个服务器线程还京会以共 享模式来获得锁。这并不是一个问题，因为各服务器线程绝对不会对同一个请求元素进行 更新：线程。处理偶数号请求，线程1处理奇数号请求。
当找到一个正确的请求号时，线程会将该元素从队列中取出，调用 ReleaseSRWLockShared,然后给服务器列表框发送一个消息。现在，服务器线程会调用 WakeConditionVariable,将&g_cvReadyToProduce作为参数传入，来通知客户线程队列 中有新的空位可用。
8.6.2在停止线程时的死锁问题
我最初给对话框中添加Stop按钮的时候，并没有想到会造成死锁的结果。用来停止客户线 程和服务器线程的代码非常直观：
(indows核心编程(第5版)
void StopProcessing() (
if (!g_fShutdown) (
// Ask all threads to end
InterlockedExchangePointer((PLONG*) &g_fShutdown, (LONG) TRUE);
// Free all threads waiting on condition variables
WakeAlICondit ionVariable(&g_cvReadyToConsume)；
WakeAllConditionVariable(&g_cvReadyToProduce)；
II Wait for all the threads to terminate & then clean up
WaitForMultipleObjects(g_nNumThreads, g_hThreads, TRUE, INFINITE);
// Don't forget to clean up kernel resources
// Note： This is not really mandatory since the process is exiting while (g_nNumThreads--)
CloseHandle(g_hThreads[g_nNumThreads])；
// Close each list box
AddText (GetDlgltemCg.hWnd, IDC_SERVERS) , TEXT( ------------------------))；
AddText (GetDlgItem(g_hWndz IDC_CLIENTS) , TEXT (-----------------------•))；
}
}
236
代码先把g_fShutdown标志设为TRUE,接着调用WakeAllConditionVariable来触发两个 条件变量，然后调用WaitForMultipleObjects,把所有正在运行的线程的句柄在一个数组 参数内传入。当WaitForMultipleObjects返回的时候，所有线程的句柄都巳关闭，代码把 两个列表框的最后一行添加到列表框中。
在客户/服务器这边，一旦因为 WakeAllConditionVariable而把它们从 SleepConditionVariableSRW调用中唤醒，照道理这些线程应该会监视g_fShutdown标志 并在各自的列表框中显示“byebye”后直接退出。死锁正是发生在当线程向列表框发送消息 的时候。如果执行StopProcessing函数的代码位于WM_COMMAND消息处理函数的内部,' 那么负责处理消息的用户界面线程会阻塞在WaitForMuItipleObjects函数中。因此，当其 中一个客户线程或服务器线程调用ListBox__SetCurSel和ListBox_AddString的时候——死 锁了。我选择的解决方案是在Stop命令消息处理函数中禁用该按钮，直到消息处理函数 退出为止，这样其他线程就能够安全地调用StopProcessing函数，同时也不会存在死锁的 危险。
DWORD WINAPI StoppingThread(PVOID pvParam) {
StopProcessing()；
return(0);
}
void Dlg_OnCommand(HWND hWnd, int id, HWND hWndCtlr UINT codeNotify) (
switch (id) {
case IDCANCEL:-
EndDialogfhWnd, id)；
break；	7
case IDC_BTN_STOP:
(
// StopProcessing can't be called from the UI thread
第8章用户模式下的线程同步
// or a deadlock will occur: SendMessage() is used
// to fill up the list boxes
// --> Another thread is required
DWORD dwThreadlD;
CloseHandle(chBEGINTHREADEX(NULL, 0, StoppingThread,
NULL, 0, &dwThreadID));
// This button can't be pushed twice
Button_Enable(hWndCt1, FALSE);
}
break；
}
}
不要忘记，当我们从另一个线程以阻塞方式对用户界面的内容进行同步时，同样面临着死 锁的危险。比如同步对共享资源的访问就是阻塞方式的一个例子。下面几节提供了一些窍 门和技巧，可以帮助避免死锁情况的发生。
最后注意一点，字符串是通过帮助函数AddText来添加到列表框中的，它利用了新的安全 版的字符串函数_vstprintf_s：
void AddText(HWND hWndLB, PCTSTR pszFormat, ...) {
va_list argList;*
va_start(argList, pszFormat);
TCHAR sz[20 * 1024];
_vstprintf_s(szr _countof(sz), pszFormat, argList)；
ListBox_SetCurSel(hWndLB, ListBox_AddString(hWndLB, sz));
va_end(argList);
}
8.6.3	一些有用的窍门和技巧
当我们在使用锁的时候，比如关键段或读取者/写入者锁，应该养成一些良好的习惯并避免 一些不太好的做法。下面几个窍门和技巧会对锁的使用有所帮助。这些技巧也同样适用于 内核同步对象(会在下一章讨论)。
1.	以原子方式操作一组对象时使用一个锁
一种常见的情况是多个对象聚在一起会构成一个单独的“逻辑”资源。例如，每当我们向 一个集合中添加元素的时候，可能同时需要对另一个计数器进行更新。为此，无论我们需 要对这个逻辑资源进行读操作还是写操作，都应该只使用一个锁。
应用程序中的每个逻辑资源都应该有自己的锁，用来对逻辑资源的部分和整体的访问进行 同步。我们不应该为所有的逻辑资源都创建单独的锁，这是因为如果多个线程访问的是不 同的逻辑资源，那么这样做会降低可伸缩性：任一时刻系统只允许一个线程执行。
2.	同时访问多个逻辑资源
有时我们需要同时访问两个(或更多个)逻辑资源。例如，应用程序可能需要锁定一个资源
indows核心编程(第5版)
来取出一个元素，同时锁定另一个资源来把元素加入其中。如果每个资源都有自己的锁， 那么我们必须使用所有的锁才能以原子方式完成这个操作。这里有一个例子：
DWORD WINAPI ThreadFunc(PVOID pvParam)(
EnterCriticalSection(&g_csResourcel);
EnterCriticalSection(&g_csResource2);
// Extract the item from Resourcel
// Insert the item into Resource2
LeaveCriticalSection(&g_csResource2)；
LeaveCriticalSection(&g_csResourcel);
return(0);
}
假设进程中有另一个线程也要求访问这两个资源，线和的代码如下面所示：
DWORD WINAPI OtherThreadFunc(PVOID pvParam) (
EnterCriticalSection(&g_csResource2)；
EnterCriticalSection(&g_csResourcel)；
// Extract the item from Resourcel
// Insert the item into Resource2
LeaveCriticalSection(&g_csResource2)；
LeaveCriticalSection(&g_csResourcel)； return(0)；	.
}
刚才的函数所做的改动就是调换了 EnterCriticalSection和LeaveCriticalSection的调用顺 序。但是由于这两个函数的编写方式，有可能会导致死锁。假设ThreadFunc开始运行并 得到g__csResourcel关键段的所有权。然后执行OtherThreadFunc函数的线程得到一些
CPU时间并得到g_csResource2关键段的所有权。现在我们就陷入了一个死锁的情形。当
ThreadFunc和OtherThreadFunc中的任何一个试图继续执行的时候，都无法得到它需要 的另一个关键段的所有权。
为了解决这个问题，我们必须在代码中的任何地方以完全相同的顺序来获得资源的锁。注 意，在调用LeaveCriticalSection的时候顺序无关紧要，这是因为该函数从来不会让线程进 入等待状态。
3.不要长时间占用锁
如果一个锁被长时间占用，那么其他线程可能会进入等待状态，这会影响到应用程序的性 能。我们可以用下面这个技巧来把花在关键段中的时间降至最低。下面的代码会在 WM_SOMEMSG消息被发送到另一个窗口之前阻止其他线程修改gji的值：
SOMESTRUCT g_s；
CRITICAL_SECTION g_cs;
DWORD WINAPI SomeThread(PVOID pvParam) (
EnterCriticalSection(&g_cs)；
// Send a message to a window.
SendMessage(hWndSomeWnd, WM_SOMEMSG, &g_s, 0);
LeaveCriticalSection(&g_cs);
第8章用户模式下的线程同步
return(0)；
)
239
我们不可能知道窗口过程(Window procedure)需要多长时间来处理WM_SOMEMSG消息， 可能只需要几微秒，也可能需要几年。在这段时间内，其他线程都无法得到结构的访 问权。把前述代码写成下面这种形式会更好：
SOMESTRUCT g_S；
CRITICAL_SECTION g_cs；
DWORD WINAPI SomeThread(PVOID pvParam) (
EnterCriticalSection(&g_cs); SOMESTRUCT sTemp = g_s； LeaveCriticalSection(&g_cs);
// Send a message to a window.
SendMessage(hWndSomeWnd, WM_SOMEMSG, &sTemp, 0); return(0);
}
前述代码把值保存在sTemp中，它是一个临时变量。我们大概可以猜到CPU需要多长的 时间来执行这行代码——只要几个CPU周期就够了。在保存了临时变量之后，我们立即调 用LeaveCriticalSection,因为此时已经不需要再对它进行保护了。第二种实现方式比第一 种实现方式要好得多，这是因为如果其他线程需要使用g_s结构，那么它们最多只需要等 待几个CPU周期，而不是一段长度不确定的时间。当然，这个技巧假设窗口过程只需读取 结构的“快照”就已经足够了，它同时还假设窗口过程不需要修改结构中的成员。
本■内容
9.1
9.2
9.3
9.4
9.5
9.6
9.7
9.8
2〉
ALT "二
第9章 用内核对象进行线程同步
等待函数
等待成功所引起的副作用 事件内核对象“宵 可等待的计时器内核对象 信号量内核对象
互斥量内核对象
线程同步对象速查表 其他的线程同步函数
在第8章中，我们讨论了一些线程同步机制，这些机制可以在进行线程同步的同时让线程 保持在用户模式下。在用户模式下进行线程同步的最大好处就是速度非常快。如果关心应 用程序的性能，那么应该先看看用户模式下的同步机制能否适用。
虽然用户模式下的线程同步机制提供了非常好的性能，但它们也的确存在一些局限性，而 且不适用于许多应用程序。例如，对Interlocked系列函数只能对一个值进行操作，它们从 来不会把线程切换到等待状态。我们可以用关键段来把线程切换到等待状态，但是它们只 能用来对同一个进程中的线程进行同步。此外，在使用关键段的时候我们很容易陷入死锁 的情形，这是因为我们无法为进入关键段指定一个最长等待时间。
本章将讨论如何使用内核对象来对线程进行同步。我们将会看到，与用户模式下的同步机 制相比，内核对象的用途要广泛得多。实际上，内核对象唯一的缺点就是它们的性能。当 我们调用本章介绍的任何一个新函数时，调用线程必须从用户模式切换到内核模式。这种 切换是非常耗时的：在x86平台上，一个空的系统调用大概会占用200个CPU周期——当 然，这还不包括执行被调用函数在内核模式下的实现代码。但是，造成内核对象比用户模 式下的同步机制慢几个数量级的原因，是伴随调度新线程而来的刷新高速缓存以及错过高 速缓存(即未命中)。这里我们谈论的是成百上千个CPU周期。
贯穿本书，我们已经讨论了好几种内核对象，包括进程、线程以及作业(job)。几乎所有这 些内核对象都可以用来进行同步。对线程同步来说，这些内核对象中的每一种要么处于触 发(signaled)状态，要么处于未触发(nonsignaled)状态。Microsoft为每种对象创建了一些规 则，规定如何在这两种状态之间进行转换。例如，进程内核对象在创建的时候总是处于未 触发状态。当进程终止的时候，操作系统会自动使进程内核对象变成触发状态。当进程内
第9章用内核对象进行线程同步
核对象被触发后，它将永远保持这种状态，再也不会变回到未触发状态。
在进程内核对象的内部有一个布尔变量，当系统创建内核对象的时候会把这个变量的值初 始化为FALSE(未触发)。当进程终止的时候，操作系统会自动把相应的内核对象中的这个 布尔值设为TRUE,表示该对象已经被触发。
如果我们想要编写一些代码，来检查一个进程是否正在运行，那么我们只需要调用一个函 数，让操作系统来检查进程对象的布尔值就可以了。够简单吧。我们可能还想让系统把我 们的线程切换到等待状态，然后当这个布尔值从FALSE变成TRUE的时候，再自动地唤 醒线程。这样，如果父进程的一个线程需要等待子进程终止，那么我们可以编写代码让线 程直接进入睡眠，直到标识子进程的内核对象被触发为止。正如我们将会看到的那样， Microsoft Windows提供了许多函数，可以非常容易地实现所有这些需求。
刚才介绍了 Microsoft为进程内核对象定义的规则。我们会发现线程内核对象也遵循同样的 规则。也就是说，线程内核对象在创建的时候总是处于未触发状态。当线程终止的时候， 操作系统会自动将线程对象的状态改为已触发。因此，我们可以在应用程序中使用相同的 技术来确定一个线程是否仍在运行。与进程内核对象相同，线程内核对象绝对不可能回到 未触发状态。
下面的内核对象既可以处于触发状态，也可以处于未触发状态：
•	进程
•	线程
•	作业
•	文件以及控制台的标准输入流/输出流/错误流
•	事件
•	可等待的计时器(waitable timer)
•	信号量
•	互斥量
线程可以自己切换到等待状态，直到另一个对象被触发为止。注意，用来决定每个对象处 于触发状态还是未触发状态的规则与对象的类型有关。刚才已经介绍了进程对象和线程对 象的规则。作业的规则也已在第5章做过介绍。
在本章，我们会先看一看那些允许一个线程等待某个特定的内核对象被触发的函数。然后 我们会看一看Windows提供的专门用来帮助我们进行线程同步的内核对象：事件、可等待 计时器、信号量以及互斥量。
回想当初自己学习这些内容的经历，我认为如果能够把每个内核对象想象为都包含一面旗 帜，将有助于对整个内容的理解。当对象被触发的时候，旗帜升起；当对象未被触发的时 候，旗帜落下。如下图所示。
242
indows核心编程（第5版）
内核对象	内核对象
当线程正在等待的对象处于未触发状态（旗帜落下）的时候，它们是不可调度的。但是，一 旦对象被触发（旗帜升起），那么线程就会看到这面旗帜，从而变成可调度状态，然后很快 就会继续执行。如下图所示。
内核对象	内核对象
9.1等待函数
等待函数使一个线程自愿进入等待状态，直到指定的内核对象被触发为止。注意，如果线 程在调用一个等待函数的时候，相应的内核对象己经处于触发状态，那么线程是不会进入 等待状态的。到目前为止，这些等待函数中最常用的是WaitForSingleObject：
DWORD WaitForSingleObject（
HANDLE hObject,
DWORD dwMi Hi seconds）;
当线程调用这个函数的时候，第一个参数hObject用来标识要等待的内核对象，这个内核
对象可以处于触发状态或未触发状态。（上一页列出的任何一种对象都可以使用。）第二个 参数dwMilliseconds用来指定线程最多愿意花多长的时间来等待对象被触发。
下面的函数调用告诉系统，调用线程希望一直等待，直到hProcess句柄标识的进程终止 为止：
WaitForSingleObject(hProcess, INFINITE)；
第9章用内核对象进行线程同步
第二个参数告诉系统，调用线程愿意永远等待（无限长的时间），或者等到这个进程终止 为止。
我们通常会给WaitForSingleObject的第二个参数传INFINITE,但也可以传任何其他的值 （以微秒为单位）。顺便提一下，INFINITE被定义为OxFFFFFFFF（或-1）。当然，传INFINITE 可能会有点危险。如果对象永远不被触发，那么调用线程就永远不会被唤醒——它会一直 阻塞在那里，但幸运的是，它并没有浪费宝贵的CPU时间。
下面的例子用了一个不同于INFINITE的时间长度来调用WaitForSingleObject：
DWORD dw = WaitForSingleObject（hProcess, 5000）;
switch （dw） （
case WAIT_OBJECT_0:
// The process terminated.
break；
case WAIT_TIMEOUT：
// The process did not terminate within 5000 milliseconds.
break;
case WAIT_FAILED:
// Bad call to function （invalid handle?）
break；
}
前述代码告诉系统，除非指定的进程已经终止，或者等待时间已满5000微秒，否则不应该 对调用线程进行调度。如果进程已经终止，那么这个调用会在5000微秒之内返回，如果进 程尚未终止，那么这个调用大约会在5000微秒左右返回。注意，我们可以给dwMilliseconds 参数传0。如果这样做，WaitForSingleObject总是会立即返回，即使它要等待的条件还没 有满足。
WaitForSingleObject的返回值表示为什么调用线程又能够继续执行了。如果是因为线程等 待的对象被触发，.那么返回值是WAIT_OBJECT_0；如果是因为等待超时，那么返回值是 WAIT_TIMEOUTo如果给WaitForSingleObject传入了无效参数（比如一个无效的句柄）， 那么返回值是WAIT_FAILED（这时调用GetLastError可以得到更详细的信息）。
下面的函数 WaitForMultipleObjects与 WaitForSingleObject相似。唯一的不同之处在于 它允许调用线程同时检查多个内核对象的触发状态：
DWORD WaitForMultipleObjects（
DWORD dwCount #
CONST HANDLE* phObjects,
BOOL bWaitAll,
DWORD dwMilliseconds）；
参数dwCount表示我们希望函数检查的内核对象的数量。这个值必须在 1〜MAXIMUM_WAIT_OBJECTS（在WinNT.h头文件中被定义为64）之间。参数phObjects 是一个指针，指向一个内核对象句柄的数组。
我们可以通过两种不同的方式来使用WaitForMultipleObjects, 一种是让线程进入等待状

lows核心编程(第5版)
态直到指定内核对象中的一个被触发为止，另一种是让线程进入等待状态直到指定内核对 象中的全部被触发为止。参数bWaitAll用来告诉函数我们希望使用哪种方式。如果给这个 参数传TRUE,那么在所有内核对象被触发之前，函数将不会允许调用线程继续执行。
参数dwMilliseconds的用法与WaitForSingleObject中完全相同。如果在等待的时候，超 出了指定的时间氏度，那么即使内核对象还没有被触发，函数也会返回。再重复一遍，我 们通常传INFINITE给这个参数，但为了避免可能出现的死锁，在编写代码的时候应该 小心。
WaitForMultipleObjects函数的返回值告诉调用方函数为什么它得以继续运行。可能的返 回值包括WAIT_FAILED和WAIT_TIMEOUT,它们都不言自明。如果给bWaitAll传的 是TRUE而且所有对象都被触发了，那么返回值是WAIT__OBJECT_Oo如果给bWaitAU 传的是FALSE,那么只要任何一个对象被触发，函数就会立即返回。这时的返回值是 WAIT_OBJECT_0 和(WAIT_OBJECT_0 + dwCount - 1)之间的任何一个值。换句话说， 如果返回值既不是WAIT_TIMEOUT ,也不是WAIT_FAILED,那么我们应该把返回值 减去WAIT_OBJECT_0o得到的数值是我们在第二个参数中传给WaitForMultipleObjects 的句柄数组的一个索引，用来告诉我们被触发的是哪个对象。
下面的示例代码可以更清晰地对此进行解释:
HANDLE h[3];
h[0] = hProcessl;
h[l] = hProcess2 ；
h [2] = hProcess3 ;
DWORD dw = WaitForMultipleObjects(3, hz FALSE, 5000); switch (dw) {
case WAIT_FAILED:
// Bad call to function (invalid handle?) break；
case WAIT_TIMEOUT:
// None of the objects became signaled within 5000 milliseconds. break；
case WAIT_OBJECT_0 + 0:
// The process identified by h[0] (hProcessl) terminated, break；
case WAIT_OBJECT_0 + 1:
// The process identified by h[1] (hProcess2) terminated, break；
case WAIT_OBJECT_0 + 2：
// The process identified by h[2] (hProcess3) terminated, break；
245
如果传给bWaitAll参数是FALSE,那么WaitForMultipleObjects会从句柄数组的索引0 开始检查，所找到的第一个被触发的对象就满足了等待条件。这可能会产生一些不希望的 结果。比如，我们的线程可能会给函数传入三个子进程的句柄，然后等待它们终止。如果 索引为0的进程终止了，那么WaitForMultipleObjects将返回。现在线程就可以做自己想
第9章用内核对象进行线程同步
做的任何事情，然后再次进入循环，等待另一个进程终止。如果线程传入与前一次调用时 相同的三个句柄，那么函数会再次立即返回WAIT_OBJECT_Oo除非从数组中去掉己触发 的那个句柄，否则我们的代码将无法正常工作。
9.2等待成功所引起的副作用
对一些内核对象来说，成功地调用 WaitForSingleObject或 WaitForMultipleObjects事实 上会改变对象的状态。一个成功的调用指的是函数发现对象己经被触发了，然后返回 WAIT_OBJECT_0的一个相对值。如果调用不成功，那么函数返回的是WAIT_TIMEOUT 或WAIT_FAILED,在这种情况下对象的状态绝对不会发生变化。
如果对象的状态发生了变化，我则称之为等待成功所引起的副作用(successiul wait side effects)o举个例子，现在假设线程正在等待一个自动重置事件对象(auto-reset event object)(本 章稍后会进行介绍)。当事件对象被触发的时候，函数会检测到这一情况，这时它可以直接 返回WAIT_OBJECT_0给调用线程。但是，就在函数返回之前，它会使事件变为非触发 状态——这就是等待成功所引起的副作用。
自动重置事件内核对象之所以会有这样的副作用，其原因是，这是Microsoft为此类对象定 义了诸多规则中的一条。其他对象有不同的副作用，有些对象则完全没有副作用。进程和 线程内核对象就完全没有副作用，也就是说，等待这些对象绝对不会改变对象的状态。随 着本章对各种内核对象的讨论，我们会更详细地介绍它们的等待成功所引起的副作用。
WaitForMultipleObjects之所以这么有用的原因，是因为它能够以原子方式执行所有操作。 当线程调用WaitForMultipleObjects的时候，函数会测试所有对象的触发状态，并引发相 应的副作用，所有这些都是作为一个操作来完成的。
下面让我们来看一个例子。两个线程以完全相同的方式调用WaitForMultipleObjects： HANDLE h[2];
h[OJ = hAutoResetEvent1;	// Initially nonsignaled
h[l] = hAutoResetEvent2；	// Initially nonsignaled
WaitForMultipleObjects(2, h, TRUE, INFINITE)；
当WaitForMultipleObjects被调用的时候，两个事件对象均未被触发，这迫使两个线程都 进入等待状态。然后hAutoResetEventl对象被触发。两个线程都发现事件巳经被触发，但 由于hAutoResetEventl对象仍然没有被触发，因此系统不会唤醒它们中的任何一个。由于 两者均没有等待成功，因此不会对hAutoResetEventl对象产生任何的副作用。
接下来，hAutoResetEventl对象被触发。此时，两个线程中的一个检测到它等待的所有对 象都己经被触发了。这样等待就成功了，系统把两个事件对象都设为未触发状态，并让线 程继续执行。但另一个线程呢？它会继续等待，直到发现两个事件对象都被触发为止。虽 然它曾经检测到hAutoResetEventl被触发过，但现在它看到的却是该对象未被触发。
idows核心编程（第5版）
匕
我们刚才己经提到过，WaitForMultipleObjects是以原子方式工作的，这一点值得注意。 当函数检查内核对象的状态时，任何其他线程都不能在背后修改对象的状态。这就防止了 死锁情况的发生。想象一下，如果一个线程看见hAutoResetEventl被触发，于是把事件重 置为未触发状态，然后另一个线程看见hAutoResetEventl被触发，于是把这个事件也重置 为未触发状态。两个线程都会冻结在那里：一个线程将会等待另一个线程已经得到的对象, 而反过来也是一样。WaitForMultipleObjects确保这种情况不会发生。
这就引出了一个有趣的问题：如果多个线程等待同一个内核对象，那么当对象被触发的时 候，系统如何决定应该唤醒哪个线程？ Microsoft的官方回答是，“算法是公平的o "Microsoft 并不想对系统内部使用的算法做任何承诺。它只是说算法是公平的，也就是说如果有多个 线程在等待，那么每次当对象被触发的时候，每个线程都有机会被唤醒。
这意味着线程优先级将没有效果：优先级最高的线程不一定能得到对象。这同样意味着等 待时间最长的线程不一定能得到对象。而且，得到对象的线程再次循环并再次得到对象也 是有可能的。但是，这对其他线程来说并不公平，因此算法会尽量防止这种情况。即便如 此，系统并不保证绝对不会发生这种情况。
实际上，Microsoft所使用的算法只不过是众所周知的“先入先出”机制。等待时间最长的 线程得到对象。但是，系统内部的一些操作可能会改变这种行为，这使得它变得更加不可 预测。这也是Microsoft为什么不明确说明算法的工作原理的原因。这些操作中的一种是线 程被挂起。如果线程先等待一个对象，然后线程被挂起，那么系统会忘记这个线程还在等 待对象。这是Windows的一项特性，因为系统没有理由去调度一个被挂起的线程。当后来 线程恢复的时候，系统会认为这个线程才刚开始等待对象。
我们在调试一个进程的时候，如果遇到断点，那么进程中所有的线程都会被挂起。因此， 调试一个进程会使这个“先入先出”算法变得极其难以预测，这是因为线程会被频繁地挂 起和恢复。
9.3事件内核对象
在所有的内核对象中，事件比其他对象要简单得多。事件包含一个使用计数（这一点和所有 其他内核对象一样），一个用来表示事件是自动重置事件还是手动重置事件的布尔值，以及 另一个用来表示事件有没有被触发的布尔值。
事件的触发表示一个操作巳经完成。有两种不同类型的事件对象：手动重置事件和自动重 置事件。当一个手动重置事件被触发的时候，正在等待该事件的所有线程都将变成可调度 状态。而当一个自动重置事件被触发的时候，只有一个正在等待该事件的线程会变成可调 度状态。
事件最通常的用途是，让一个线程执行初始化工作，然后再触发另一个线程，让它执行剩 余的工作。一开始我们将事件初始化为未触发状态，然后当线程完成初始化工作的时候， 触发事件。此时，另一个线程一直在等待该事件，它发现事件被触发，于是变成可调度状
第9章用内核对象进行线程同步
态。第二个线程知道第一个线程已经完成了它的工作。
247
下面是CreateEvent函数，用来创建一个事件内核对象：
HANDLE CreateEvent(
PSECURITY_ATTRIBUTES psa,
BOOL bManualReset,
BOOL blnitialState,
PCTSTR pszName);
在第3章，我们讨论了内核对象的机理，即如何设置它们的安全属性，如何统计使用计数， 如何继承它们的句柄，以及如何通过名字来共享对象。由于我们已经熟悉了这些内容，因 此就没有必要再在这里介绍这个函数的第一个和第三个参数了。
参数bManualReset是一个布尔值，用来告诉系统应该创建一个手动重置事件(TRUE)还是 一个自动重置事件(FALSE)o参数blnitialState表示应该将事件初始化为触发状态(TRUE) 还是未触发状态(FALSE)o当系统创建了事件对象之后，CreateEvent会返回一个事件内核 对象句柄，这个句柄与当前的进程相关联。Windows Vista还提供了一个新的函数 CreateEventEx来创建事件：
HANDLE CreateEventEx(
PSECURITY_ATTRIBUTES psa,
PCTSTR pszName,
DWORD dwFlags,
DWORD dwDesiredAccess)；
参数psa和pszName与CreateEvent函数中对应的参数相同。参数dwFlags可'以接受两个 位掩码，如表9.1所示。
表9-1用于CreateEventEx的标志
WinBase.h中定义的常量	描述
CREATE_EVENT_INITIAL_SET (0x00000002)	等价于CreateEvent中传入的blnitialState参数。如果设 置了这个位标志，那么函数会将事件初始化为触发状态， 否则函数会将事件初始化为未触发状态
CREATE_EVENT_MANUAL_RESET (0x00000001)	等价于CreateEvent中传入的bManualReset参数。如果 设置了这个位标志，那么创建的将是一个手动重置事件， 否则创建的将是一个自动重置事件
参数dwDesiredAccess允许我们指定在创建事件时返回的句柄对事件有何种访问权限。这 是一种创建事件句柄的新方法，它可以减少权限，相比较而言，CreateEvent总是被授予全 部权限。但CreateEventEx更有用的地方在于它允许我们以减少权限的方式来打开一个已 经存在的事件，而CreateEvent总是要求全部权限。举个例子，为了能够调用下面马上就 会看到的 SetEvent , ResetEvent以及 PulseEvent函数，我们必须使用 EVENT_MODIFY_STATE (0x0002)。如果想了解与访问权限有关的更多细节，请参阅 MSDN 上对应的网页(http://msdn2.microsofi.com/en-us/library/ms686670.aspx)。
%s核心编程(第5版)
其他进程中的线程可以通过多种方式来访问该事件对象，这包括调用CreateEvent并在 pszName参数中传入相同的值，使用继承，使用DuplicateHandle函数，或者调用OpenEvent 并在pszName参数中指定与CreateEvent中相同的名字：
HANDLE OpenEvent(
DWORD dwDesiredAccess,
BOOL blnherit,
PCTSTR pszName)；
248-249
一如既往，我们应该在不再需要事件内核对象的时候调用CloseHandle函数来将它关闭。
一旦创建了事件，我们就可以直接控制它的状态。当调用SetEvent的时候，我们把事件变 成触发状态：
BOOL SetEvent(HANDLE hEvent);
当调用ResetEvent的时候，我们把事件变成未触发状态：
BOOL ResetEvent(HANDLE hEvent);
事情就是这么简单。
Microsoft为自动重置事件定义了一个等待成功所引起的副作用：当线程成功等到自动重置 事件对象的时候，对象会自动地重置为未触发状态。这也正是自动重置对象名字的由来。 对自动重置对象来说，通常不需要调用ResetEvent,这是因为系统会自动将事件重置。相 反,Microsoft并没有为手动重置对象定义一个等待成功所引起的副作用。
现在让我们来看一个例子，它展示了如何使用事件内核对象来对线程进行同步。下面就是 代码：
// Create a global handle to a manual-reset, nonsignaled event.
HANDLE g_hEvent;
int WINAPI _tWinMain(...) {
// Create the manual-reset, nonsignaled event.
g_hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
// Spawn 3 new threads.
HANDLE hThread[3];
DWORD dwThreadID;
hThread[0] = _beginthreadex(NULL, 0, WordCount, NULL, 0, &dwThreadID)； hThread(l] = _beginthreadex(NULL, 0, Spellcheck, NULL, 0, &dwThreadID)； hThread[2] = _beginthreadex(NULL, 0, GrammarCheck, NULL, 0, &dwThreadID);
OpenFi1eAndReadCont entsIntoMemory(...)；
// Allow all 3 threads to access the memory.
SetEvent(g_hEvent)；
• • •
}
DWORD WINAPI WordCount(PVOID pvParam) (
// Wait until the file's data is in memory. WaitForSingleObject(g_hEvent, INFINITE);
第9章用内核对象进行线程同步
// Access the memory block.
return(0); }
DWORD WINAPI Spellcheck (PVOID pvParam) (
// Wait until the file's data is in memory. WaitForSingleObject(g_hEvent, INFINITE);
// Access the memory block.
return(0); )
DWORD WINAPI GrammarCheck (PVOID pvParam) {
// Wait until the file's data is in memory. WaitForSingleObject(g_hEvenc, INFINITE);
// Access the memory block.
return(0)； }
当进程开始运行的时候，它会创建一个未触发的手动重置事件并将句柄保存在一个全局变 量中。这使得进程中的其他线程能够更加容易地访问这个事件对象。接着程序会创建三个 线程。这些线程会一直等待，直到文件内容己经被读入内存为止。然后每个线程会访问数 据：一个线程进行字数统计，另一个线程进行拼写检查，第三个线程进行语法检查。这三 个线程的函数的开头是完全相同的：每个线程都调用了 WaitForSingleObject,这使得线程 被挂起，直到主线程巳经把文件的内容读入到内存中为止。
一旦主线程将数据准备完毕，它会调用SetEvent来触发事件。在这个时候，系统会使所有 三个次要线程都变成可调度状态——它们都会得到CPU时间并会访问内存块。注意，所有 三个线程都将以只读方式来访问内存，这也正是为什么所有三个线程能够同时运行的唯一 原因。另外值得注意的是，如果机器中有多个CPU,那么所有这些线程将能够真正地同时 运行，并能在很短的时间内完成大量的工作。
如果我们用自动重置对象来代替手动重置对象，那么应用程序的行为将会不太一样。当主 线程调用SetEvent之后，系统只会让次要线程中的一个变成可调度状态。再重复一遍，系 统并不保证一定会调度其中的哪个线程。剩下的两个线程将继续等待。
变成可调度状态的那个线程独占对内存块的访问。下面让我们把线程函数改写一下，让每 个函数在返回之前调用SetEvent（就像jWinMain函数中那样）。下面是改写后的线程函数:
DWORD WINAPI WordCount(PVOID pvParam) {
// Wait until the file's data is in memory.
WaitForSingleObject(g_hEvent, INFINITE)；
// Access the memory block.
SetEvent(g_hEvent)； return(0)；
WS核心编程(第5版)
)
DWORD WINAPI Spellcheck (PVOID pvParam) (
// Wait until the file's data is in memory.
WaitForSingleObject(g_hEvent, INFINITE)；
// Access the memory block.
. ・ ♦
SetEvent(g_hEvent)；
return(0)；
}
DWORD WINAPI Grammarcheck (PVOID pvParam) {
// Wait until the file's data is in memory.
WaitForSingleObject(g_hEvent, INFINITE);
// Access Che memory block.
• • •
SetEvent(g_hEvent);
return(0)；
)
当三个线程中的其中一个完成对数据的独占访问时，会调用SetEvent,这样系统会把剩下 两个正在等待的线程中的一个变成可调度状态。再次重申，虽然我们并不知道系统会选择 哪个线程，但是这个线程会独占对内存的访问。当这个线程完成的时候，也同样会调用 SetEvent,这使得第三个也是最后一个线程能够独占对内存块的访问。注意，当我们使用 自动重置事件的时候，即使第二个线程以读/写方式来访问内存，也不会存在任何问题，这 是因为各线程没有必要再继续认为数据是只读的了。这个例子清晰地展示了手动重置事件 和自动重置事件之间的区别。
出于完整性的考虑，下面介绍另一个可以用于事件的函数：
BOOL PulseEvent(HANDLE hEvent)；
PulseEvent会先触发事件然后立刻将其恢复到未触发状态，这就相当于在调用SetEvent之 后立即调用ResetEvent -样。如果对一个手动重置事件调用PulseEvent,那么当事件被脉 冲触发的时候，所有正在等待该事件的线程都会变成可调度状态。如果对一个自动重置事 件调用PulseEvent,那么只有一个正在等待该事件的线程会变成可调度状态。如果当事件 被脉冲触发的时候没有线程在等待该事件，那么将不会产生任何效果。
PulseEvent的用处不大。事实上，我从来没有在实际的应用程序中用过这个函数，这是因 为我们根本不知道到底会不会有线程发现这个触发脉冲，即使有，我们也不知道哪个线程 会发现这个触发脉冲并变成可调度状态。由于在调用PulseEvent的时候我们无法知道任何 线程的状态，因此这个函数并不怎么有用。虽然这么说，而且我也想象不出什么具体的情 形，但是我还是相信在某些情况下，PulseEvent可能会派得上用场。请参阅本章后面对 SignalObjectAndWait的讨论，其中有关于PulseEvent的一些信息。
第9章用内核对象进行线程同步
Handshake示例程序
Handshake应用程序(09-Handshake.exe)展示了自动重置对象的使用。应用程序的源代码和 资源文件在本书配套网页的09-Handshake目录中。Handshake应用程序启动后，会显示下 图所示的对话框。
Handshake接受一个请求字符串，然后颠倒字符串中字符的顺序，最后把结果放到Result 文本框中。Handshake最有趣的是它完成这项任务的方式。
Handshake解决了一个常见的编程问题。我们有一个客户端和一个服务器端，两者想要相 互交流。刚开始，服务器端没有什么事做，于是就进入等待状态。当客户端准备好把请求 提交给服务器端的时候，它会先把请求放到一个共享的内存缓存中，然后触发一个事件， 这样服务器端的线程就知道应该去检查数据缓存并处理客户端的请求了。当服务器端的线 程正在忙于处理请求的时候，客户端线程需要进入等待状态，直到服务器端已经处理完请 求并准备好结果为止。当客户端再次被唤醒的时候，它知道结果就在共享的数据缓存中， 这时就可以把结果显示给用户了。
当应用程序启动的时候，会立即创建两个未触发的自动重置事件对象。一个事件是 g^hevtRequestSubmitted,表示需要服务器端处理的请求在什么时候就绪。这个事件由客 户端来触发，服务器端的线程会等待这个事件。第二个事件是 Oevt-ResultReturned,表 示处理结果在什么时候就绪。这个事件由服务器端的线程来触发，客户线程会等待这个 事件。
当事件创建完成后，程序会创建服务器端线程并执行ServerThread函数。这个函数会立刻 让服务器等待客户端的请求。同时主线程，也就是客户端线程，会调用DialogBox来显示 应用程序的用户界面。我们可以在Request文本框中输入一些文字，然后当用户单击Submit Request To Server按钮的时候，应用程序会把请求字符串放到一个为客户端和服务器端共 享的缓存中，并触发g^hevtRequestSubmitted事件。然后客户端线程会通过 g_hevtResultReturned事件，来等待服务器端的处理结果。
服务器被唤醒后，会把共享的内存缓存中的字符串颠倒顺序，然后触发 g^hevtResultReturned事件。服务器端的线程进入下一轮循环，等待另一个客户请求。注
fjndows核心编程（第5版）
意，该应用程序从来没有调用过ResetEvent,这是因为没有这个必要：当一次等待成功后, 自动重置事件会自动重置为未触发状态。与此同时，客户端线程检测到 g_hevtResultReturned事件己经被触发，于是开始继续执行，把共享内存缓存中的字符串 复制到用户界面上的Result文本框中。
这个应用程序剩下的特性中唯一值得关注的可能就是它的关闭方式了。为了关闭应用程序, 我们只要关闭对话框就可以了。这使WjWinMain中对DialogBox的调用结束。此时，主 线程先把全局变量g_hMainDlg设为NULL,接着把一个特殊的字符串复制到共享内存中， 最后唤醒服务器端的线程，让它来处理这个特殊请求。主线程会等待服务器端的线程，直 到它对请求进行应答并最终结束为止。当服务器端的线程检测到这个特殊的客户请求字符 串，并且发现g_hMainDlg的值为NULL的时候，会跳出循环，线程就此结束。只要主对 话框还显示着，g_hMainDlg的值就不会为NULL,这个神秘的请求也就绝对不会被当成是 要求服务器端的线程退出的请求。
之所以让主线程调用WaitForMultipleObjects来等待服务器端的线程退出，是为了让读者 了解如何使用这个函数。实际匕 我也可以调用WaitForSingleObject并传入服务器端的 线程的句柄，两种方法得到的结果完全相同。
一旦主线程知道服务器端的线程已经停止执行，它会调用CloseHandle H次来销毁应用程 序使用的所有内核对象。当然，我们也可以让系统自动执行关闭操作，但对我来说，自己 做的感觉会更好。我喜欢代码始终在我的掌控之下。
#include #include ♦include #include
■..\CommonFiles\CmnHdr.h" <windowsx.h> <tchar.h>
■Resource.h*
Handshake・ cpp /***********************************★**************★***************•**********• Module: Handshake.cpp
Notices： Copyright (c) 2008 Jeffrey Richter & Christophe Nasarre
*************************************************** *.************** ★.***★**•***.*
////////////////////////////////////////////////////////////zy/SBKHIIIMHB^
// This event is signaled when the client has a 日 HANDLE g_hevt Request Submi 11 ed;
•「"；,‘ a/, I',：：，’ £ 二 从魅
// This event is signaled when the server has a
HANDLE g_hevtResultReturned;
// The buffer shared between the client and server threads TCHAR g_szSharedRequestAndResultBuf fer[1024]；
Z/J The special value sent from the client that c&uses 七精"横 // server thread to terminate cleanly.
TCHAR g_szServerShutdown[]=
TEXT(•Server Shutdown■)；
// The server thread will check that the main dialog is no // when the shutdown message is received.
HWND g__hMa inDig；
第9章用内核对象进行线程同步
///////////////////////////////////////////////////////////////////////////////
// This is the code executed by the server thread
DWORD WINAPI ServerThread(PVOID pvParam) (
// Assume that the server thread is to run forever
BOOL fShutdown = FALSE;
while (!fShutdown) (
// Wait for the client to submit a request
WaitForSingleObject(g_hevtRequestSubmitted, INFINITE)；
// Check to see if the client wants the server to terminate fShutdown =
(gJiMainDlg == NULL) && (__tcscmp(g_szSharedReque8tAndResultBufferr g__szServerShutdown) == 0);
if (!fShutdown) (
// Process the client's request (reverse the string) _tcsrev(g_szSharedRequestAndResultBuffer);
}
// Let the client process the request's result
SetEvent (g_hevtResultRetumed)；
// The client wants us to shut down, exit return(0);
///////////////////////////////////////////////////////////////////////////////
BOOL Dlg_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM 1Param) ( chSETDLGICONS(hwnd, IDI_HANDSHAKE);
// Initialize the edit control with some test data request Edit_SetText(GetDlgItem(hwndr IDC_REQUEST), TEXT("Some test data')); // Store the main dialog window handle g_hMainDlg = hwnd;
return(TRUE)；
//〃///////////////〃〃/〃//〃//////////〃////////〃〃〃〃/〃〃〃///〃//〃/////
void Dlg_OnCommand(HWND hwnd, int id, HWND hwndCtl；.tUINT codeNotify) -
switch (id) (
」■；	、?；,	m宫
case IDCANCEL:
EndDialog(hwnd, id)；
break；
case IDC_SUBMIT： // Submit a request to the server thread	挥翌;漏•皆露爆
// Copy the request string into the shared data buffer EditjGetText(GetDlgItem(hwnd, IDC_REQUEST),
g_szSharedRequestAndResultBuffer.


Windows核心编程（第5版）
..countof (g_szSharedRequestAndResultBuf f er));
// Let the server thread know that a request is ready in the buffer SetEvent(g_hevtRequestSubmitted);
// Wait for the server to process the request and give us the result WaitForSingleObject(g_hevtResultReturned, INFINITE);
// Let the user know the result
Edit_SetText(GetDlgItem(hwnd, IDC_RESULT), g_szSharedRequestAndResultBuffer)；
break；
)
}
///////////////////////////////////////////////////////////////////////////////
INT_PTR WINAPI Dlg_Proc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM iParam) ( switch (uMsg) { chHANDLE_DLGMSG(hwnd, WM_INITDIALOG, Dlg^OnlnitDialog);
chHANDLE_DLGMSG(hwnd, WWLCOMMAND, Dlg_OnCoiranand);
}
return(FALSE);
)
//////////////////////////////////////////////////////////////////////////////I
int WINAPI _tWinMain(HINSTANCE hlnstanceExe, HINSTANCE, PTSTR, int) {
// Create & initialize the 2 nonsignaled, auto-reset events g_JievtRequestSubmi11ed = CreateEvent(NULLZ FALSE, FALSE, NULL); g.hevtResultReturned = CreateEvent(NULL, FALSE, FALSE, NULL);
// Spawn the server thread
DWORD dwThreadID；
HANDLE hThreadServer = chBEGINTHREADEX(NULL, 0, ServerThread, NULLk? 0, &dwThreadID);
// Execute the client thread's user interface
DialogBox (hlnstanceExe, MAKEINTRESOURCE (工DJHANDSHAKE), NULL, Dlg__Proc); gJiMainDlg = NULL;
// The client * s UI is closing, have the server thread shutdown _tcscpy_s(g_szSharedRequestAndResultBuffer,
_count of (g_:
SetEvent(g_hev
RequestSubmitte	2d)；	精孳密蓊耕巍
		
server thread	to acknowledge t	
server thread	to fully termina	te耘：；；： '彦藏艇嚓
// Wait for the
// wait for the HANDLE h[2]; h[0] = g—hevtResultReturned； h[l] = hThreadServer; WaitForMultipleObjects(2r h, TRUE, INFINITE);
// Properly clean up everything CloseHandle(hThreadServer)；
CloseHandle (g__hevtRequestSubmitted)；
CloseHandle(g^hevtResultReturned)；
77 The client thread terminates with the whole process

第9章用内核对象进行线程同步
return(0);
//////////////////////////////// End of File //////〃////〃////////〃//////////
9.4可等待的计时器内核对象
可等待的计时器是这样一种内核对象，它们会在某个指定的时间触发，或每隔一段时间触 发一次。它们通常用来在某个时间执行一些操作。
要创建可等待的计时器，我们只需调用CreateWaitableTimer函数:
HANDLE CreateWaitableTimer( PSECURITY_ATTRIBUTES psa, BOOL bManualReset, PCTSTR pszName);
参数psa和pszName在第3章己经讨论过。当然了，进程还可以调用OpenWaitableTimer 函数来得到一个已经存在的可等待计时器的句柄，该句柄与当前进程相关联：
HANDLE OpenWaitableTimer( DWORD dwDesiredAccess, BOOL blnheritHandle, PCTSTR pszName);
与事件一样，参数bManualReset表示要创建的是一个手动重置计时器还是自动重置计时 器。当手动重置计时器被触发的时候，正在等待该计时器的所有线程都会变成可调度状态。 当自动重置计时器被触发的时候，只有一个正在等待该计时的线程会变成可调度状态。
在创建的时候，可等待的计时器对象总是处于未触发状态。当我们想要触发计时器的时候, 必须调用SetWaitableTimer函数来告诉它：
BOOL SetWaitableTimer(
HANDLE hTimer, const LARGE_INTEGER *pDueTime, LONG IPeriod,
PTIMERAPCROUTINE pfnCompletionRoutine, PVOID pvArgToCompletionRoutine,
BOOL bResume)；
这个函数有许多参数，在使用的时候很容易让人感到疑惑。当然，参数hTimer表示我们 想要触发的计时器。后面两个参数pDueTime和IPeriod在一起使用。参数pDueTime表示 计时器第一次触发的时间应该在什么时候，参数IPeriod表示在第一次触发之后，计时器应 该以怎样的频度触发。下面的代码把计时器的第一次触发时间设为2008年1月1日下午 1:00,之后每隔6小时触发一次：
// Declare our local variables. HANDLE hTimer;
SYSTEMTIME St;
FILETIME ftLocal, ftUTC; LARGE_INTEGER liUTC;
dows核心编程(第5版)
// Create an auto-reset timer.
hTimer = CreateWaitableTimer(NULL, FALSE, NULL);
// First signaling is at January 1, 2008, at 1:00 P-M. (local time).
st.wYear	=	2008；	//	Year			
st.wMonth	=	1;	//	January			
st.wDayOfWeek	=	0;	//	Ignored			
st.wDay	=	1；	//	The first	of the month		
st.wHour	=	13;	//	1PM			
st.wMinute	=	0;	//	0 minutes	into	the	hour
st.wSecond	=	0;	//	0 seconds	into	the	minute
st.wMilliseconds	=o；	//	0 milliseconds		into the second	
SystemTimeToFileTime(&st, &ftLocal);
// Convert local time to UTC time.
LocalFileTimeToFileTime(&ftLocal, &ftUTC);
// Convert FILETIME to LARGE_INTEGER because of different alignment.
liUTC.LowPart = ftUTC.dwLowDateTime； liUTC.HighPart = ftUTC.dwHighDateTime； // Set the timer.
SetWaitableTimer(hTimer, &liUTC, 6 * 60 * 60 * 1000,
NULL, NULL, FALSE) ; . . .
痴沱57~258尹
前述代码先初始化了一个SYSTEMTIME结构，用来表示计时器第一次触发的时间。这个 时间是本地时间，也就是根据本机的时区校正后的时间。由于SetWaitableTimer的第二个 参数的类型是const LARGEJNTEGER *,因此它不能直接接受SYSTEMTIME结构。但 是，FILETIME结构和LARGEJNTEGER结构的二进制格式完全相同，两者都包含两个 32位值。因此，我们可以把SYSTEMTIME结构转型为FILETIME结构。下面还有一个 问题，对SetWaitableTimer来说，它认为传入的时间始终是全球标准时间(Coordinated Universal Time, UTC)。我们可以调用LocalFileTimeToFileTime,这样就可以轻易地完成 时间转换。
由于FILETIME结构和LARGEJNTEGER结构的二进制格式完全相同，因此我们可能 倾向于直接把FILETIME结构传给SetWaitableTimer,如下面的代码所示：
// Set the timer.
SetWaitableTimer(hTimer, (PLARGE_INTEGER) &fLUTC,
6 * 60 * 60 * 1000, NULL, NULL, FALSE);
事实上，这也正是我一开始所写的代码。但这是个严重的错误！虽然FILETIME结构和 LARGEJNTEGER结构具有完全相同的二进制格式，但是这两个结构的对齐方式是不同 的。所有FILETIME结构的地址必须对齐到32位边界①，而所有LARGE_INTEGER结 构的地址则必须对齐到64位边界二 调用SetWaitableTimer并传入FILETIME结构是否 能够正常工作，取决于FILETIME结构是否正好在64位边界上。但是，编译器会确保 LARGEJNTEGER结构的地址始终都在64位边界上，因此正确的做法(任何时候都能够 正常工作的做法)是先把FILETIME的成员复制到LARGEJNTEGER的成员中，然后再
①	译注：即地址是4的整数倍。
②	译注：即地址是8的整数倍。
第9章用内核对象进行线程同步
把 LARGE_INTEGER 的地址传给 SetWaitableTimer。
说明x86处理器会对未经对齐的数据引用进行处理，而不会报错。因此，如果应用 程序是在 x86处理器上运行，那么把一个 FILETIME 地址传给 SetWaitableTimer将总是能够正常工作。但是，其他处理器不会不报任何错误， 就直接对未经对齐的数据引用进行处理。实际上，大多数其他处理器会抛出 EXCEPTION_DATATYPE_MISALIGNMENT异常，从而导致进程被终止。在把 代码从x86处理器移植到其他处理器的时候，对齐错误是产生问题的最大原因。如 果我们现在开始注意对齐问题，那么今后在移植代码的时候就能够节省大量的时间 和精力！与对齐问题有关的更详细信息，请参阅第13章。
现在，为了使计时器能够在2008年1月1日下午1:00之后每隔6小时触发一次，让我们 来关注一下IPeriod参数。这个参数表示自从第一次触发之后，计时器应该以怎样的频度触 发。对6小时来说，传入的参数是21 600 000(6小时x每小时60分钟x每分钟60秒x每秒 1000微秒)。顺便提一下，即使传入的时间是一个已经逝去的绝对时间，比如1975年1月 1日下午1:00, SetWaitableTimer也不会失败。
在调用SetWaitableTimer的时候，我们除了能给计时器第一次触发的时间指定一个绝对时 间，还可以指定一个相对时间。只要在pDueTime参数中传入一个负值。传入的值必须是 100纳秒的整数倍。由于我们一般不太会以100纳秒为单位来考虑问题，因此下面的换算 可能会有所帮助：1秒=1 000毫秒=1 000 000微秒=10 000 000个100纳秒。
下面的代码把计时器第一次触发的时间设为SetWaitableTimer调用结束的5秒钟后：
// Declare our local variables.
HANDLE hTimer;
LARGE_INTEGER li;
// Create an auto-reset timer.
hTimer = CreateWaitableTimer(NULL, FALSE, NULL);
// Set the timer to go off 5 seconds after calling SetWaitableTimer.
// Timer unit is 100 nanoseconds.
const int nTimerUnitsPerSecond = 10000000;
// Negate the time so that SetWaitableTimer knows we
// want relative time instead of absolute time.
li.QuadPart = -(5 * nTimerUnitsPerSecond)；
// Set the timer.
SetWaitableTimer(hTimer, &li, 6 * 60 * 60 * 1000,
NULL, NULL, FALSE); •・.
通常莪们会希望有一种一次性计时器，这种计时器只触发一次，之后再也不触发。这很容 易实现，只要给IPeriod参数传0就可以了。然后我们可以调用CloseHandle来关闭计时器, 或者再次调用SetWaitableTimer来重置计时器，给它设置一个新的触发时间。
对支持挂起(suspend)和继续执行(resume)的计算机来说，SetWaitableTimer的最后一个参数 bResume会有用处。我们通常传FALSE给这个参数，刚才那段代码就是这么做的。但是，
r
OWS核心编程(第5版)
如果我们正在编写一个会议规划程序之类的应用程序，那么应该传TRUE给这个参数。当 计时器被触发的时候，系统会使机器结束挂起模式(如果机器正处于挂起模式下)，并唤醒 正在等待该计时器的线程。应用程序这时可以播放一个声音，并向用户显示一个消息框， 告诉用户即将召开的会议。如果传给bResume参数的值是FALSE,那么计时器会被触发， 但在机器继续执行之前(通常是用户使机器继续执行)，被唤醒的任何线程都得不到CPU 时间。
如果不讨论CancelWaitableTimer,那么我们对可等待的计时器的介绍就不够完整：
BOOL CancelWaitableTimer(HANDLE hTimer);
这个函数很简单，只有一个参数。该函数会把句柄所标识的计时器取消，这样计时器就永 远不会触发了，除非以后再调用SetWaitableTimer来对它进行重置。如果想要改变计时器 的触发时间，那我们并不一定要在调用SetWaitableTimer之前调用CancelWaitableTimero 每次调用SetWaitableTimer都会在设置新的触发时间之前将原来的触发时间取消。
9.4.1让可等待的计时器添加APC调用
到目前为止，我们己经学习了如何创建计时器以及如何设置计时器。我们也知道了如何把 句柄传给WaitForSingleObject或WaitForMultipleObjects函数来等待计时器触发。另夕卜， 当计时器触发的时候，Microsoft还允许计时器把一个异步过程调用(asynchronous procedure call, APC)放到SetWaitableTimer的调用线程的队列中。
通常，当我们调用SetWaitableTimer的时候，会给pfnCompletionRoutine和 pvArgToCompletionRoutine 两个参数传 NULL。当 SetWaitableTimer 看到这两个参数为 NULL的时候，它知道时间一到应该触发计时器对象。但是，如果希望时间一到就让计时 器把一个APC添加到队列中去，就必须实现一个计时器APC函数，并把函数的地址传入。 这个函数的原型如下：
VOID APIENTRY TimerAPCRoutine(PVOID pvArgToCompletionRoutine,
DWORD dwTimerLowValue, DWORD dwTimerHighValue) (
// Do whatever you want here.
)
我将这个函数命名为TimerAPCRoutine,但读者也可以用任何自己喜欢的名字来给它命名。 计时器被触发的时候，当且仅当SetWaitableTimer的调用线程正处于可提醒状态(alertable state)时，这个函数会被同一个线程①调用。换句话说，线程必须是由于调用SleepEx、 WaitForSingleObjectEx、WaitForMultipleObjectsEx、MsgWaitForMultipleObjectsEx 或 SignalObjectAndWait而进入的等待状态。如果线程并非在其中的一个函数内等待，那么 系统不会把计时器的APC函数添加到队列中。这可以避免线程的APC队列因为计时器的
① 译注：即调用SetWaitableTimer的线程.
第9章用内核对象进行线程同步
APC通知而负荷过多，从而避免浪费系统中的大量内存。第10章更详细地介绍了可提醒 状态。
当计时器被触发的时候，如果线程处于可提醒状态，系统会让线程调用回调函数。回调函 数的第一个参数的值与我们传给SetWaitableTimer函数的pvArgToCompletionRoutine参 数的值相同。我们可以给TimerAPCRoutine传一些上下文信息(通常是一个指针，指向一 个自定义的结构)。剩下的两个参数，dwTimerLowValue和dwTimerHighValue,表示计 时器被触发的时间。下面的代码读取这些信息并将它显示给用户：
VOID APIENTRY TimerAPCRoutine(PVOID pvArgToCompletionRoutine,
DWORD dwTimerLowValue, DWORD dwTimerHighValue) (
FILETIME ftUTC, ftLocal;
SYSTEMTIME st;
TCHAR szBuf[256];
// Put the time in a FILETIME structure.
ftUTC.dwLowDateTime = dwTimerLowValue；
ftUTC.dwHighDateTime = dwTimerHighValue；
// Convert the UTC time to the user's local time.
FileTimeToLocalFileTime(&ftUTC, &ftLocal)；
// Convert the FILETIME to the SYSTEMTIME structure
// required by GetDateFormat and GetTimeFormat.
FileTimeToSystemTime(&ftLocalz &st)；
// Construct a string with the
// date/time that the timer went off.
GetDateFormat(LOCALE_USER_DEFAULT, DATE_LONGDATE,
&st, NULL, szBuf, _countof(szBuf))；
_tcscat_s(szBufz _countof(szBuf)z TEXT(■ ■))；
GetTimeFormat(LOCALE_USER_DEFAULT, 0,
&st, NULL, _tcschr(szBuf, TEXT(1\0')),
(int)(_countof(szBuf) - _tcslen(szBuf)))；
// Show the time to the user.
MessageBox(NULL, szBuf, TEXT("Timer went off at..."), MB_OK)；
}
只有当所有的APC函数都处理完毕后，才会返回可警告函数(alertable function)e因此，我 们必须确保自己的TimerAPCRoutine函数会在计时器再次被触发之前结束，不然APC函 数加入队列的速度就快过了处理它们的速度。
下面的代码显示了使用计时器和APC的正确方法：
void SomeFunc() {
// Create a timer. (It doesn't matter whether it's manual-reset
// or auto-reset.)
HANDLE hTimer = CreateWaitableTimer(NULL, TRUE, NULL)；
// Set timer to go off in 5 seconds.
LARGE_INTEGER li = { 0 };
SetWaitableTimer(hTimer, &li, 5000, TimerAPCRoutine, NULL, FALSE)；
// Wait in an alertable state for the timer to go off.
SleepEx(INFINITE, TRUE);
CloseHandle(hTimer)；
}
Endows核心编程（第5版）
最后提醒一句：线程不应该在等待一个计时器句柄的同时以可提醒的方式等待同一个计时 器。让我们看一看下面的代码：
HANDLE hTimer = CreateWaitableTimer（NULL, FALSE, NULL）；
SetWaitableTimer（hTimer, ..., TimerAPCRoutine,...）;
WaitForSingleObjectEx（hTimer, INFINITE, TRUE）；
我们不应该编写类似的代码，因为对WaitForSingleObjectEx的调用实际上会等待计时器 两次：一次是可提醒的，另一次是内核对象句柄。当计时器被触发的时候，等待成功，线 程被唤醒，这使线程退出可提醒状态，APC函数没有被调用。正如前面已经提到过，我们 一般很少有理由要在使用可等待计时器的同时使用APC函数，因为我们总是可以先等待计 时器被触发，然后再执行我们想要执行的操作。
9.4.2计时器的剩余问题
计时器被频繁用于通信协议。例如，如果客户向服务器发送一个请求而服务器未能在一定 时间内响应，那么客户可以认为服务器不可用。今天，客户机会同时与多个服务器进行通 信。如果要为每个请求创建一个计时器内核对象，那将影响到系统的性能。可以想象一下， 对大多数应用程序来说，只创建一个计时器对象并根据需要改变触发时间，应该是可行的。 对计时器的触发时间进行管理并重置计时器是一项乏味的工作，很少有应用程序真的这样 做。但是，在新的线程池函数（会在第11章中介绍）中，有一个叫CreateThreadpoolTimer 的函数，它可以帮助我们完成所有这些工作。如果需要创建并管理多个计时器对象，那么 应该看一看这个函数，它可以降低应用程序的开销。
计时器可以将APC函数添加到线程的队列中，这一点虽然好，但现今大多数的应用程序并 没有使用APC,而是使用I/O完成端D（I/O completion port）机制。过去，我曾经需要每隔一 段时间把自己的（通过I/O完成端口来管理的）线程池中的一个线程唤醒。不巧的是，可等待 的计时器并不提供相应的支持。为了满足自己的需求，我不得不另外再创建一个线程，这 个线程唯一的工作就是设置和等待可等待的计时器。当计时器被触发的时候，该线程会调 用PostQueuedCompletionStatus来强制为我的线程池中的线程触发事件。
最后要注意一点：任何有经验的Windows开发人员会立即比较可等待计时器和用户计时器 （通过SetTimer函数来设置）。两者最大的区别在于用户计时器需要在应用程序中使用大量 的用户界面基础设施，从而消耗更多的资源。此外，可等待计时器是内核对象，这意味着 它们不仅可以在多个线程间共享，而且可以具备安全性。
用户计时器会产生WM_TIMER消息，这个消息被送回调用SetTimer的线程（对回调计时 器来说），或者被送回创建窗口的线程（对基于窗口的计时器来说）。因此，当一个用户计时 器触发的时候，只有一个线程会得到通知。另一方面，多个线程可以等待可等待计时器， 如果计时器是手动重置计时器，那么有多个线程可以变成可调度状态。
第9章用内核对象进行线程同步
如果打算在计时器被触发的时候执行与用户界面相关的操作，那么使用用户计时器可能会 使代码更容易编写，这是因为使用可等待计时器要求线程既要等待消息，又要等待内核对 象。（如果想要改写我们的代码，那么可以使用MsgWaitForMultipleObjects函数，它的存 在正是为了这个目的。）最后，如果使用可等待计时器，那我们更有可能是因为等待超时而 得到通知。WM_TIMER消息总是优先级最低的，只有当线程的消息队列中没有其他消息 的时候才会被处理。可等待的计时器的处理方式与其他内核对象没有任何不同，如果计时 器被触发而且线程正在等待，那么系统将唤醒线程。
9.5信号量内核对象
信号量内核对象用来对资源进行计数。与其他所有内核对象相同，它们也包含一个使用计 数，但它们还包含另外两个32位值：一个最大资源计数和一个当前资源计数。最大资源计 数表示信号量可以控制的最大资源数量，当前资源计数表示信号量当前可用资源的数量。
为了正确理解信号量的重要性，让我们来看一看应用程序会如何使用它。假设我们正在开 发一个服务器进程，其中分配了一块缓存来保存客户请求。我们已经在代码中把缓存的大 小固定死了，这样服务器进程在任一时刻最多只能保存5个客户请求。如果一个新的客户 试图在尚有5个请求未处理的时候来连接服务器，那么它将被拒绝并得到一个错误信息， 表示服务器正忙，请该客户稍后重试。
262
当我们的服务器进程初始化的时候，会创建一个线程池，它由5个线程组成，每个线程都 已准备就绪，新的客户请求一到就可以进行处理。
刚开始，还没有客户发出请求，因此我们的服务器不允许对线程池中的任何线程进行调度。 但是，如果有三个客户请求同时到达，那么线程池中的三个线程应该变成可调度状态。我 们可以用信号量来非常好地监视资源并调度线程：把资源计数设为5,因为这是我们事先 定好的缓存容量。由于还没有客户发出请求，因此当前资源计数被初始化为Oo随着服务 器不断接受客户请求，当前资源计数随之递增；随着服务器线程池接手处理客户请求，当 前资源计数随之递减。
信号量的规则如下：
•	如果当前资源计数大于0,那么信号量处于触发状态
•	如果当前资源计数等于0,那么信号量处于未触发状态
•	系统绝对不会让当前资源计数变为负数
•	当前资源计数绝对不会大于最大资源计数
在使用信号量的时候，不要把信号量对象的使用计数和它的当前资源计数混为一谈。
下面这个函数用来创建信号量内核对象：
lows核心编程（第5版）
HANDLE CreateSemaphore( PSECURITY_ATTRIBUTE psa, LONG UnitialCount, LONG IMaximumCount, PCTSTR pszName);
参数psa和pszName在第3章已经讨论过。我们也可以用下面这个函数来直接在 dwDesiredAccess参数中指定访问权限。注意，dwFlags是系统保留的，应该设为0。
HANDLE CreateSemaphoreEx( PSECURITY.ATTRIBUTES psa, LONG UnitialCount, LONG IMaximumCount, PCTSTR pszName, DWORD dwFlags,
DWORD dwDesiredAccess);
当然，任何进程都可以调用OpenSemaphore来得到一个己经存在的信号量的句柄，该句 柄与当前进程相关联：
HANDLE OpenSemaphore( DWORD dwDesiredAccess, BOOL blnheritHandle, PCTSTR pszName);
参数IMaximumCount告诉系统应用程序能够处理的资源的最大数量。由于这是一个32位 有符号值，因此我们最多可以有2 147 483 647个资源。参数UnitialCount表示这些资源中 一开始（现在）有多少个可供使用。在我们的服务器进程初始化的时候，没有任何客户请求, 因此我们用下面的代码来调用CreateSemaphore：
HANDLE hSemaphore = CreateSemaphore(NULL, 0, 5, NULL);
这行代码创建一个信号量，它的最大资源计数为5,但一开始只有0个资源可供使用。（顺 便提一下，这个内核对象的使用计数是1,这是因为我们刚创建它，不要把这些计数器搞 混了。）因为当前资源计数器被初始化为0,所以信号量未被触发。任何等待该信号量的线 程将因此进入等待状态。
为了获得对被保护资源的访问权，线程要调用一个等待函数并传入信号量的句柄。在内部, 等待函数会检查信号量的当前资源计数，如果它的值大于0（信号量处于触发状态），那么函 数会把计数器减1并让调用线程继续运行。信号量最大的优势在于它们会以原子方式来执 行这些测试和设置操作，也就是说，当我们向信号量请求一个资源的时候，操作系统会检 查资源是否可用，并将可用资源的数量递减，整个过程不会被别的线程打断。只有当资源 计数递减完成之后，系统才会允许另一个线程请求对资源的访问。
如果等待函数发现信号量的当前资源计数为0（信号量处于未触发状态），那么系统会让调用 线程进入等待状态。当另一个线程将信号量的当前资源计数递增时，系统会记得那个（或那 些）还在等待的线程，使它们变成可调度状态（并相应地递减当前资源计数）。
线程通过调用ReleaseSemaphore来递增信号量的当前资源计数:
第9章 用内核对象进行线程同步
BOOL Releasesemaphore（
HANDLE hSemaphore,
LONG IReleaseCount,
PLONG plPreviousCount）;
这个函数只是把IReleaseCount的值加到信号量的当前资源计数上。通常我们会传1给 IReleaseCount参数，但这不是必需的。我常常会传2或更大的值。该函数同时会在 *plPreviousCount中返回当前资源计数的原始值。很少有应用程序会真的用到这个值，因 此我们可以直接传NULL来忽略它。
有时候，我们可能想知道一个信号量的当前资源计数，但同时又不改变它的值。最开始的 时候，我觉得调用ReleaseSemaphore函数并给IReleaseCount参数传0也许是可行的。但 事实上这行不通，ReleaseSemaphore会直接把*plPreviousCount设成0。接着，我又尝试 了在第二个参数中传入一个非常大的值，希望这样做不会影响当前资源计数，因为那会使 计数值超过最大允许值。但ReleaseSemaphore还是会把*p!PreviousCount的值设为0。很 遗憾，我们没有办法在不改变当前资源计数的前提下来得到它的值。
264
9.6互斥量内核对象
互斥量（mutex）内核对象用来确保一个线程独占对一个资源的访问。实际上，这也是互斥量 名字的由来七互斥量对象包含一个使用计数、线程ID以及一个递归计数。互斥量与关键 段的行为完全相同。但是，互斥量是内核对象，而关键段是用户模式下的同步对象。（除非 对资源的争夺非常激烈，这种情况下等待关键段的线程将不得不进入内核模式等待，正如 我们在第8章所见到的那样。）这意味着互斥量比关键段慢。但这同时意味着不同进程中的 线程可以访问同一个互斥量，这还意味着线程可以在等待对资源的访问权时指定一个最长 等待时间。
线程ID用来标识当前占用这个互斥量的是系统中的哪个线程，递归计数表示这个线程占用 该互斥量的次数。互斥量有许多用途，它们是使用最为频繁的内核对象之一。它们一般用 来对多个线程访问的同一块内存进行保护。如果多个线程要同时更新内存块，那么其中的 数据将遭到破坏。互斥量可以确保正在访问内存块的任何线程会独占对内存块的访问权， 这样就维护了数据的完整性。
下面是互斥量的规则：
•	如果线程ID为0（无效线程ID）,那么该互斥量不为任何线程所占用，它处于触发 状态
•	如果线程ID为非零值，那么有一个线程已经占用了该互斥量，它处于未触发状态
•	与所有其他内核对象不同，操作系统对互斥量进行了特殊处理，允许它们违反一些 常规的规则（我们马上就会讲解这些例外的情况）
① 译注：mutex = mutual exclusive。
lows核心编程（第5版）
要使用互斥量，进程必须先调用CreateMutex来创建一个互斥量：
HANDLE CreateMutex(
PSECURITY_ATTRIBUTES psa,
BOOL blnitialOwner,
PCTSTR pszName);
参数psa和pszName在第3章已经讨论过。我们也可以用下面这个函数来直接在 dwDesiredAccess参数中指定访问权限。参数dwFlags替代了 CreateMutex中的参数 blniHalOwned： 0 表示 FALSE, CREATE_MUTEX_ INITIAL_OWNER 等价于 TRUEo
HANDLE CreateMutexEx(
PSECURITY_ATTRIBUTES psa,
PCTSTR pszName,
DWORD dwFlags,
DWORD dwDesiredAccess);
当然，另一个进程也可以调用OpenMutex来得到一个已经存在的互斥量的句柄，该句柄与 当前进程相关联：
HANDLE OpenMutexf
DWORD dwDesi redAcces s,
BOOL blnheritHandle,
PCTSTR pszName）;
参数blnitialOwner用来控制互斥量的初始状态。如果传的是FALSE（通常的情况），那么 互斥量对象的线程ID和递归计数都将被设为0。这意味着互斥量不为任何线程占用，因此 处于触发状态。
如果给blnitialOwner传的是TRUE,那么对象的线程ID将被设为调用线程的线程ID,递 归计数将被设为1。由于线程ID为非零值，因此互斥量最初处于未触发状态。
为了获得对被保护资源的访问权，线程要调用一个等待函数并传入互斥量的句柄。在内部, 等待函数会检查线程ID是否为0（互斥量处于触发状态）。如果为0,那么函数会把线程ID 设为调用线程的线程ID,把递归计数设为1,然后让调用线程继续运行。
如果等待函数检测到线程ID不为0（互斥量处于未触发状态），那么调用线程将进入等待状 态。当另一个线程将互斥量的线程ID设为0的时候，系统会记得有一个线程正在等待，于 是它把线程ID设为正在等待的那个线程的线程ID,把递归计数设为1,使正在等待的线程 变成可调度状态。一如既往，这些对互斥量内核对象的检查和修改都是以原子方式进行的。
在用来触发普通内核对象和撤销触发普通内核对象的规则中，有一条不适用于互斥量。假 设线程试图等待一个未触发的互斥量对象。在这种情况下，线程通常会进入等待状态。但 是，系统会检查想要获得互斥量的线程的线程ID与互斥量对象内部记录的线程ID是否相 同。如果线程ID一致，那么系统会让线程保持可调度状态——即使该互斥量尚未触发。对 系统中的任何其他内核对象来说，我们都找不到这种“异常”的举动。每次线程成功地等 待了一个互斥量，互斥量对象的递归计数会递增。使递归计数大于1的唯一途径是利用这 个例外，让线程多次等待同一个互斥量。
第9章用内核对象进行线程同步
一旦成功地等到了互斥量，线程就知道自己已经独占了对受保护资源的访问。任何试图(通 过等待互斥量来)获得对资源的访问权的线程将进入等待状态。当目前占有访问权的线程不 再需要访问资源的时候，它必须调用ReleaseMutex函数来释放互斥量：
BOOL ReleaseMutex(HANDLE hMutex)；
这个函数会将对象的递归计数减lo如果线程成功地等待了互斥量对象不止一次，那么线 程必须调用ReleaseMutex相同的次数才能使对象的递归计数变成0。当递归计数变成0的 时候，函数还会将线程ID设为0,这样就触发了对象。
当对象被触发的时候，系统会检查有没有其他线程正在等待该互斥量。如果有，那么系统 会“公平地”选择一个正在等待的线程，把互斥量的所有权给它。当然，这就意味着把 对象内部的线程ID设为所选择的那个线程的线程ID,并把递归计数设为lo如果没有线程 在等待互斥量，那么该互斥量会保持在触发状态，这样下一个等待它的线程就可以立即得 到它。
9.6.1遗弃问题
互斥量与所有其他内核对象不同，这是因为它们具有“线程所有权”的概念。我们在本章 讨论的所有内核对象中，除了互斥量，没有任何一个会记住自己是哪个线程等待成功的。
互斥量的这种线程所有权的概念，也是它具有特殊规则的原因，这使它即使在未触发的状 态下，也能为线程所获得。
这个例外不仅适用于试图获得互斥量的线程，而且适用于试图释放互斥量的线程。当线程 调用ReleaseMutex的时候，函数会检查调用线程的线程ID与互斥量内部保存的线程ID是 否一致。如果线程ID一致，那么正如我们前面已经提到过的那样，递归计数会递减。如果 线程ID不一致，那么ReleaseMutex将不执行任何操作并返回FALSE(表示失败)给调用者。 这时调用GetLastError会返回ERROR_NOT_OWNER(试图释放的互斥量不属于调用者)。 因此，如果占用互斥量的线程在释放互斥量之前终止(使用ExitThread> TerminateThread, ExitProcess或TerminateProcess),那对互斥量和正在等待该互斥量的线程来说，会发生什 么情况呢？答案是系统认为互斥量被遗弃(abandoned)——由于占用互斥量的线程已经终 止，因此再也无法释放它。
因为系统会记录所有的互斥量和线程内核对象，因此它确切地知道互斥量何时被遗弃。当 互斥量被遗弃的时候，系统会自动将互斥量对象的线程ID设为0,将它的递归计数设为0。 然后系统会检查有没有其他线程正在等待该互斥量。如果有，那么系统会“公平地”选择 一个正在等待的线程，把对象内部的线程ID设为所选择的那个线程的线程ID,并把递归 计数设为1,这样被选择的线程就变成可调度状态。
这一切都和从前一样，唯一的不同之处在于等待函数不再返回通常的WAIT OBJECT 0,
jndows核心编程（第5版） 
而是返回一个特殊的值WAIT_ABANDONEDo这个特殊的返回值（只适用于互斥量）表示线 程正在等待的互斥量为其他线程所占用，但该线程在完成对共享资源的使用之前终止了。 这种情况有些尴尬。刚获得互斥量的线程并不知道资源目前处于什么状态——它可能己经 被完全破坏了。在这种情况下，我们的应用程序必须自己决定该怎么做。
在实际情况中，由于线程很少会不释放互斥量就直接终止，因此大多数应用程序从来不会 显式地检查WAIT_ABANDONED返回值。（这里的讨论也提供了另一个非常好的例子，告 诉我们为什么绝对不应该调用TerminateThread函数。）
9.6.2互斥量与关键段的比较
就如何对等待它们的线程进行调度而言，互斥量和关键段具有相同的语义。但是，它们的 其他方面有所不同。表9.2对它们进行了比较。
表9・2互斥■和关键段的比较
特征	互斥■	关键段
性能	慢	快
是否能跨进程使用	是	否
声明	HANDLE hmtx;	CRITICAL SECTION cs;
初始化	hmtx = CreateMutex (NULL, FALSE, NULL);	InitializeCriticalSectioii(&cs);
清理	CloseHan(lle(hintx);	DeleteCriticalSection(&cs);
无限等待	WaitForSingleObject (hmtx, INFINITE);	EnterCriticalSection(£cs);
0等待	WaitForSingleObject (hmtx, 0);	TryEnterCriticalSection(&cs);
任意时间长度的等待	TryEnterCriticalSection(&cs);	不支持
释放	ReleaseMutex(hmtx);	LeaveCriticalSection(&cs);
是否能同时等待其他内 核对象	是（使用 WaitForMultipleObjects 或类似的 函数）	否
9.6.3	Queue示例程序
Queue应用程序（09-Queue.exe）使用了一个互斥量和一个信号量来对一个队列的简单数据元 素进行控制。在第8章中，我们已经看到了如何使用SRWLock和条件变量来对此类队列 进行管理。在这里，我们将看到如何使队列具备线程安全性，并且如何更容易地从不同的 线程中对它进行操控。应用程序的源代码和资源文件在本书配套网页的OdQueue目录中。 Queue应用程序启动后，会显示下图所示的对话框。
第9章用内核对象进行线程同步
Client threads	-	- fer/er threads
Sending 3:1		0: Processing 1:1
Sending 1:1		0: Processing 0:1
Sending 0:1		1: Processing 3:1
Sending 2;1		0; Processing 21
Sending 3:2		0: Processing 0:2
Sending 0:2		0: Processing 1:2
Sending 1:2		1: Processing 3:2
Sending 2:2		0: Processing 2:2
Sending 3:3		I 0: Pfocessina 0:3
Sending 0:3 Sending 2:3 Sending 1:3 Sending 3:4 Sending 2:4 Sending 0:4 Sending 1:4 Sending 0:5 Sending 2:5 Sending 1:5 (full) Sending 3:5 (full) Sending 2:6 Sending 0:6 Sending 1:6		
Sending 3:6 (full)	I 4 i	
同在第8章中一样，当Queue应用程序初始化的时候，会创建4个客户线程和两个服务器 线程。每个客户线程会先睡眠一段时间，然后把一个请求元素添加到队列中。当每个请求 元素进入队列的时候，Client Threads列表框会更新。列表框中的每一项表示该项是哪个客 户线程添加的第几次请求。例如，列表框中的第一项表示它是客户线程3添加的第一个请 求。然后是客户线程1, 0和2添加了它们的第一个请求，接着是客户线程3添加了它的第 二个请求，依此类推。
服务器线程一开始无事可做，直到队列中出现至少一个元素。当一个元素出现时，有一个 服务器线程会被唤醒来对请求进行处理。Server Threads列表框显示了服务器线程的状态。 第一项显示了服务器线程0在处理来自客户线程1的请求，该请求是客户线程的第一个请 求。第二项显示了服务器线程0在处理客户线程0的第一个请求，依此类推。
在这个例子中，由于服务器线程不能足够快地处理客户的请求，因此队列很快就放满了。 在初始化的时候，我有意让队列数据结构在同一时刻最多只能容纳10个元素，这样队列很 快就会放满。加之，客户线程有4个，而服务器线程只有两个。我们可以看到，当客户线 程3试图把它的第5个请求添加到队列中的时候，队列就已经满了。
好了，我们已经看到了应用程序是如何运行的，更有趣的是应用程序内部是如何工作的。 程序通过一个C廿类CQueue来管理队列，这个类是线程安全的％
class CQueue (
public:
① 译注：第8章中的CQueue类不是线程安全的。
WS核心编程（第5版）
Struct ELEMENT (
int m_nThreadNum, m_nRequestNum;
// Other element data should go here. }；
typedef ELEMENT* PELEMENT;
private：
PELEMENT m_pElements； int m_nMaxElements； HANDLE m_h[2];
HANDLE &m_hmtxQ;
HANDLE &m_hsemNumElements；
// Array of elements to be processed
// # of elements in the array
// Mutex & semaphore handles
// Reference to m_h[0]
// Reference co m_h[1]
public：
CQueue(int nMaxElements); -CQueue();
BOOL Append(PELEMENT pElement,
BOOL Remove(PELEMENT pElement, };
DWORD dwMilliseconds); DWORD dwMilliseconds);
这个类的公有ELEMENT结构定义了队列数据元素，元素的实际内容并不重要。在这个示 例程序中，客户线程把它们的线程号和它们的请求号放在这个请求元素中，这样当服务器 对请求元素进行处理的时候，就能够把这些信息也显示在服务器线程的列表框中。一个真 实的应用程序通常不需要这些信息。
林9
在其他的私有成员中，有一个mjElements成员，它指向一个INNER_ELEMENT结构的 数组，数组的长度是固定的。这就是需要保护的数据，不能让多个客户/服务器线程同时访 问。m_nMaxElements成员表示当CQueue对象构造的时候，数组的初始长度是多少。下 一个成员m_h,是一个由两个内核对象句柄组成的数组。为了能够对队列中的元素进行适 当的保护，我们需要两个内核对象：一个互斥量和一个信号量。在CQueue的构造函数中, 会创建这两个对象并将它们的句柄保存在这个数组中。
正如我们一会儿就会看到的那样，代码有时候会调用WaitForMultipleObjects并传入句柄 数组的地址。同时我们还会看到代码有时候只需要使用这些内核对象句柄中的一个。为了 使代码更容易阅读和维护，我另外声明了两个成员来引用句柄，它们分别是m.hmtxQ和 m_hsemNumElementSo当CQueue的构造函数执行的时候，会将这两个句柄分别初始化为 m_h（0]和 m_h|l]o
理解CQueue的构造函数和析构函数对读者来说应该不成问题，因此我们下面来关注一下 Append函数。这个函数试图把一个ELEMENT添加到队列中去。但首先，线程必须先确 保它具有对队列的独占访问权。为了达到这个目的，Append方法会调用 WaitForSingleObject,并传入m_hmtxQ互斥量。如果返回值为WAIT_OBJECT_0,那么 线程具有对队列的独占访问权。
接着，为了尝试向队列中添加新的元素，Append函数必须调用ReleaseSemaphore并传入 lo如果Releasesemaphore调用成功，那么队列还没有满，可以添加新的元素。幸运的是, ReleaseSemaphore还会在IPreviousCount变量中返回队列原来的元素数量，这确切地告诉 我们应该把新的元素放在队列数组中的哪个索引处。在把元素复制到队列中后，函数返回。
第9章用内核对象进行线程同步
一旦把元素完全添加到队列中，Append会调用ReleaseMutex,这样其他线程就可以访问 队列了。Append函数的剩余部分对失败的情况和出错的情况进行处理。
现在，让我们来看一看服务器线程如何调用Remove函数来从队列中取出一个元素。首先, 线程必须确保它具有对队列的独占访问权，而且队列中必须至少有一个元素。后一点是显 然的，如果队列中没有元素，那么当然没有理由唤醒服务器线程。因此，Remove函数首 先调用WaitForMultipleObjects,并传入互斥量和信号量的句柄。只有当这两个内核对象 都被触发的时候，才会唤醒服务器线程。
如果返回值是WAIT_OBJECT_0,那么线程不仅具有对队列的独占访问权，而且队列中必 定有至少一个元素。这时，代码取出数组中索引为0的元素，然后把数组中剩余的元素向 前挪一个位置。这并非实现队列的最佳方式，因为像这样的内存复制操作是非常费时的， 但我们这里的主要目的是为了展示线程同步。最后，函数会调用ReleaseMutex,这样其他 线程就能够安全地访问队列了。
注意，信号量对象用来记录在任一时刻队列中有多少个元素。我们可以看到这个值是如何 递增的：当Append函数把新元素添加到队列中的时候会调用Releasesemaphore。但当我 们从队列中移除一个元素的时候，却并不能立刻看出这个值是如何递减的。事实上，递减 是Remove函数在调用WaitForMultipleObjects的时候完成的。记住，成功等待信号量的 副作用就是使它的计数减一，这对我们来说非常方便。
现在我们已经清楚了 CQueue类是如何工作的，剩下的代码就非常容易理解了。
Queue.cpp
Module: Queue.cpp
Notices： Copyright (c) 2008 Jeffrey Richter & Christophe Nasarre
#include "..\CommonFiles\CmnHdr.h"	/* See Appendix A. ♦/
#include <windowsx.h>
#include <tchar.h>
#include <StrSafe.h>
#include *Resource.h"
//////Z///////////////////////////////////Z//ZZ///X.///Z////////////////////////

class CQueue (	‘爵
public：
struct ELEMENT (
int n\_nThreadNum, nunRequestNum； // Other element data should go here };
typedef ELEMENT* PELEMENT;
J ，革 出a
private：
PELEMENT nt_pE 1 ement s； int
HANDLE
HANDLE
HANDLE
m_nMaxElements； 心⑵； &ro_hmtxQ； &m__hsemNumElements;
Array
Maximum # of	淬陶貌瞬精，
Mutex & semaphore handles
Reference to 心[0]
Reference to	”
indows核心编程（第5版）
///////////////////////////////////////////////////////////////////////////////
public：
CQueue(int nMaxElements)； -CQueue();
BOOL Append(PELEMENT pElement, DWORD dwMilliseconds); BOOL Remove(PELEMENT pElement, DWORD dwMilliseconds);

///////////////////////////////////////////////////////////////////////////////
CQueue::CQueue(int nMaxElements)
:m_hmtxQ (nch [0 ]), nuhsemNumElements (nUi [ 1 ]) {
nt_pElements = (PELEMENT)
HeapAlloc(GetProcessHeap(), 0, sizeof(ELEMENT) * nMaxElements); nunMaxE 1 emen t s = nMaxElements ；	•
nuhmtxQ = CreateMutex(NULL, FALSE, NULL)； m_hsemNumElements = CreateSemaphore(NULL, 0. nMaxElements, NULL):
CQueue::-CQueue() {
///////////////////////////////////////////////////////////////////////////////
CloseHcindle (nL-hsexnNumElements);
CloseHandle	；
HeapFree(GetProcessHeap()r 0, moElements):
BOOL CQueue::Append(PELEMENT pElament, DWORD dwTimeout)
BOOL fOk = FALSE; DWORD dw
=WaitForSingleObject(nuhmexQ, dwTimeout)；
if (dw == WAIT__OBJECT_0) (
// This thread has exclusive access to the queue
// Increment the number of elements in the queue
LONG iPrevCount;
fOk = ReleaseSemaphore(nuhsemNumElements, 1# &lPrevCount)； if (fOk) {
// The queue is not full, append the new element nupElements[IPrevCount] = *pElement； else {	•吒:;•打# •彳;
// The queue is full, set the ..erttri^de 廷鞭潼镣俄命底薮Xiim SetLastError (ERROR__DATABASE_FULL) M f
}	十每
// Allow other threads to access ReleaseMutex(nL_hmtxQ)；
} else {
// Timeout, set error code and return failu: SetLastError(ERROR-TIMEOUT);
return(fOk)；
// Call GetLastError for more info
第9章用内核对象进行线程同步
DWORD WINAPI ClientThread(PVOID pvParam) (
CQueue g__q(10)； volatile LONG g_fShutdown HWND g_hwnd;
if (fOk) (
// The queue has an element, pull it from the queue ♦pElement = in_pElements[0];
} else (
// Timeout, set error code and return failure SetLastError(ERROR_TIMEOUT);
}
//〃///////////////〃//////////////////////////////////////////////////////////
BOOL CQueue::Remove(PELEMENT pElement, DWORD dwTimeout) {
// Wait for exclusive access to queue and for queue to have element. BOOL fOk = (WaitForMul tipi eObjects (_countof (nc_h), in_h, TRUE, dwTimeout) ==WAIT__OBJECT_0);
// Shift the remaining elements down MoveMemory (tncpElements [0], &nL_pElements [1], sizeof (ELEMENT) * (m__nMaxElements - 1))；
// Allow other threads to access the queue ReleaseMutex (nL_hmtxQ);
return(fOk);	// Call GetLastError for more info
///////////////////////////////////////////////////////////////////////////////
The shared queue
Signals client/server threads to die How client/server threads give status
// Handles to all client/server threads & HANDLE g_hThreads[MAXIMUWLWAIT_OBJECTS]; int g_nNumThread8 = 0；
///////////////////////////////////////////////////////////////////////////////
int nThreadNum = PtrToUlong(pvParam)；
HWND hwndLB = GetDlgItem(g_hwnd/ IDC_CLIENTSM做决 int nRequestNum = 0;	嚓彩M
while ((PVOID) 1 !=	WtyL
InterlockedCompareExchangePointer(
((PVOID*)&g_fShutdown, (PVOID) 0, ,^010)0)) (
// Keep track of the current processed nRequestNum^ +;
TCHAR sz(1024);	二隧
CQueue:: ELEMENT e = { nThreadNim, nRequestNum	'蹭%;
// Try to put an element on the queue
if (g_q.Append(&e, 200)) (
[indows核心编程（第5版）
// Indicate which thread sent it and which request StringCchPrintf(sz, _countof(sz), TEXT(* Sending %d：%d"), nThreadNum, nRequestNum);
} else {
// Couldn't put an element on the queue StringCchPrintf(sz, _countof(sz), TEXT("Sending %d：%d (%s),), nThreadNum, nRequestNum, (GetLastError() == ERROR_TIMEOUT) ? TEXT("timeout") : TEXT(-full"));
}
// Show result of appending element ListBox_SetCurSel(hwndLB, ListBox^AddString(hwndLB, sz)); Sleep(2500);	// Wait before appending another element
)
return(0);
}
///////////////////////////////////////////////////////////////////////////////
DWORD WINAPI ServerThread(PVOID pvParam) (
int nThreadNum = PtrToUlong(pvParam)；
HWND hwndLB = GetDlgItem(g_hwndr IDC_SERVERS};
while (((PVOID)1 !=
InterlockedCompareExchangePointer(
(PVOID*)&g_fShutdown,(PVOID)0, (PVOID)0)) (
TCHAR sz[1024];
CQueue::ELEMENT e;
// Try to get an element from the queue
• if (g_q.Remove(&e, 5000)) {
// Indicate which thread is processing it, which thread
// sent it and which request we're processing
StringCchPrintf(szr __countof(sz), TEXT("%d： Processing %d：%d・)， nThreadNum, e.nt-nThreadNum, e.nL_nRequestNum)；
// The server takes some time to process the request
Sleep(2000 * e.nL.nThreadNiim);
} else {
// Couldn't get an element from the queue
StringCchPrintf(sz, _countof(sz), TEXT(■%d: (timeout)*), nThreadNum);
// Show result of processing element ListBox_SetCurSel(hwndLB, 1
Li s tBox_AddString （1|»碗曲s 萄*臻；
仃噂'片.":扫的号件•如-整
return(0)； }
第料:舞k ..，
/////////////〃////////〃/////////////〃///〃蹬兹耕以力叔^^《////〃
加|%眼勰济.沌翎懦r	■ ■■ ■
奇"二脊产七或盛I炒""• ■
g_hwnd = hwnd; // Used by client/server threads to 而条 割澜如蒲‘饥站
BOOL Dlg__OnInitDialog (HWND hwnd, HWND hwndFocus,
chSETDLGICONS(hwnd, IDI_QUEUE);

第9章用内核对象进行线程同步
• DWORD dwThreadID；
// Create the client threads
for (int x = 0; x < 4; x++)
g_hThreads[g_nNumThreads++]= chBEGINTHREADEX(NULL, 0, ClientThread, (PVOID) (INT_PTR) x, 0, &dwThreadID)；
'// Create the server threads
for (int x = 0； x v 2； x++)
g_hThreads [ g_jiNumThreads++]= chBEGINTHREADEX(NULL, 0, ServerThreadz (PVOID) (INT_PTR) x, 0, &dwThreadID);
return(TRUE);
}
///////////////////////////////////////////////////////////////////////////////
void Dlg_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify) ( switch (id) (
case IDCANCEL:
EndDialog(hwnd, id)；
break;
}
///////////////////////////////////////////////////////////////////////////////
INT_PTR WINAPI Dlg_Proc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM iParam) (
switch (uMsg) {
chHANDLE_DLGMSG(hwnd, WM_INITDIALOG, Dlg_OnInitDialog); chHANDLE_DLGMSG(hwnd, WICCOMMAND,	D1g_OnCommand);
}
return(FALSE);
}
///////////////////////////////////////////////////////////////////////////////
int WINAPI _tWinMain(HINSTANCE hinstExe, HINSTANCE, PTSTR pszCmdLine, int) {
DialogBox(hinstExe, MAKEINTRESOURCE(IDD_QUEUE)r NULL, Dlg^Proc); InterlockedExchange(&g_fShutdown, TRUE);
// Wait for all the threads to terminate & then cleanup WaitForMultipleObjects(g_nNumThreadsr g__hThreads, TRUE, INFINITE);
while (g__nNumThreads一)
CloseHandle (g_hThreads [g_nNxjmThreads])；
return(0);

//////////////////////////////// End of File
////〃	躁磨萌南//
<271*276
Vihdows核心编程（第5版）
9.7线程同步对象速查表
表9-3总结了各种内核对象与线程同步有关的行为。
表9-3内核对象与线程同步
对象	何时处于未触发状态	何时处于触发状态	成功等待 的副作用
进程	进程仍在运行的时候	进程终止的时候(ExitProcess , TerminateProcess)	没有
线程	线程仍在运行的时候	线程终止的时候(ExitThread , T erminateThread)	没有
作业	作业尚未超时的时候	作业超时的时候	没有
文件	有待处理的I/O请求的时候	I/O请求完成的时候	没有
控制台输入	没有输入的时候	有输入的时候	没有
文件变更通知	文件没有变更的时候	文件系统检测到变更的时候	重置通知
自动重置事件	ResetEvent* PulseEvent 或等待 成功的时候	SetEvent/PulseEvent 被调用的时候	重置事件
手动重置事件	ResetEvent, PulseEvent	SetEvent/Pu IseEvent 被调用的时候	没有
自动重置 可等待计时器	CancelWaitableTimer 或等待成 功的时候	时间到的时候(SetWaitableTimer)	重置计时器
手动重置可 等待计时器	CancelWaitableTimer	时间到的时候(SetWaitableTimer)	没有
信号量	等待成功的时候	计数大于0的时候 (ReleaseSemaphore)	计数减1
互斥量	等待成功的时候	不为线程占用的时候 （ReleaseMutex）	把所有权 交给线程
关键段 （用户模式）	等待成功的时候 ((Try)EnterCriticalSection)	不为线程占用的时候 （LeaveCriticalSection）	把所有权 交给线程
SRWLock （用户模式）	等待成功的时候 (AcquireSRWLock(Exclusive))	不为线程占用的时候 (ReleaseSRWLock(Exclusive))	把所有权 交给线程
条件变量 （用户模式）	等待成功的时候 (SleepConditionVariable*)	被唤醒的时候 (Wake(All)ConditionVariable)	没有
Interlocked系列函数（用户模式）从来不会使线程变成不可调度状态，它们只是修改一个值 并立即返回。
276-277
第9章用内核对象进行线程同步
9.8其他的线程同步函数
WaitForSingleObject和WaitForMuItipleObjects是在进行线程同步时最为常用的函数。但 是，Windows还提供了这两个函数的一些变种。如果读者已经理解了 WaitForSingleObject 和WaitForMultipleObjects,那么再去理解这些函数是如何工作的就根本不成问题。本节 我们将简要介绍一下这些函数中的一部分。
9.8.1异步设备I/O
异步设备I/O(asynchronous device I/O)允许线程开始读取操作或写入操作，但不必等待读取 操作或写入操作完成。我们将在第10章对此进行更详细的介绍。例如，如果线程需要把一 个大文件载入到内存中，那么线程可以告诉系统把文件载入到内存。然后，当系统在载入 文件的时候，线程可以忙着执行其他任务——创建窗口，初始化数据结构，等等。当初始 化完成之后，线程可以将自己挂起，等系统通知它文件已经载入完毕。
设备对象是可同步的内核对象，这意味着我们可以调用WaitForSingleObject,并传入文件 句柄、套接字、通信端口，等等。当系统执行异步I/O的时候，设备对象处于未触发状态。 一旦操作完成，系统会将对象变成触发状态，这样线程就知道操作已经完成了。这时，线 程就可以继续执行。
9.8.2	WaitForlnputldle 函数
线程可以调用WaitForlnputldle函数来将自己挂起：
DWORD WaitForlnputldle(
HANDLE hProcess,
DWORD dwMi Hi seconds)；
这个函数会等待由hProcess标识的进程，直到创建应用程序第一个窗口的线程中没有待处 理的输入为止。这个函数对父进程来说比较有用。父进程可以创建一个子进程来完成一些 工作。当父进程调用CreateProcess的时候，父进程可以一边继续执行，一边让子进程进行 初始化。父进程可能需要得到子进程创建的窗口的句柄。父进程能够知道子进程己经初始 化完毕的唯一方法，就是等待了进程，直到它不再处理任何输入为止。因此，在调用 CreateProcess 之后，父进程可以调用 WaitForlnputldle。
当我们需要强制在应用程序中输入一些按键的时候，也可以使用WaitForlnputldle。假设 我们把下面的这些消息发送给应用程序的主窗口：
WMJCEYDOWN WM KEY DOWN
虚拟键(virtual key)为 VK_MENU 虚拟键为VK F
indows核心编程(第5版)
WMJCEYUP
WM_KEYUP
WMJCEYDOWN
WMJCEYUP
虚拟键为VK_F
虚拟键为VK_MENU
虚拟键为VK_O
虚拟键为VK_O
这个序列把按键Alt+F, O发送给应用程序，在大多数英文应用程序中，这相当于是在文件 (File)菜单中选择“打开” (Open)命令。这个命令打开一个对话框，但在对话框显示之前， Windows还必须从文件中载入对话框模板，并遍历模板中所有的控件，为每个控件调用 CreateWindowo这可能会耗费一些时间。因此，发送WM_KEY*消息的应用程序可以调 用WaitForlnputldle,这使得应用程序进入等待状态，直到对话框已经创建完毕，可以接 受用户输入为止。应用程序现在就可以强制向对话框和它的子控件输入更多的按键，这样 应用程序就可以继续执行需要执行的操作。
16位Windows应用程序的开发人员经常会遇到这个问题。应用程序想要发送消息给一个窗 口，但却不知道窗口什么时候能够创建完毕并准备就绪。WaitForlnputldle函数解决了这 个问题。
9.8.3	MsgWaitForMultipleObjects(Ex)函数
线程也可以调用 MsgWaitForMultipleObjects 或 MsgWaitForMultipleObjectsEx,这使得 线程等待需要自己处理的消息：
DWORD MsgWaitForMultipleObjects(
DWORD dwCount,
PHANDLE phObjects,
BOOL bWaitAll,
DWORD dwMi Hi seconds,
DWORD dwWakeMask);
DWORD MsgWaitForMultipleObjectsEx(
DWORD dwCount,
PHANDLE phObjectS,
DWORD dwMilliseconds,
DWORD dwWakeMask,
DWORD dwFlags);
这些函数与WaitForMultipleObjects函数类似。不同之处在于，不仅内核对象被触发的时 候调用线程会变成可调度状态，而且当窗口消息需要被派送到一个由调用线程创建的窗口 时，它们也会变成可调度状态。
创建窗口的线程和执行与用户界面相关的任务的线程不应该使用 WaitForMultipleObjects> 而应该使用 MsgWaitForMultipIeObjectsExo 这是因为前者会妨 碍线程对用户在用户界面上的操作进行响应。
第9章用内核对象进行线程同步
9.8.4	WaitForDebugEvent 函数
Windows操作系统内建了绝佳的调试支持。当调试器开始执行的时候，会将自己附着(attach) 到被调试程序(debuggee)o然后调试器只是在一边闲着，等待操作系统通知它有与被调试程 序相关的事件发生。调试器通过调用WaitForDebugEvent函数来等待这些事件：
BOOL Wait Fo rDebug Event(
PDEBUG_EVENT pde,
DWORD dwMilliseconds);
当调试器调用这个函数的时候，调试器的线程会挂起。系统通过让WaitForDebugEvent 返回的方式，来通知调试器有调试事件发生。参数pde指向的结构包含了与刚才发生的调 试事件有关的信息。MSDN杂志的一篇文章uEscape from DLL Hell with Custom Debugging and Instrumentation Tools and Utilities, Part 2”对如何编写自己的调试器进行了详细介绍 (http://msdn.microsoft.com/msdnmag/issues/02/08/EscapefromDLLHell/)o
9.8.5	SignalObjectAndWait 函数
SignalObjectAndWait函数会通过一个原子操作来触发一个内核对象并等待另一个内核 对象：
DWORD SignalObjectAndWait(
HANDLE hObjectToSignal,
HANDLE hObj ectToWa i tOn,
DWORD dwMi Hi seconds ,
BOOL bAlertable)；
当我们调用这个函数的时候，参数hObjectToSignal标识的必须是一个互斥量、信号量或 事件。任何其他类型的对象将导致函数返回WAIT_FAILED,这时调用GetLastError会 返回ERROR_INVALID_HANDLEo该函数在内部会检查对象的类型并分别执行与 ReleaseMutex, ReleaseSemaphore(使用的释放计数为1)或SetEvent等价的操作。
参数hObjectToWaitOn可以标识下列内核对象中的任何一种：互斥量、信号量、事件、计 时器、进程、线程、作业、控制台输入以及变更通知。和以往一样，参数dwMilliseconds 表示函数最多应该花多长时间来等待对象触发。标志bAlertable表示当线程处于等待状态 的时候，是否应该能够对添加到队列中的异步过程调用进行处理。
279-280
该函数返回下列值的其中之一：WAIT_OBJECT__0, WAIT_TIMEOUT, WAIT_FAILED、 WAIT__ABANDONED(本章前面已经讨论过)或者 WAITJO_COMPLETIONo
出于两个原因，这个函数非常受欢迎。首先，因为我们经常需要触发一个对象并等待另一 个对象，让一个函数完成两个操作可以节省处理时间。每当我们调用的函数使线程从用户 模式切换到内核模式的时候，大概需要花费200个CPU周期(在x86平台上)，而且对线程
A^dows核心编程(第5版) _
进行重新调度甚至需要花费更多的时间。例如，执行下面的代码需要花费大量的CPU周期： ReleaseMutex(hMutex);
WaitForSingleObject(hEvent, INFINITE);
在高性能服务器应用程序中，SignalObjectAndWait可以节省大量的处理时间。
其次，如果没有SignalObjectAndWait函数，那么一个线程就无法知道另一个线程何时处 于等待状态。对PulseEvent之类的函数来说，此类信息非常有用。正如本章前面已经提到 过，PulseEvent会先触发一个事件，然后将自己重置。如果当前没有线程在等待该事件， 那么没有线程会捕获这个脉冲事件。我曾经见过有人编写出下面这样的代码：
// Perform some work. ... SetEvent(hEventWorkerThreadDone);
WaitForSingleObject(hEventMoreWorkToBeDone, INFINITE);
// Do more work....
一个工作线程(worker thread)先执行一些代码，然后再调用SetEvent来表示工作已经完成。 另--个线程执行下面这样的代码：
WaitForSingleObject(hEventWorkerThreadDone)；
PulseEvent(hEventMoreWorkToBeDone)；
工作线程的那段代码写得非常糟糕，这是因为它不能可靠地工作。当工作线程调用SetEvent 之后，另一个线程可能会立即被唤醒并调用PulseEvento这样工作线程的运行权会被抢占， 它没有机会从SetEvent调用中返回，也就不可能调用WaitForSingleObject 了。其结果就 是工作线程会错过hEventMoreWorkToBeDone事件触发的时机。
如果我们用SignalObjectAndWait来改写工作线程的代码，如下面所示，那么代码将能够 可靠地工作，这是因为触发和等待操作是通过原子方式来执行的：
// Perform some work. ... SignalObjectAndWait{hEventWorkerThreadDone, hEventMoreWorkToBeDonez INFINITE, FALSE);
// Do more work....
当一个非工作线程被唤醒的时候，它可以百分之百地确信工作线程正在等待 hEventMoreWorkToBeDone事件，因此当脉冲事件被触发时，工作线程一定能够看到。
2S0
9.8.6使用等待链遍历API来检测死锁
开发多线程应用程序是最为复杂的任务之一，但对它们进行调试并找到与锁有关的缺陷， 尤其是死锁和无限等待，比开发过程还要夏杂。Windows Vista提供了一组新的等待链遍历 (Wait Chain Traversal, WCT)API,这些函数可以让我们列出所有的锁，并检测进程内部， 甚至是进程之间的死锁。Windows会随时对表9-4列出的线程同步机制或锁定的原因进行 记录。
警告 WCT不会记录第8章介绍的SRWLock同步机制。另外请注意，WCT也不会记录 许多其他内核对象，比如事件、信号量以及可等待的计时器，这是因为任何线程在 任一时刻都可以触发任意多个此类对象，从而唤醒被阻塞的线程。
第9章用内核对象进行线程同步
表9V WCF所记录的同步机制的类型
可能的锁	描述
关键段	Windows会记录哪个线程正在占用哪个关键段
互斥量	Windows会记录哪个线程正在占用哪个互斥量。即便是被遗弃的 互斥量也不例外
进程和线程	Windows会记录哪个线程正在等待进程终止或线程终止
SendMessage 调用	正如我们在8.6.2节的''在停止线程时的死锁问题”中已经看到过， 知道哪个线程正在等待SendMessage调用返回是非常重要的
COM初始化和调用	Windows会记录对CoCreatelnstance的调用以及对COM对象的方 法的调用
高级本地过程调用(Advanced Local Procedure Call, ALPC)	在Windows Vista中，作为新的未公开的内核进程间通信 (interprocess communication, IPC)机制，ALPC 已经取代了 本地过 程调用(Local Procedure Call)
LockCop示例程序
LockCop应用程序(09-LockCop.exe)展示了如何使用WCT函数来创建一个非常有用的工具 程序。应用程序的源文件和资源文件在本书配套网页的09-LockCop目录中。当我们启动示 例程序并从Processes组合框中选择一个会产生死锁的应用程序时，会得到图9.1所示的窗 口，这使我们得以看到所有处于死锁状态的线程。
281
图9-1运行中的LockCop
首先，LockCop会用第4章中介绍过的ToolHelp32函数来枚举当前正在运行的进程，并把 每个进程的进程ID和名字放到Processes组合框中。当我们选择一个进程的时候，程序会 列出进程中所有进入了死锁状态的线程，以及它们的线程ID和等待链(wait chain)o MSDN
lows核心编程(第5版)
在线帮助将“等待链”定义如下：
“一条等待链是一个序列，在这个序列中线程和同步对象交替出现，每个线程等 待它后面的对象，而该对象却为等待链中更后面的线程所占用。”
为了把等待链解释清楚，下面让我们来看一个例子。在图9.1中，线程3212是一次死锁的 一个部分，它的等待链解释了下面的情况。
•	线程3212被一个关键段(让我们称之为CS1)阻塞。
•	这个关键段(CS1)为另一个线程所占用(2260),而该线程被另一个关键段(让我们称 之为CS2)阻塞。
•	后一个关键段(CS2)为第一个线程3212所占用。
总结一下：线程3212正在等待线程2260释放一个关键段，而线程2260却在等待线程3212 释放另一个关键段。正如8.6.3节已经解释过，这就是典型的死锁情况。
LockCop应用程序显示的所有信息基本上都是调用各种WCT函数得到的。为了更容易地 使用WCT函数，我创建了一个名叫CWCT的C++类(包含在WaitChainTraversal.h文件 中)。这个类使得对等待链进行遍历变得非常容易。我们只要从CWCT派生一个类，并覆 盖(override)下面的类定义中用粗体显示的两个虚函数，然后在运行的时候，调用 ParseThreads并传入我们感兴趣的进程ID就可以了。
class CWCT
(
public：
CWCT();
-CWCT();
// Enumerate all the threads running in the given process,
// and for each, dump the wait chain void ParseThreads(DWORD PID);
protected：
// Implement this method to be called before each thread is analyzed // Note： if nodeCount is 0, it was not possible to analyze this thread virtual void OnThread(DWORD TID, BOOL bDeadlock, DWORD nodeCount);
// Implement this method to be called for each wait node virtual void OnChaiaNodelofo(DWORD rootTID, DWORD currentNode, WAITCHAIN_NODE_INFO nodeinfo);
// Return the number of nodes in the current thread chain
DWORD GetNodesInChain();
// Return the PID of the parsed process
DWORD GetPIDO ；
private:
void InitCOMO;	'
void ParseThread(DWORD TID);	S
private:
// Handle of the WCT session
HWCT _hWCTSession；
// Handle of OLE32.DLL module
第9章用内核对象进行线程同步
HMODULE _hOLE32DLL;
DWORD _PID;
DWORD _dwNodeCount;
}；
构造一个CWCT实例的时候，程序先调用RegisterWaitChainCOMCallback来向WCT注 册COM运行环境(实现细节请参阅InitCOM函数)，然后调用下面的函数来打开一次等待 链会话：
HWCT OpenThreadWaitChainSession(
DWORD dwFlags, PWAITCHAINCALLBACK callback);
283
如果希望会话是同步的，那么应该给dwFlags参数传0,如果希望会话是异步的，那么应 该传WCT_ASYNC_OPEN_FLAG。在异步的情况下，我们把回调函数的指针作为第二个 参数传入。如果系统正处于重内存负荷之下，那么要取得一个较长的等待链可能需要很长 一段时间。在这种情况下，打开一个异步会话比打开一个同步会话更有吸引力，这是因为 我们可以通过调用CloseThreadWaitChainSession来取消对等待链的遍历。但是，CWCT 类是以同步方式来对等待链进行遍历的，因此传给dwFlags参数的值是0,传给回调函数 参数的值是NULLo在CWCT的析构函数中，调用了 CloseThreadWaitChainSession来关 闭WCT会话，传入的会话句柄是先前调用OpenThreadWaitChainSession时返回的。
ParseThreads函数封装了对一个给定进程中的线程进行枚举的操作，它基于第4章中介绍 过的一个ToolHelp快照功能：
void CWCT::ParseThreads(DWORD PID) (
_PID = PID;
// List all threads in the given process
CToolhelp th(TH32CS_SNAPTHREAD, PID);
THREADENTRY32 te = { sizeof(te) );
BOOL fOk = th.ThreadFirst(&te);
for (; fOk； fOk = th.ThreadNext(&te)) (
// Only parse threads of the given process
if (te.th320wnerProcessID == PID) ( ParseThreadCte.th32ThreadID)；
}
}
)
ParseThread函数是对等待链进行遍历的核心：
void CWCT::ParseThread(DWORD TID) (
WAITCHAIN_NODE_INFO chain(WCT_MAX_NODE_COUNT];
DWORD	dwNodes InChain；	3	泞蹄.「:爵31、
BOOL	bDeadlock;	\
土*或客"「,"「"必号土 i "疽技二氯Mi；"或WW；"•胃新综如真尊* dwNodesInChain = WCT_MAX JNODE_COUNT;
// Get the chain for the current thread
if (!GetThreadWaitChain(_hWCTSessionr NULL, WCTP_GETINFO«_ALL_FLAGS,
TID, &dvrtQodesInChain, chain, &bDeadlock)) {
_dwNodeCount = 0;
ndows核心编程(第5版)
OnThread(TID, FALSE, 0);
return；
}
// Start the chain processing for the current thread _dwNodeCount = min(dwNodesInChain, WCT_MAX_NODE_COUNT); OnThread(TIDr bDeadlock, dwNodesInChain);
// For each node in the chain, call the virtual method with details for (
DWORD current = 0;
current < min(dwNodesInChain, WCT_MAX_JK)DE_COUNT);
current++
)(
OnCha*nNoaemfo(TID, current r chain [current]);
GetThreadWaitChain函数用来填满一个WAITCHAIN_NODE_INFO数组，数组中的每 个元素既可以描述一个被阻塞的线程，也可以描述导致线程阻塞的同步机制：
BOOL WINAPI GetThreadWaitChain(
HWCT hWctSession,
DWORD_PTR pContext,
DWORD dwFlagS/
DWORD TID,
PDWORD pNodeCount,
PWAITCHAIN_NODE_INFO pNodelnfoArray,
LPBOOL pblsCycle
)；
传给hWctSession参数的值是OpenThreadWaitChainSession函数返回的句柄。如果会话 是异步的，则可以在pContext参数中传入任何附加信息。我们通过参数dwFiags来指定我 们对哪种跨进程的情形感兴趣，表9.5列出了可用的标志，可以将它们按位或起来使用。
表 9-5 GetThreadWaitChain 标志
dwFiags 的值	描述
WCT_OUT_OF_PROC_FLAG (0x1)	如果没有设置这个标志，等待链将不会包含与当前进程 之外的其他进程有关的节点信息。如果要构建一个多进 程系统，或构建的系统要创建进程并等待它们终止，就 应该设置该标志
WCT_OUT_OF_PROC_CS_FLAG (0x4)	收集当前进程之外的其他进程中的关键段信息。如果要 构建一个多进程系统，或构建的系统要创建进程并等待 它们终止，就应该设置该标志
WCT OUT OF PROC COM FLAG (0x2)	若要用到MTA COM服务器，则该标志非常重要
WCTP GETINFO ALL FLAGS	以上所有标志的集合
参数TID是线程ID,表示我们希望等待链从它标识的线程开始。等待链的详细信息在最后 三个参数中返回：
第9章用内核对象进行线程同步
•	pNodeCount指向的DWORD值包含等待链中节点的数量
•	等待链中的节点被保存在通过pNodelnfoArray参数传入的数组中
•	如果检测到了死锁，那么函数会将pblsCycle参数指向的布尔变量设为TRUE
285
对进程中的每个线程执行ParseThread的时候，我们提供的OnThread覆盖函数会被调用 一次。传给OnThread的第一个参数是线程ID。若发现死锁，则传入的第二个参数 bDeadLock将为TRUE。传入的第三个参数nodeCount中包含的是该线程的等待链中节点 的数量(0表示遇到了问题，比如访问被拒绝)。每当一个节点被加入到等待链中的时候，我 们提供的OnChainNodelnfo覆盖函数会被调用一次。传给OnChainNodelnfo的第一个参 数rootTID就是传给OnThread的线程ID。传入的第二个参数currentNode是当前节点的 索引值，从0开始计数。传入的第三个参数nodeinfo是对当前节点的描述，它是一个 WAITCHAIN_NODE_INFO结构，该结构在wct.h头文件中定义。
typedef struct _WAITCHAIN_NODE_INFO
(
WCT_OBJECT_TYPE ObjectType；
WCT__OBJECT_STATUS Objectstatus；
union (
struct (
WCHAR ObjectName[WCT__OBJNAME_LENGTH];
LARGE_INTEGER Timeout;	// Not implemented in vl
BOOL Alertable；	// Not implemented in vl
} LockObject;
struct (
DWORD Processld;
DWORD Threadld; DWORD WaitTime;
DWORD ContextSwitches;
} Threadobject;
}；
} WAITCHAIN_NODE_INFO, * PWAITCHAIN_NODE_INFO;
节点的类型被定义为ObjectType字段，它是一个WCT_OBJECT_TYPE枚举类型。表9-6 列出了节点对象所有可能的类型。
只有当ObjectType被设为WctThreadType的时候，联合类型中的ThreadObject才有意 义。在所有其他情况下，应用使用联合类型中的LockObjecto线程等待链始终从一个 WctThreadType类型的节点开始，它的Threadld成员与后面OnChainNodelnfo所接收的 rootTID参数相对应。
表9-6等待链节点对象的类型
WCT OBJECT TYPE	对等待链中节点的描述
WctThreadType	等待链中被阻塞的线程
WctCriticalSectionType	占用的对象是一个关键段
WctSendMessageType	阻塞在Send Message调用
WctMutexType	占用的对象是一个互斥量
lows核心编程(第5版)
续表
WCT OBJECT TYPE	对等待链中节点的描述
WctAlpcType	阻塞在一个ALPC调用
WctComType	正在等待一个COM调用返回
WctThreadWaitType	正在等待一个线程结束
WctProcessWaitType	正在等待一个进程终止
WctComActivationType	正在等待"个CoCreatelnstance调用返回
WctUnknownType	用于今后对API进行扩展的占位符
286
如果ObjectType字段为WctThreadType,那么Objectstatus字段详细描述了线程的状态。 否则，它会用下面显示的WCT_OBJECT_STATUS枚举类型，来描述与节点相对应的锁 的状态：
typedef enum _WCT_OBJECT_STATUS {
WctStatusNoAccess = 1, WctStatusRunning, WctStatusBlocked, WctStatusPidOnly, WctStatusPidOnlyRpcss, WctStatusOwned, WctStatusNotOwned, WctStatusAbandoned, WetStatusunknown, WctStatusError, WctStatusMax
} WCT_OBJECT_STATUS;
// ACCESS_DENIED for // Thread status
// Thread status
// Thread status
// Thread status
// Dispatcher object // Dispatcher object // Dispatcher object II All objects
// All objects
this object
status status status
LockCop应用程序有一个叫做09-BadLock的配套项目，该项目实现了许多死锁和无限锁 (infinite lock)。读者应该在LockCop应用程序中选择09-BadLock,这样就可以对WCT如 何根据锁的类型来填写WAITCHAIN_NODE_INFO结构有一个更好的理解。
注意 LockCop工具程序可以帮助我们在Windows Vista上对自己应用程序中的无限循环 和死锁进行诊断，但它有一个限制：不支持 WaitForMultipleObjects»如果代码调 用了这个函数来同时等待多个对象，那么LockCop虽然能够帮助我们发现线程等待 链中的回路，但是当GetThreadWaitChain返回并调用我们的OnThread覆盖函数 时，程序将检测不到任何死锁的情况。
醐 287»
第10章 同步设备I/O与异步设备I/O
'八— —一*"一 一…一…一二…——二一—Wd …星箜一土一
*画蕾".命悌关闭设备觐翳M	蜂
「亏I箍*'辰甬**设备	项;参
10.3执行同步设备I/O 『簪
10.5	接收I/O请求完成通知
本章介绍的Microsoft Windows相关技术使我们可以设计高性能、伸缩性好、响应性好，而 且健壮的应用，因此本章的重要性再怎么强调都不为过。一个伸缩性好的应用程序在处理 大量并发操作时和处理少数并发操作时同样高效。对一个服务应用程序(service application) 来说，典型的操作是对客户请求进行处理，我们无法预见这些客户请求会在何时到达，也 无法预见处理这些客户请求需要消耗多少处理器资源。这些操作常常来自诸如网卡、适配 器之类的I/O设备，而对这些请求进行处理又经常会用到额外的I/O设备，比如磁盘文件。
在Microsoft Windows应用程序中，线程是我们最好的工具，可以用来对工作进行划分。我 们可以给每个线程指定一个处理器，这样在多处理器的机器上就可以同时执行多个操作， 从而提高吞吐量。当线程发出一个异步设备I/O清求的时候，它会被临时挂起，直到设备 完成I/O请求为止。此类挂起会损害性能，这是因为线程无法进行有用的工作，比如开始 对另一个客户请求进行处理。因此，简而言之，我们希望线程不会被阻塞住，这样它们就 能始终进行有用的工作。
为了不让线程闲下来，我们需要让各个线程就它们正在执行的操作相互通信。Microsoft在 这个领域花了数年的时间进行研究和测试，并开发出了一种非常好的机制来进行这类通信。 这种机制被称为I/O完成端□ (I/O completion port),它可以帮助我们创建高性能而且伸缩性 好的应用程序。通过使用I/O完成端口，我们可以让线程在读取设备和写入设备的时候不 必等待设备的响应，从而显著地提高吞吐量。
I/O完成端口最初被设计用来处理设备I/O,但这么多年来，Microsoft已经构架出了越来越 多能够非常好地适合I/O完成端口模型的操作系统设施。其中一个例子就是作业内核对象, 它对进程进行监视并向I/O完成端口发送事件通知。第5章介绍的Job Lab示例程序展示了 I/O完成端口和作业内核对象是如何协同工作的。
作为一名Windows开发人员，这么多年来，我发现I/O端口有越来越多的用处，也认为每

Widows核心编程（第5版）
个Windows开发人员都必须完全理解I/O完成端口的工作方式。虽然本章介绍的I/O完成 端口与设备I/O有关，但值得注意的是I/O完成端口也可以和设备I/O完全无关——简单地 说，它是一种有无数种用途的绝佳的线程间通信机制。
项 28A290
从前面这些介绍中，读者也许能够看出我是一个I/O完成端口的忠实拥护者。希望到本章 结束的时候，你也能像我一样，成为I/O完成端口的一名忠实拥护者。但是，我们会先介 绍Windows最初为开发人员提供的设备I/O支持，而不是直接就跳到I/O完成端口的细节。 这样做的目的是为了让读者能够更好地体会到I/O完成端口的价值。我们会在10.5.4节“I/O 完成端口”中对I/O完成端口进行介绍。
10.1打开和关闭设备
Windows的优势之一是它所支持的设备数量。就我们的讨论而言，我们把设备定义为能够 与之进行通信的任何东西。表10-1列出了一些设备及其常见用途。
表10・1各种设备及其常见用途
设备	常见用途
文件	永久存储任何数据
目录	属性和文件压缩的设置
逻辑磁盘驱动器	格式化驱动器
物理磁盘驱动器	访问分区表
串11	通过电话线传输数据
并口	将数据传输至打印机
邮件槽	一对多数据传输，通常是通过网络传到另一台运行Windows的机器上
命名管道	一对一数据传输，通常是通过网络传到另一台运行Windows的机器上
匿名管道	单机上的一对一数据传输（绝对不会跨网络）
套接字	报文或数据流的传输，通常是通过网络传到任何支持套接字的机器上（机器不一 定要运行Windows操作系统）
控制台	文本窗口的屏幕缓存
本章将讨论应用程序如何与这些设备进行通信而不必等待设备响应。Windows尽可能地对 开发人员隐藏设备之间的差异。也就是说，当我们打开一个设备并和它通信的时候，许多 Windows函数允许我们以相同的方式来从设备读取数据和向设备写入数据，而不必关心它 是何种类型的设备。虽然这些函数能让我们在读写数据的时候不必关心设备的类型，但各 个设备之间显然存在着差异。例如，对串口来说，设置波特率（baudrate）是合理的，但在使 用命名管道来进行跨网络（或在单机上）通信的时候，波特率就没有意义。各种设备之间存 在许多细微的差别，我们不会对此进行专门的介绍。但是，我们会花时间来对文件做一些 介绍，因为文件实在是太常用了。为了执行任何类型的I/O,我们必须先打开想要操作的设
第10章 同步设备I/O与异步设备I。
备并得到一个句柄。得到设备句柄的方式取决于具体的设备类型。表10・2列出了各种设备 以及用来打开它们的函数。	一一
290*291 >
表10・2用来打开各种设备的函数
设备	用来打开设备的函数
文件	CreateFile(pszName为路径名或UNC路径名)
目录	CreateFile(pszName为路径名或UNC路径名)。如果在调用CreateFile的时候指 定 FILE_FLAG_BACKUP_SEMANTICS 标志，那么 Windows 允许我们打开一 个目录。打开目录使我们能够改变目录的属性(比如正常、隐藏，等等)和它的时 间戳
逻辑磁盘驱动器	CreateFile(pszName为”\\.\x:”)。如果指定的字符串是”\\.\x:”的形式，那么Windows 允许我们打开一个逻辑磁盘驱动器，其中的x是驱动器的盘符。打开驱动器使我 们能够格式化驱动器或检测驱动器媒介的大小
物理磁盘驱动器	CreateFile(pszName 为 “WAPHYSICALDRIVEx”)。如果指定的字符串是 "WAPHYSICALDRIVEx”的形式，那么Windows允许我们打开一个物理磁盘驱动 器，其中的x是物理驱动器号。例如，为了读写用户的第一个物理驭动器的扇区， 我们应该指定"WAPHYSICALDRIVEO%打开物理驱动器使我们能够直接访问硬盘 的分区表。打开物理驱动器有潜在的危险，错误地写入设备口J能会导致操作系统 的文件系统无法访问磁盘的内容
串口	CreateFile(pszName 为”COMx”)
并口	CreateFile(pszName 为”LPTx”)
邮件槽服务器	CreateMaiislot(pszName 为"\\.\mailslot\mailslotnameH)
邮件槽客户端	CreateFiIe(pszName 为"\\servemame\mailslot\mailslotname")
命名管道服务器	CreateNamedPipe(pszName 为"\\.\pipe\pipename")
命名管道客户端	CreateFiiefpszName 为'*\\servemame\pipe\pipenameM)
匿名管道	CreatePipe用来打开服务器和客户端
套接字	Socket* accept 或 AcceptEx
控制台	CreateConsoleScreenBuffer 或 GetStdHandle
表10-2中的每个函数都返回一个用来标识设备的句柄。我们可以将该句柄传给许多函数来 与设备进行通信。例如，可以调用SetCommConfig来设置串口的波特率：
BOOL SetCommConfig(
HANDLE	hCommDev,
LPCOMMCONFIG pCC,
DWORD	dwSize);
在等待读取数据的时候，可以调用SetMailslotlnfo来设置一个超时值：
BOOL SetMailslotlnfo(
HANDLE hMailslot,
I^^idows核心编程(第5版)	_
DWORD dwReadTimeout);
正如我们刚才看到的那样，这些函数都要求传给它们的第一个参数是句柄。
当完成对设备的操作后，我们必须将其关闭。对大多数设备来说，只需要调用最为常用的
CloseHandle 函数：
BOOL CloseHandle(HANDLE hObject);
但如果设备是套接字，那么必须调用closesocket：
int. closesocket (SOCKET s);
如果有一个设备句柄，那么可以调用GetFileType来查出设备的类型：
DWORD GetFileType(HANDLE hDevice);
我们只要把句柄传给GetFileType函数，该函数会返回表10-3中列出的其中一个值。
表10-3 GetFileType函数的返回值	
值	描述
FILE TYPE UNKNOWN	指定的文件为未知类型
FILE TYPE DISK	指定的文件是一个磁盘文件
FILE TYPE CHAR	指定的文件是一个字符文件，一般来说是一个并口设备或控制台
FILE TYPE PIPE	指定的文件是一个命名管道或匿名管道
细看CreateFile函数
CreateFile函数当然可以用来创建和打开磁盘文件，但不要被函数名给愚弄了——它同样 可以打开许多其他设备：
HANDLE CreateFile(
PCTSTR pszName,
DWORD dwDesiredAccess,
DWORD dwShareMode,
PSECURITY_ATTRIBUTES psa,
DWORD dwCreationDisposition,
DWORD dwFlagsAndAttributes,
HANDLE hFileTemplate);
可以看出，CreateFile需要许多参数，这使得我们在打开设备的时候有相当大的灵活性。 下面我们来详细介绍这些参数。
调用CreateFile的时候，参数pszName既表示设备的类型，也表示该类设备的某个实例。
参数dwDesiredAccess用来指定我们想以何种方式来和设备进行数据传输。我们可以传入 表10-4中列出的4个普遍使用的标志。某些类型的设备还支持额外的访问控制标志。例如, 当打开一个文件的时候，我们可以指定诸如FILE_READ_ATTRIBUTES之类的访问标志。
第10章 同步设备I /O与异步设备I/O
有关这些标志的详细信息，请参阅Platform SDK的文档。
表1（M GetFileType函数的返回值	
值	含义
0	我们不希望从设备读取数据或向设备写入数据。如果只想改变设备的配置（比 如只是修改文件的时间戳），那么可以传0
GENERIC READ	允许对设备进行只读访问
GENERIC_WRITE	允许对设备进行只写访问。例如，备份软件会用到这个标志，如果想把数据发 送到打印机，也可以使用这个标志。注意，GENERIC_WRITE标志并没有隐 式地包含GENERIC READ标志
GENERIC_READ | GENERIC WRITE	允许对设备进行读写操作。由于这个标志允许我们和设备之间自由地交换数 据，因此最为常用
参数dwShareMode用来指定设备共享特权（device-sharing privilege）。当我们仍然打开着一 个设备的时候（也就是说，我们尚未调用CloseHandle来关闭设备），该参数可以控制其他的 CreateFile调用，能够以何种方式来打开设备。表10-5列出了一些可以传给dwShareMode 参数的值。
表10»5 可以传给CreateFile的dwShareMode参数的与I/O相关的标志
值	含义
0	要求独占对设备的访问。如果设备已经打开，CreateFile调用会失败。如 果我们成功地打开了设备，那么后续的CreateFile调用会失败
FILE_SHARE_READ	如果有其他内核对象要使用该设备，我们要求它们不得修改设备的数据。 如果设备已经以写入方式或独占方式打开，那么我们的CreateFile调用会 失败。如果我们成功地打开了设备，那么后续的使用了 GENERIC_WRITE 访问标志的CreateFile调用会失败
FILE_SHARE_WRITE	如果有其他内核对象要使用该设备，我们要求它们不得读取设备的数据。 如果设备己经以读取方式或独占方式打开，那么我们的CreateFile调用会 失败。如果我们成功地打开了设备，那么后续的使用了 GENERIC_READ 访问标志的CreateFile调用会失败
FILE_SHARE_READ | FILE_SHARE_WRITE	如果有其他内核对象要使用该设备，我们不关心它们会从设备读取数据还 是会向设备写入数据。如果设备己经以独占方式打开，那么我们的 CreateFile调用会失败。如果我们成功地打开了设备，那么后续的要求独 占读取访问、独占写入访问或独占读写访问的CreateFile调用会失败
FILE_SHARE_DELETE	当对文件进行操作的时候，我们不关心文件是否被逻辑删除或是被移动。 在Windows内部，系统会先将文件标记为待删除，然后当该文件所有已打 开的句柄都被关闭的时候，再将其真正地删除
<293

Endows核心编程（第？版2
说明 在打开一个文件的时候，传入的路径名最长不能超过MAX_PATH（在winDef.h中被 定义为260）个字符。但是，通过调用CreateFileW（Unicode版本的CreateFile）并给 路径名加上“\\?\”前缀，我们可以超越这个限制。CreateFileW会把前缀去除，它 允许我们传入的路径名长度超过32 000个Unicode字符。但需要记住的是，在使用 这个前缀的时候，我们必须使用完整的路径名，系统不会对诸如和之类 的相对路径进行处理。此外，路径中的每个独立的组成部分仍然不能超过 MAX_PATH个字符。如果在源代码中还看到_MAX_PATH常量，那也不必感到奇 怪，C/C++标准库在stdlib.h中将该常量定义为260。
参数psa指向一个SECURITY_ATTRIBUTES结构，可以用来指定安全信息以及我们是否 希望CreateFile返回的句柄能够被继承。只有当我们在具备安全性的文件系统（比如NTFS） 中创建文件的时候，才会用到结构内部的安全描述符（即IpSecurityDescriptor成员），在其他 所有情况下，该安全描述符会被忽略。通常，我们只需要传NULL给psa参数，这表示用 默认的安全设定来创建文件，并且返回的句柄是不可继承的。
在用CreateFile来打开设备的时候，参数dwCreationDisposition对文件的含义更重大（相 比较于它对其他类型的设备的含义）。表10・6列出了我们可以传给这个参数的值。
表 10~6 可以传给 CreateFile 的 dwCreationDisposition 参数的值
值	含义
CREATE_NEW	告诉CreateFile创建一个新文件，如果同名文件已经存在，那么 CreateFile调用会失败
CREATE_ALWAYS	告诉CreateFile无论同名文件存在与否都创建一个新文件。如果同名文 件已经存在，那么CreateFile会覆盖原来的文件
OPEN_EXISTING	告诉CreateFUe打开」个己有的文件或设备，如果文件或设备不存在， 那么CreateFile调用会失败
OPEN_ALWAYS	告诉CreateFile打开一个已有的文件，如果文件存在，那么CreateFile 会直接打开文件，如果文件不存在，那么CreateFile会创建--个新文件
TRUNCATE_EXISTING	告诉CreateFile打开一个已有的文件并将文件的大小截断为。字节，如 果文件不存在，那么CreateFile调用会失败
说明 调用CreateFile来打开文件之外的其他设备时，必须将OPEN_EXISTING传给 dwCreationDisposition 参数。
CreateFile的dwFlagsAndAttributes参数有两个用途：其一■,它允许我们设置一些标志来 微调与设备之间的通信；其二，如果设备是一个文件，我们还能够设置文件的属性。这些 通信标志中的大多数都是一些信号，用来告诉系统我们打算以何种方式来访问设备。这样 系统就可以对缓存算法进行优化，来帮助我们提高应用程序的效率。下面我们会先介绍通
第10章 同步设备I/O与异步设备I/O
信标志，然后再介绍文件属性。
1.	CreateFile的高速缓存标志
本节介绍CreateFile的各种高速缓存标志，主要关注文件系统对象。其他的内核对象（比如 邮件槽），请读者自行参阅MSDN文档来获得更详细的信息。
FILE_FL AG_NO_BUFFERING这个标志表示在访问文件的时候不要使用任何数据缓 存。为了提高性能，系统在访问磁盘的时候会对数据进行缓存。我们通常不指定这个标志, 于是高速缓存管理器就能够将文件系统中最近访问的那部分保存在内存中。这样，如果我 们先从文件中读取几个字节，然后再读取几个字节，那么文件的数据很可能己经被载入到 了内存中。因此，我们不必访问磁盘两次，而只需要访问一次就够了，这就显著地提高了 性能。但是，这个过程同时也意味着文件数据的这一部分会在内存中出现两次：高速缓存 管理器有一个缓存，当我们在调用某些函数（比如ReadFile）的时候，这些函数会将数据从 高速缓存管理器的缓存中复制到我们自己的缓存中。
高速缓存管理器在对数据进行缓存的时候，它可能会提前读取一些数据，这样当我们要读 取下一个字节的时候，数据很可能己经在内存中了。再重复一遍，速度的提升是通过从文 件中读取超出实际需要的数据量来达到的。如果我们不再从文件中读取数据，那么可能会浪 费内存。（要想进一步了解提前读取，请参阅后面介绍的FILE_FLAG_SEQUENTIAL_SCAN 和 FILE_FLAG_RANDOM_ACCESS 标志）。
通过指定FILE_FLAG_NO_BUFFERING标志，我们告诉高速缓存管理器我们不希望它对 任何数据进行缓存——我们会自己对数据进行缓存！这取决于我们正在做什么。这个标志 可以提高应用程序的性能和内存的使用效率。由于文件系统的设备驱动程序会将文件数据 直接写入到我们提供的缓存中，因此我们必须遵循一定的规则：
•	在访问文件的时候，使用的偏移量必须正好是磁盘卷的扇区大小的整数倍（可以用 GetDiskFreeSpace函数来确定磁盘卷的扇区大小）
•	读取/写入文件的字节数必须正好是扇区大小的整数倍
•	必须确保缓存在进程地址空间中的起始地址正好是扇区大小的整数倍
FILE_FLAG_SEQUENTIAL_SCAN 和 FILE_FLAG_RANDOM_ACCESS 只有当我们 允许系统对文件数据进行缓存的时候，这些标志才有用。如果指定了 FILE_FLAG_NO_BUFFERING标志，那么这两个标志都会被忽略。
如果指定了 FILE_FLAG_SEQUENTIAL_SCAN标志，那么系统会认为我们将顺序地访问 文件。当我们从文件中读取数据的时候，系统从文件中实际读取的数据量会超过我们所要 求的数量。这个过程减少了对硬盘的访问次数并提高了应用程序的运行速度。如果我们重 新设置文件指针，那么系统所花费的额外时间以及缓存在内存中的数据就浪费了。这完全 没有问题，但如果经常需要这样做，最好还是指定FILE_FLAG_RANDOM_ACCESS标 志。这个标志告诉系统不要提前读取文件数据。
Windows核心编程（第5版）
为了对一个文件进行管理，高速缓存管理器必须为该文件保存一些内部数据结构——文件 越大，所需的数据结构就越多。在处理非常大的文件时，高速缓存管理器可能无法分配它 所需的内部数据结构，从而导致打开文件失败。为了访问非常大的文件，我们必须用 FILE_FLAG_NO_BUFFERING 标志来打开文件。
^295-296
FILE_FLAG_WRITE_THROUGH这是最后一个与高速缓存有关的标志。它禁止对文件 写入操作进行缓存以减少数据丢失的可能性。当我们指定这个标志的时候，系统会将所有 对文件的修改直接写入到磁盘中。但是，系统仍然会在内部的缓存中保存文件数据，这样 文件读取操作会继续使用缓存中的数据（如果可供使用的话），而不必直接从磁盘中读取数 据。如果用这个标志来打开网络服务器上的文件，那么只有在数据已经被写入到服务器的 磁盘之后，各个Windows文件写入函数才会返回到调用线程。
与缓存有关的通信标志就到此结束了。现在我们来讨论那些剩下的通信标志。
2.	CreateFile的其他标志
本节介绍CreateFile的其他标志，这些标志用来对高速缓存之外的各种行为进行定制。
FILE_FLAG_DELETE_ON_CLOSE 使用这个标志可以让文件系统在文件所有的句柄都 被关闭后，删除该文件。这个标志通常和FILE_ATTRIBUTE_TEMPORARY属性一起使 用。当这两个标志一起使用的时候，应用程序可以创建一个临时文件，向文件中写入数据， 从文件中读取数据，最后关闭文件。当关闭文件的时候，系统会自动删除该文件——真是 太方便了！
FILE_FLAG_BACKUP_SEMANTICS 这个标志一般用于备份和恢复软件。在打开或创 建任何文件之前，为了确保试图打开文件或创建文件的进程具有所需的访问特权，系统通 常会执行安全性检查。但是，备份和恢复软件有一定的特殊性，它们会跳过某些文件安全 性检查。当我们指定FILE_FLAG_BACKUP_SEMANTICS标志的时候，系统会检查调用 者的存取令牌（access token）是否具备对文件和目录进行备份/恢复的特权。如果调用者具备 相应的特权，那么系统会允许它打开文件。我们也可以使用 FILE_FLAG_BACKUP_SEMANTICS标志来打开一个目录的句柄。
FILE_FLAG_POSIX_SEMANTICS 在Windows中，文件名会保留最初命名时使用的大 小写，而在查找文件的时候文件名是不区分大小写的。但是，POSIX子系统要求在查找文 件名的时候区分大小写。FILE_FLAG_POSIX_SEMANTICS标志让CreateFile在创建文 件或打开文件的时候，以区分大小写的方式来查找文件名。在使用 FILE_FLAG_POSIX_SEMANTICS的时候要极其小心——如果在创建一个文件的时候使 用这个标志，那么Windows应用程序可能会无法访问该文件。
FILE_FLAG_OPEN_REPARSE_POINT 在我看来，这个标志应该叫做 FILE_FLAG_ IGNORE_REPARSE_POINT,因为它告诉系统忽略文件的重解析属性（即reparse attribute, 如果有的话）。重解析属性允许一个文件系统过滤器对打开文件、读取文件、写入文件以及
第10章 同步设备I/。与异步设备I/O
关闭文件这些行为进行修改。通常这样的修改行为是我们想要的，因此不推荐使用 FILE_FLAG_OPEN_ REPARSE_POINT 标志。
FILE_FLAG_OPEN_NO_RECALL这个标志告诉系统不要将文件内容从脱机存储器（即 offline storage,比如磁带）恢复到联机存储器（即online storage,比如硬盘）。当文件很长一 段时间没有被访问的时候，系统可以将文件内容转移到脱机存储器，从而腾出硬盘空间。 当系统执行这个操作的时候，并不会销毁硬盘上的文件，而只会销毁文件中的数据。当文 件被打开的时候，系统会自动地从脱机存储器中恢复文件数据。
FILE_FLAG_OPEN_NO_RECALL标志告诉系统不要恢复数据，这会导致系统对脱机存 储器媒介进行I/O操作。
FILE_FLAG_OVERLAPPED这个标志告诉系统我们想要以异步方式来访问设备。我们 会注意到打开设备的默认方式是同步1/0（即没有指定FILE_FLAG_OVERLAPPED标志）。 同步I/O是大多数开发人员习惯使用的方式。从文件中读取数据的时候，我们的线程会被 挂起，等待要读取的信息。一旦信息读取完毕，线程会重新得到控制权并继续执行。
•
由于设备I/O比大多数其他操作要慢，因此我们可能会考虑以异步的方式来与某些设备进 行通信。下面是异步I/O的工作方式：基本上，我们调用一个函数来告诉系统要读取或写 入数据，但这个函数调用不会等待I/O操作完成，而是立即返回，操作系统会在自己的线 程中替我们完成I/O操作。当操作系统完成我们要求的I/O操作时，会通知我们。要创建 高性能、伸缩性好、响应性好而且健壮的应用程序，异步I/O是关键。Windows提供了多 种方法来进行异步I/O,本章会介绍所有这些方法。
3.文件属性标志
现在让我们来看看那些传给CreateFile的dwFIagsAndAttributes参数的属性标志，表10-7 列出了这些标志。除非我们正在创建一个新文件,而且我们传给CreateFile的hFileTemplate 参数的值为NULL,否则系统会完全忽略dwFIagsAndAttributes参数所指定的这些标志。 读者应该已经对其中的大部分属性非常熟悉了。
表10・7 可以传给CreateFile的dwFIagsAndAttributes参数的值
标志	含义
FILE_ATTRIBUTE^ARCHIVE	文件是一个存档文件。应用程序用这个标志来将文件标记为 待备份或待删除。当CreateFHe创建一个新文件的时候，会 自动设置这个标志
FILE ATTRIBUTE ENCRYPTED	文件是经过加密的
FILE ATTRIBUTE HIDDEN	文件是隐藏的。它不会出现在通常的目录清单中
FILE ATTRIBUTE NORMAL	文件没有其他属性。只有单独使用的时候，这个标志才有效
FILE ATTRIBUTE NOT CONTENT —	OM	MM INDEXED	内容索引服务（content indexing service）不会对文件进行索引
indows核心编程(第5版)
	续表
标志	含义
FILE_ATTRIBUTE_OFFLINE	文件虽然存在，但文件内容已经被转移到脱机存储器中。这 个标志对层级存储系统(hierarchical storage system)比较有用
FILE_ATTRIBUTE_READONLY	文件是只读的。应用程序可以读取文件，但不能写入文件或 删除文件
FILE ATTRIBUTE SYSTEM	文件是操作系统的一部分，或专供操作系统使用
FILE_ATTRIBUTE_TEMPORARY	文件数据只会使用一小段时间。为了将访问时间降至最低， 文件系统会尽量将文件数据保存在内存中，而不是保存在磁 盘中
售297
如果我们要创建临时文件，那么应该使用FILE_ATTRIBUTE_TEMPORARY标志。当 CreateFile用临时文件属性创建文件的时候，CreateFile会尽量将文件数据保存在内存中， 而不是保存在磁盘上，这使得访问文件的内容变得更快。如果我们不断地写入文件直到系 统再也无法继续将数据保存在内存中的时候，操作系统将被迫开始将数据写入到硬盘中。
通过将 FILE_ATTRIBUTE_TEMPORARY 标志和前面介绍过的 FILE_FLAG_DELETE_ON_CLOSE标志组合起来使用，我们可以提高系统的性能。一般 来说，当系统关闭文件的时候，会将文件在缓存中的数据写入磁盘。但是，如果系统发现 需要在关闭文件的同时删除它，那么系统就无需将文件在缓存中的数据写入磁盘。
除了所有这些通信标志和属性标志，还有其他一些标志，当打开一个命名管道的时候，这 些标志可以允许我们对安全服务质量(security quality of service)进行控制。由于这些标志是 专门用于命名管道的，因此我们就不在这里介绍了。如果想了解这些标志，请参阅Platform SDK文档中对CreateFile函数的介绍。
CreateFile的最后一个参数hFileTemplate,既可以标识一个已经打开的文件的句柄，也可 以是NULLo如果hFileTemplate标识一个文件句柄，那么CreateFile会完全忽略 dwFlagsAndAttributes参数，并转而使用hFileTemplate所标识的文件的属性。为了能够 让函数以这种方式工作，hFileTemplate标识的文件必须是一个已经用GENERIC_READ 标志打开的文件。如果CreateFile要打开己有的文件(而不是创建新文件)，那么它会忽略 hFileTemplate 参数。
如果CreateFile成功地创建或打开了文件或设备，那么它会返回文件或设备句柄。如果 CreateFile 失败了，那么它会返回 INVALID_HANDLE_VALUE。
说明 大多数以句柄为返回值的 Windows函数在失败的时候会返回NULL。但是， CreateFile返回的却是INVALID_HANDLE_VALUE(被定义为-1)。我经常看到类 似下面的代码：
HANDLE hFile = CreateFile(...);
if (hFile == NULL) (
第10章 同步设备I/O与异步设备I/O
// We'll never get in here
) else (
// File might or might not be created OK
}
前述代码实际上是错误的，下面是检查无效文件句柄的正确方式:
HANDLE hFile = CreateFile(...); if (hFile == INVALID_HANDLE_VALUE) (
// File not created
} else {
II File created OK
}
10.2使用文件设备
由于文件的使用非常普遍，因此我希望花些时间来讨论一些只和文件设备有关的问题。本 节介绍如何设置文件指针的位置以及如何改变文件的大小。
我们必须意识到的第一个问题是：Windows的设计允许我们处理非常大的文件。Microsoft 最初的设计者选择了 64位值来表示文件大小，而不是32位值。这意味着理论上一个文件 最大可以达到16 EB(exabytes)o
在32位操作系统中处理64位值使得我们在使用文件的时候会不太方便，这是因为大量的 Windows函数要求我们将一个64位值分为两个32位值来传入。但我们一会儿就会看到， 处理这些值并不难，而且在日常工作中我们可能并不需要处理大于4GB的文件。皮意味着 64位的文件大小的高32位在大多数情况下都会是0o
10.2.1取得文件的大小
在使用文件的时候，我们经常需要得到文件的大小。要达到这一目的，最简单的方法是调
用 GetFileSizeEx：
BOOL GetFileSizeEx(
HANDLE	hFile,
PLARGE_INTEGER pliFileSize);
第一个参数hFile是一个已打开文件的句柄，参数pliFileSize是一个LARGE_INTEGER 联合类型的地址。这个联合允许我们以一个64位有符号数的形式来引用一个64位有符号 数，或者以两个32位值的形式来引用一个64位有符号数。在处理文件的大小和偏移量时， 这会相当地方便。下面是这个联合的(大概)定义：
typedef union _LARGE_INTEGER struct (
DWORD LowPart;	//
LONG HighPart;	//
);
LONGLONG QuadPart;	//
(
Low 32-bit unsigned value High 32-bit signed value
Full 64-bit signed value
WS核心编程(第5版)
} LARGE_INTEGER, *PLARGE_INTEGER;
除了 LARGE_INTEGER之外，还有一个ULARGEJNTEGER结构，用来表示64位无符 号值：
typedef union _ULARGE_INTEGER (
struct (
DWORD LowPart；	// Low 32-bit unsigned value
DWORD HighPart;	II High 32-bit unsigned value
}；
ULONGLONG QuadPart;	// Full 64-bit unsigned value
} ULARGE_INTEGER, *PULARGE_INTEGER;	___
可以用来取得文件大小的另一个非常有用的函数是GetCompressedFileSize：
DWORD GetCompressedFileSize(
PCTSTR pszFileName,
PDWORD pdwFileSizeHigh);
这个函数返回的是文件的物理大小，而GetFHeSizeEx返回的是文件的逻辑大小。例如，假 设一个100 KB的文件经过压缩后只占用85 KBo调用GetFileSizeEx返回的是文件的逻辑 大小——即100 KB,而调用GetCompressedFileSize返回的则是文件在磁盘上实际占用的 字节数——即85 KBo
与GetFileSizeEx不同的是，GetCompressedFileSize要求将文件名通过一个字符串的形式 传入，而不是将文件在第一个参数中以句柄的形式传入。GetCompressedFileSize函数通过 一种不同寻常的方式来返回64位的文件大小：文件大小的低32位是函数的返回值，文件 大小的高32位值被放在pdwFileSizeHigh参数指向的 DWORD 中。这时 ULARGEJNTEGER结构就有了用武之地：
ULARGE_INTEGER ulFileSize；
ulFileSize.LowPart = GetCompressedFileSize(TEXT("SomeFile.dat"),
&ulFileSize.HighPart)；
// 64-bit file size is now in ulFileSize.QuadPart
10.2.2设置文件指针的位置
调用CreateFile会使系统创建一个文件内核对象来管理对文件的操作。在这个内核对象内 部有一个文件指针，它是一个64位偏移量，表示应该在哪里执行下一次同步读取或写入操 作。这个文件指针一开始被设为0,因此如果在调用CreateFile之后立即调用ReadFile, 那么会从偏移量为0的地方读取文件。如果从文件中读取了 10个字节到内存中，那么系统 会更新文件指针，这样下一次调用ReadFUe的时候就会从偏移量为10的地方开始读取文 件的第11个字节。例如，下面的代码先把文件的前10个字节读取到缓存中，然后再把之 后的10个字节读取到缓存中：
BYTE pb[10J;
DWORD dwNumBytes;
HANDLE hFile = CreateFile(TEXT("MyFile.dat■), ...); // Pointer set to 0
ReadFile(hFile, pb, 10, &dwNumBytes, NULL);	// Reads bytes 0-9
ReadFile(hFilez pb, 10, &dwNumBytesz NULL)；	// Reads bytes 10 - 19
第10章 同步设备I。与异步设备I。
由于每个文件内核对象都有自己的文件指针，因此两次打开同一个文件得到的结果会略有 不同：
BYTE pb[10];
DWORD dwNumBytes；
HANDLE hFilel = CreateFile(TEXT("MyFile.dat"),...);
HANDLE hFile2 = CreateFile(TEXT("MyFile.daf),...);
ReadFile(hFilel, pb, 10, &dwNumBytes, NULL);
ReadFile(hFile2/ pb, 10, &dwNumByteS/ NULL);
// Pointer set // Pointer set // Reads bytes // Reads bytes
to 0 to 0 0-9 0-9
在这个例子中，使用了两个不同的内核对象来管理同一个文件。由于每个内核对象都有自 己的文件指针，用一个文件对象来对文件进行操作不会影响到其他对象的文件指针，因此 文件的前10个字节被读取了两次。
下面的例子对此进行了更清楚的说明：
BYTE pb[10];
DWORD dwNumBytes；
HANDLE hFilel = CreateFile(TEXT("MyFile.dat")z . . .) ;	// Pointer set to 0
HANDLE hFile2;
DuplicateHandle(
GetCurrentProcess(), hFilel,
GetCurrentProcess(), &hFile2,
0, FALSE, DUPLICATE_SAME_ACCESS);
ReadFile(hFilel, pb, 10, &dwNumBytes, NULL)；	// Reads bytes 0-9
ReadFile(hFile2, pb, 10, &dwNumByces, NULL);	// Reads bytes 10 - 19
300
在这个例子中，两个文件句柄引用了同一个文件内核对象。无论用哪个句柄来对文件进行 操作，都会更新那个唯一的文件指针。和本节中的第一个例子相同，两次读取操作读取的 是不同的字节。
如果需要随机访问文件，那么我们需要改变与文件内核对象相关联的文件指针。我们通过 调用SetFilePointerEx来达到这个目的：
BOOL SetFilePointerEx(
HANDLE	hFile,
LARGE_INTEGER liDistanceToMove,
PLARGE_INTEGER pliNewFilePointer,
DWORD	dwMoveMethod);
参数hFile表示我们想要修改哪个文件内核对象的文件指针。参数liDistanceToMove告诉 系统我们想要把指针移动多少字节。系统会把我们指定的数值与文件指针的当前值相加， 因此使用负数可以将文件指针向后移动。SetFilePointerEx的最后一个参数是 dwMoveMethod,它用来告诉 SetFilePointerEx 如何解释 liDistanceToMove 参数。表 10・8 列出了可以通过dwMoveMethod参数传入的三个值，我们用这些值来指定移动文件指针时 的起始位置。
表 10-8 可以传给 SetFilePointerEx 的 dwMoveMethod 参数的值	
值	含义
FILE_BEGIN	文件对象的文件指针将被设为liDistanceToMove参数指定的值。注意， liDistanceToMove在这里被解释为一个无符号64位值
indows核心编程(第5版)
		 • 续表
值	含义
FILE_CURRENT	文件对象的文件指针将与liDistanceToMove相加。注意，为了能够让文件指针 向后移动，liDistanceToMove在这里被解释为-一个有符号64位值
FILE_END	文件对象的文件指针被设为文件的逻辑大小加上liDistanceToMove参数。注意， 为了能够让文件指针从后往前移动，liDistanceToMove在这里被解释为一个有符 号64位值
( 301-302^
SetFilePointerEx更新了文件对象的文件指针之后，会在pliNewFilePointer参数指向的 LARGEJNTEGER结构中返回文件指针的新值。如果对新的值不感兴趣，可以传NULL 给 pliNewFilePointer 参数。
下面一些与SetFilePointerEx有关的事实值得我们注意。
•	将文件指针的值设为超过文件当前的大小是正当操作。除非是在该位置向文件写入 数据或者是调用SetEndOfFile,否则这样做不会增加文件在磁盘上的实际大小。
•	如果SetFilePointerEx操作的文件是用FILE_FLAG_NO_BUFFERING标志打开 的，那么文件指针只能被设置为扇区大小的整数倍。本章后面的FileCopy示例程序 展示了如何用正确的方式来设置文件指针。
•	Windows没有提供一个GetFilePointerEx函数，但正如下面的代码所显示的那样， 我们可以调用SetFilePointerEx将文件指针移动0个字节，通过这种方式来达到相 同的效果。
LARGE_INTEGER liCurrentPosition = { 0 }; SetFilePointerEx(hFile, liCurrentPosition, &liCurrentPosition, FILE_CURRENT);
10.2.3设置文件尾
通常，在关闭文件的时候，系统会负责设置文件尾。但是，有时我们可能想要强制使文件 变得更小或变得更大。在这些情况下，可以调用下面的函数：
BOOL SetEndOfFile(HANDLE hFile);
这个SetEndOfFile函数会根据文件对象的文件指针当前所在的位置来截断文件的大小或增 大文件的大小。例如，如果想将文件的大小强制设为1024,可以像下面这样使用 SetEndOfFile：
HANDLE hFile = CreateFilef...);
LARGE_INTEGER 1i D i s t anceToMove;
liDistanceToMove.QuadPart = 1024；
SetFilePointerEx(hFilez liDiscanceToMove, NULL, FILE_BEGIN)；
SetEndOfFile(hFile);
CloseHandle(hFile);
如果用Windows资源管理器来查看文件的属性，会发现文件的大小正好是1024字节。
第10章 同步设备I /O与异步设备I /O
10.3执行同步设备I/O
本节讨论的Windows函数允许我们执行同步设备I/O。记住，设备既可以是文件，也可以 是邮件槽、管道、套接字，等等。无论使用的是何种类型的设备，我们都用相同的函数来 执行I/O操作。
毫无疑问，最方便和最常用的对设备数据进行读/写的函数是ReadFile和WriteFile：
BOOL ReadFile(
HANDLE	hFile,
PVOID	pvBuffer,
DWORD	nNumBytesToRead,
PDWORD	pdwNumBytes,
OVERLAPPED* pOveFlapped);
BOOL WriteFile(
HANDLE	hFile,
CONST VOID *pvBuffer,
DWORD	nNumBytesToWrite,
PDWORD	pdwNumBy tes,
OVERLAPPED* pOverlapped);
参数hFile用来标识我们想要访问的设备的句柄。在打开设备的时候，我们一定不能指定 FILE_FLAG_OVERLAPPED标志，否则系统会认为我们想要与该设备执行异步I/O。参 数pvBuffer指向一个缓存，函数会把设备数据读取到该缓存中，或者把该缓存中的数据写 入到设备。参数 nNumBytesToRead 和 nNumBytesToWrite 分别告诉 ReadFile 和 WriteFile 要从设备读取多少个字节以及要向设备写入多少个字节。
参数pdwNumBytes是一个指向DWORD的地址，函数会将成功从设备读取的字节数和成 功向设备写入的字节数保存在这个参数中并返回给调用者。在执行同步I/O的时候，最后 一个参数pOverlapped应该被设为NULL。稍后讨论异步I/O的时候我们会详细介绍这个 参数。
ReadFile和WriteFile在调用成功的时候都会返回TRUE。顺便提一下，ReadFile H能用 于那些用GENERIC_READ标志打开的设备。同样，WriteFile只能用于那些用 GENERIC_WRITE标志打开的设备。
10.3.1将数据刷新至设备
读者是否还记得，当我们介绍CreateFile函数的时候，提到过可以传一些标志来改变系统 对文件数据进行缓存的方式。其他一些设备，比如串口、邮件槽以及管道，也会对数据进 行缓存。如果我们想要强制系统将缓存数据写入到设备，那么可以调用FlushFileBufTers： BOOL FlushFileBuffers(HANDLE hFile)；
FlushFileBufTers函数会强制将与hFile参数所标识的设备相关联的所有缓存数据写入设
WS核心编程（第5版）
备。设备必须是通过GENERIC_WRITE标志打开的，这样FlushFileBuffers才能够正常 工作。如果调用成功，那么函数会返回TRUEo
10.3.2同步I/O的取消
用来进行同步I/O的函数很容易使用，但它们会阻塞住来自同一个线程（即发出I/O请求的 线程）的任何其他操作。CreateFile操作就是一个极好的例子。当用户在用鼠标和键盘进行 输入的时候，窗口消息会被添加到相应的消息队列中，这个消息队列隶属于创建窗口的线 程。如果线程，由于正在等待CreateFile返回而被阻塞，那么窗口消息将无法得到处理， 该线程创建的所有窗口都会停滞在那里。应用程序停止响应的最常见的原因，就是因为要 等待同步I/O操作完成而被阻塞住！
在Windows Vista中，Microsoft添加了一些比较大的特性来缓解这个问题。例如，如果一 个控制台应用程序是因为同步I/O而停止响应，那么用户现在可以按Ctrl+C来拿回控制权 并继续使用控制台，用户再也不用“杀死”控制台进程了。另外，新的Vista “打开文件” | “保存文件”对话框提供了一个取消按钮，如果打开文件的时间太长（一般来说是因为试图 访问网络服务器上的文件而引起的），用户可以取消该操作。
为了创建响应性好的应用程序，我们应该尽可能执行异步I/O操作。一般来说这使我们能 够在应用程序中使用较少的线程，从而节省资源（比如线程内核对象和线程栈）。另外，如 果I/O操作是以异步方式进行的，那么要向用户提供取消操作的功能通常会很简单。例如， 在Intemet Explorer中，当一个Web请求耗费的时间太长而用户又失去耐心的时候，它允 许用户（通过红色的X按钮或Esc键）取消Web请求。
不幸的是，某些Windows API（比如CreateFile）没有提供任何方法来进行异步调用。虽然有 些函数在等待时间太长的情况下最终会超时（比如试图访问网络服务器），但如果能有一个 API供我们调用来强制线程取消同步I/O操作并退出等待，那就再好不过了。在Windows Vista中，下面的函数允许我们将一个给定线程尚未完成的同步I/O请求取消：
BOOL CancelSynchronousIo（HANDLE hThread）；
参数hThread是由于等待同步I/O请求完成而被挂起的线程的句柄。这个句柄必须是用 THREAD_TERMINATE访问权限创建的。如果不是这样，那么CancelSynchronousIo调 用会失败，这时调用GetLastError会返回ERROR_ACCESS_ DENIEDo当我们在用 Creat eThread 或_beginthreadex 创建自己的线程时，返回的句柄是用 THREAD_ALL_ACCESS访问权限创建的，其中包括了 THREAD_TERMINATE访问权 限。但是，如果我们要利用线程池，或者取消操作的代码被一个定时器回调函数调用，那 么我们通常必须调用OpenThreiid来得到与当前线程标识符相对应的线程句柄，这时不要 忘了在第一个参数中传入THREAD_TERMINATEo
如果指定的线程由于等待同步I/O操作完成而被挂起，那么CancelSynchronousIo会将被
第10章 同步设备I/。与异步设备I 0
挂起的线程唤醒，线程试图执行的操作将会失败，这时调用GetLastError会返回 ERROR_OPERATION_ABORTEDo 另夕F，CancelSynchronousIo 会返回 TRUE 给调用者。 注意，调用CancelSynchronousIo的线程实际上并不知道调用同步操作的线程目前处于什 么状态。可能是线程尚未与设备进行通信的时候它的运行权就被抢占，可能是线程由于要 等待设备响应而被挂起，也可能是设备刚响应，线程的调用正在返回的过程中。如果在调 用CancelSynchronousIo的时候，线程并不是因为要等待设备响应而被挂起，那么 CancelSynchronousIo 会返回 FALSE , 这时调用 GetLastError 会返回 ERROR_NOT_FOUNDo
由于这个原因，我们可能希望使用其他一些线程同步机制(第8章和第9章中介绍的)来确 定我们是否正在取消一个同步操作。但在实践中，这通常是不必要的，这是因为取消操作 通常是用户发现应用程序被挂起而要求的。另外，如果第一次取消操作看起来没有生效， 那么用户可能会再次(或多次)尝试取消。顺便提一下，为了允许用户在控制台和“打开文 件T'保存文件”对话框中重新拿回控制权，Windows在内部调用了 CancelSynchronousloo
.304-305
警告 取消I/O请求取决于将对应系统层(system layer)实现的那个驱动程序。可能出现某个 驱动程序不支持取消的情况。在这种情况下，无论如何CancelSynchronousIo还是 会返回TRUE,这是因为函数已经找到了一个请求并将其标记为正在取消。将请求 真正地取消是驱动程序的责任。为了在Windows Vista中支持同步取消，许多驱动 程序都进行了更新，网络重定向程序(network redirector)就是其中的一个例子。
10.4异步设备I/O基础
与计算机执行的大多数其他操作相比，设备I/O是其中最慢、最不可预测的操作之一。CPU 从文件中或跨网络读取数据的速度，以及CPU向文件或跨网络写入数据的速度，比它执行 算术运算的速度，甚至比它绘制屏幕的速度都要慢得多。但是，使用异步设备I/O使我们 能够更好地使用资源并创建出更高效的应用程序。
假设一个线程向设备发出一个异步I/O请求。这个I/O请求被传给设备驱动程序，后者负 责完成实际的I/O操作。当驱动程序在等待设备响应的时候，应用程序的线程并没有因为 要等待I/O请求完成而被挂起，线程会继续运行并执行其他有用的任务。
到了某一时刻，设备胆动程序完成了对队列中的I/O请求的处理，这时它必须通知应用程 序数据已发送，数据已收到，或发生了错误。有关设备骤动程序如何通知应用程序I/O已 经完成的细节，我们会在后面的10.5节“接收I/O请求完成通知”中学习。就目前而言， 让我们先关注如何把异步I/O请求加入队列。把异步I/O请求加入队列是设计高性能、可 伸缩好的应用程序的本质所在，本章的剩余部分将全部用来讨论异步I/Oo
为r以异步的方式来访问设备，我们必须先调用CreateFile,并在dwFlagsAndAttributes
J^^dows核心编程(第5版)
参数中指定FILE_FLAG_OVERLAPPED标志来打开设备。这个标志告诉系统我们想要以 异步的方式来访问设备。
为了将I/O请求加入设备驱动程序的队列中，我们必须使用ReadFile和WriteFile函数(这 两个函数我们已经在10.3节“执行同步设备I/O”中介绍过了)。为了方便起见，我们在这 里再次列出函数的原型：
BOOL ReadFile(
HANDLE	hFile,
PVOID	pvBuffer,
DWORD	nNumBytesToRead,
PDWORD	pdwNumBytes,
OVERLAPPED* pOverlapped);
BOOL WriteFile(
HANDLE	hFile,
CONST VOID *pvBuffer,
DWORD	nNumBytesToWrite,
PDWORD	pdwNumBytes,
OVERLAPPED* pOverlapped)；
305-306
当我们调用这两个函数中的任何一个时，函数会检查hFile参数标识的设备是否是用 FILE_FLAG_OVERLAPPED标志打开的。如果打开设备时指定了这个标志，那么函数会 执行异步设备I/O。顺便提一下，当调用这两个函数来进行异步I/O的时候，我们可以(也 通常会)传NULL给pdwNumBytes参数。毕竟我们希望这两个函数在I/O请求完成之前就 返回，因此这时就检查已经传输的字节数是没有意义的。
10.4.1	OVERLAPPED 结构
在执行异步设备I/O的时候，我们必须在pOverlapped参数中传入一个已初始化的 OVERLAPPED结构。“overlapped”在这里的意思是执行I/O请求的时间与线程执行其他 任务的时间是重叠的(overlapped)o下面是OVERLAPPED结构的定义：
typedef struct .OVERLAPPED (
DWORD	Internal;	//	[out]	Error code	
DWORD	InternalHigh；	//	(out]	Number of bytes	transferred
DWORD	Offset；	//	[in]	Low 32-bit file	offset
DWORD	OffsetHigh；	//	tin]	High 32-bit file	f offset
HANDLE	hEvent；	//	(in]	Event handle or	data
} OVERLAPPED, *LPOVERLAPPED;
这个结构包含5个成员。其中的三个成员(即Offset, OfTsetHigh和hEvent)必须在调用 ReadFile和WriteFile之前进行初始化。其他两个成员(Internal和InternalHigh)由驱动程 序来设置，当I/O操作完成的时候我们可以检查它们的值。下面是对这些成员变量的更详 细介绍。
1.	Offset 和 Offs色tHigh 成员
这两个成员构成一个64位的偏移量，它们表示当访问文件的时候应该从哪里开始进行I/O 操作。回想一下，每个文件内核对象都有一个与之相关联的文件指针。当我们发出同步I/O
第10章 同步设备I/O与异步设备I O
请求的时候，系统知道应该从文件指针指向的位置开始访问。在操作完成后，系统会自动 更新文件指针，这样下一次操作就会从上一次操作结束的地方继续。
在执行异步I/O的时候，系统会忽略文件指针。想象一下，如果我们的代码用ReadFile来 (对同一个文件内核对象)进行两次异步调用，那会发生什么情况？在这种情形下，系统将 无法知道第二个ReadFile调用应该从哪里开始读取数据。我们想要的起始位置和第一次调 用ReadFile时的起始位置可能并不相同，我们可能希望紧接着第一次调用ReadFile时读 取的最后一个字节处开始第二次读取。为了避免在对同一个对象进行多个异步调用的时候 出现混淆，所有异步I/O请求必须在OVERLAPPED结构中指定起始偏移量。
注意，非文件设备会忽略Offset和OffsetHigh——我们必须将这两个成员都初始化为0, 否则I/O请求会失败，这时调用GetLastError会返回ERROR_INVALID_PARAMETER。
2.	hEvent 成员
用来接收I/O完成通知的4种方法中，其中一种方法(即表10-9中的最后一种方法——使用 I/O完成端口)会用到这个成员。当使用可提醒I/O通知(alertable I/O notification)函数时，我 们可以根据自己的需要来使用这个成员。就我所知，许多开发人员会在hEvent中保存一个 C++对象的地址。(10.5.2节“触发事件内核对象”会对这个成员做更进一步介绍。)
3.	Internal 成员
这个成员用来保存己处理的I/O请求的错误码。一旦我们发出一个异步I/O请求，设备驱 动程序会立即将Internal设为STATUS_PENDING,表示没有错误，因为操作尚未开始。
实际上，WinBase.h中定义的HasOverlappedloCompleted宏允许我们检查一个异步I/O操 作是否已经完成。如果请求还处在等待状态，那么该宏会返回FALSE。如果I/O请求己经 完成，那么该宏会返回TRUEo下面就是这个宏的定义：.
•define HasOverlappedloCompleted(pOverlapped) \
((pOverlapped)->Internal != STATUS_PEND工NG)
4.	InternalHigh 成员
当异步I/O请求完成的时候，这个成员用来保存已传输的字节数。
在最初设计OVERLAPPED结构的时候，Microsoft决定不公开Internal和InternalHigh 成员(名符其实)。随着时间的推移，Microsoft认识到这些成员中包含的信息会对开发人员 有用，因此把它们公开了。但是，Microsoft没有改变这些成员的名字，这是因为操作系统 的源代码频繁地用到它们，而Microsoft并不想为此修改源代码。
说明 异步I/O请求完成的时候，我们会收到一个OVERLAPPED结构的地址，它就是 我们发出请求时使用的那个。在OVERLAPPED结构中传入更多的上下文信息在 很多时候是有用的——例如，我们想要把发出I/O请求时使用的设备句柄保存在 OVERLAPPED结构中°OVERLAPPE D结构既没有提供一个成员来保存设备句柄， 也没有提供别的成员来保存上下文信息，但我们可以相当容易地解决这个问题。
:indows核心编程(第5版)
我经常会创建一个派生自OVERLAPPED结构的C++类。这个C++类能够存放我想 要的任何附加信息。当应用程序收到OVERLAPPED结构的地址时，我只需要把这 个地址转型为该C++类。现在我既可以访问OVERLAPPED结构的成员，又可以访 问应用程序所需的任何附加信息。本章最后的FileCopy示例程序展示了这个技巧。 具体细节请参阅FileCopy示例程序中名叫CIOReq的C++类。
10.4.2异步设备I/O的注意事项
在执行异步I/O的时候，我们应该意识到一些问题。首先，设备驱动程序不必以先入先出 的方式来处理队列中的i/o请求。例如，如果线程执行下面的代码，那么设备驱动程序可 能会先写入文件再读取文件：
OVERLAPPED ol = { 0 };
OVERLAPPED o2 = { 0 };
BYTE bBuffer(100］；
ReadFile (hFile, bBuffer, 100, NULL, &ol);
WriteFile(hFile, bBuffer, 100, NULL, &o2) ;
307-308
如果不按顺序来执行I/O请求能够提高性能，那么设备驱动程序一般都会这样做。例如， 为了降低磁头的移动和寻道时间，文件系统驱动程序可能会在I/O请求队列中寻找那些要 访问的位置在物理硬盘上相邻的请求。
我们必须意识到的第二点是如何用正确的方式来检查错误。大多数Windows函数返回 TRUE来表示失败，或是非零值来表示成功，但ReadFile和WriteFile略有不同。举一个 例子可能会更有助于解释。
当我们试图将一个异步I/O请求添加到队列中的时候，设备驱动程序可能会选择以同步的 方式来处理请求。当我们从文件中读取数据的时候，系统会检查我们想要的数据是否己经 在系统的缓存中，这时就可能发生这种情况。如果数据巳经在缓存中，那么系统不会 将我们的I/O请求添加到设备驱动程序的队列中，而会将高速缓存中的数据复制到我们 的缓存中，从而完成这个I/O操作。驱动程序总是会以同步的方式来执行某些操作，比 如NTFS文件的压缩，增大文件的长度，或向文件追加信息。要想进一步了解那些始 终都以同步方式执行的操作，请参阅 http://support.microsoft.com/default.aspx?scid= kb%3Ben・us%3B 156932。
如果请求的I/O操作是以同步方式执行的，那么ReadFile和WriteFile会返回非零值。如 果请求的I/O操作是以异步方式执行的，或者在调用ReadFile或WriteFile的时候发生了 错误，那么这两个函数会返回FALSE,我们必须调用GetLastError来检查到底发生了什 么。如果GetLastError返回的是ERRORJO^PENDING,那么I/O请求已经被成功地加 入了队列，会在晚些时候完成。
如果GetLastError返回的是ERRORJO_PENDING以外的值，那么表示I/O请求无法被 添加到设备驱动程序的队列中。下面列出了当I/O请求无法被添加到设备驱动程序的队列
第10章 同步设备I /O与异步设备I /O
中时，GetLastError返回的一些最常见的错误码。
•	ERROR_INVALID_USER_BUFFER 或 ERROR_NOT_ENOUGH_MEMORY 每 个设备驱动程序会在非分页缓冲池(nonpaged pool)中维护一个固定大小的列表来管 理待处理的I/O请求。如果这个列表己满，那么系统将无法将我们的请求加入队列， 因此ReadFile和WriteFile会返回FALSE, GetLastError会报告这两个错误码之 一(具体是其中的哪一个取决于驱动程序)。
•	ERROR_NOT_ENOUGH_QUOT A 某些设备要求将我们的数据缓存所在的存储 器页面锁定，这样当I/O在等待处理的时候，数据不会被换出内存。当使用了 FILE_FLAG_NO_BUFFERING标志的时候，显然必须满足这个页面锁定的要求。 但是，系统对一个进程能够锁定的存储器页面数量做了限制。如果ReadFile和 WriteFile返回不能锁定我们的缓存所在的存储器页面，那么函数会返回FALSE, 这时调用GetLastError会报告ERROR_NOT_ENOUGH_QUOTA。我们可以调用 SetProcessWorkingSetSize 来增加进程的配额。
我们应该怎样处理这些错误？这些错误的发生基本上是因为还有一定数量的待处理的I/O 请求尚未完成，因此我们需要等一些待处理的I/O请求完成后再次调用ReadFile和 WriteFiko
我们应该意识到的第三个问题是在异步I/O请求完成之前，一定不能移动或是销毁在发出 I/O请求时所使用的数据缓存和OVERLAPPED结构。当系统将I/O请求加入设备驱动程 序的队列中时，会将数据缓存的地址和OVERLAPPED结构的地址传给驱动程序。注意， 传的只是地址而不是实际的数据块。这样做的原因应该显而易见：内存复制是非常费时的, 会浪费大量的CPU时间。
当设备驱动程序准备好处理我们添加到队列中的请求时，会传输pvBuffer地址所引用的数 据，并访问pOverlapped参数指向的OVERLAPPED结构中的文件偏移量和其他成员。具 体说来，设备驱动程序会在Internal成员中保存I/O的错误码，在InternalHigh成员中保 存已传输的字节数。
说明在I/O请求完成之前，不移动或是销毁这些数据缓存是至关重要的。否则，内存就 会遭到破坏。另外，我们必须为每个I/O请求分配并初始化一个不同的 OVERLAPPED 结构.
刚才的附注非常重要，它是开发人员在实现异步设备I/O时最常犯的错误之一。下面的例 子展示什么事情“不”应该做：
VOID ReadData(HANDLE hFile)(
OVERLAPPED o = { 0 };
BYTE b[100];
ReadFile(hFile, b, 100, NULL, &o)；
}
这段代码看上去好像没有什么害处，ReadFile的调用也完全没有问题。唯一的问题在于当 异步I/O请求被加入队列之后，这个函数会返回。这个函数的返回实际上导致位于线程栈
lows核心编程（第5版）
上的缓存以及OVERLAPPED结构被释放，但设备驱动程序并没有意识到ReadData己经 返回了。设备驱动程序仍然有两个指向线程栈的内存地址。当I/O完成的时候，设备驱动 程序会去修改线程栈中的内存，从而破坏那里的数据。由于内存修改是以异步的方式进行 的，因此这个缺陷很难找到。有时候，设备驱动程序可能会以同步方式来执行I/O,在这种 情况下我们不会遇到这个缺陷。有时候，I/O可能正好在函数返回后完成，也可能在一个小 时后完成，天晓得那个时候线程栈正在被谁使用？！
10.4.3取消队列中的设备I/O请求
有时候，我们可能想要在设备驱动程序对一个已经加入队列的设备I/O请求进行处理之前 将其取消。Windows提供了多种方式来达到这一目的。
•	我们可以调用Cancello来取消由给定句柄所标识的线程添加到队列中的所有I/O请 求（除非该句柄具有与之相关联的I/O完成端口）：
BOOL Cancello（HANDLE hFile）;
•	我们可以关闭设备句柄，来取消巳经添加到队列中的所有I/O请求，而不管它们是 由哪个线程添加的。
•	当线程终止的时候，系统会自动取消该线程发出的所有I/O请求，但如果请求被发 往的设备句柄具有与之相关联的I/O完成端口，那么它们不在被取消之列。
•	如果需要将发往给定文件句柄的一个指定的I/O请求取消，那么我们可以调用
CancelloEx：
BOOL CancelloEx（HANDLE hFile, LPOVERLAPPED pOverlapped）;
使用CancelloEx,我们能够将调用线程之外的其他线程发出的待处理的I/O请求取消。 这个函数会将hFile设备的待处理的I/O请求中所有与pOverlapped参数相关联的请求 都标记为已经取消。由于每个待处理的I/O请求都应该有自己的OVERLAPPED结构, 因此每个CancelloEx调用应该只取消一个待处理的请求。但是，如果pOverlapped 为NULL,那么CancelloEx会将hFile指定的设备的所有待处理I/O请求都取消掉。
说明 被取消的I/O请求会返回错误码ERROR OPERATION ABORTEDo
10.5接收I/O请求完成通知
到目前为止，我们已经知道了如何将异步设备I/O请求添加到队列中，但我们还没有介绍 设备驱动程序如何通知我们I/O请求已经完成。
Windows提供了 4种不同的方法来接收I/O请求已经完成的通知（表10-9对它们进行了简要 的介绍），本章涵盖了所有这些方法。表的内容是根据复杂度编排的，从最容易理解和实现
第10章 同步设备I。与异步设备I。
的(触发设备内核对象)到最难理解和实现的(I/O完成端口)。
表10・9用来接收I/O完成通知的方法	
技术	摘要
触发设备内核对象	当向一个设备同时发出多个I/O请求的时候，这种方法没什么用。它允许一个线 程发出I/O请求，另一个线程对结果进行处理
触发事件内核对象	这种方法允许我们向一个设备同时发出多个I/O请求。它允许一个线程发出I/O 请求，另一个线程对结果进行处理
使用可提醒I/O	这种方法允许我们向一个设备同时发出多个I/O请求。发出I/O请求的线程必须 对结果进行处理
使用I/O完成端曰	这种方法允许我们向一个设备同时发出多个I/O请求。它允许一个线程发出I/O 请求，另一个线程对结果进行处理。这项技术具有高度的伸缩性和最佳的灵活性
310
正如本章开头所述，用来接收I/O完成通知的4种方法中，I/O完成端口无疑是最好的。通 过学习所有这4种方法，我们将会了解到Microsoft为什么要在Windows中加入I/O完成端 口，以及如何用I/O完成端口来解决在其他方法中存在的所有问题。
10.5.1触发设备内核对象
一旦一个线程触发了一个异步I/O请求，该线程将会继续运行，以执行其他有用的任务。 但即便如此，线程最终还是需要与I/O操作的完成状态进行同步。换句话说，我们会运行 到线程代码中的一个点，在这个点上，除非设备数据已经被载入到缓存中，否则线程将无 法继续执行后继操作。
在Windows中，设备内核对象可以用来进行线程同步，因此对象既可能处于触发状态，也 可能处于未触发状态。ReadFile和WriteFile函数在将I/O请求添加到队列之前，会先将设 备内核对象设为未触发状态。当设备驱动程序完成了请求之后，驱动程序会将设备内核对 象设为触发状态。	・
线程可以通过调用WaitForSingleObject或WaitForMultipleObjects来检查一个异步I/O请
求是否己经完成。下面是一个简单的例子：
HANDLE hFile = CreateFile(..., FILE_FLAG_OVERLAPPEDz ...)；
BYTE bBuffer[100];
OVERLAPPED O = { 0 };
©.Offset = 345;
BOOL bReadDone = ReadFile(hFile, bBuffer, 100, NULL, &o)；
DWORD dwError = GetLastError()；
if (!bReadDone && (dwError == ERROR_IO_PENDING)) (
// The I/O is being performed asynchronously； wait for it to complete WaitForSingleObject(hFile, INFINITE)； bReadDone = TRUE;
Jndows核心编程(第5版)
}
if (bReadDone) (
// o.Internal contains the I/O error
// o.InternalHigh contains the number of bytes transferred
// bBuffer contains the read data
} else {	.
//An error occurred； see dwError
)
这段代码先发出一个异步I/O请求，然后立即等待该请求完成，这枉费了异步I/O的设计 意图！显然，在实际编写代码的时候我们绝对不应该这样做，但前述代码展示了一些重要 的概念，我们在这里总结如下。
•	设备必须是用FILE_FLAG_OVERLAPPED标志以异步方式打开的。
•	必须对OVERLAPPED结构的Offset, OffsetHigh和hEvent成员进行初始化。在 上面的示例代码中，我们将Offset设为345,将其他的值都设为0,这样ReadFile 就会从文件的第346个字节开始读取数据。
•	ReadFile的返回值被保存在bReadDone中，它表示该I/O请求是不是以同步方式 完成的。
•	如果该I/O请求不是以同步方式完成的，代码继续检查是否有错误发生，亦或是该 I/O操作是以异步方式完成的。我们将 GetLastError的返回值与 ERRORJO_PENDING进行比较来得到这一信息。
•	为了等港数房，代码调用了 WaitForSingleObject并传入设备内核对象的句柄。正 如我们在第9章中已经看到过，调用这个函数会将线程挂起，直到该内核对象被触 发为止。当设备驱动程序完成I/O的时候，会触发该内核对象。在 WaitForSingleObject 返回后，I/O 己经完成，代码将 bReadDone 设为 TRUE。
•	在读取完成之后，我们可以查看bBuffer中的数据，可以查看保存在OVERLAPPED 结构的Internal成员中的错误码，还可以查看保存在OVERLAPPED结构的 InternalHigh成员中的巳传输的字节数。
•	如果真的发生了错误，那么dwError中保存的错误码可以给出更多的信息。.
311*312
10.5.2触发事件内核对象
刚才描述的接收I/O完成通知的方法非常简单明了，但它实际上并不怎么有用，因为它不 能处理多个I/O请求。举个例子，假设我们要同时对一个文件执行多个异步操作。如果我 们想要从文件中读取10个字节并同时向文件写入10个字节，那么代码如下：
HANDLE hFile = CreateFile(..・，FILE_FLAG_OVERLAPPED,...);
BYTE bReadBuffer[10]；
OVERLAPPED oRead = { 0 };
oRead.Offset = 0；
ReadFile(hFile, bReadBuffer, 10, NULL, &oRead);
BYTE bWriteBuffer[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
OVERLAPPED ©Write = { 0 };
oWrite.Offset = 10；
WriteFilefhFile, bWriteBuffer, _countof(bWriteBuffer), NULL, &oWrite)；
第10章 同步设备I。与异步设备I 0
WaitForSingleObject(hFile, INFINITE);
//We don't know what completed: Read? Write? Both?
我们不能通过等待设备内核对象被触发的方式来对线程进行同步，这是因为一旦任何一个 操作完成，该内核对象就会被触发。如果我们调用WaitForSingleObject并传入设备句柄, 那么我们将无法确定函数返回的原因到底是因为读取操作完成了，还是因为写入操作完成 了。显然，我们需要有一种更好的方法来同时执行多个异步I/O请求，这样就不会遭遇类 似的困境——幸运的是，的确存在这样的方法。
OVERLAPPED结构的最后一个成员hEvent用来标识一个事件内核对象。我们必须通过 CreateEvent来创建这个事件对象。当一个异步I/O请求完成的时候，设备驱动程序会检查 OVERLAPPED结构的hEvent成员是否为NULL。如果hEvent不为NULL,那么驱动程 序会调用SetEvent来触发事件。驱动程序仍然会像从前那样，将设备对象设为触发状态。 但是，如果我们使用事件来检查一个设备操作是否己经完成，那么我们就不应该等待设备 对象被触发，我们应该等待的是事件对象。
说明 为了略微提高性能，我们可以告诉Windows在操作完成的时候不要触发文件对象。 我们通过调用SetFileCompletionNotificationModes函数来达到这一目的：
BOOL SetFileCompletionNotificationModes(HANDLE hFile, UCHAR uFlags);
参数hFile是一个文件句柄，参数uFlags用来告诉我们希望对 Windows在 I/O操作完成时的正常行为进行何种方式的定制。如果传入 FILE__SKIP_SET_EVENT_ON_HANDLE标志，那么当对文件的操作完成的时候, Windows不会触发文件句柄。注意，FILE SKIP SET EVENT ON HANDLE标 志的命名非常糟糕，取FILE SK1P SIGNAL之类的名字应该会更好。
如果想要同时执行多个异步设备I/O请求，我们必须为每个请求创建不同的事件对象，并 初始化每个请求的OVERLAPPED结构中的hEvent成员，然后再调用ReadFile或 WriteFUe0当运行到代码中的那个点，必须与I/O请求的完成状态进行同步的时候，我们 只需要调用WaitForMultipieObjects,并传入与每个待处理I/O请求的OVERLAPPED结 构相关联的事件句柄。通过这种方式，我们可以非常容易地、可靠地同时执行多个异步设 备I/O操作并使用同一个设备对象。下面的代码展示了这种方法：
HANDLE hFile = CreateFile(..., FILE_FLAG_OVERLAPPED,...);
BYTE bReadBuffer[10J；
OVERLAPPED oRead = { 0 };
oRead.Offset = 0；
oRead.hEvent = CreateEvent(...);
ReadFile(hFile, bReadBuffer, 10, NULL, &oRead);
BYTE bWriteBuffer[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
OVERLAPPED oWrite = { 0 }；
oWrite.Offset = 10;
oWrite.hEvent = CreateEvent
WriteFile(hFile, bWriteBuffer, _countof(bWriteBuffer)z NULL, &oWrite)；
「indows核心编程(第5版)
HANDLE h[2];
h[0] = oRead.hEvent;
h[l} = oWrite.hEvent;
DWORD dw = WaitForMultipleObjects(2z h, FALSE, INFINITE)；
switch (dw - WAIT_OBJECT_0) (
case 0：	// Read completed
break；
case 1:	// Write completed
break；
}
这段代码是故意这样设计的，虽然我们在实际的应用程序中并不会“完全”这样做，但它 确实可以阐明我的观点。一般来说，实际的应用程序会用一个循环来等待I/O请求完成。 当每个请求完成的时候，线程会执行它想执行的任务，将另一个异步I/O请求添加到队列 中，进入下一次循环并等待更多的I/O请求完成。
GetOverlappedResult 函数
还记得吗，Microsoft当初并不打算公开OVERLAPPED结构的Internal和InternalHigh 成员，这意味着Microsoft需要提供另一种方式来让开发人员知道在I/O处理过程中传输了 多少字节，并取得I/O的错误码。为了让我们得到这些信息，Microsoft创建了 GetOverlappedResult 函数：
BOOL GetOverlappedResult(
HANDLE	hFile,
OVERLAPPED* pOverlapped,
PDWORD	pdwNumBytes,
BOOL	bWait);
由于现在 Microsoft 已经公开了 Internal 和 InternalHigh 成员，因此 GetOverlappedResult 函数就不怎么有用了。但是，当我最开始学习异步I/O的时候，我决定对该函数进行逆向 工程，以巩固我头脑中的概念。下面的代码显示了 GetOverlappedResult在内部是如何实 现的：
BOOL GetOverlappedResult(
HANDLE hFile,
OVERLAPPED* p。，
PDWORD pdwNumBytes,
BOOL bWait) (
if (po->Internal == STATUS_PENDING) {
DWORD dwWaitRet = WAIT_TIMEOUT;
if (bWait) (
// Wait for the I/O to complete dwWaitRet = WaitForSingleObject(
(po->hEvent != NULL) ? po->hEvent : hFile, INFINITE)； )
if (dwWaitRet == WAIT_TIMEOUT) {
// I/O not complete and we're not supposed to wait SetLastError(ERROR_IO_INCOMPLETE);
return(FALSE)；

第10章 同步设备I/O与异步设备I ,O
if (dwWaitRet != WAIT_OBJECT_0) (
// Error calling WaitForSingleObject return(FALSE);
)
}
// I/O is complete； return number of bytes transferred *pdwNumBytes = po->InternalHigh；
if (SUCCEEDED(po->Internal))(
return (TRUE) ;	// No I/O error
}
// Set last error to I/O error
SetLastError(po->Internal);
return(FALSE);
10.5.3可提醒I/O
可用来接收I/O完成通知的第三种方法被称为可提醒I/O(alertable I/O)o最初，Microsoft对 开发人员吹捧说，可提醒I/O是创建高性能且伸缩性好的应用程序的最佳途径。但当开发 人员开始使用可提醒I/O之后，很快就意识到可提醒I/O并不能达到Microsoft预期的承诺。
我曾经用过可提醒I/O,也会是第一个告诉你真相的人，可提醒I/O非常糟糕，应该避免使 用。但是，为了使可提醒I/O能够正常工作，Microsoft在操作系统中添加了一些基础设施, 我发现这些基础设施非常有用，也很有价值。当读者在阅读这一节的时候，请将注意力集 中在基础设施上，而不要纠缠在与I/O有关的方面。
当系统创建一个线程的时候，会同时创建一个与线程相关联的队列。这个队列被称为异步 过程调用(asynchronous procedure call, APC)队列。当发出一个I/O请求的时候，我们可以 告诉设备驱动程序在调用线程的APC队列中添加一项。为了将I/O完成通知添加到线程的 APC队列中，我们应该调用ReadFileEx和WriteFUeEx函数：
BOOL ReadFileEx(
HANDLE	hFile,
PVOID	pvBuffer,
DWORD	nNumBytesToRead,
OVERLAPPED* pOverlapped,
LPOVERLAPPED_COMPLETION_ROUTINE pfnCompletionRoutine);
BOOL WriteFileEx(
HANDLE	hFile,
CONST VOID *pvBuffer/
DWORD	nNumBytesToWrite,
OVERLAPPED* pOverlapped,
LPOVERLAPPED_COMPLETION_ROUTINE pfnCompletionRoutine)；
与ReadFile和WriteFDe相似，ReadFileEx和 WriteFileEx在将I/O请求发给设备驱动程 序之后，会立即返回。ReadFUeEx和WriteFileEx的大多数参数与ReadFile和WriteFile 相同，只有两个例外。首先，*Ex函数没有一个指向DWORD的指针作为参数来保存已传 输的字节数，该信息只有回调函数才能得到。其次，*Ex函数要求我们传入一个回调函数
lows核心编程(第5版)
的地址，这个回调函数被称为完成函数(completion routine)。
VOID WINAPI CompletionRoutine(
DWORD	dwError,
DWORD dwNumBytes,
OVERLAPPED* po);
当我们用ReadFileEx和WriteFileEx发出一个I/O请求的时候，这两个函数会将回调函数 的地址传给设备驱动程序。当设备驱动程序完成I/O请求的时候，会在发出I/O请求的线 程的APC队列中添加一项。该项包含了完成函数的地址，以及在发出I/O请求时所使用的 OVERLAPPED结构的地址。
说明 顺便提一下，当一个可提醒I/O完成时，设备驱动程序不会试图去触发一个事件对 象。事实上，设备根本就没有用到OVERLAPPED结构的hEvent成员。因此，如 果需要，我们可以将hEvent据为己用。
当线程处于可提醒状态的时候(马上就会讨论到)，系统会检查它的APC队列，对队列中的 每一项，系统会调用完成函数，并传入I/O错误码，己传输的字节数，以及OVERLAPPED 结构的地址。注意，错误码和已传输的字节数也可以通过OVERLAPPED结构的Internal 和InternalHigh成员得到。俄们前面已经提到过，由于Microsoft最初并没有打算公开这 些成员，因此必须将它们作为参数传给完成函数。)
我们马上会回过来讨论完成函数。现在首先让我们来看一看系统是如何处理异步I/O请求 的。下面这段代码将三个不同的异步操作添加到队列中：
hFile = CreateFile(...z FILE_FLAG_OVERLAPPED,...);
ReadFileEx(hFile, . . .) ;	//	Perform	first	ReadFileEx
WriteFileEx(hFile, . . .) ;	//	Perform	first	WriteFileEx
ReadFileEx(hFile, . . .) ;	//	Perform	second	ReadFileEx
SomeFunc();
让我们假设执行SomeFunc调用需要一些时间，而系统在SomeFunc函数返回之前就完成 了所有三个操作。线程在执行SomeFunc函数的同时，设备驱动程序正在将己完成的I/O 一项一项地添加到线程的APC队列中。APC队列可能会这样：
first WriteFileEx completed
second ReadFileEx completed
first ReadFileEx completed
这个APC队列是由系统在内部维护的。从这个列表中，我们同时还可以注意到系统会以任 意的顺序来执行我们添加到队列中的I/O请求，我们最后发出的I/O请求可能最先完成， 最先发出的I/O请求可能最后完成。添加到线程的APC队列中的每一项包含一个回调函数 的地址，以及一个要传给该回调函数的值。
当I/O请求完成的时候，系统会将它们添加到线程的APC队列中——回调函数并不会立即 被调用，这是因为线程可能还在忙于处理其他事情，不能被打断。为了对线程APC队列中 的项进行处理，线程必须将自己置为可提醒状态。这只不过意味着我们的线程在执行的过
第10章 同步设备I/。与异步设备I。
程中己经到达了一个点，在这个点上它能够处理被中断的情况。Windows提供了 6个函数， 可以将线程置为可提醒状态：.
DWORD SleepEx(
DWORD dwMilliseconds,
BOOL bAlertable);	.
DWORD WaitForSingleObjectEx(
HANDLE hObject,
DWORD dwMilliseconds,
BOOL bAlertable);
DWORD WaitForMultipleObjectsEx(
DWORD cObjects,
CONST HANDLE* phObjectS,
BOOL bWaitAll,
DWORD dwMi Hi seconds,
BOOL bAlertable)；
BOOL SignalObjectAndWait(
HANDLE hObjectToSignal,
HANDLE hObjectToWaitOn,
DWORD dwMilliseconds,
BOOL bAlertable);
BOOL GetQueuedCompletionStatusEx(
HANDLE hCompPortr
LPOVERLAPPED_ENTRY pCompPortEntries,
□LONG ulCount,
PULONG pulNumEntriesRemoved,
DWORD dwMi11i seconds,
BOOL bAlertable);
DWORD MsgWaitForMultipleObjectsEx(
DWORD nCount,
CONST HANDLE* pHandles,
DWORD dwMilliseconds,
DWORD dwWakeMask,
DWORD dwFlags);
316*317
前5个函数的最后一个参数是一个布尔值，表示调用线程是否应该将自己置为可提醒状态。 对 MsgWaitForMultipleObjectsEx 来说，我们必须使用 MWMO_ALERTABLE 标志来让 线程进入可提醒状态。Sleep, WaitForSingleObject 和 WaitForMultipleObjects 函数在内 部调用了和它们对应的*Ex函数，并总是传FALSE给bAlertable参数。如果读者熟悉这 些不带Ex的函数，那么一定不会对此感到吃惊。
当我们调用刚才提到的6个函数之一并将线程置为可提醒状态时，系统会首先检查线程的 APC队列。如果队列中至少有一项，那么系统不会让线程进入睡眠状态。系统会将APC 队列中的那一项取出，让线程调用回调函数，并传入已完成I/O请求的错误码，已传输的 字节数，以及OVERLAPPED结构的地址。当回调函数返回的时候，系统会检查APC队 列中是否还有其他的项，如果还有，那么会继续处理。但如果没有其他的项，那么我们对 可提醒函数的调用会返回。需要牢记在心的是，当调用这些函数中的任何一个时，只要线 程的APC队列中至少有一项，线程就不会进入睡眠状态。	一_
喻7-318
WS核心编程（第5版）
在调用这些函数的时候，当且仅当线程的APC队列中一项都没有的时候，这些函数才会将 线程挂起。当线程被挂起的时候，如果我们正在等待的那个（或那些）内核对象被触发，或 线程的APC队列中出现了一项，那么线程将会被唤醒。因为我们的线程处于可提醒状态， 所以一旦APC队列中出现一项，系统会唤醒我们的进程并（通过调用回调函数来）清空队列。 然后函数会立即返回——线程不会再次进行睡眠状态来等待内核对象被触发。
这6个函数的返回值表示它们返回的原因是什么。如果返回的是 WAIT_IO_COMPLETION（或者 GetLastError 返回的是 WAITJO_COMPLETION）,那 么我们就知道线程得以继续执行的原因是线程至少处理了 APC队列中的一项。如果这6个 函数是因为其他原因而返回的，那么线程被唤醒的原因可能是因为睡眠的时间超出了指定 的时间，也可能是因为指定的那个（或那些）内核对象被触发，还有可能是因为一个互斥量 被遗弃了。
可提醒I/O的优劣
到这里，我们已经讨论了进行可提醒I/O的机制。现在我们需要知道两个问题，正是这两 个问题使得将可提醒I/O用于设备I/O成为一种非常糟糕的选择。
•	回调函数 可提醒I/O要求我们必须创建一个回调函数，这使得代码的实现变得更 加复杂。由于这些回调函数一般来说并没有足够的与某个问题有关的上下文信息， 因此我们最终不得不将大量的信息放在全局变量中。幸运的是，我们不需要对这些 全局变量进行同步，这是因为调用六个可提醒函数之一的线程与执行回调函数的线 程是同一个线程。由于同一个线程不可能同时在两个地方执行，因此全局变量是安 全的。
•	线程问题 实际上可提醒I/O的大问题是：发出I/O请求的线程必须同时对完成通 知进行处理。如果一个线程发出多个请求，那么即使其他线程完全处于空闲状态， 该线程也必须对每个请求的完成通知做出响应。由于不存在负载均衡机制，因此应 用程序的伸缩性不会太好。
这两个问题都相当严重，因此我强烈推荐不要将可提醒I/O用于设备I/O。我相信读者现在 已经猜到，下一节介绍的I/O完成端口机制可以解决刚才提到的这两个问题。在跳到I/O 完成端口之前，让我们来看一看可提醒I/O基础设施有哪些优点。
Windows提供了一个函数，允许我们手动地将一项添加到APC队列中：
DWORD QueueUserAPC（
PAPCFUNC pfnAPC,
HANDLE hThread,
ULONG_PTR dwData）;
第一个参数是一个指向APC函数的指针，该函数必须符合下面的函数原型：
VOID WINAPI APCFunc（ULONG_PTR dwParam）;
第二个参数是线程的句柄，用来告诉系统我们想要将该项添加到哪个线程的队列中。注意, 这个线程可以是系统中的任何线程。如果hThread标识的线程在另一个进程的地址空间中,
第10章 同步设备I/O与异步设备I 0
那么pfnAPC指定的函数内存地址也必须在另一个线程所在进程的地址空间中。 QueueUserAPC的最后一个参数dwData,它只不过是一个要传给回调函数的值而己。
即使QueueUserAPC的函数原型返回的是DWORD,但该函数实际上返回的是一个BOOL 类型，表示操作成功与否。我们可以使用QueueUserAPC来进行非常高效的线程间通信， 甚至能够跨越进程的界限。但遗憾的是，我们只能传递一个值。
QueueUserAPC也可以用来强制让线程退出等待状态。假设我们有一个线程由于调用了 WaitForSingleObject而正在等待内核对象被触发。当线程还在等待的时候，用户想要终止 应用程序。我们知道线程应该干净地销毁自己，但我们如何能够强制唤醒正在等待内核对 象的线程，并让它将自己“杀死” ？ QueueUserAPC就是答案。
下面的代码展示了如何强制一个线程退出等待状态，这样它就能够干净地退出。主函数创 建了一个新的线程，并将一个内核对象的句柄传给它。当第二个线程运行的时候，主线程 同时也在运行。.正在执行ThreadFunc函数的第二个线程调用了 WaitForSingleObjectEx, 这会挂起线程，并将其置为可提醒状态。现在，假设用户告诉主线程要终止应用程序。当 然，上线程可以直接退出，这样系统就会“杀死”整个进程。但是，这种方法不够干净， 而且在许多情形下，我们并不想终止整个进程，而只是想终止一个操作。
因此主线程调用了 QueueUserAPC,该函数将一个APC项添加到第二个线程的APC队列 中。由于第二个线程处于可提醒状态，因此现在它会被唤醒，并调用APCFunc函数来清 空自己的APC队列。这个函数并没有做任何事情就返回了。由于现在APC队列己经被清 空，因此线程从WaitForSingleObjectEx调用中返回，返回值为WAIT_IO_COMPLETION。 ThreadFunc函数会特别检查这个返回值，这样它就知道自己收到了一个用来表示线程应该 退出的APC项。
// The APC callback function has nothing to do
VOID WINAPI APCFunc(ULONG_PTR dwParam) (
// Nothing to do in here
}
UINT WINAPI ThreadFunc(PVOID pvParam) (
HANDLE hEvent = (HANDLE) pvParam； // Handle is passed to this thread
// Wait in an alertable state.so that we can be forced to exit cleanly
DWORD dw = WaitForSingleObjectEx(hEvent, INFINITE, TRUE)；
if (dw == WAIT_OBJECT_0) (
// Object became signaled
}
if (dw == WAIT_IO_COMPLETION) (
// QueueUserAPC forced us out of a wait state
return(0)；	// Thread dies cleanly
)
return(0);
}
void main()(
HANDLE hEvent = CreateEvent(...)；
HANDLE hThread = (HANDLE) _beginthreadex(NULL, 0,
ThreadFunc, (PVOID) hEvent, 0, NULL);
WS核心编程（第5版）
// Force the secondary thread to exit cleanly QueueUserAPC(APCFunc, hThread, NULL); WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread)； CloseHandle(hEvent);
319-320
我知道某些读者可能会想，创建另一个事件内核对象来通知第二个线程应该终止，并用 WaitForMultipleObjects 来代替 WaitForSingleObjectEx,也能解决这个问题。但是，如果 第二个线程也需要调用WaitForMultipleObjects来等待所有的对象被触发，那么 QueueUserAPC将是强制线程退出等待状态的唯一方法。
10.5.4	I/O 完成端口
Windows的设计目标是一个安全的、健壮的操作系统，能够运行各种各样的应用程序来为 成千上万的用户服务。回顾历史，我们能够采用以下两种模型之一来构架一个服务应用 程序。
•	串行模型（serial model） 一个线程等待一个客户（通常是通过网络）发出请求。当请求 到达的时候，线程会被唤醒并对客户请求进行处理。
•	并发模型（concurrent model） 一个线程等待一个客户请求，并创建一个新的线程来 处理请求。当新线程正在处理客户请求的时候，原来的线程会进入下一次循环并等 待另一个客户请求。当处理客户请求的线程完成整个处理过程的时候，该线程就会 终止。
串行模型的问题在于它不能很好地同时处理多个请求。如果两个客户同时发出请求，那么 一次只能处理一个，第二个请求必须等第一个请求的处理结束。使用串行模型设计出来的 服务不能充分发挥多处理器机器的优势。显然，串行模型只能满足最简单的服务器应用程 序，在这类应用程序中客户请求非常少，而且能够非常快地完成处理。Ping服务器就是串 行服务器的一个很好的例子。
由于串行模型存在这样的限制，因此并发模型极其受欢迎。在并发模型中，每个客户请求 都会由一个新创建的线程来对其进行处理。这种模型的优点在于等待请求的线程只有很少 的工作需要做。大多数时间它都处于睡眠状态。当客户请求到达的时候，该线程会被唤醒, 创建一个新的线程来处理请求，然后等待下一个客户请求。这意味着能够对客户的请求进 行快捷的处理。此外，因为每个客户请求都有自己的线程，所以服务器应用程序具备非常 好的伸缩性，能够轻易地发挥多处理器机器的优势。因此，如果使用的是并发模型并对硬 件进行升级（添加另一个CPU）,那么服务器应用程序的性能就能相应地提高。
使用并发模型的服务应用程序是在Windows中实现的。Windows开发组注意到应用程序的 性能不如预期的高。尤其是，开发组注意到同时处理许多客户请求意味着系统中会有许多 线程并发执行。Microsoft意识到由于所有这些线程都处于可运行（runnable）状态（并非因为 要等待某些事情发生而被挂起），因此Windows内核在各可运行的线程之间进行上下文切 换花费了太多时间，以至于各线程都没有多少CPU时间来完成它们的任务了。为了将
第10章 同步设备I/O与异步设备I。
Windows打造成一个出色的服务器环境，Microsoft需要解决这个问题。其结果就是I/O完 成端口内核对象。
1.创建I/O完成端口
I/O完成端口背后的理论是并发运行的线程的数量必须有一个上限——也就是说，同时发出 的500个客户请求不应该允许出现500个可运行的线程。那么，可运行线程的数量是多少 才算合适呢？无须考虑太长的时间，我们就会意识到如果机器只有两个CPU,那么允许可 运行线程的数量大于2——每个处理器一个线程——将没有什么意义。一旦可运行线程的 数量大于可用的CPU数量，系统就必须花时间来执行线程上下文切换，而这会浪费宝贵的 CPU周期——这也是并发模型的一个潜在缺点。
并发模型的另一个缺点是需要为每个客户请求创建一个新的线程。虽然和创建一个有自己 的虚拟地址空间的进程相比，创建一个线程的开销要低得多，但它的开销仍然不能算小。 如果能在应用程序初始化的时候创建一个线程池，并让线程池中的线程在应用程序运行期 间一直保持可用状态，那么服务应用程序的性能就能够得到提高。I/O完成端口的设计初衷 就是与线程池配合使用。
I/O完成端口可能是最复杂的内核对象了。为了创建一个I/O完成端口，我们应该调用
CreateloCompletionPort：
HANDLE CreateloCompletionPort(
HANDLE hFile,
HANDLE hExistingCompletionPort,
ULONG_PTR CompletionKey,
DWORD dwNuinberOfConcurrentThreads);
这个函数执行两项不同的任务：它不仅会创建一个I/O完成端口，而且会将一个设备与一 个I/O完成端口关联起来。依我之见，该函数己经太复杂了，Microsoft应该将它分成两个 单独的函数。当我在使用I/O完成端口的时候，会创建两个小函数来对 CreateloCompletionPort调用进行抽象，其目的是将这两项任务分开。我编写的第一个函 数叫 CreateNewCompletionPort,它的实现如下：
HANDLE CreateNewCompletionPort(DWORD dwNuinberOfConcurrentThreads) (
return(CreateloCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, dwNuinberOfConcurrentThreads));
}
这个函数只有一个参数 dwNumberOfConcurrentThreads , 它调用了 CreateloCompletionPort,并在前三个参数中传入固定的值，在最后一个参数中传入 dwNumberOfConcurrentThreads的值。我们可以看到，只有当我们要将一个设备与一个I/O 完成端口关联在一起的时候(我们马上就会对此进行介绍)，才会用到CreateloCompletionPort 的前三个参数。为了只创建I/O完成端口，我给CreateloCompletionPort的前三个参数分别 传入了 INVALID_HANDLE_VALUE, NULL 和 0。
参数dwNumberOfConcurrentThreads告诉I/O完成端口在同一时间最多能有多少线程处
indows核心编程(第5版)
于可运行状态。如果给dwNumberOfConcurrentThreads参数传0,那么I/O完成端口会使 用默认值，也就是允许并发执行的线程数量等于主机的CPU数量。为了避免额外的上下文 切换，通常这样的设定正是我们想要的。如果处理一个客户请求需要长时间的计算，而且 中间很少会被阻塞，那么我们可•能想要增大这个值，但我强烈建议不要这样做。我们可以 用不同的值来对dwNumberOfConcurrentThreads进行试验，并在目标硬件平台上对应用 程序的性能进行比较，以找到最佳的值。
读者可能会注意到CreateloCompletionPort不需要我们传一个SECURITY_ATTRIBUTES 结构给它，在所有用来创建内核对象的Windows函数中，CreateloCompletionPort大概是 绝无仅有的。这是因为I/O完成端口的设计初衷就是只在一个进程中使用。在介绍如何使 用I/O完成端口的时候我们将会对具体原因有一个清晰的认识。
将设备与I/O完成端口关联起来
当我们创建一个I/O完成端口的时候，系统内核实际上会创建5个不同的数据结构，如图 10・1所示。在阅读本章后面的内容时，请读者随时参考这张图。
第一个数据结构是一个设备列表，表示与该端口相关联的一个或多个设备。我们通过调用 CreateloCompletionPort来将设备与端口关联起来。前面已经提到过，我还创建了另一个 自己的函数 AssociateDeviceWithCompletionPort,用于对 CreateloCompletionPort 进行 抽象：
BOOL AssociateDeviceWithCompletionPort(
HANDLE hCompletionPort, HANDLE hDevice, DWORD dwCompletionKey) (
HANDLE h = CreateloCompletionPort(hDevice, hCompletionPort, dwCompletionKey, 0); return(h == hCompletionPort);
)
AssociateDeviceWithCompletionPort把一项添加到一个已有I/O完成端口的设备列表中。 我们需要向这个函数传入一个己有I/O完成端口的句柄(由前一个 CreateNewCompleHonPort调用返回)、设备的句柄(可以是文件、套接字、邮件槽、管道等) 以及一个完成键(即completion key, 一个对我们有意义的值，操作系统并不关心我们在这 里传入的到底是什么值)。每次将一个设备与该端口关联起来的时候，系统会将这些信息追 加到I/O完成端口的设备列表中。
说明 CreateloCompletionPort函数太复杂，我建议读者根据调用该函数的原因从心理上 将其一分为二。让这个函数变得这么复杂有一个好处：我们可以在创建一个I/O完 成端口的同时将一个设备与之关联起来。例如，下面的代码打开一个文件，创建一 个新的I/O完成端口，并将文件与端口关联起来。所有发往该文件的I/O请求在完 成的时候都有一个CK_FILE完成键，端口最多允许两个线程并发执行。
#define CK_FILE 1
handle hFile = CreateFile(...);
HANDLE hComplet ion Port = CreateloCompletzionPort (hFile, NULL, CK FILE, 2);
322-323
第10章 同步设备I/O与异步设备I/O
设备列表
每条记录包含：
I hDevice I dwCompletionKey
当满足以下条件时，会在列表中添加新项:
♦ CreateloCompletionPort 被调用 当满足以下条件时，会将列中的项删除：
•设备句柄被关闭 
I/O完成队列（先入先出）
每条记录包含：	一
I dwBvtesThmsfknvd I dwCogletionKey I pOverlauped I dwError
当漪足以下条件时，会在列表中添加新项：
•	I/O请求完成
•	PostQueuedCompletionStatus 被调用 当满足以下条件时，会将列中的项删除：
•完成端口从等待线程队列中删除一项 
等待线程队列（后入先出）
每条记录包含：
dwThreadld
当满足以下条件时，会在列表中添加新项:
•线程调用 GetQueuedCompletionStatus
当满足以下条件时，会将列中的项删除：
♦I/O完成队列不为空，而且正在运行的线程数小于最大并发线程数（GetQueuedCompletionStatus 会先从I/O完成队列中删除对应的项，接着将dwThreadld转移到已释放线程列表，最后函 数返回）
巳释放线程列表
每条记录包含：
I dwThreacild I
当满足以下条件时，会在列表中添加新项：
•完成端口在等待线程队列中唤醒一个线程
•已暂停的线程被唤醒
当满足以下条件时，会将列中的项删除：
•线程再次调用GetQueuedCompletionStatus （dwThreadld再次回到等待线程队歹0）
.•线程调用一个函数将自己挂起（dwThreadld转移到己暂停线程列表）
已暂停线程列表 每条记录包含： dwThreadld
当满足以下条件时，会在列襄中添加新项：
•已释放的线程调用一个函数将自己挂起
当满足以下条件时，会将列中的项删除，
•己挂起的线程被唤醒（dwThreadld回到已释放线程队列）
图10・1 I/O完成端口的内部运作
第二个数据结构是一个I/O完成队列。当设备的一个异步I/O请求完成时，系统会检查设 备是否与一个I/O完成端口相关联，如果设备与一个I/O完成端口相关联，那么系统会将
Endows核心编程(第5版)
该项已完成的I/O请求追加到I/O完成端口的I/O完成队列的末尾。这个队列中的每一项包 含的信息有：已传输的字节数、最初将设备与端口关联在一起的时候所设的完成键的值、 一个指向I/O请求的OVERLAPPED结构的指针以及一个错误码。
说明 向设备发出I/O请求，但不把该项已完成的I/O请求添加到I/O完成端口的队列中也 是有可能的。通常我们并不需要这样做，但这样做偶尔还是有用的一一比如，我们 通过一个套接字发送数据，但并不关心数据实际上到底有没有送达。
为了发出一个在完成的时候不要被添加到队列中的I/O请求，我们必须在 OVERLAPPED结构的hEvent成员中保存一个有效的事件句柄，并将它与1按位 或起来，如下面的代码所示：
Overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
Overlapped.hEvent = (HANDLE) ((DWORD_PTR) Overlapped.hEvent I 1);
ReadFile (. .., Overlapped);
现在我们可以发出I/O请求，并将OVERLAPPED结构的地址传给我们想要调用的 函数(比如上面的ReadFile函数)。
如果不必仅仅为了这个目的而专门创建一个事件，那岂不更好？我希望能够编写下 面的代码，但这行不通：
Overlapped.hEvent = 1:
ReadFile(..., &Overlapped);
另外，在关闭这个事件句柄的时候，不要忘了将最低位清掉：
CloseHandle((HANDLE) ((DWORD PTR) Overlapped.hEvent & ~1));
2.	I/O完成端口的周边架构
当我们的服务应用程序初始化的时候，应该调用CreateNewCompietionPort之类的函数来 创建I/O完成端口。应用程序接着应该创建一个线程池来处理客户请求。现在我们面临的 问题是，“线程池中应该有多少线程？ ”这个问题很难回答，我们会在后面的“线程池中 有多少线程？ ”一节中对此进行更深入地探讨。就目前而言，标准的经验法则是取主机的 CPU数量并将其乘以2。因此，在一台双处理器的机器上，我们应该创建一个有4个线程 的线程池。
线程池中的所有线程应该执行同一个函数。一般来说，这个线程函数会先进行一些初始化 工作，然后进入一个循环，当服务进程被告知要停止的时候，这个循环也应该就此终止。
在循环内部，线程将自己切换到睡眠状态，来等待设备I/O请求完成并进入完成端口。调 用 GetQueuedCompletionStatus 可以达到这一目的：
BOOL GetQueuedCompletionStatus(
HANDLE	hCompletionPort,
PDWORD	pdwNumberOfBytesTransferred,
PULONG_PTR pComplet ionKey z OVERLAPPED** ppOverlapped, DWORD	dwMilliseconds)；
32』
第10章 同步设备I/O与异步设备I/O
第一个参数hCompletionPort表示线程希望对哪个完成端口进行监视。许多服务应用程序 只使用一个I/O完成端口，并让所有I/O请求的完成通知进入这个端口。 GetQueuedCompletionStatus的任务基本上就是将调用线程切换到睡眠状态，直到指定的 完成端口的I/O完成队列中出现一项，或者等待的时间已经超出了(在dwMilliseconds参数 中)指定的时间为止。
与I/O完成端口相关的第三个数据结构是等待线程队列。当线程池中的每个线程调用 GetQueuedCompletionStatus的时候，调用线程的线程标识符会被添加到这个等待线程队 列，这使得I/O完成端口内核对象始终都能够知道，有哪些线程当前正在等待对已完成的 I/O请求进行处理。当端口的I/O完成队列中出现一项的时候，该完成端口会唤醒等待线程 队列中的一个线程。这个线程会得到已完成I/O项中的所有信息：已传输的字节数、完成 键以及OVERLAPPED结构的地址。这些信息是通过传给GetQueuedCompletionStatus 的 pdwNumberOfBytesTransferred, pCompletionKey 以及 ppOverlapped 参数来返回给 线程的。
确定GetQueuedCompletionStatus返回的原因有些困难，下面这段代码展示了正确的做法:
DWORD dwNumBytes;
ULONG_PTR CompletionKey;
OVERLAPPED* pOverlapped;
// hlOCP is initialized somewhere else in the program
BOOL bOk = GetQueuedCompletionStatus(hlOCP,
&dwNumBytes, &CompletionKeyz &pOverlapped, 1000);
DWORD dwError = GetLastError()；
if (bOk)(
// Process a successfully completed I/O request
} else (
if (pOverlapped != NULL) (
// Process a failed completed I/O request
// dwError contains the reason for failure
} else (
if (dwError == WAIT_TIMEOUT) (
// Time-out while waiting for completed I/O entry
} else {
// Bad call to GetQueuedCompletionStatus
// dwError contains the reason for the bad call
)
)
}
正如读者可能预料的那样，移除I/O完成队列中的各项是以先入先出的方式来进行的。但 是，读者可能没有预料到的是，唤醒那些调用了 GetQueuedCompletionStatus的线程是以 后入先出的方式来进行的。举个例子，假设有4个线程在等待线程队列中等待。如果出现 了一个已完成的I/O项，那么最后一个调用GetQueuedCompletionStatus的线程会被唤醒， 来处理这一项。当最后这个线程完成对该项的处理后，线程再次调用 GetQueuedCompletionStatus来进入等待线程队列。如果现在又出现了另一个已完成的I/O 项，那么处理上一项的同一个线程会被唤醒，来处理这个新的项。
325
如果I/O请求完成得足够慢，使得一个线程就能够将它们全部处理完，那么系统会不断地
endows核心编程（第5版）
唤醒同一个线程，而让其他线程继续睡眠。通过使用这种后入先出算法，系统可以将那些 未被调度的线程的内存资源（比如栈空间）换出到磁盘，并将它们从处理器的高速缓存中清 除。这意味着让许多线程等待一个完成端口并不是什么坏事。如果正在等待的线程数量大 于已完成的I/O请求的数量，那么系统会将多余线程的大多数资源换出内存。
在Windows Vista中，如果预计会不断地收到大量的I/O请求，那么我们可以调用下面的函 数来同时取得多个I/O请求的结果，而不必让许多线程等待完成端口，从而可以避免由此 产生的上下文切换所带来的开销：
BOOL GetQueuedCompletionStatusEx（
HANDLE hComplet ionPort,
LPOVERLAPPED_ENTRY pCompletionPortEntries,
ULONG ulCount,
PULONG pulNumEntriesRemoved,
DWORD dwMilliseconds,
BOOL bAlertable）;
第一个参数hCompletionPort表示线程想要对哪个完成端口进行监视。当该函数被调用的 时候，会取出指定的完成端口的I/O完成队列中存在的各项，并将它们的信息复制到 pCompletionPortEntries数组参数中。参数ulCount表示最多可以复制多少项到数组中， 参数pulNumEntriesRemoved指向的长整型值用来接收完成队列中被移除的I/O请求的确 切数量。
数组pCompletionPortEntries的每个元素是一个OVERLAPPED_ENTRY结构，它用来保 存已完成的I/O请求的所有相关信息：完成键、OVERLAPPED结构的地址、I/O请求的返 回码（或错误码）以及已传输的字节数。
typedef struct _OVERLAPPED_ENTRY （
ULONG_PTR IpCompletionKey；
LPOVERLAPPED IpOverlapped;
ULONG_PTR Internal;
DWORD dwNumberOfBytesTransferred；
} OVERLAPPED_ENTRY, *LPOVERLAPPED_ENTRY;
字段Internal没有明确的含义，不应该使用。
如果将最后一个参数bAlertable设为FALSE,那么函数会一直等待一个巳完成的I/O请求 被添加到完成端口，直到超出指定的等待时间（在参数dwMilliseconds中指定）为止。如果 参数bAlertable被设为TRUE而且队列中没有已完成的I/O请求，那么正如我们在本章前 面所介绍的那样，线程将进入可提醒状态。
326
说明 如果一个设备有完成端口与之相关联，那么当我们向它发出一个异步I/O请求的时 候，Windows会将结果添加到完成端口的队列中.即使异步请求是以同步方式完成 的，Windows仍然会这样做，其目的是为了向开发人员提供一个一致的编程模型。 但是，维护编程模型的一致性会略微损伤性能，这是因为已完成的请求信息必须被 放到端口的队列中，线程也必须从端口的队列中取得这些信息。
为了能够略微提高性能，我们可以通过调用SetFileCompletionNotificationModes函
第10章 同步设备I/O与异步设备I，0
数（在10.5.2节“触发事件内核对象”中介绍了）并传入FILE_SKIP_COMPLETION_ PORT_ON_SUCCESS标志，以此来告诉Windows不要将以同步方式完成的异步请求 添加到与设备相关联的完成端口中。
对性能极其关注的开发人员还可以考虑使用SetFileloOveHa叩edRange函数。（更多 的信息请参阅Platform SDK文档。）
3.	I/O完成端口如何管理线程池
现在是讨论I/O完成端口为什么如此有用的时候了。首先，当我们创建I/O完成端口的时 候，需要指定允许多少个线程并发运行。正如前面已经提到过，我们通常会将这个值设为 主机的CPU数量。当已完成的I/O项被添加到队列中的时候，I/O完成端口想要唤醒正在 等待的线程。但是，完成端口唤醒的线程数量最多不会超过我们指定的数量。因此，如果 有4个I/O请求已完成，有4个线程正在等待GetQueuedCompletionStatus,那么I/O完成 端口只会唤醒两个线程，而让其他两个线程继续睡眠。当每个线程处理完一个已完成的I/O 项时，会再次调用GetQueuedCompletionStatuso这时系统发现队列中还有其他的项，于 是会唤醒同一个线程来对剩余的项进行处理。
如果读者仔细考虑一下，就应该注意到有些东西没有太大的意义：如果完成端口只允许同 时唤醒指定数量的线程，那么为什么还要让更多的线程在线程池中等待呢？举个例子，假 设我们正在一台有两个CPU的机器上运行，我们创建了一个I/O完成端口，并告诉它同时 最多只能有两个线程来处理已完成的项。但我们在线程池中创建了 4个线程（是CPU数 量的两倍）。看起来似乎我们创建了两个多余的线程，它们永远都不会被唤醒来处理任何 东西。
但I/O完成端口是非常智能的。当完成端口唤醒一个线程的时候，会将该线程的线程标识 符保存在与完成端口相关联的第4个数据结构中，也就是已释放线程列表（released thread list）,请参阅图10-1 o这使得完成端口能够记住哪些线程已经被唤醒，并监视它们的执行情 况。如果一个己释放的线程调用的任何函数将该线程切换到了等待状态，那么完成端口会 检测到这一情况，此时它会更新内部的数据结构，将该线程的线程标识符从已释放线程列 表中移除，并将其添加到已暂停线程列表（paused thread list）中（与I/O完成端口相关联的第5 个也是最后一个数据结构）。
完成端口的目标是根据在创建完成端口时指定的并发线程的数量，将尽可能多的线程保持 在已释放线程列表中。如果一个已释放线程由于任何原因而进入等待状态，那么已释放线 程列表会缩减，完成端口就可以释放另一个正在等待的线程。如果一个己暂停的线程被唤 醒，那么它会离开已暂停线程列表并重新进入已释放线程列表。这意味着此时已释放线程 列表中的线程数量将大于最大允许的并发线程数量。
说明 一旦一个线程调用了 GetQueuedCompletionStatus,该线程会被“指派”给指定的 完成端口。系统假定所有被指派的线^程都是以该完成端口的名义来完成工作的。只 有当指派给完成端口的正在运行的线程数量小于它最大允许的并发线程数量时，完
■^dows核心编程(第5版)
成端口才会从线程池中唤醒线程。
我们可以通过以下3种方式之一来结束线程/完成端口的指派：
•让线程退出。
•	让线＜程调用GetQueuedCompletionStatus,并传入另一个不同的I/O完成端口的 句柄。
•	销毁线程当前被指派的I/O完成端口。
让我们把这些总结一下。假设我们在一台有两个CPU的机器上运行。我们创建了一个同时 最多只允许两个线程被唤醒的完成端口，还创建了 4个线程来等待已完成的I/O请求。如 果3个已完成的I/O请求被添加到端口的队列中，只有两个线程会被唤醒来对请求进行处 理，这降低了可运行线程的数量，并节省了上下文切换的时间。现在，如果一个可运行线 程调用了 Sleep, WaitForSingleObject, WaitForMultipleObjects, SignalObjectAndWait* 一个异步I/O调用或任何能够导致线程变成不可运行状态的函数，I/O完成端口会检测到这 一情况并立即唤醒第3个线程。完成端口的目标是使CPU保持在满负荷状态下工作。
最后，第一个线程将再次变成可运行状态。当发生这种情况的时候，可运行线程的数量将 超过系统中CPU的数量。但是，完成端口仍然知道这一点，在线程数量降到低于CPU数 量之前，它是不会再唤醒任何线程的。I/O完成端口体系结构假定可运行线程的数量只会在 很短一段时间内高于最大允许的线程数量，一旦线程进入下一次循环并调用 GetQueuedCompletionStatus,可运行线程的数量就会迅速下降。这就解释了为什么线程池 中的线程数量应该大于在完成端口中设置的并发线程数量。
4.线程池中有多少线程？
现在来讨论线程池中应该有多少线程再合适不过了。有两个问题需要考虑。首先，当服务 应用程序初始化的时候，我们想要创建最少数量的线程，这样就不必经常地创建和销毁线 程。记住，创建和销毁线程会浪费CPU时间，因此我们最好是尽一切可能将这一过程减至 最少。其次，我们想要设置一个最大线程数量，这是因为创建太多的线程会浪费系统资源。 即便这些资源中的大多数可以被换出内存，如果我们能够有效地管理，将系统资源的使用 减到最少，甚至连页交换文件中的空间也不浪费，那么这对我们将是有利的。
读者可能想要用不同数量的线程来进行实验。大多数服务(包括Microsoft Internet Information Services)使用启发式的算法来对它们的线程池进行管理，我建议读者也这样做。 例如，我们可以创建下面这些变量来管理线程池：
LONG g_nThreadsMin；	//	Minimum	number	of	threads	in pool
LONG g_nThreadsMax；	//	Maximum	number	of	threads	in pool
LONG g_nThreadsCrnt;	//	Current	number	of	threads	in pool
LONG g_nTh reads Busy ；	//	Number	of busy	threads in	pool
在应用程序初始化的时候，可以创建g_nThreadsMin个线程，所有线程都执行同一个线程 池函数。下面的伪代码显示了这个线程池函数大致的样子：
DWORD WINAPI ThreadPoolFunc(PVOID pv) (
第10章 同步设备「0与异步设备I O
// Thread is entering pool
Interlockedlncrement(&g_nThreadsCrnt); Interlockedlncrement(&g_nThreadsBusy);
for (BOOL bStaylnPool = TRUE； bStaylnPool;) (
// Thread stops executing and waits for something to do InterlockedDecrement(&m_nThreadsBusy);
BOOL bOk = GetQueuedCompletionStatus(...)；
DWORD dwIOError = GetLastError()；
// Thread has something to do, so ifs busy
int nThreadsBusy = Interlockedlncrement(&m_nThreadsBusy)；
// Should we add another thread to the pool?
if (nThreadsBusy == m_nThreadsCrnt) (	// All threads are busy
if (nThreadsBusy < m_nThreadsMax) (	// The pool isn't full
if (GetCPUUsage() < 75) (	// CPU usage is below 75%
// Add thread to pool CloseHandle(chBEGINTHREADEX(...));
}
)
}
if (!bOk && (dwIOError == WAIT_TIMEOUT) ) {	// Thread timed out
// There isn* t much for the server to do, and this thread // can die even if it still has outstanding I/O requests bStaylnPool = FALSE;
)
if (bOk I I (po != NULL)) (
// Thread woke to process something； process it
if (GetCPUUsage() > 90) (	// CPU usage is above 90%
if (g_nThreadsCrnt > g_nThreadsMin)) ( // Pool above min bStaylnPool = FALSE； // Remove thread from pool
}
}
}
)
// Thread is leaving pool
InterlockedDecrement(&g_nThreadsBusy);
InterlockedDecrement(&g_nThreadsCurrent); return(0)；
)
,329~330
这段伪代码显示了在使用I/O完成端口的时候，我们可以充分发挥自己的创造力。 GetCPUUsage函数并不是Windows API的一部分。如果想要这种行为，我们就必须自己实 现该函数。另外，我们必须确保线程池中总是至少有一个线程，否则客户请求将永远得不 到处理。请将前面的伪代码用作参考，但也可能某些特别的服务需要以不同的方式编写， 才能够得到更好的性能。
说明 在本章1043节“取消队列中的设备I/O请求”中，我们提到当一个线程终止的时 候，系统会自动将该线程发出的所有待处理的I/O请求取消掉。在Windows Vista 之前的版本中，当线程向一个与完成端口相关联的设备发出I/O请求的时候，存在 一条硬性规定，即在请求完成之前，该线程必须不能终止，否则，Windows会将该
Endows核心编程(第5版)
线程发出的任何待处理的请求取消掉。而在Windows Vista中，已经不存在类似的 规定了：线程现在可以发出请求并终止，请求仍然能够得到处理，处理结果将会被 添加到完成端口的队列中。
许多服务都提供了一个管理工具，能够让管理员在某种程度上对线程池的行为进行控制一一 比如，线程的最大数量和最小数量，CPU时间使用的阈值，以及在创建I/O完成端口时使 用的最大并发线程数量。
10.5.5模拟已完成的I/O请求
I/O完成端口并不一定要用于设备I/O。本章还涵盖了与线程间通信有关的技术，而I/O完 成端口是一项非常棒的技术，可以用来进行线程间通信。在10.5.3节“可提醒I/O”中，我 们介绍了 QueueUserAPC函数，该函数允许线程将一个APC项添加到另一个线程的队列 中。I/O完成端口有一个类似的函数，名叫PostQueuedCompletionStatus：
BOOL PostQueuedCompletionStatus(
HANDLE	hCompletionPort,
DWORD	dwNumBytes,
ULONG_PTR Comp1et i onKey/	-
OVERLAPPED* pOverlapped)；
这个函数用来将一个已完成的I/O通知追加到I/O完成端口的队列中。第一个参数 hCompletionPort表示我们要将该项添加到哪个完成端口的队列中。剩下的3个参数一一 dwNumBytes, CompletionKey和pOverlapped-表示应该返回什么值给那个调用了
GetQueuedCompletionStatus的线程。当线程从I/O完成队列中得到一个模拟项的时候， GetQueuedCompletionStatus会返回TRUE,表示I/O请求已成功执行。
PostQueuedCompletionStatus函数的有用程度令人难以置信——它为我们提供了一种方式 来与线程池中的所有线程进行通信。例如，当用户终止服务应用程序的时候，我 们想要让所有线程都干净地退出。但如果各线程还在等待完成端口但又没有己完成 的I/O请求，那么它们将无法被唤醒。通过为线程池中的每个线程都调用一次 PostQueuedCompletionStatus ,我们可以将它们都唤醒。每个线程会对 GetQueuedCompletionStatus的返回值进行检查，如果发现应用程序正在终止，那么它就 可以进行清理工作并正常地退出。
330-331
在使用刚才介绍的线程终止技术的时候必须小心。示例代码能够工作的原因是线程池中的 线程正在退出，不会再次调用GetQueuedCompletionStatuso但是，如果想要通知线程池 中的每个线程发生了某些事情，让它们进入下一次循环并再次调用 GetQueuedCompletionStatus,那么我们就有问题了，这是因为线程是以后入先出的方式被 唤醒的。因此，为了确保线程池中的每个线程都能有机会得到模拟的I/O项，我们还必须 在应用程序中采用其他线程同步机制。如果不采用其他线程同步机制，那么同一个线程可 能会多次得到相同的通知。
第10章 同步设备I/o与异步设备I 0
说明 在Windows Vista中，当我们调用CloseHandle并传入一个完成端口的句柄时，系 统会将所有正在等待GetQueuedCompletionStatus返回的线程唤醒，并返回FALSE 给它们。此时调用GetLastError会返回ERROR_INVALID_HANDLE,线程可以 通过这种方式来知道自己应该得体地退出了。
FileCopy示例程序
本章最后的FileCopy示例程J^( 10-FileCopy.exe),展示了 I/O完成端口的使用。应用程序的 源代码和资源文件在本书配套网页的10-FileCopy目录中。示例程序只是把用户指定的一个 文件复制为一个名为FileCopy.cpy的新文件。当用户执行FileCopy的时候，会显示图10-2 中的对话框。
GE2SHB
〔Copy ]
File size: |0
图10-2 FileCopy示例程序的对话框
用户先单击Pathname按钮来选择一个需要复制的文件，Pathname和File Size文本框会随 之更新。当用户单击Copy按钮的时候，程序会调用FileCopy函数，这个函数完成了所有 困难的工作。下面让我们来集中讨论FileCopy函数。
在准备复制的阶段，FileCopy会打开源文件并取得它的大小，以字节为单位。由于我们希 望文件复制能够尽可能快，因此使用了 FILE_FLAG_NO_ BUFFERING标志来打开文件。 使用FILE_FLAG_NO_ BUFFERING标志打开文件允许我直接访问文件，同时可以避免 额外的内存复制开销，这是因为我们并不需要系统对文件进行缓存来“帮助”我们访问文 件。当然，直接访问文件意味着我有更多的工作要做：在访问文件时使用的偏移量必须始 终是磁盘卷的扇区大小的整数倍，读取和写入的数据量也必须是扇区大小的整数倍。我决 定以BUFFSIZE(64 KB)为单位来传输文件数据，因为这个大小肯定是扇区大小的整数倍。 这也是我为什么要将源文件的大小取整到BUFFSIZE的整数倍的原因。读者还会注意到， 源文件是通过FILE_FLAG_OVERLAPPED标志打开的，这样发往文件的I/O请求就能够 以异步方式来执行。
目标文件的打开与此相似：同时指定了 FILE_FLAG_NO_BUFFERING和 FILE_FLAG_OVERLAPPED标志。另外，在创建目标的时候，我还将源文件的句柄作为 CreateFile的hFileTemplate参数传入，这使得目标文件具有与源文件相同的属性。
说明 一旦两个文件都已打开，代码会立刻调用SetFilePointerEx和SetEndOfFile来将目 标文件的大小设为最终的文件大小。现在就调整文件的大小是极其重要的，这是因 为NTFS会维护一个最高水位(high-water marker), 来表示文件被写入的最高位置。 如果我们越过这个位置读取文件，那么系统知道要返回0。如果我们越过这个位置
Endows核心编程（第5版）
写入文件，那么系统会用0来填满从老的最高水位到当前写入偏移量之间的文件数 据，将我们的数据写入文件，并更新文件的最高水位。这样的行为满足了 C2安全 性要求，它要求不呈现原先的数据。当我们在NTFS分区上写入文件尾的时候，会 移动最高水位，这时即使我们要求的是异步I/O, NTFS也必须以同步的方式来执行 该I/O请求。如果FileCopy函数无法设置目标文件的大小，那么将没有任何一个重 叠的I/O请求能够以异步方式执行。
现在两个文件都已经打开，可以对它们进行处理了，于是FileCopy创建了一个I/O完成端 口。为了让I/O完成端口更加容易使用，我创建了一个很小的C++类，CIOCP,它只是对 I/O完成端口进行了非常简单的封装。这个类在lOCP.h中，附录A对lOCP.h进行了介绍。 FileCopy通过创建CIOCP类的一个（名叫iocp的）实例来创建I/O完成端口。
程序通过调用CIOCP的AssociateDevice成员函数来将源文件和目标文件与完成端口关联 起来。在关联完成端口的时候，会给每个设备分配一个完成键。当发往源文件的I/O请求 完成时，相应的完成键是CK_READ,表示读取操作已经完成。与此相似，当发往目标文 件的I/O请求完成时，相应的完成键是CK_WRITE,表示写入操作已经完成。
现在我们已经准备好对一组I/O请求（OVERLAPPED结构）和它们的内存缓存进行初始化 了。FileCopy函数在同一时刻可以保存4个（MAX_PENDING_IO_REQS）待处理的I/O请 求。对读者自己的应用程序来说，读者可能更倾向于使I/O请求的数量能够根据需要动态 地增加或缩减。在FileCopy程序中，CIOReq类对一个I/O请求进行了封装。正如我们能 够看到的那样，这个C++类继承自OVERLAPPED结构，但包含一些附加的上下文信息。 FileCopy分配一个CIOReq对象数组，并调用AUocBuffer函数来给每个I/O请求分配一块 大小为BUFFSIZE的数据缓存。这个数据缓存是用VirtualAlloc函数分配的。使用 VirtualAlloc函数可以确保内存块的起始位置位于分配粒度的边界，从而满足了 FILE_FLAG_NO_BUFFERING标志的要求：缓存的起始地址必须是磁盘卷的扇区大小的 整数倍。
为了向源文件发出读取请求，我使用了一个小伎俩：往I/O完成端口添加4个CK_WRITE 来模拟I/O完成通知。当主循环运行的时候，主循环所在的线程会等待该端口并立刻被唤 醒，认为有•写入操作己经完成。这使得该线程向源文件发出一个读取请求，从而真正地启 动了整个文件复制过程。
密332
当没有待处理的I/O请求时，主循环会终止。只要还有待处理的I/O请求，循环内部就会 调用CIOCP的GetStatus函数（它在内部调用了 GetQueuedCompletionStatus）来等待完成端 口。这个调用让线程进入睡眠状态，直到I/O完成端口出现已完成的I/O请求为止。当 GetQueuedCompletionStatus返回的时候，程序会检查返回的完成键Completion Key。如 果CompletionKey是CK_READ,那么表示已完成的I/O请求是发往源文件的。然后程序 调用CIOReq的Write函数来向目标文件发出一个写入I/O请求。如果CompIetionKey是 CK_WRITE,那么表示已完成的I/O请求是发往目标文件的。如果尚未读到源文件的末尾,
第10章 同步设备I/。与异步设备I。
那么程序会调用CIOReq的Read函数来继续读取源文件。
当没有待处理的I/O请求时，循环会终止，并通过关闭源文件和目标文件的句柄来完成清 理工作。在FileCopy返回之前，还必须执行另一项任务：它必须修复目标文件的大小，使 之与源文件的大小相同。为了达到这个目的，我再次打开文件，但没有指定 FILE_FLAG_NO_BUFFERING标志。由于没有指定该标志，因此文件操作不必在扇区的 边界上进行。这使得程序能够将目标文件的大小缩减为与源文件相同的大小。
/****•••*******************************•••*******••**************•******•****** Module: FileCopy.cpp
Notices： Copyright (c) 2008 Jeffrey Richter & Christophe Nasarre
**m************************** *******•******•***************************★*/
tinclude "stdafx.h" ♦include ■Resource.hB
///////////////////////////////////////////////////////////////////////////////
// Each I/O request needs an OVERLAPPED structure and a data buffer class CIOReq : public OVERLAPPED { public：
CIOReq() {
Internal = InternalHigh = 0；
Offset = OffsetHigh = 0;
hEvent = NULL;
nunBuffSize = 0; m_pvData = NULL;
}
-CIOReq() (
if (nupvData != NULL)
VirtualFree(m^vData, 0, MEM_RELEASE);
}
BOOL AllocBuffer(SIZE.T nBuffSize) (
nunBuffSize = nBuffSize；
nupvData = VirtualAlloc (NULL, m_nBuf fSize, MEbt-COMMIT, PAGE__READWRITE); return(nupvData != NULL)；
}
BOOL Read(HANDLE hDevice, PLARGE_INTEGER pliOffset = NULL) ( if (pliOffset != NULL) (
Offset = pliOffset->LowPart;	Q陌
OffsetHigh = pliOffset->HighPart;
,.)	噤去
return (:: ReadFile (hDevice, m_pvData,	f f S；
}
BOOL Write (HANDLE hDevice, PLARGE_INTEGER 翊衿
if (pliOffset != NULL) (	专
Offset = pliOffset->LowPart;
OffsetHigh = pliOffset->HighPart;
}
return(::WriteFile(hDevice, m_pvDatar nunBuf	this))；
)
private:	-、炙它：；、’
SIZE_T nunBuffSize；	'霍i零％冷二如•炒：
indows核心编程（第5版）
PVOID m_jpvData； )；
///////////////////////////////////////////////////////////////////////////////
#define BUFFSIZE	(64 * 1024) // The size of an I/O buffer
#define MAX_PENDING_IO_REQS 4	// The maximum # of I/Os
// The completion key values indicate the type of con^leted I/O. #define CK_READ 1
#define CK.WRITE 2
///////////////////////////////////////////////////////////////////////////////
BOOL FileCopy(PCTSTR pszFileSrc, PCTSTR pszFileDst) (
BOOL fOk = FALSE; // Assume file copy fails LARGE^INTEGER liFileSizeSrc = { 0 }, liFileSizeDst;
try (
(
// Open the source file without buffering & get its size CEnsureCloseFile hFileSrc = CreateFile(pszFileSrC/ GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAGJNO_BUFFERING I FILE_FLAG__OVERLAPPED, NULL);
if (hFileSrc.Islnvalid()) goto leave；
// Get the file's size
GetFileSizeEx(hFileSrc, &liFileSizeSrc);
// Nonbuffered I/O requires sector-sized transfers.
// I 'll use buffer-size transfers since it's easier to calculate. liFileSizeDst.QuadPart = chROUNDUP(liFileSizeSrc.QuadPart, BUFFSIZE)；
// Open the destination file without buffering & set its size CEnsureCloseFile hFileDst = CreateFile(pszFileDst, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_FLAG_NOJBUFFERING I FILE_FLAG_OVERLAPPED, hFileSrc);
if (hFileDst.Islnvalid()) goto leave；
// File systems extend files synchronously. Extend the destination file // now so that I/Os execute asynchronously improving performance. SetFilePointerEx(hFileDst, liFileSizeDst, NULL, FILE_BEGIN);
SetEndOfFile(hFileDst);
// Create an I/O completion port and associate the files with it. CIOCP iocp(0);	,
iocp.AssociateDevice(hFileSrc, CK__READ) ； // Read from source file iocp.AssociateDevice(hFileDst, CK_WRITE)； // Write to destination file
// Initialize record-keeping variables
CIOReq ior[MAX_PENDING_IO_REQS];
LARGE_INTEGER liNextReadOffset = { 0 };
int nReadsInProgress = 0;	]小 ；.，
int nWritesInProgress = 0;	'
// Prime the file copy engine by simulating that writes have con^leted. // This causes read operations to be issued.	"
for (int nIOReq = 0; nIOReq < _countof (ior) ； nIOReqi) (
// Each I/O request requires a data buffer for transfers
第10章 同步设备I/O与异步设备I。
(nWritesInProgress > 0)) (
I/O completes
an
&dwNumBytes, (OVERLAPPED**) &pior, INFINITE);
// Loop while outstanding I/O while ((nReadsInProgress > 0)
// Suspend the thread until ULONG_PTR CompletionKey； DWORD dwNumBytes;
CIOReq* pior； iocp.GetStatus(SCompletionKey,
chVERIFY(ior(nIOReq].AllocBuffer(BUFFSIZE)); nWritesInProgress++; iocp.PostStatus(CK_WRITEr 0, &ior[nlOReq]);
requests still exist
break；
return(fOk)；
chSETDLGICONS(hWnd, IDI^FILECOPY);
is selected yet. FALSE);
// Disable Copy button since no file EnableWindow(GetDlgItem(hWndr IDOK),
SetFilePointerEx(hFileDst, liFileSizeSrc, NULL, FILE_BEGIN); SetEndOfFile(hFileDst):
switch (CompletionKey) (
case CK_READ： // Read completed/ write to destination nReadsInProgress--;
pior->Write(hFileDst); // Write to same offset read from source nWritesInProgress++； break；
case CK_WRITE: // Write completed, read from source nWritesInProgress--； if (1iNextReadOffset.QuadPart < 1iFileSizeDst.QuadPart) {' // Not EOF, read the next block of data from the source file. pior->Read(hFileSrc/ &liNextReadOffset)； nReadsInProgress++;
liNextReadoffset.QuadPart += BUFFSIZE； // Advance source offset
fOk = TRUE;
if (fOk) (
// The destination file size is a multiple of the page size. Open the // file WITH buffering to shrink its size to the source file's size. CEnsureCloseFile hFileDst = CreateFile(pszFileDst, GENERIC_WRITE, 0, NULL, OPEN^EXISTING, 0, NULL);
(hFileDst.IsValid()) (
. .4挡#疔

////////////////////////////////////////////////////////"^^
BOOL Dlg_OnInitDialog(HWND hWnd, HWND hWndFocus, LPARAM

Endows核心编程（第5版）
return(TRUE);
)
///////////////////////////////////////////////////////////////////////////////
void Dlg_OnCommand(HWND hWnd, int id, HWND hWndCtl, UINT codeNotify) (
TCHAR szPathname[_MAX_PATH];
switch (id) {
case IDCANCEL:
EndDialog(hWnd, id);
break;
case IDOK:
// Copy the source file to the destination file.
Static_GetText(GetDlgItem(hWnd, IDC_SRCFILE), szPathname, sizeof(szPathname))；
SetCursor(LoadCursor(NULL, IDC_WAIT));
chMB(FileCopy(szPathname, TEXT(■FileCopy.cpy*))
? "File Copy Successful" : "File Copy Failed*); break;
case IDC_PATHNAME:
OPENFILENAME ofn = { OPENFILENAME_SIZE_VERSION_400 };
ofn.hwndOwner = hWnd;
ofn.lpstrFilter = TEXT(■*.*\0");
1strcpy(szPathname, TEXT(■*.*•))；
ofn.IpstrFile = szPathname；
ofn.nMaxFile = _countof(szPathname)；
ofn.IpstrTitle = TEXT("Select file to copy■)；
ofn.Flags = OFN_EXPLORER I OFN_FILEMUSTEXIST;
BOOL fOk = GetOpenFileName(&ofn);
if (fOk) (
// Show user the source file's size
Static_SetText(GetDlgItem(hWnd, IDC_SRCFILE), szPathname)； CEnsureCloseFile hFile = CreateFile(szPathname, 0, 0, NULL, OPEN.EXISTING, 0, NULL);
if (hFile.IsValid()) (
LARGE_INTEGER liFileSize；
GetFileSizeEx(hFile, SliFileSize)；
// NOTE: Only shows bottom 32 bits of size SetDlgltemlnt(hWnd, IDC.SRCFILESIZE, liFileSize.LowPart, FALSE);
}
}
IDOK), fOk);
break；
> t/v V— : i». •• If ZQ J	JS"	...
；...WW V	'
INT_PTR WINAPI Dlg_Proc(HWND hWnd, UINT uMsg, WPAi嚼布皿爻尴嶙
switch (uMsg) (
chHANDLE_DLGMSG (hWnd, WICINITDIALOG, Dlg.OnlnitDialog); & 技 W	"
chHANDLE^DLGMSG (hWnd, WK»COMMAND,	Dlg.OnCommand);品警;? -	:
)
return (FALSE)；	'砌土 '
第10章 同步设备I。与异步设备I。
〃/////////〃〃///////〃///////////////////////////////////////////////////////
int WINAPI _tWinMain(HINSTANCE hlnstExe, HINSTANCE, PTSTR pszCmdLine, int) ( MAKEINTRESOURCE(IDD_FILECOPY), NULL, Dlg_Proc);
'颁讲沛:N •j.'JKjrOH
W； .I J" *\'V	\\
DialogBox(hlnstExe, return(0);
}
'///////////////〃///// End of File //////////////////////////////////
11.5回调函数的终止操作
在第10章中，我们讨论了 Microsoft Windows的I/O完成端口内核对象，介绍了完成端口 如何提供I/O请求队列，以及完成端口如何以一种智能的方式来分派线程，让它们对队列 中的各项进行处理。但是，I/O完成端口只对等待它的线程进行分派，创建和销毁线程的工 作仍然必须由我们自己来完成。
对如何创建和销毁线程，每个人都有自己的意见。在过去的这些年中，笔者自己巳经用不 同的实现方式创建了数个线程池，其中的每一个实现都为某个特定的情形而做了精心调整。 为了简化开发人员的工作,Windows提供了一个（与I/O完成端口相配套的）线程池机制来简 化线程的创建、销毁以及日常管理。这个新的通用线程池可能并不适用于所有的情况，但 很多情况下它能够满足我们的需要并节省大量的开发时间。
这些新的线程池函数允许我们做以下这些事情:
•	以异步的方式来调用一个函数
•	每隔一段时间调用一个函数
•	当内核对象触发的时候调用一个函数
•	当异步I/O请求完成的时候调用一个函数
说明 Microsoft 是从 Windows 2000 开始引入线程池 API 的。在 Windows Vista 中，Microsoft 对线程池进行了重新构架，并因此引入了一组新的线程池APL当然，为了向后兼 容原有版本的Windows, Windows Vista仍然支持那些在Windows 2000中引入的老 API。但是，如果应用程序不需要在Windows Vista之前的版本上运行，那么建议使 用新的API。本章将集中介绍Windows Vista中引入的新的线.程API,本书以前的版 本已经对老API进行了介绍，因此在本书的这一版中就不再赘述。
当一个进程初始化的时候，它并没有任何与线程池有关的开销。但是，一旦调用了新的线 程池函数，系统就会为进程创建相应的内核资源，其中的一些资源在进程终止之前都将一
第11章 Windows线程池
直存在。正如我们可以看到，使用线程池的开销取决于用法：系统会以进程的名义来分配 线程、其他内核对象以及内部数据结构。因此我们不应该盲目地使用这些线程池函数，而 是必须谨慎地考虑，这些函数能做什么，以及它们不能做什么。
好了，下面就让我们来看一看线程池函数允许我们做的事情。
11.1情形1:以异步方式调用函数
为了用线程池来以异步的方式执行一个函数，我们需要定义一个具有以下原型的函数：
VOID NTAPI SimpleCallback（
PTP_CALLBACK_INSTANCE plnstance, //请参阅11.5节“回调函数的终止操作” PVOID pvContext）;
然后为了让线程池中的一个线程执行该函数，我们需要向线程池提交一个请求。为了达到 这个目的，我们只需调用下面的函数：
BOOL TrySubmitThreadpoolCallback（
PTP_SIMPLE_CALLBACK pfnCallback,
PVOID pvContext,
PTP_CALLBACK_ENVIRON pcbe） ; //清参阅11.5.1节“对线程池进行定制”
该函数（通过调用PostQueuedCompletionStatus来）将一个工作项（work item）添加到线程池 的队列中，若调用成功，则返回TRUE,若调用失败，则返回FALSE o在调用 TrySubmitThreadpoolCallback的时候，pfnCallback参数用来标识我们编写的那个符合 SimpleCallback 原型的函数。参数 pvContext 是一个应该（通过 SimpleCallback 的 pvContext 参数）传给我们的函数的值。我们可以直接给PTP_CALLBACK_ENVIRON参数传NULL。 （我们会在后面的11.5.1节“对线程池进行定制”解释这个参数，我们还会在11.5节“回调 函数的终止操作 ” （callback termination actions）中解释 SimpleCallback 的 plnstance 参数。）
注意，我们从来不需要自己调用CreateThreado系统会自动为我们的进程创建一个默认的 线程池，并让线程池中的一个线程来调用我们的回调函数。此外，当这个线程处理完一个 客户请求之后，它不会立刻被销毁，而是会回到线程池，准备好处理队列中的任何其他工 作项。线程池会不断地重复使用其中的线程，而不会频繁地创建和销毁线程。对应用程序 来说，这样可以显著地提升性能，因为创建和销毁线程会消耗大量的时间。当然，如果线 程池检测到创建另一个线程将能够更好地为应用程序服务，那么它就会这样做。如果线程 池检测到它的线程数量己经供过于求，那么它就会销毁其中一些线程。除非我们非常清楚 自己在做什么，否则的话最好还是相信线程池的内部算法，让它自动地对应用程序的工作 量进行微调。
11.1.1	显式地控制工作项
在某些情况下，比如内存不足或配额限制，TrySubmitThreadpoolCallback调用可能会失
indows核心编程(第5版)
败。当多项操作需要相互协调的时候(比如一个计时器要依靠一个工作项来取消另一个 操作的时候)，这是不能接受的。在设置计时器的时候，我们必须确保用来取消操作的 那个工作项会被提交到线程池中，并会被线程池处理。但是，当计时器设定的时间到的 时候，可用的内存或配额的情况与创建定时器的时候可能并不相同，因此 TrySubmitThreadpoolCallback有可能会失败。在这种情况下，我们必须在创建定时器的 同时就创建一个工作项对象，并一直持有它，直到我们需要显式地将该工作项提交到线程 池中为止。
每一次调用TrySubmitThreadpooICaUback的时候，系统会在内部以我们的名义分配一个 工作项。如果打算提交大量的工作项，那么出于对性能和内存使用的考虑，创建工作项一 次，然后分多次提交它会更好。我们调用下面的函数来创建一个工作项：
PTP_WORK CreateThreadpoolWork(
PTP_WORK_CALLBACK pfnWorkHandler,
PVOID pvContext,
PTP_CALLBACK_ENVIRON pcbe) ; //请参阅11.5.1节“对线程池进行定制”
这个函数会在用户模式内存中创建一个结构来保存它的三个参数，并返回指向该结构的指 针。参数pfnWorkHandler是一个函数指针，当线程池中的线程最终对工作项进行处理的 时候，会调用该函数指针指向的函数。参数pvContext可以是需要传给回调函数的任意值。 在参数pfnWorkHandler中传入的函数必须符合下面的函数原型：
VOID CALLBACK WorkCallback(
PTP_CALLBACK_INSTANCE :Instance,
PVOID Context,
PTP_WORK Work);
当我们想要向线程池提交一个请求的时候，可以调用SubmitThreadpoolWork函数：
VOID SubmiCThreadpoolWork(PTP_WORK pWork);
现在我们可以假定已经成功地将请求添加到了队列中(亦即我们将成功地通过线程池中的 线程来调用回调函数)。事实上,这也是为什么SubmitThreadpoolWork的返回类型为VOID 的原因。
警告 如果需要多次提交同一个工作项，那么每次回调函数被调用的时候，传入的 pvContext值会是相同的，也就是在创建工作项的时候指定的那个值。因此，如果 想要重复使用同一个工作项来执行多个操作，那么我们需要意识到这个问题。我们 很可能希望依次执行这些操作，这样就可以准确无误地区分每一个操作。
如果我们有另一个线程，该线程想要取消已经提交的工作项，或者该线程由于要等待工作 项处理完毕而需要将自己挂起，那么可以调用下面的函数：
VOID WaitForThreadpoolWorkCallbacks(
PTP_WORK pWork,
BOOL bCancelPendingCallbacks);
参数pWork指向一个工作项，该工作项是我们之前调用CreateThreadpoolWork和
SubmitThreadpooIWork来创建和提交的。如果该工作项尚未提交，那么这个函数将立即
第11章 Windows线程池
返回而不执行任何操作。
如果我们传 TRUE 给 bCancelPendingCaUbacks 参数，那么 WaitForThreadpoolWorkCaUbacks 会试图取消先前提交的那个工作项。如果线程池中的线程正在处理那个工作项，那么该过 程不会被打断，WaitForThreadpoolWorkCaUbacks会一直等到该工作项己经完成后再返 回。如果已提交的工作项尚未被任何线程处理，那么函数会先将它标记为已取消，然后立 即返回。当完成端口从队列中取出该工作项的时候，线程池知道无须调用回调函数，这样 该工作项根本就不会执行。
如果传 FALSE 给 bCancelPendingCaUbacks 参数，那么 WaitForThreadpoolWorkCaUbacks 会将调用线程挂起，直到指定工作项的处理已经完成，而且线程池中处理该工作项的线程 也己经被收回并准备好处理下一个工作项为止。
说明 如果用一个PTP_WORK对象提交了多个工作项，而且传给bCancelPendingCaUbacks 参数的值为FALSE,那么WaitForThreadpoolWorkCaUbacks会等待线程池处理完 所有已提交的工作项。如果传给bCancelPendingCaUbacks 的值为TRUE,那 么WaitForThreadpoolWorkCaUbacks只会等待当前正在运行的工作项完成。
不再需要一个工作项的时候，我们应该调用CloseThreadpoolWork并在它唯一的参数中传 入指向该工作项的指针：
VOID CloseThreadpoolWork(PTP_WORK pwk)；
11.1.2	Batch示例程序
下面的Batch示例程序(ll.Batch.exe),展示了如何使用线程池的工作项函数来实现对多个 操作进行批处理，每个操作会通知用户界面线程该操作的状态，并以它所在线程的线程标 识符为前缀。该应用程序实现了一个简单的方案，来知道整个批处理何时结束。图11-1显 示了应用程序执行的状况。
图11-1 Batch应用程序产生的输出
[ndows核心编程（第5版）
应用程序的源文件和资源文件在本书配套网页的11-Batch目录中。
嘤342
/******************************************★*************★******************★★*
Module： Batch.cpp
Notices: Copyright (c) 2008 Jeffrey Richter & Christophe Nasarre ***********★********★**********★*********•*********•******************•★******/
#include "stdafx.h" #include ■Batch.h*
//////////////////////////////////////////////////////////////////////////////
// Global variables
HWND g_hDlg = NULL;
PTP__WORK g_pWorkItem = NULL; volatile LONG g_nCurrentTask = 0;
// Global definitions
#define WM_APP_COMPLETED (WM_APP+123)
//////////////////////////////////////////////////////////////////////////////
void AddMessage(LPCTSTR szMsg) (
HWND hListBox = GetDlgltemtg.hDlg, IDC_LB_STATUS);
ListBox_SetCurSel(hListBox, ListBox_AddString(hListBox, szMsg)); }
//////////////////////////////////////////////////////////////////////////////
void NTAPI TaskHandler(PTP_CALLBACK_INSTANCE Instance, PVOID Context, PTP_WORK Work) (
LONG currentTask = Interlockedlncrement(&g_nCurrentTask);
TCHAR szMsg[MAX_PATH];
StringCchPrint f(
szMsg, ..countof (szMsg),
TEXT(■[%u] Task #%u is starting.")r GetCurrentThreadld(), currentTask)； AddMessage(szMsg)；
// Simulate a lot of work
Sleep(currentTask * 1000);
StringCchPrint f(
szMsg, __countof (szMsg),
TEXT("[%u] Task #%u is done.”), GetCurrentThreadld(), currentTask);
AddMessage(szMsg)；
if (InterlockedDecrement(&g_nCurrentTask) == 0)
(
// Notify the UI thread for completion.
PostMessage (g__hDlgz WM__APP_COMPLETED, 0, (LPARAM) currentTask);
}
}
(
! (SDHJ, ' (HOJAfH一JiHVIS—皿旷0<11 ^uMqJuiaqifiia^SD) ©TQ^ua^uoq^ng uoqqnq aqq axqpua oq qafijtoj q.uoa //
i (fiswzs)a5ess©wppv
i (ureaedi z (« qgeq aq。jo s(spq 涟己]aqQ spm n%# ^sej. -)d,X3J.
* (Bswzs) jo^unoo~ Sswzs .u 口冲 gugS
i (T +HJ,Vd_XVW] 6swzS HVHD1 ) :asXSadWOD-ddV^HM aseo / (pueuiuioouo-6ia "QNVWWOO^WM *puMU) 0SW9qa~3naNVHqo / (BoieTQ^TUiuo_6ia 'DCHVnLLINfWM *punq)oswsqa_saaNYHqo } (fiswn) qoqTMs
} (ureaedl WYHYdT 'UlEKedM WVHYdM 'Bsjqn ^Nin 'PUMq QNMH) □OJd~Sia IdYNIM KJLd-JLNI
//////////////////////////////////////////////////////////////////////////////
? (an&L)gngx
/puMU = 6iaU~5 seSpssaui jojjs joj Mopuiw fiojexp utw jo	de ax //
} (urej^di WVHVdT zsnoojpuMq ONMH 'puMU CINMH) 8。1*(1¥口1口0一如a 1009
ixearq
f Oqoqea^jeqsuO
:HDJAfKuVIS—MLH-DCH sseo
'(PT 'puMH)Bo〔eiapus :aaoNvoai 海己。
：XOai aseo } (PT) qo^TMS
} (AjTqoNspoD XNin FDPuMq ONMH 'PT 1ut 'puMq ONMH)puBUiuioouo~6ia PTOa
/////////////////////////////////////////////////////////////////////////////Z
/ ( („ -paqqTUiqns 由弓 sns” . ) J,X3X) 9bessawppv
i (uiaqi^jOMCl~6) ^JOMIoodpeajqi^yuiqns
i (uieqi^jOM^6) xJOMloodpeaJHJ,q xuiqns i (uia^ixJOMd-fi) JOMTOOdpeajqxqxuiqns
! (uiaqi^aoMcT~5) JtJOMIoodpeajq.iqTuiqns uiaqy xjiom auras aq? fiuxsn Aq	p ^yujqns //
f ( (.--qoqeq wau e qjeqs------..) J.X3J.) afiessawppY
i (HSTVd 4 (Haiva~<LHV>LS-Nia_Dai *Biaq-6)ureqi5-[aqao)9Tqeu3-uoqqng uo-^qnq cuss aiQ^STa //
'** H 2；-'	“ . "	上
} ()qs即MSSUO PTOA
//////////////////////////////////////////////////////////////////////////////
弟曜奔SAAOPUIM直I l第
dows核心编程(第5版)
return(FALSE);
int APIENTRY _tWinMain(HINSTANCE hlnstance, HINSTANCE, LPTSTR pCmdLine, int) (
// Create the work item that will be used by all tasks
pWorkltem = CreateThreadpoo1Work(TaskHandler, NULL, NULL);
if (g_pWorkItem == NULL) (
MessageBox(NULL, TEXT("Impossible to create the work item for tasks.•), TEXT(■■)r MB_ICONSTOP);
return(-1)；
}
DialogBoxParam(hlnstance, MAKEINTRES0URCE(IDD_J4AIN), NULL, Dlg_Proc,
_ttoi(pCmdLine))；
// Don't forget to delete the work item
// Note that it is not mandatory here since the process is exiting CloseThreadpoolWork(g_pWorkItem)；
return (0)；
}
//////////////////////////////// End of File /////////////////////////////////
343-345
在创建主窗口之前，程序会创建一个工作项。如果该操作失败，那么应用程序会弹出一个 消息框来报告错误并结束运行。当用户单击Start batch按钮的时候，程序会调用 SubmitThreadpooIWork函数，分4次将该工作项提交到默认的线程池中。为了避免用户 再次提交另一个批处理，该按钮会同时被禁用。线程池中的线程会调用回调函数，后者会 调用Interlocke(IIncrement(第8章介绍的)来自动递增全局任务计数器，并在它开始运行和 结束运行的时候分别向日志中添加一项。
TaskHandler函数在返回之前，会调用InterlockedDecrement来自动递减全局任务计数器。 如果该任务是最后一项任务，那么函数会向主窗口发一条消息，由主窗口负责在日志中添 加一条结束消息，然后重新启用Start按钮。检测批处理结束的另一种方法是创建一个线程, 并让它调用 WaitForThreadpoolWorkCallbacks(g_pWorkItem, FALSE)o 当该函数调用返 回的时候，我们就可以确信线程池巳经将所有已提交的工作项都处理完了。
11.2情形2：每隔一段时间调用一个函数
有时应用程序需要在某些时间执行某些任务。Windows提供了可等待的计时器内核对象(参 见第9章)，它使我们非常容易的就能够得到一个基于时间的通知。许多开发人员会为应用 程序需要执行的每个基于时间的任务创建一个可等待的计时器对象，但这是不必要的，而 且会浪费系统资源。我们应该只创建一个可等待的计时器，设置它下一次应该触发的时间， 将它重置，并等到下一次触发后，再重复这一过程。但是，编写代码来实现这一过程需要 很多的技巧。幸运的是，我们可以让线程池函数来为我们打理这些事情。
第11章Windows线程池
为了将一个工作项安排在某个时间执行，我们必须定义一个回调函数，它的函数原型如下:
VOID CALLBACK TimeoutCallback（
PTP_CALLBACK_INSTANCE plnstance, //清参阅11.5节“回调函数的终止操作”
PVOID pvContext,
PTP_TIMER pTimer）;
然后调用下面的函数来通知线程池应该在何时调用我们的函数：
PTP_TIMER CreateThreadpoolTimer（
PTP__TIMER_CALLBACK pfnTimerCallback,
PVOID pvContext,
PTP_CALLBACK_ENVIRON pcbe） ; //请参阅11.5.1节“对线程池进行定制”
这个函数的工作方式与我们在前一节介绍的CreateThreadpoolWork函数相似。参数 pfnTimerCallback必须是一个符合TimeoutCallback原型的函数。每当线程池调用 pfnTimerCallback指向的函数时，会将参数pvContext的值传给它，并在它的pTimer参 数中传入一个计时器对象的指针，该计时器对象由CreateThreadpoolTimer函数创建并 返回。
当我们想要向线程池注册计时器的时候，应该调用SetThreadpoolTimer函数：
VOID SetThreadpoolTimer（
PTP_TIMER pTimer,
PFILETIME pftDueTime,
DWORD msPeriod,
DWORD msWindowLength）；

参数 pTimer 用来标识 CreateThreadpoolTimer 返回的 TP__TIMER 对象。参数 pftDueTime 表示第一次调用回调函数应该是什么时候。我们可以传一个负值（以微秒为单位）来指定一 个相对时间，该时间相对于调用SetThreadpoolTimer的时间。但-1是一个特例，用来表 示立即开始。为了指定一个绝对时间，我们应该传一个正值，这个值以100纳秒为单位， 从1600年的1月1日开始计算。
如果只想让计时器触发一次，那么可以给msPeriod参数传0。但是，如果想让线程池定期 地调用我们的函数，那么应该给msPeriod指定一个非零值（表示在再次调用我们的 TimerCallback之前需要等待多少微秒）。参数msWindowLength用来给回调函数的执行时 间增加一些随机性，这使得回调函数会在当前设定的触发时间，到当前设定的触发时间加 ± msWindowLength设定的时间之间触发。如果我们有多个计时器，它们触发的频度几乎 相同，但我们又不希望产生太多的冲突，那么这个参数就非常有用——它可以让我们避免 在回调函数中用一个随机数来调用Sleepo
参数msWindowLength的另一个作用是将多个计时器分成一组。如果我们有大量的计时器 在几乎相同的时间触发，那么为了避免太多的上下文切换，我们可能想把它们分成一组。 举个例子，如果计时器A在5微秒后触发，计时器B在6微秒后触发，那么5微秒后计时 器A的回调函数会被调用，然后该线程会回到线程池并进入睡眠状态。随即它会被再次唤 醒来调用计时器B的回调函数，并重复这一过程。为了避免上下文切换，以及将它们放入 线程池和从线程池中取出，我们可以将计时器A和计时器B的msWindowLength参数设
(indows核心编程(第5版)
为2。现在线程池知道计时器A预计它的回调函数会在5〜7微秒之间被调用，而计时器B 预计它会在6〜8微秒之间触发。在这种情况下，线程池知道在同一时间，也就是6微秒的 时候对这两个计时器进行批处理会更加高效。这样，线程池只会唤醒一个线程，先让它 执行计时器A的回调函数，再让它执行计时器B的回调函数，最后让它回到线程池中进入 睡眠状态。如果计时器的触发频度非常接近，而且唤醒线程和将线程切换回睡眠状态的代 价与计时器的触发频度也具有相当的可比性，那么在这种情况下，这项优化是至关重要的。
必须指出的是，在设管了计时器之后，我们还可以通过调用SetThreadpoolTimer并在 pTimer参数中传入先前设置的计时器指针，以此来对已有的计时器进行修改。我们也可以 给pftDueTime, msPeriod和msWindowLength参数传入新的值。事实上，我们可以传NULL 给pftDueTime,这等于是告诉线程池停止调用我们的TimerCallback函数。这不失为一种 将计时器暂停但又不必销毁计时器对象的好方法，尤其在回调函数内部，更是如此。
同时，我们可以通过调用IsThreadpoolTimerSet来确定某个计时器是否已经被设置(也就是 说，它的pftDueTime值不为NULL)：
BOOL IsThreadpoolTimerSet(PTP_TIMER pti);
最后，我们可以通过调用WaitForThreadpoolTimerCallbacks来让线程等待一个计时器完 成，还口J以通过调用CloseThreadpoolTimer函数来释放计时器的内存。这两个函数的工作 方式与本章前面介绍的 WaitForThreadpoolWork 和 CloseThreadpoolWork 相似。
Timed Message Box 示例程序
下面的Timed Message Box示例程JT(11-TimedMsgBox.exe),展示了如何使用线程池的计时 器函数来实现一个消息框。如果用户在一段时间内没有对消息框做出响应，那么该消息框 会自动关闭。应用程序的源代码和资源文件在本书配套网页的11-TimedMsgBox目录中。
当应用程序启动的时候，会将全局变量g^nSecLeft设为10。这表示用户必须在多少秒内对 消息框做出响应。程序接着调用CreateThreadpoolTimer函数来创建一个线程池计时器， 并将它传给SetThreadpoolTimer ,告诉线程池从第一秒开始，每秒调用一次 MsgBoxTimeout函数。一旦将一切都初始化完毕，程序会调用MessageBox来向用户显示 下图所示的消息框。
You have 10 seconds to respond
当消息框等待用户响应时，线程池中的线程会调用MsgBoxTimeout函数。这个函数会找到 该消息框的窗口句柄，将全局变量g_nSecLeft递减，并更新消息框中的字符串。当
第11章Windows线程池
MsgBoxTimeout被第一次调用之后，消息框如下图所示。
当MsgBoxTimeout被调用了 9次之后，g_nSecLeft变量将到达1,这时MsgBoxTimeout 会调用EndDialog来销毁消息框，主线程的MessageBox调用会返回。为了告诉线程池计 时器己经不需要了，并让它停止调用 MsgBoxTimeout函数，程序调用了 CloseThreadpooiTimero之后程序会显示如下图所示的另一个消息框来告诉用户，他或她 未能在指定的时间内对刚才的消息框做出响应。
如果用户在超时之前做出了响应，那么会显示如下图所示的消息框。
Module: TimedMsgBox.cpp
Notices: Copyright (c) 2008 Jeffrey Richter & Christophe Nasarre
I****************************************************************************
#include *..\CommonFiles\CmnHdr.h" tinclude <tchar.h>
#include <StrSafe.h>
//////////////////////////////////////////////////////////////////////////////
// The caption of our message box TCHAR g_szCaption[100];
// How many seconds we'll display the message box int g_nSecLeft = 0;
Jindows核心编程（第5版）
// This is STATIC window control ID for a message box
#define ID_J4SGBOX_STATIC_TEXT OxOOOOffff
//////////////////////////////////////////////////////////////////////////////
VOID CALLBACK MsgBoxTimeoutCallback(
PTP_CALLBACK__INSTANCE plnstance,
PVOID	pvContext,
PTP_TIMER	pTimer
)(
// NOTE： Due to a thread race condition, it is possible (but very unlikely) // that the message box will not be created when we get here.
HWND hwnd = FindWindow(NULL, g_szCaption);
if (hwnd != NULL)(
if (g_nSecLeft == 1)(
// The time is up； force the message box to exit.
EndDialog(hwnd# IDOK);
return；
}
// The window does exist； update the time remaining.
TCHAR szMsg[100];
StringCchPrintf(szMsg, _countof(szMsg),
TEXT("You have %d seconds to respond*), 一g_nSecLeft)； SetDlgltemText(hwnd, ID_MSGBOX_STATIC_TEXT, szMsg);
} else {
// The window does not exist yet; do nothing this time.
// We'll try again in another second.
}
int WINAPI ^tWinMain(HINSTANCE, HINSTANCE, PTSTR, int) (
_tcscpy_s(g_szCaptionr 100, TEXT("Timed Message Box*));
// How many seconds we'll give the user to respond g_nSecLeft = 10；
// Create the threadpool timer object PTP_TIMER IpTimer =
CreateThreadpoolTimer(MsgBoxTimeoutCallback, NULL, NULL)；
if (IpTimer == NULL) (
TCHAR szMsg[MAX_PATH];
StringCchPrintf(szMsg, _countof(szMsg),
TEXT(■Impossible to create the timer： %u")r GetLastError())； MessageBox(NULLr szMsg, TEXT (• Error") , MB_OK I MB^ICONERROR);)：-
return(-1)；
// Start the timer in one second to trigger every 1 second 混• 鞍; ULARGE_INTEGER ulRelativeStartTime；
ulRelativeStartTime.QuadPart = (LONGLONG) - (10000000);
FILETIME ftRelativeStartTime；
ftRelativeStartTime.dwHighDateTime = ulRelativeStartTime.HighPart;晦
ftRelativestartTime.dwLowDateTime = ulRelativeStartTime. SetThreadpoolTimer(
IpTimer,
aftRelativeStartTime,
1000, // Triggers every 1000 milliseconds
0);
第11章 Windows线程池
// Display the message box
MessageBox(NULL, TEXT("You have 10 seconds to respond"), g_szCaptionr MB_OK)；
// Clean up the timer
CloseThreadpoolTimer(IpTimer);
// Let us know if the user responded or if we timed out MessageBox(
NULL, (g_nSecLeft == 1) ? TEXT("Timeout") : TEXT("User responded")r TEXT("Result"), MB_OK);
return(0);
}
//////////////////////////////// End of File /////////////////////////////////
^349*351
在进入下一个情形的讨论之前，还需要提及其他一些事项。设置一个周期性的计时器可以 保证我们的工作项每隔一段时间都会被添加到队列中。如果我们创建的时期性计时器每隔 10秒钟触发一次，那么回调函数每隔10秒钟会被调用一次。值得注意的是，线程池可能 会用多个线程来调用我们的回调函数，因此我们可能得自己对工作项函数的各部分进行同 步。另外请注意，如果线程池超负荷运行，可能会延误计时器工作项。举个例子，如果我 们将线程池的最大线程数量设为一个很低的值，那么线程池将不得不延迟调用我们的回调 函数。
如果工作项耗时较长，我们又不喜欢上述行为，而希望能够在每个工作项开始运行之后的 10秒钟后将新的工作项添加到队列中，那么我们必须通过另一种途径来构造一种智能的一 次性计时器。
(1)	我们仍然通过CreateThreadpoolTimer来创建计时器，这一点没有任何变化。
(2)	在调用SetThreadpoolTimer的时候给msPeriod参数传0,表示这个计时器是一次 性的。
(3)	当待处理的工作完成后，重置计时器，仍然将msPeriod设为0。
⑷最后，当最终需要停止计时器的时候，必须在CloseThreadpoolTimer执行之前调用 WaitForThreadpoolTimerCallbacks,并传TRUE给最后一个参数,其目的是为了告 诉线程池不应该再为该计时器处理任何的工作项。如果不这样做，那么线程池仍然会 调用我们的回调函数，从而导致在SetThreadpoolTimer执行的时候引发异常。
注意，如果真的需要一次性计时器，则应该在回调函数中调用SetThreadpoolTimer并传0 给msPeriod参数，同时为了确保对线程池的资源进行清理，我们还应该在回调函数返回之 前调用 CloseThreadpoolTimer0
11-3情形3：在内核对象触发时调用一个函数
Microsoft发现许多应用程序创建线程的目的仅仅是为了等待一个内核对象被触发。一旦对
A^dows核心编程（第5版）	.
象被触发，等待的线程会向另一个线程发出某种形式的通知并进入下一轮循环，等待该对 象再次被触发。这恰恰是此前我们在Batch示例程序中见到的情形，其中用了一个专门的 工作项来监视进行实际操作的回调函数何时完成。一些开发人员甚至还会让多个线程来等 待一个对象。这是对系统资源的极端浪费。当然，与创建进程相比，创建线程所涉及的开 销要小得多，但线程也并非免费的午餐。每个线程都有一个线程栈，并需要大量的CPU指 令来创建和销毁线程。我们应该尽量避免此类开销。
351-352 够
如果想要注册一个工作项，让它在一个内核对象被触发的时候执行，那么我们需要遵循的 流程与本章前面已经介绍过的流程非常相似。首先，编写一个符合下面的原型的函数： VOID CALLBACK WaitCallback（
PTP_CALLBACK_INSTANCE plnstance, //请参阅11.5节“回调函数的终止操作”
PVOID Context,
PTP_WAIT Wait, TP_WAIT_RESULT WaiCResult）;
然后通过调用CreateThreadpoolWait来创建一个线程池等待对象：
PTP_WAIT CreateThreadpoolWait（
PT P_WAIT_CALLBACK	pfnWaitCalIback,
PVOID	pvContext,
PTP_CALLBACK_ENVIRON pcbe） ; //清参阅 11.5.1 “对线程池进行定制”
当创建完成后，我们调用下面的函数来将一个内核对象绑定到这个线程池：
VOID SetThreadpoolWait（
PTP_WAIT pWaitltem,
HANDLE hObject, PFILETIME pftTimeout）;
显然，参数pWaitltem用来标识CreateThreadpoolWait返回的对象。参数hObject用来标 识某个内核对象。当该对象被触发的时候，会导致线程池调用我们的WaitCallback函数。
另外，参数pftTimeout用来表示线程池最长应该花多少时间来等待该内核对象被触发。传 0表示根本不用等待，传负值表示相对时间，传正值表示绝对时间，传NULL表示无限长 的时间。
线程池在内部会让一个线程调用（第9章已介绍）WaitForMultipleObjects函数，传入通过 SetThreadpoolWait函数注册的一组句柄，并传FALSE给bWaitAll参数。这样当任何一 个句柄被触发的时候，线程池就会被唤醒。由于WaitForMultipleObjects有一个限制（第9 章中提到过），一次最多只能等待64（MAXIMUM_WAIT_OBJECTS）个句柄，因此线程池事 实上正是为每64个内核对象分配一个线程来进行等待，其效率还是相当高的。
另外，由于WaitForMultipleObjects不允许我们将同一个句柄传入多次，因此我们必须确 保不会用SetThreadpoolWait来多次注册同一个句柄。但是，我们可以调用 DuplicateHandle,这样就可以分别注册原始句柄和复制的句柄。
当内核对象被触发或超出等待时间的时候，线程池中的某个线程会调用我们的 WaitCallback函数（在前面显示）。大多数参数都不言自明，只有最后一个参数WaitResuIt 例外。参数WaitResuIt的类型为TP_WAIT_RESULT（它本身是一个DWORD）,用来表示
第11章Windows线程池
WaitCaUback被调用的原因。表11・1列出了参数WaitResult可能的值。
@352~353
表11・1 WaitResult可能的值
WaitResult 的值	解释
WAIT_OBJECT_0	如果传给SetThreadpoolWait的内核对象在超时之前被触发，那么我们的 回调函数会接收到这个值
WAIT_TIMEOUT	如果传给SetThreadpoolWait的内核对象在超时之前没有被触发，那么我 们的回调函数会接收到这个值
WAIT_ABANDONED_0	如果传给SetThreadpoolWait的内核对象是一个互斥量并旦该互斥量被 遗弃，如9.6.1节“遗弃问题”中所述，那么我们的回调函数会接收到这 个值
一旦线程池的一个线程调用了我们的回调函数，对应的等待项(wait item)将进入不活跃 (inactive)状态。“不活跃”意味着如果想让回调函数在同一个内核对象被触发的时候再次 被调用，那么我们需要调用SetThreadpoolWait来再次注册。
假设我们注册了一个等待项来等待一个进程内核对象。一旦该进程对象被触发，它将保持 在触发状态。在这种情况下，我们可能并不想用同一个进程句柄来再次注册该等待项。但 是，我们可以通过SetThreadpoolWait来重用该等待项，我们既可以传入一个不同的内核 对象句柄，也可以传入NULL来将该等待项从线程池中移除。
最后，我们可以通过调用WaitForThreadpoolWaitCallbacks函数来等待一个等待项完成， 我们还可以通过调用CloseThreadpoolWait函数来释放一个等待项的内存。这两个函数的 工作方式与本章前面介绍的WaitForThreadpoolWork和CloseThreadpoolWork函数相似。
说明 绝对不要让回调函数调用 WaitForThreadpoolWork并将自己的工作项作为参数传 入，因为那样会导致死锁。之所以会发生这样的情况，是因为线程会一直被阻塞， 只有当线程本身退出后才能得以继续运行，但线程此时又无法退出，因为线程本身 已经被阻塞。另外，当线程池在等待传给SetThreadpoolWait的句柄时，我们应该 确保该句柄不会被关闭。最后，我们可能并不想通过PulseEvent来触发一个已注册 的事件，因为当PulseEvent被调用的时候，我们无法保证线程池正好在等待该事件。
11.4情形4：在异步I/O请求完成时调用一个函数
在第10章，我们讨论了如何使用Windows I/O完成端口来高效地执行异步I/O操作，我们 还解释了如何创建一个线程池并让其中的线程等待I/O完成端口。幸运的是，本章通篇介 绍的线程池函数可以替我们管理线程的创建和销毁，而这些线程会在内部等待I/O完成端 口。但是，在打开一个文件或设备的时候，我们必须先将该文件/设备与线程池的I/O完成 端口关联起来。然后我们必须告诉线程池，当发往文件/设备的异步I/O请求完成时，应该
Windows核心编程（第5版）
调用哪个函数。
首先，我们必须编写一个符合以下原型的函数:
VOID CALLBACK OverlappedCompletionRoutine(
PTP_CALLBACK_INSTANCE plnstance, // See "Callback Termination Actions" section PVOID	pvContext,
PVOID	pOverlapped,
□LONG	loResult,
ULONG_PTR	NumberOfBytesTransferred,
PTP_IO	pio)；
当一个I/O操作完成的时候，这个函数会被调用并得到一个指向OVERLAPPED结构的指 针，这个指针是我们在调用ReadFile或WriteFile来发出I/O请求的时候（通过pOverlapped 参数）传入的。操作的结果通过loResult参数传入，如果I/O成功，那么该参数为 NO_ERRORo已传输的字节数通过NumberOfBytesTransferred参数传入，而通过pio参 数传入的，则是一个指向线程池中的I/O项的指针。参数plnstance会在11.5节"回调函 数的终止操作”中介绍。
然后我们通过调用CreateThreadpoolIo来创建一个线程池I/O对象，并将我们想要与线程 池内部的1/0完成端口相关联的文件/设备句柄（通过用FILE_FLAG_OVERLAPPED标志 调用CreateFile函数所打开的），在第一个参数中传入：
PTP_IO CreateThreadpoolIo(
HANDLE	hDevice,
PTP_WIN32_IO_CALLBACK pfnloCallback,
•PVOID	pvContext,
PTP_CALLBACK_ENVIRON pcbe) ; //清参阅11.5.1节“对线程池进行定制”
当线程池I/O对象创建完毕后，我们通过调用下面的函数来将嵌入在I/O项中的文件/设备 与线程池内部的I/O完成端口关联起来：
VOID StartThreadpoolIo(PTP_IO pio);
注意，在每次调用ReadFile和WriteFile之前，我们必须调用StartThreadpoollOo如果每 次在发出I/O 请求之前没有调用StartThreadpoolIo，那么我们的 OverlappedCompletionRoutine回调函数将不会被调用。
如果想在发出I/O请求之后让线程池停止调用我们的回调函数，那么可以调用下面的函数:
VOID CancelThreadpoolIo(PTP_IO pio)；
如果在发出请求的时候，ReadFile或 WriteFHe调用失败了，那么我们仍然必须调用 CancelThreadpoollOo例如，如果这两个函数的返回值为FALSE并且GetLastError的返 回值为ERROR_IO_PENDING以外的值。当对文件/设备的使用完成后，我们应该调用 CloseHandle来将其关闭，并调用下面的函数来解除它与线程池的关联：
VOID CloseThreadpoolIo(PTP_IO pio)；
我们还可以调用下面的函数来让另一个线程等待一•个待处理的I/O请求完成:
第11章Windows线程池
VOID WaitForThreadpoolloCa1Ibacks(
PTP_IO pi。，
BOOL bCancelPendingCallbacks)；
如果传给bCancelPendingCallbacks参数的值为TRUE,那么当请求完成的时候，我们的 回调函数不会被调用(如果它尚未被调用)。这和调用CancelThreadpoolIo函数的时候相似。
11.5回调函数的终止操作
线程池提供了一种便利的方法，用来描述在我们的回调函数返回之后，应该执行的一些操 作。回调函数用传给它的不透明的plnstance参数(其类型为PTP_CALLBACK_INSTANCE) 来调用以下这些函数：
VOID LeaveCriticalSectionWhenCallbackReturns(
PTP_CALLBACK_INSTANCE pci, PCRITICAL_SECTION pcs);
VOID ReleaseMutexWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE mut);
VOID Re1easeSemaphoreWhenCa1IbackReturns(PTP_CALLBACK_INSTANCE pci,
HANDLE sem, DWORD crel);
VOID SetEventWhenCalIbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE evt);
VOID FreeLibraryWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HMODULE mod);
正如plnstance参数的名字所暗示的那样，它表示线程池当前正在处理的一个工作项、计 时器项、等待项或I/O项。对刚才列出的每个函数，表11・2列出了线程池所执行的与它们 相对应的终止操作。
表11・2回调函数的终止函数以及它们对应的操作
函数	终止操作
LeaveCriticalSectionWhenCallbackReturns	当回调函数返回的时候，线程池会自动调用 LeaveCriticalSection ,并在参数中传入指定的 CRITICAL SECT【ON 结构
ReleaseMutexWhenCallbackReturns	当回调函数返回的时候，线程池会自动调用 ReleaseMutex,并在参数中传入指定的HANDLE
ReleaseSemaphore WhenCallbackReturns	当回调函数返回的时候，线程池会自动调用 ReleaseSemaphore.并在参数中传入指定的HANDLE
SetEventWhenCallbackReturns	当回调函数返I可的时候，线程池会自动调用SetEvent, 并在参数中传入指定的HANDLE
FreeLibraryWhenCallbackReturns	当回调函数返回的时候，线程池会自动调用FreeLibrary, 并在参数中传入指定的HMODULE
前4个函数为我们提供了一种方式来通知另一个线程，线程池中的线程的工作项已经完成 了某项任务。最后一个函数(FreeLibraryWhenCallbackReturns)为我们提供了一种方式， 让我们可以在回调函数返回的时候将动态链接库(DLL)从内存中卸载。如果回调函数是在一 个DLL中实现的，而我们又希望在回调函数完成它的工作之后将DLL从内存中卸载，那 么这种方式尤其有用。当然，我们不能让回调函数自己调用FreeLibrary,这是因为那会将


Vindows核心编蛰秘版2
回调函数的代码从进程中清除，这样当FreeLibrary调用试图返回到回调函数的时候，将 会引发访问违规。
重要提示 对任何一个回调函数的实例，线程池中的线程只会执行一种终止操作。因此我 们无法要求线程池在处理完我们的工作项后同时触发一个事件和互斥量。最后 调用的终止函数会覆盖之前调用的那个终止函数。
除了这些终止函数之外，还有两个函数可用于回调函数的实例：
BOOL CallbackMayRunLong(PTP_CALLBACK_INSTANCE pci);
VOID DisassociateCurrentThreadFromCallback(PTP_CALLBACK_INSTANCE pci)；
CallbackMayRunLong函数实际上与终止操作并没有什么关系，它更多地是用来通知线程 池回调函数的运行时间会比较长。如果一个回调函数认为自己需要较长的时间来处理当前 的项，那么它应该调用CallbackMayRunLongo由于线程池会坚持不创建新线程，因此长 时间运行的项可能会使线程池队列中的其他项挨饿。如果CallbackMayRunLong返回 TRUE,那么说明线程池中还有其他线程可•供使用，来对队列中的项进行处理。但是，如 果CallbackMayRunLong返回FALSE,那么说明线程池中没有其他线程可以用来处理队 列中的项。为了维持线程池的运行效率，最好是让该项将它的任务划分成更小的部分来处 理(将每一部分单独地添加到线程池的队列中)。任务的第一部分可以在当前线程中执行。
DisassociateCurrentThreadFromCallback函数相对来说比较高级，回调函数调用它来告诉线 程池，逻辑上自己已经完成了工作。这使得任何由于调用WaitForThreadpoolWorkCallbacks, WaitForThreadpoolTimerCallbacks , WaitForThreadpoolWaitCallbacks 或 WaitForThreadpoolIoCallbacks而被阻塞的线程能够早一些返回，而不必等到线程池 的线程从回调函数中返回。
11.5.1对线程池进行定制
在 调用 CreateTh readpool Work, CreateThreadpoolTimer, CreateThreadpoolWait 或 CreateThreadpoolIo 的时候，我们有机会传入一个 PTP_CALLBACK_ENVIRON 参数。
如果传给这个参数的值为NULL,那么我们会将工作项添加到进程默认的线程池中，默认 的线程池的配置能够很好地满足大多数应用程序的要求。
但是，有时我们可能想根据自己应用程序的需要来对线程池进行特殊的配置。举个例子， 也许我们想修改线程池中可运行线程的最小数量和最大数量，也许有多个可以单独地创建 和销毁的线程池会对应用程序有所帮助。
我们可以在自己的应用程序中调用下面的函数来创建一个新的线程池：
PTP_POOL CreateThreadpool(PVOID reserved)；
目前，参数reserved是保留的，因此我们应该传NULL。在将来的Windows版本中这个参
第11章Windows线程池
数可能会有意义。该函数返回一个PTP_POOL值，表示新创建的线程池。现在我们就可 以调用下面的函数来设置线程池中线程的最大数量和最小数量了：
BOOL SeCThreadpoolThreadMinimum(PTP_POOL pThreadPool, DWORD cthrdMin)；
BOOL SetThreadpoolThreadMaximum(PTP_POOL pThreadPool, DWORD cthrdMost);
线程池始终保持池中的线程数量至少是指定的最小数量，并允许线程数量增长到指定的最 大数量。顺便提一下，默认线程池的最小数量为1,最大数量为500。
在一些少见的情形下，如果要索取信息的线程终止了，那么Windows会取消相关的请求。 以RegNotifyChangeKeyValue函数为例，当线程调用这个函数的时候，会传入一个事件句 柄，当某些注册表的值被修改时，Windows会触发该事件。但是，如果调用 RegNotifyChangeKeyValue的线程终止了，那么Windows将不会再触发该事件。
只要线程池认为创建或销毁线程有助于提高性能，它们就会这样做。因此，如果线程池中 的一个线程调用了 RegNotifyChangeKeyValue函数，线程池有可能(甚至是很可能)会在某 一时刻终止这个线程，在这种情况下，Windows就不会再通知应用程序注册表已经被修改 了。也许解决这个问题的最好的方法就是用CreateThread来创建一个专门的线程，这个线 程不会终止，它的唯一目的就是调用RegNotifyChangeKeyValue函数。但还有另一种解决 方案，那就是创建一个线程池，并将线程的最小数量和最大数量设为相同的值。这样，线 程池会创建一组线程，这些线程永远都不会被销毁。现在，我们不但可以让线程池的线程 调用RegNotifyChangeKeyValue之类的函数，而且可以确信当注册表被修改的时候， Windows始终都会通知我们的应用程序。
当应用程序不再需要它为自己定制的线程池时，应该调用CloseThreadpool将其销毁:
VOID CloseThreadpool(PTP_POOL pThreadPool);
在调用这个函数之后，我们将无法再将任何新的项添加到线程池的队列中。线程池中当前 正在处理队列中的项的线程会完成它们的处理并终止。此外，线程池的队列中所有尚未开 始处理的项将被取消。
一旦我们创建了自己的线程池，并指定了线程的最小数量和最大数量，我们就可以初始化 一个回调环t»(callbackenvironment),它包含了一些可应用于工作项的额外的设置或配置。
线程池回调环境的数据结构在WinNT.h中定义如下:
typedef struct _TP_CALLBACK_ENVIRON (
TP_VERS：CON	Version;
PTP_POOL	Pool;
PTP_CLEANUP_GROUP	CleanupGroup;
PTP_CLEANUP_GROUP_CANCEL_CALLBACK C1eanupGroupCancelCallback； PVOID struct _ACTIVATION_CONTEXT PTP_SIMPLE_CALLBACK
RaceDll；
*ActivationContext;
FinalizationCallback；
union (
DWORD struct ( DWORD DWORD
Flags；
LongFunction : 1;
Private : 31；
indows核心编程(第5版)
} S；
} U；
} TP_CALLBACK_ENVIRON, * PTP_CALLBACK_ENVIRON;
357-358 渺
虽然我们可以手工检查这个数据结构并对其中的字段进行操作，但我们不应该这样做。我 们应该认为这个数据结构是不透明的，应该通过调用在WinBase.h头文件中定义的各个函 数来对其中的字段进行操作。为了对这个结构进行初始化，我们应该首先调用下面的函数: VOID InitializeThreadpoolEnvironment(PTP_CALLBACK_ENVIRON pcbe);
这个内联函数会将Version设为1,并将其余字段都设为0。同往常一样，当我们不再需要 使用线程池回调环境的时候，应该调用DestroyThreadpoolEnvironment来对它进行清理： VOID DestroyThreadpoolEnvironment(PTP_CALLBACK_ENVIRON pcbe);
为了将一个工作项添加到线程池的队列中，回调环境必须标明该工作项应该由哪个线程池 来处理。我们可以调用SetThreadpoolCallbackPooL并传给它一个(由CreateThreadpool 所返回的)PTP_POOL值，来指定一个特定的线程池：
VOID SetThreadpoolCallbackPool(PTP_CALLBACK_ENVIRON pcbe, PTP_POOL pThreadPool);
如果我们不调用 SetThreadpoolCallbackPool,那么 TP_CALLBACK_ENVIRON 的 Pool 字段会一直为NULL,当用这个回调环境来添加工作项的时候，工作项会被添加到进程默 认的线程池。
我们可以调用SetThreadpoolCallbackRunsLong函数来告诉回调环境，工作项通常需要较 长的时间来处理。这使得线程池会更快地创建线程，其目的是为了尝试在对工作项进行处 理的时候，以一种更公平的方式来替代最有效的方式。
VOID SetThreadpoolCallbackRunsLong(PTP_CALLBACK_ENVIRON pcbe)；
我们可以调用SetThreadpooICaUbackLibrary来确保只要线程池中还有待处理的工作项， 就将一个特定的DLL 一直保持在进程的地址空间中。
VOID SetThreadpooICaUbackLibrary(PTP_CALLBACK_ENVIRON pcbe, PVOID mod);
基本上，SetThreadpooICaUbackLibrary函数的存在目的是为了消除潜在的竞态条件(race condition),从而避免町能导致的死锁。这是个相当高级的特性，更详细的信息请参阅 Platform SDK 文档。
11.5.2得体地销毁线程池：清理组
线程池可以处理大量的队列项，这些项的来源各不相同。这使得我们很难知道线程池结束 处理队列项的确切时间，但只有这样才能得体地将它销毁。为了帮助我们对线程池进行得 体的清理，线程池提供了清理组(cleanupgroup)。注意，本节讨论的内容不适用于默认的线 程池，这是因为它不会被销毁。默认的线程池的生命期与进程相同，在进程终止的时候， Windows会将其销毁并负责所有的清理工作。
358
第11章 Windows线程池
本节我们己经讨论了如何初始化一个TP_CALLBACK_ENVIRON结构，该结构可以用来 将队列项添加到我们的私有线程池。为了得体地销毁私有线程池，我们首先需要通过调用 CreateThreadpoolCleanupGroup 来创建一个清理组：
PTP_CLEANUP_GROUP CreateThreadpoolCleanupGroup();
我们然后需要调用下面的函数，将这个清理组与一个已经绑定到线程池的
TP_CALLBACK_ENVIRON 结构关联起来：
VOID SetThreadpoalCallbackCleanupGroup(
PTP_CALLBACK_ENVIRON pcbe, PTP_CLEANUP_GROUP ptpcg, PTP_CLEANUP_GROUP_CANCEL_CALLBACK pfng);
这个函数在内部会设置PTP_CALLBACK_ENVIRON的CleanupGroup字段和 CleanupGroupCancelCallback字段。在调用这个函数的时候，参数pfng可以标识一个回 调函数的地址，如果清理组被取消，那么这个回调函数会被调用。如果传给pfng参数的值 不为NULL,那么回调函数必须符合下面的原型：
VOID CALLBACK CleanupGroupCancelCallback(
PVOID pvObjectContext,
PVOID pvCleanupContext);
每当我们调用 CreateThreadpoolWork, CreateThreadpoolTimer, CreateThreadpoolWait 或CreateThreadpoolIo的时候，如果最后那个参数，即指向PTP_CALLBACK_ENVIRON 结构的指针，不等于NULL,那么所创建的项会被添加到对应的回调环境的清理组中，其 目的是为了表示有线程池中又添加了一项，需要潜在的清理。在这些队列项完成后，如果 我们调用 CloseThreadpoolWork , CloseThreadpoolTimer , CloseThreadpoolWait 和 CloseThreadpoolIo,那等于是隐式地将对应的项从清理组中移除。
现在，当我们的应用程序想要销毁线程池的时候，可以调用下面这个函数：
VOID CloseThreadpoolCleanupGroupMembers(
PTP_CLEANUP_GROUP ptpcg,
BOOL bCancelPendingCallbacks,
PVOID pvCleanupContext)；
这个函数与本章已经介绍过的各个 WaitForThreadpooI*(比如WaitForThreadpoolWork) 函数相似。当线程调用CloseThreadpoolCleanupGroupMembers的时候，函数会 一直等待，直到线程池的工作组中所有剩余的项(即已经创建但尚未关闭的项)都已 经处理完毕为止。调用者还可以传TRUE给bCancelPendingCallbacks参数，这 样会将所有己提交但尚未处理的工作项直接取消，函数会在所有当前正在运行的 工作项完成之后返回。如果传给bCancelPendingCallbacks参数的值为TRUE,而 且传给 SetThreadpoolCallbackCleanupGroup 的 pfng 参数的值是一个 CleanupGroupCancelCallback函数的地址，那么对每一个被取消的工作项，我们的回调函 数会被调用。在CleanupGroupCancelCallback函数中，参数pvObjectContext会包含每个 被取消的项的上下文。(该上下文信息是通过CreateThreadpool*函数的pvContext参数设 置的。)在 CleanupGroupCancelCallback 函数中，参数 pvCleanupContext 包含的上下文 是通过 CloseThreadpoolCleanupGroupMembers 函数的 pvCleanupContext 参数传入的。
lows核心编程(第5版)
如果在调用 CloseThreadpoolCleanupGroupMembers 的时候传 FALSE 给 bCancelPendingCallbacks参数，那么在返回之前，线程池会花时间来处理队列中所有剩余 的项。注意，这种情况下由于我们的CleanupGroupCancelCallback函数绝对不会被调用， 因此可以传NULL给pvCleanupContext参数。
当所有的工作项被取消或被处理之后，我们然后调用CloseThreadpoolCleanupGroup来释 放清理组所占用的资源：
VOID WINAPI CloseThreadpoolCleanupGroup(PTP_CLEANUP_GROUP ptpcg)；
最后，我们可以调用DestroyThreadpoolEnvironment和CloseThreadpooL这样就得体地 关闭了线程池。
使用纤程
为了更容易地将已有的UNIX服务器应用程序移植到Windows,Microsoft在Windows中增 加了纤程(fiber)。虽然(根据Wind赢的定义)UNIX服务器应用程序是单线程的，但却能够 为多个客户提供服务。换句话说，UNIX应用程序的开发人员已经创建了自己的线程架构 函数库(threading architecture library),可以用来模拟纯粹的线程。这个线程包(threading package)能够创建多个栈，保存某些CPU寄存器，并能够在它们之间进行切换来对客户请 求进行服务。
显然，为了得到最佳的性能，这些UNIX应用程序必须重新设计：必须用Windows提供的 纯线程来替换模拟的线程函数库。但是，这样的重新设计可能要花费数个月甚至更长的时 间才能完成，因此各公司一开始只是将它们现有的UNIX代码移植到Windows,这样它们 就能够很快地向Windows市场发布一些产品。
在将UNIX代码移植到Windows的过程中，会出现一些问题。具体说来，Windows对线程 栈的管理不仅仅是分配内存，而要复杂得多。Windows的线程栈一开始只占用相对较小的 物理存储器，然后会根据需要增长。第16章描述了这个过程。第23〜25章介绍的结构化 异常处理也使得移植的过程变得更加复杂。
为了帮助各公司更快地、正确地将它们的代码移植到Windows, Microsoft在操作系统中增 加了纤程。本章我们将介绍纤程的概念，用来操作纤程的函数，以及如何发挥纤程的优势。 记住，我们当然应该尽量避免使用纤程，尽量对应用程序进行合理的设计，使之能够使用 Windows提供的线程。
使用纤程
首先需要注意的一点是，线程是在Windows内核中实现的。操作系统对线程了如指掌，并 会根据Microsoft定义的算法来对线程进行调度。纤程是在用户模式下实现的，内核对纤程 一无所知，内核会根据我们定义的算法来对纤程进行调度。由于纤程调用算法是我们定义 的，因此就内核而言，它对纤程的调度不是抢占式的。
需要注意的另一点是，一个线程可以包含一个或多个纤程。就内核而言，它会对线程进行
I
四dows核心编程（第5版）
抢占式调度来让线程执行代码。但是，线程一次只能执行一个纤程的代码——哪个纤程由 我们决定。（这些概念会随着我们下面的讨论而变得更加清晰。）
使用纤程的第一个步骤是将一个已有的线程转换为一个纤程。我们通过调用 ConvertThreadToFiber 来达到这一目的：
PVOID ConvertThreadToFiber（PVOID pvParam）;
这个函数会为纤程的执行上下文（execution context）分配（大约200个字节的）内存。这个执行 上下文由下列元素构成：
•	一个用户自定义的值，它被初始化为传给ConvertThreadToFiber的pvParam参数 '的值
•	结构化异常处理链的头
•	纤程栈的顶部和底部的内存地址（当我们将一个线程转换为一个纤程的时候，这同 时也是线程栈）
•	某些CPU寄存器，其中包括栈指针、指令指针以及其他寄存器
在默认的情况下，在x86系统中，CPU的浮点状态信息不属于CPU寄存器的一部分，不会 每个纤程都维护一份，因此如果纤程需要执行浮点操作，那将会导致数据被破坏。为了覆 盖系统默认的行为，我们应该调用新的ConvertThreadToFiberEx函数，它允许我们在 dwFlags 参数中传入 FIBER_FLAG_FLOAT_SWITCH 标志：
PVOID ConvertThreadToFiberEx（
PVOID pvParam,
DWORD dwFlags）；
当我们分配了纤程执行上下文并对其进行初始化之后，还必须将执行上下文的地址与线程 关联起来。这样我们就将线程转换成了一个纤程，该纤程在这个线程中运行。 ConvertThreadToFiber返回的实际上是纤程的执行上下文的内存地址。我们以后会用到这 个地址，但我们绝对不应该自己读写执行上下文数据——纤程函数会在需要的时候替我们 对该结构的内容进行操作。现在，如果我们的纤程（线程）返回，或调用ExitThread,那么 纤程和线程都将结束。
除非我们打算创建更多的纤程，并让它们在同一个线程中运行，否则没有理由将一个线程 转换为纤程。为了创建另一个纤程，线程（即当前正在运行的那个纤程）应该调用 CreateFiber：
PVOID CreateFiber(
DWORD dwStackSize,
PFIBER_START_ROUTINE pfnStartAddress,
PVOID pvParam)；
CreateFiber首先会试图创建一个新的栈，栈的大小由dwStackSize参数决定。通常我们会 传0,在默认情况下，函数会创建一个一开始只调拨了两个物理存储页的栈，但栈的大小 最大可以增长到1 MB0如果指定的是非零值，那么函数会用这个指定的大小来预订栈区域 并为之调拨物理存储器。如果要使用大量的纤程，那么我们可能希望纤程栈消耗更少的内 存。在这种情况下，我们可以使用下面的函数来代替CreateFiber：
第12章纤程
PVOID CreateFiberEx(
SIZE_T dwSt ackCommit Size,
SIZE_T dwStackReserveSize,
DWORD dwFlags,
PFIBER_START_ROUTINE pSCartAddress,
PVOID pvParam);	____
362-363 参数dwStackCommitSize用来设置一开始要调拨的物理存储页。参数dwStackReserveSize 允许我们预订指定数量的虚拟内存。为了将浮点状态包括到纤程上下文中，参数dwFlags 可以接受 FIBER_FLAG_FLOAT_SWITCH 标志，这一点与 ConvertThreadToFiberEx 相 同。其余的参数与CreateFiber相同。
接着，CreateFiber(Ex)会分配一个新的纤程执行上下文结构并对其进行初始化。函数会将 那个用户自定义的值设为在pvParam参数中传入的值，将新栈的顶部和底部的内存地址保 存起来，并将纤程函数的内存地址(在pfnStartAddress参数中传入)保存起来。
参数pfnStartAddress用来指定纤程函数的地址,我们必须根据下面的函数原型来实现纤程 函数：
VOID WINAPI FiberFunc(PVOID pvParam)；
当系统第一次调度一个纤程的时候，会执行纤程函数并传入pvParam参数，该参数就是原 来传给CreateFiber的pvParam值。我们可以在这个纤程函数中做任何事情。但是，纤程 函数的返回类型为VOID——这并不是因为返回值没有意义，而是因为这个函数根本不应 该返回！如果纤程函数返回，那么该线程以及为它创建的所有纤程都将立即被销毁。
与ConvertThreadToFiber(Ex)相似，CreateFiber(Ex)返回的是纤程执行上下文的内存地 址。但是，与ConvertThreadToFiber(Ex)^同的是，这个新的纤程并不会执行，这是因为 当前正在运行的纤程还在执行。在一个线程中，同一时刻只能执行一个纤程。为了让新的 纤程执行，我们应该调用SwitchToFiber：
VOID SwitchToFiber(PVOID pvFiberExecutionContext);
SwitchToFiber只有一个参数pvFiberExecutionContext,它是纤程的执行上下文的内存地 址，由先前的ConvertThreadToFiber(Ex)或CreateFiber(Ex)调用所返回。这个内存地址告 诉函数应该调度哪个纤程。在内部，SwitchToFiber会执行以下步骤。
(1)	将一些CPU寄存器目前的值，其中包括指令指针寄存器和栈指针寄存器，保存到当前 正在运行的纤程的执行上下文中。
(2)	从即将运行的纤程的执行上下文中，将先前保存的寄存器的值载入到CPU寄存器中。 这些寄存器中包括栈指针寄存器，这样当线程继续执行的时候，会使用新纤程的栈。
(3)	将新纤程的执行上下文与线程关联起来，让线程运行指定的纤程。
(4)	将线程的指令指针设为先前保存的指令指针。这样线程(纤程)就会从上次执行的地方 开始继续往下执行。
SwitchToFiber是让纤程得到CPU时间的唯一方法。由于我们的代码必须在合适的时间显
lows核心编程(第5版)
式地调用SwitchToFiber,因此对纤程的调度完全在我们的掌控之下。记住，纤程调度与线 程调度没有任何关系。操作系统随时可能会夺取纤程所在线程的运行权。当该线程被调度 的时候，当前被选择的纤程得以运行，除非正在运行的纤程显式地调用SwitchToFiber,否 则其他纤程将无法运行。
我们调用DeleteFiber来销毁纤程：
VOID DeleteFiber(PVOID pvFiberExecutionContext);
参数pvFiberExecutionContext是纤程的执行上下文的地址，这个函数会删除该参数所标识 的纤程。这个函数会释放纤程的栈并销毁纤程的执行上下文。但是，如果传入的纤程地址 当前正与线程相关联，那么该函数会在内部调用ExitThread,从而使线程以及为它创建的 纤程都结束。
DeleteFiber通常为一个纤程调用，以删除另一个纤程。被删除的纤程的栈将被销毁，纤程 的执行上下文会被释放。这里请注意纤程和线程的区别：线程通常通过调用ExitThread来 结束自己。实际上，在一个线程中使用TerminateThread来终止另一个线程是一种不好的 做法。如果我们真的调用TerminateThread,那么系统将不会销毁被终止线程的栈。我们 可以利用纤程的这项能力来干净地删除另一个纤程——具体的用法会在本章后面介绍示例 程序的时候解释。当所有纤程都被删除的时候，我们可以通过调用ConvertFiberToThread, 来解除线程的纤程状态(该线程原来是因为调用了 ConvertThreadToFiber(Ex)itu变成纤程 的)，同时释放将线程转换为纤程所占用的最后一块内存。
如果需要为每个纤程保存一些信息，那么我们可以使用纤程局部存储区(Fiber Local Storage, FLS)函数。这些函数对纤程所做的操作与(第6章介绍的)TLS函数对线程所做的 操作相同。我们首先调用FlsAlloc来分配一个FLS槽，使得当前进程中正在运行的所有纤 程都可以使用该FLS槽。这个函数只有一个参数：一个回调函数。当纤程被销毁，或当FLS 槽由于FIsFree调用而被删除的时候，该回调函数会被调用。我们通过调用FlsSetValue来 在FLS槽中保存与每个纤程相关的数据，我们通过调用FlsGetValue来得到这些数据。如 果需要知道我们是否正在一个纤程执行上下文中运行，那么我们只需调用IsThreadAFiber 并检查它返回的布尔值。
系统还为我们提供了其他一些便利的纤程函数。线程在同一时刻只能运行一个纤程，操作 系统始终都知道当前与线程相关联的是哪个纤程。如果想要得到当前正在运行的纤程的执 行上下文的地址，那么我们可以调用GetCurrentFiber：
PVOID GetCurrentFiber();
另一个便利的函数是GetFiberData：
PVOID GetFiberData();
正如我们己经提到过，每个纤程的执行上下文中包括一个用户自定义的值。这个值被初始 化为传给 ConvertThreadToFiber(Ex)或 CreateFiber(Ex)的 pvParam 参数的值，它同样会 作为参数传给纤程回调函数。GetFiberData只不过是查看一下当前正在运行的纤程的执行
第12章纤程
上下文，并返回保存在其中的值。
364
GetCurrentFiber和GetFiberData都非常快，而且通常作为内在函数（intrinsic function）来实 现，这意味着编译器在生成代码时会内联这些函数的代码。
Counter示例程序
Counter示例程序（12.Counter.exe）使用了纤程来实现后台处理。当应用程序启动的时候，会 弹出图12-1所示的对话框。（为了真正理解到底发生了什么，并观察程序的行为，我建议 读者在继续阅读的过程中运行该应用程序。）
Count to: S	Answer:	0
Currently running fiber: User interface
图12-1 Counter应用程序的对话框
我们可以认为这个应用程序是一个由两个单元格组成的超小型电子表格。第一个单元格是 可写的，它被实现为一个编辑框控件（它的标签为Count To）,第二个单元格是只读的，它 被实现为一个静态控件（它的标签为Answer）o当我们修改编辑框中的数值时，Answer单元 格会自动重算（recalculation）o对这个简单的应用程序来说，重算只是让一个计数器从。开 始计数，然后缓慢地递增，直到Answer单元格中的值与输入的值相同为止。出于演示的需 要，对话框底部的静态控件会更新，来表示当前正在执行的是哪个纤程。该纤程既可以是 用户界面纤程，也可以是执行重算的纤程（后简称为重算纤程）。
为了测试这个应用程序，请在编辑框中输入5。Currently Running Fiber字段会变成 Recalculation, Answer字段会慢慢地从0递增到5。当计数完成后，Currently Running Fiber 字段会变回User Interface,线程会进入睡眠状态。现在，在编辑框中5的后面输入0（使它 成为50）,并观察计数过程从0开始，一直到50结束。但这一次，当Answer字段递增的 时候，在屏幕上移动窗口。我们会发现重算纤程被夺取了运行权，用户界面纤程再次得到 运行权，这样应用程序的用户界面就能够对用户的操作保持响应。当我们停止移动窗口的 时候，重算纤程再次被调度，Answer字段会从上次中断的地方继续计数。
最后一项测试：当重算纤程在计数的时候，改变编辑框中的数值。和刚才一样，请注意用 户界面能够响应我们的输入—— 同时注意当我们停止输入的时候，重算纤程会从头开始 计数。这正是我们在一个真正的电子表格应用程序中想要的那种行为。
记住，在这个应用程序中没有使用关键段或其他线程同步对象------切都是在一个包含两
个纤程的线程中完成的。
下面让我们来讨论一下应用程序是如何实现的。当应用程序的主线程开始执行
WS核心编程（第5版）
_tWinMain（位于代码的最后）时,会调用ConvertThreadToFiber来将线程转换成一个纤程, 铉使得我们能够在稍后再创建另一个纤程。然后程序创建了一个非模态对话框，也就是应 用程序的主窗口。接着，程序初始化了一个状态变量来表示后台处理状态（background processing state, BPS）。这个状态变量是全局变量g_FiberInfo中包含的bps成员。后台处 理状态可能有三种，在表12-1中列出。
表12-1 Counter示例程序可能的状态
状态	描述
BPS DONE	重算已经完成，用户没有修改输入，因此不需要再进行重算
BPS STARTOVER	用户修改了输入，需要重头开始进行重算
BPS_CONTINUE	重算已经开始，但尚未完成。同时，用户没有修改输入，因此不需要再重头开 始进行重算
线程的消息循环会检查后台处理状态变量，这使得它比一个普通的消息循环要复杂。下面 是消息循环执行的操作。
•	如果有窗口消息（用户界面），那么就处理消息。保持用户界面的响应始终比重算具 有更高的优先级。
•	如果用户界面无事可做，那么它会检查是否需要进行重算。（后台处理状态为 BPS_STARTOVER 或 BPS_CONTINUE。）
•	如果不需要进行重算（BPS_DONE）,那么它会通过调用WaitMessage来将线程挂 起，因为只有用户界面事件才可能会导致需要重新计算。
•	如果对话框被关闭，那么它会调用DeleteFiber来将计算纤程停止，调用 ConvertFiberToThread来对用户界面纤程进行清理，并在_WinMain退出之前返回 到非纤程模式。
如果用户界面纤程无事可做，而且用户刚修改了编辑框中的值，那么我们需要重头开始重 算（BPS二STARTOVER）。首先需要意识到的是，我们可能已经有一个重算纤程正在运行， 如果是这样，必须先删除原来的纤程并创建一个新的纤程来从头开始重算。用户界面纤程 会调用DeleteFiber来销毁已有的重算纤程。与线程相比，这正是纤程有用的地方。删除重 算纤程不存在任何问题：纤程的栈和执行上下文会被完全地、干净地销毁。如果我们使用 的是线程而不是纤程，那么用户界面线程将无法干净地销毁重算线程——我们必须使用某 种形式的线程间通信机制来等待重算线程自己结束。一旦我们知道不存在重算纤程，而且 用户界面线程尚未转换到纤程模式，那么我们需要进行转换。然后我们可以创建一个新的 重算纤程，并将后台处理状态设为BPS_CONTINUE。
当用户界面处于空闲状态，而重算纤程需要进行重算时，我们通过调用SwitchToFiber来 给它调度时间。这个SwitchToFiber调用会一直等待，直到重算纤程再次调用 SwitchToFiber,并传入用户界面纤程的执行上下文为止。
第12章纤程
FiberFiinc函数包含了重算纤程执行的代码。程序会把全局的g^Fiberlnfo结构的地址传给 这个纤程函数，这样它就可以知道对话框的窗口句柄，用户界面纤程的执行上下文的地址, 以及当前的后台处理状态。实际上我们并不需要传递这个结构的地址，这是因为它是一个 全局变量，但这里的目的是为了展示如何传参数给纤程函数。此外，将地址作为参数传递 可以减少代码中的依赖关系，是个不错的做法。
366
纤程函数首先更新对话框中的状态控件来表示重算纤程正在执行。然后它会取得编辑框中 的数值并进入一个循环，从0开始计数一直到输入的数。每当要递增当前的计数值时，函 数会调用GetQueueStatus来检查线程的消息队列中是否有新的消息。（在同一个线程中运 行的所有纤程共享该线程的消息队列。）当有新的消息出现时，由于我们希望用户界面纤程 比重算纤程具有更高的优先级，因此用户界面纤程需要对消息进行处理。这时纤程函数会 立即调用SwitchToFiber,这样用户界面纤程就能够对消息进行处理。当消息处理完毕后, 用户界面纤程会再次调度重算纤程（如前所述），于是后台处理得以继续进行。
当没有消息需要处理时，重算纤程会更新对话框中的Answer字段并睡眠200微秒。在实际 产品的代码中，我们应该去掉对Sleep的调用，之所以在这里用到它，是为了将重算所需 的时间进行放大。
当重算纤程完成计算的时候，会将后台处理状态变量设为BPS_DONE,并调用 SwitchToFiber来再次调度用户界面纤程。这时，重算纤程己经被删除了，用户界面纤程也 被转换回了线程。现在用户界面纤程无事可做，于是它调用WaitMessage来将线程挂起， 这样就不会浪费CPU时间。
注意，每个纤程在FLS槽中保存了一个标识符字符串（“User interfacen或uComputationn）, 在对不同的事件进行记录时，这些字符串会被打印到日志中。可能的事件包括：纤程被删 除或FLS槽被分配该FLS槽时设置的FLS回调函数所销毁。该FLS回调函数利用了 IsThreadAFiber函数来检测是否可以使用该FLS槽的值。
367
Windows内存体系结构 探索虚拟内存 在应用程序中使用虚拟内存
3 4 5 6 7
11111

Windows内存体系结构
本章内容
13.1进程的虚拟地址空间
麝虚拟地址空间的分区宵
13.3地址空间中的区域 F
苗*『给区域调拨物理存储器
13.5物理存储器和页交换文件
13.6页面保护属性
13.7	实例分析
13.8数据对齐的重要性
操作系统所使用的内存体系结构是理解操作系统如何运作的关键。当我们开始使用一个新 的操作系统时，脑海中会涌现出许多问题。比如“怎样才能在两个应用程序间共享数据？ ”， “系统把我需要的数据保存在哪里了？”，以及“怎样才能让应用程序更高效地运行？”， 等等。
根据我的经验，充分理解系统管理内存的方式，往往有助于我们快速而准确地找到上述问 题的答案。本章将深入探讨Microsoft Windows所使用的内存体系结构。
13.1进程的虚拟地址空间
每个进程都有自己的虚拟地址空间。对32位进程来说，这个地址空间的大小为4GB,这 是因为32位指针可以表示从0x00000000到OxFFFFFFFF之间的任一值。指针在这个范围 内可以有4 294 967 296个值，它们覆盖了进程的4GB地址空间。对64位进程来说，由于 64位指针可以表示从0x00000000*00000000到0xFFFFFFFFFFFFFFFF之间的任一值，因此 这个地址空间的大小为16 EB＜，；o指针在这个范围内可以有18 446 744 073 709 551 616个值, 它们覆盖了进程的16 EB地址空间。这个地址空间实在是太大了！
因为每个进程都有自己专有的地址空间，当进程中的各线程运行时，它们只能访问属于该 进程的内存。线程既看不到属于其他进程的内存，也无法访问它们。
① 译注：exabytes,仃亿亿字节。
indows核心编程(第5版)
说明 在Windows中，正在运行的线程看不到属于操作系统本身的内存，这意味着它不能 无意间访问到操作系统的数据。
如前所述，每个进程都有自己私有的地址空间。进程A可以在位于它的地址空间内的 0x12345678地址处存储一个数据结构，而进程B也可以在“自己的”地址空间内存储一个 完全不同的数据结构——同样位于0x12345678地址处。当进程A中的线程访问位于地址 0x12345678处的内存时，它们访问的是进程A的数据结构。当进程B中的线程访问位于地 址0x12345678处的内存时，它们访问的是进程B的数据结构。进程A中的线程无法访问 位于进程B的地址空间内的数据结构，反之亦然。
别高兴得太早！虽然应用程序有这么大的地址空间可用，但是要记住这只是虚拟地址空间 ——不是物理存储器。这个地址空间只不过是一个内存地址区间。为了能够正常读/写数据， 我们还需要把物理存储器分配或映射到相应的地址空间，否则将导致访问违规(access violation)。我们会在本章的后半部分对此进行详细的介绍。
13.2虚拟地址空间的分区
每个进程的虚拟地址空间被划分成许多分区(partition)o由于地址空间的分区依赖于操作系 统的底层实现，因此会随着Windows内核的不同而略有变化。表13-1列出了各平台上对 进程地址空间的分区。
我们可以看到，32位Windows内核和64位Windows内核的分区基本一•致，唯一的不同在 于分区的大小和分区的位置。下面我们来看一下系统如何使用每一个分区。
表13・1进程的地址空间是如何划分的
分区	x86 32 位 Windows	3 GB用户模式 下的x86 32位 Windows	x64 64 位 Windows	IA-64 64 位 Windows
空指针 赋值 分区	0x00000000 OxOOOOFFFF	0x00000000 OxOOOOFFFF	0x00000000*00000000 OxOOOOOOOO'OOOOFFFF	OxOOOOOOOO^OOOOOOO OxOOOOOOOO'OOOOFFFF
用户模 式分区	0x00010000 0x7FFEFFFF	0x00010000 OxBFFEFFFF	OxOOOOOOOO'OOO 10000 0x000007FF'FFFEFFFF	0x00000000*00010000 0x000006FB'FFFEFFFF
64 KB 禁 入分区	0x7FFF0000 Ox7FFFFFFF	OxBFFFOOOO OxBFFFFFFF	OxOOOOOTFFTFFFOOOO Ox000007FF*FFFFFFFF	0x000006FBTFFF0000 Ox000006FB'FFFFFFFF
内核模 式分区	0x80000000 OxFFFFFFFF	0x00000000 OxFFFFFFFF	OxOOOOOSOO'OOOOOOOO OxFFFFFFFF'FFFFFFFF	Ox000006FC'00000000 OxFFFFFFFF'FFFFFFFF
第13章 Windows内存体系结构
13.2.1空指针赋值分区
这一分区是进程地址空间中从0x00000000到OxOOOOFFFF的闭区间，保留该分区的目的是 为了帮助程序员捕获对空指针的赋值。如果进程中的线程试图读取或写入位于这一分区内 的内存地址，就会引发访问违规。
在C/C廿程序中，错误检查经常执行得不够彻底。例如，下面的代码就没有执行错误检查: int* pnSomelnteger = （int*） malloc（sizeof（int））;
♦pnSomelnteger = 5;
372
如果malloc无法分配足够的内存，那么它会返回NULLo但是，前面的代码并没有检查这 种可能性——它想当然地认为分配一定会成功并访问位于地址0x00000000处的内存。因为 地址空间中的这一分区是禁止访问的，所以会引发内存访问违规并导致进程被终止。这一特 性可以帮助开发人员发现应用程序中的缺陷。值得注意的是，没有任何办法可以让我们分 配到位于这一地址区间内的虚拟内存，即便是使用Win32应用程序编程接口（application programming interface,通常简称为API）也不例外。
13.2.2用户模式分区
这一分区是进程地址空间的驻地。可用的地址区间和用户模式分区的大小取决于CPU体系 结构，如表13.2所示。
表13-2 CPU体系结构、对应的用户模式可用地址区间以及分区的大小
CPU体系结构	用户模式分区的可用地址区间	用户模式分区的大小
x86（普通）	0x00010000 -> 0x7FFEFFFF	〜2 GB
x86w/3GB	0x00010000 — OxBFFEFFFF	〜3 GB
x64	OxOOOOOOOO'OOO 10000 一 0x000007FFTFFEFFFF	-8192 GB
IA-64	OxOOOOOOOO'OOO 10000 一 0x000006FB'FFFEFFFF	〜7152 GB
进程无法通过指针来读取、写入或以任何方式，访问驻留在这一分区中其他进程的数据。 对所有应用程序来说，进程的大部分数据都保存在这一分区。由于每个进程都有自己的数 据分区，因此一个应用程序破坏另一个应用程序的可能性就非常小，从而使得整个系统更 加坚固。
说明 在Windows中，所有.exe和动态链接库（dynamic-link library,通常简称为DLL）都载 入到这一区域。每个进程都有可能将这些DLL载入到这一分区内的不同地址（虽然 这种可能性很小）。系统同时会把该进程可以访问的所有内存映射文件映射到这一 分区。

dows核心编程（第5版）
当我第一眼看到32位进程的地址空间时，惊讶地发现进程可用地址空间的数量居然还不到 进程整个地址空间的一半。难道内核模式分区真的需要整个地址空间的上半部分吗？实际 上，回答是肯定的。系统需要用这一空间来存放内核代码、设备驱动程序代码、设备输入/ 输出高速缓存、非分页缓冲池分配表（non-paged pool allocation）.进程页面表，等等。事实 上，Microsoft己经将内核压缩到这2 GB的空间中。在64位Windows中，内核终于得到 了它真正需要的空间。
1.在x86 Windows T得到更大的用户模式分区
有些应用程序（比如Microsoft SQL Server）会受益于大于2 GB的用户模式地址空间。可寻址更 多的数据有助于这些应用程序提高性能和可伸缩性。因此，x86版的Windows提供了一种模式 来增大用户模式分区，最多不超过3GBO为了让所有的应用程序使用大于2GB的用户模式分 区和小于1 GB的内核模式分区，我们需要对Windows中的启动配置数据（boot configuration data,后面简称为BCD）进行设定，并重新启动机器。有关BCD的更多信息，请参阅以下网址 提供的白皮书:http://www.microsoft.com/whdc/system/platfbrm/firmware/bcd.mspx。
O
要配置BCD,只需执行BCDEdit.exe并使用/set开关和IncreaseUserVA参数。例如，bededit /set IncreaseUserVa 3072告诉Windows为所有进程保留3 GB的用户模式地址空间和1 GB 的内核模式地址空间。表13-2中的“x86 W/3GB”那一行显示了当IncreaseUserVa的值为 3072时地址空间的分布。IncreaseUserVa可接受的最小值为2048,它对应于默认的2 GB。 如果需要取消对该参数的设定，只需执行下面的命令:bededit /deletevalue IncreaseUserVa®
提示 如果需要知道BCD各参数的当前设定值，在命令行运行bededit /enum即可。（有 关 BCDEdit 各参数的更多信息，请访问 http://msdn2.microsoft.com/en-us/library/ aa90621 l.aspx,）
在早期版本的Windows中，Microsoft不允许应用程序访问2 GB以上的地址空间，因此一 些有创意的开发人员决定对此加以利用。他们将指针的最高位作为一个标志位使用，只有 他们的应用程序才知道该如何解释该标志位。当应用程序访问内存地址时，会在访问内存 地址之前清除指针的最高位。可以想象，当此类应用程序在用户模式分区大于2 GB的环境 下运行时，显然会“死得很难看”①。
为了让此类应用程序即使在用户模式分区大于2 GB的环境下仍能正常运行，Microsoft必 须为这一问题提供一种解决方案。当系统即将运行一个应用程序时，它会检查应用程序在 链接时是否使用了/LARGEADDRESSAWARE链接器开关。如果是，则相当于应用程序在 声明它会充分利用大用户模式地址空间，而不会对内存地址进行任何不当的操作。反之， 如果应用程序在链接时没有使用/LARGEADDRESSAWARE开关，那么操作系统会保留用 户模式分区中2GB以上到内核模式开始处的整个部分。这样，由于所有分配到的内存地址
①译注：这种情况发生在Windows分配的内存位f 2GB以上的时候，把指针最高位的1清除会导致应用程序访问错误的内存 地址。
第13章 Windows内存体系结构
的最高位都是0,因此避免了应用程序对该位做出错误的解释。
需要注意的是，内核所需要的代码和数据原来已经被紧紧地压缩到2GB的分区内，因此, 将内核的地址空间减少到2GB以下将限制系统所能创建的线程、栈及其他资源的数量。此 外，在使用大用户模式分区时，系统最多只能使用64 GB内存，而如果使用默认的2 GB 用户模式分区，系统最多可以使用128 GB内存①。
说明 操作系统会在创建进程的地址空间时检查可执行文件的LARGEADDRESSAWARE 标志。对DLL来说，系统会忽略该标志。所有的DLL必须经过正确编写，以便能 够在用户模式分区大于2GB的情况下正常运行，否则其结果将不可预料。
2.在64位Windows下得到2 GB用户模式分区
Microsoft意识到许多开发人员希望尽可能快、尽可能容易地将已有的32位应用程序移植 到64位环境下，但是，它还存在大量为32位指针开发的源代码。仅仅重新编译应用程序 会导致指针截断错误(pointer truncation error)和不正确的内存访问。
但是，如果系统能够保证不在OX000000007FFFFFFF以上的地址分配内存，那么应用程序 就能够正常运行。把一个高33位都为0的64位地址截断为32位地址，无论如何都不会产 生问题。系统可以提供这一保证，其做法是让应用程序在地址空间沙箱(address space sandbox)中运行，这样进程可用的地址空间就被限制在最底部的2GB中。
374375
在默认情况下，当运行一个64位应用程序时，系统会保留用户模式地址空间中位于地址 0x00000000*80000000之后的所有部分。这就确保了所有的内存都分配自64位地址空间中 最底部的2 GBo这就是所谓的地址空间沙箱。对大多数应用程序来说，2 GB的地址空间 已经足够了。为了让64位应用程序能够访问整个用户模式分区，必须用 /LARGEADDRESSAWARE链接器开关来链接应用程序。
说明 操作系统会在创建进程的64位地址空间时检查可执行文件的LARGEADDRESSAWARE 标志。对DLL来说，系统会忽略该标志。所有的DLL必须经过正确编写，以便能 够在4 TB用户模式分区的情况下正常运行，否则其结果将不可预料。
3.内核模式分区
这一分区是操作系统代码的驻地。与线程调度、内存管理、文件系统支持、网络支持以及 设备驱动程序相关的代码都载入到该分区。驻留在这一分区内的任何东西为所有进程共有。 虽然这一分区就在每个进程中用户模式分区的上方，但该分区中所有代码和数据都被完全 保护起来。如果一个应用程序试图读取或写入位于这一分区中的内存地址，会引发访问违 规。在默认情况下，访问违规会导致系统先向用户显示一个消息框，然后结束该应用程序。 有关访问违规的更多信息，以及如何对其进行处理，请参阅第23章〜第25章。
①译注：详细信息诺参阅 http://msdn2.microsoft.com/en-us/!ibrary/ms791558.aspx«.
j^^dows核心编程(第5版)
说明 在64位Windows中，8 TB的用户模式分区和16 777 208 TB的内核模式分区看起 来完全不成比例。这并不是因为内核模式分区需要这么大的虚拟地址空间，而是因 为64位地址空间实在是太大了，其中大部分尚未使用。系统允许应用程序使用8TB, 也允许内核根据其需要加以使用，实际上内核模式分区中的大部分尚未使用。对内 核模式分区中尚未使用的部分，系统不必分配任何内部数据结构来对它们进行维护。
13.3地址空间中的区域
当系统创建一个进程并赋予它地址空间时，可用地址空间中的大部分都是闲置的(f^ee)或尚 未分配的(unallocated)o为了使用这部分地址空间，我们必须调用VirtualAlloc(详情参见第 15章)来分配其中的区域(region)。分配区域的操作被称为预订(reserving)。
当应用程序预订地址空间区域时，系统会确保区域的起始地址正好是分配粒度(allocation granularity)的整数倍。分配粒度会根据不同的CPU平台而有所不同。但是，在写作本书时, 所有的CPU平台都使用相同的分配粒度，大小为64KB——也就是说，系统会把分配请求 取整到64 KB的整数倍。	一＞««_
37X76
当应用程序预订地址空间中的一块区域时，系统会确保区域的大小正好是系统页面大小的 整数倍。页面是一个内存单元，系统通过它来管理内存。与分配粒度相似，页面大小会根 据不同的CPU而有所不同。x86和x64系统使用的页面大小为4 KB,而IA-64系统使用 的页面大小为8KB。
说明 有时系统会以应用程序的名义来预订地址空间区域。例如，系统会分配一块地址空 间区域来存放进程环境块(process environment block,后面简称为PEB)。PEB是一 个完全由系统创建、操控并销毁的小型数据结构。当系统创建一个进程时，它会为 PEB分配一块地址空间区域。
系统同时还需要创建线程环境块(thread environment block,后面简称为TEB)来协助 管理进程中所有的线程。系统会在创建线程时为TEB预订区域，并在销毁线程时释 放相应的区域。
虽然系统规定应用程序在预订地址空间区域时起始地址必须是分配粒度(在所有平 台上都为64KB)的整数倍，但系统自己却不存在同样的限制。非常有可能出现的情 况是，系统为PEB和TEB预订的区域的起始地址并非64 KB的整数倍。但是，这 些区域仍然必须是CPU页面大小的整数倍.
如果应用程序试图预订一块大小为10KB的地址空间区域，那么系统会自动将该请求取整 到页面大小的整数倍，然后用取整后的大小预订区域。这意味着在x86和x64系统中，系 统会预订一块大小为12KB的区域，而在IA-64系统中，系统会预订一块大小为16 KB的 区域。
当程序不再需要访问所预订的地址空间区域时，应该释放该区域。这个过程被称为释放地
第13章 Windows内存体系结构
址空间区域，通过调用VirtualFree函数来完成。
13.4给区域调拨物理存储器
为了使用所预订的地址空间区域，我们还必须分配物理存储器，并将存储器映射到所预订 的区域。这个过程被称为调拨(committing)物理存储器。物理存储器始终都以页面为单位来 调拨。我们通过调用VirtualAlloc函数来将物理存储器调拨给所预订的区域。
当我们调拨物理存储器给区域时，并不需要给整个区域都调拨物理存储器。例如，我们可 以预订一块大小为64 KB的区域，然后把物理存储器拨给该区域中的第2个页面和第4个 页面。图13-1显示了在这种情况下进程的地址空间会是什么样子。注意，地址空间会根据 CPU平台的不同而有所不同。左面显示的是X86/X64机器上(页面大小为4 KB)的地址空间， 而右面显示的是IA-64机器上(页面大小为8 KB)的地址空间。
图13・1不同CPU上的进程地址空间示例
当程序不再需要访问所预订区域中已调拨的物理存储器时，应该释放物理存储器。这个过 程被称为撤销调拨(decommitting)物理存储器，通过调用VirtualFree函数来完成。
Endows核心编程（第5版）
13.5物理存储器和页交换文件
在老式的操作系统中，物理存储器被认为是机器中内存的总量。换句话说，如果一台机器 装有16 MB内存，那么应用程序最多可以使用16 MB内存。当今的操作系统能让磁盘空间 看起来像内存一样。磁盘上的文件一般被称为页交换文件（paging file）,其中包含虚拟内存， 可供任何进程使用。
当然，为了能够使用虚拟内存，操作系统需要CPU的大力协助。当线程试图访问存储器中 的一个字节时，CPU必须知道该字节是在内存中还是在磁盘上。
g翁
从应用程序的角度来说，页交换文件以一种透明的方式增大了应用程序可用内存（或存储器） 的总量。如果一台机器装备了 1GB的内存，硬盘上还有1GB的页交换文件，那么应用程 序会认为可用内存的总量为2GB。
当然，这台机器实际上并没有装备2GB的内存。实际上，是操作系统与CPU分工协作， 把内存中的一部分保存到页交换文件中，并在应用程序需要的时候再将页交换文件中的对 应部分载入内存。因此，使用页交换文件可以增大应用程序可用内存的总量。另一方面， 页交换文件的使用并不是必须的。如果一台机器没有页交换文件，那么对系统来说，它只 是认为可供应用程序使用的内存总量减少了。但是，我们强烈建议用户使用页交换文件， 这样就可以运行更多的应用程序，而应用程序也可以操作更多的数据。最好是把物理存储 器看成是保存在磁盘（通常是硬盘）上的页交换文件中的数据。当应用程序调用VirtualAlloc 函数来把物理存储器调拨给地址空间区域时，该空间实际上是从硬盘上的页交换文件分配 得到的。系统中页交换文件的大小是决定应用程序可用内存总量的最重要因素，机器实际 装备的内存总量对它的影响相对较小。
当一个线程试图访问所属进程的地址空间中的一块数据（位于第17章介绍的内存映射文件 之外）时，有可能会出现两种情况。图13-2显示了经简化后的流程图。（更多细节请参阅Mark Russinovich 和 David Solomon 所著的 Microsoft Windows Internals,由微软出版社出版。） 第一种情况是，线程要访问的数据就在内存中。在这种情况下，CPU会先把数据的虚拟内 存地址映射到内存的物理地址，接下来就可以访问内存中的数据了。
第二种情况是，线程要访问的数据不在内存中，而是位于页交换文件中的某处。在这种情 况下，这次不成功的访问被称为页面错误。发生页面错误时，CPU会通知操作系统。操作 系统随即在内存中找到一个闲置的页面，如果找不到，操作系统必须先释放一个己分配的 页面。如果待释放的页面没有修改过，那么操作系统可以直接释放该页面。但如果系统需 要释放一个修改过的页面，那么它必须先把页面从内存复制到页交换文件。接下来，系统 会在页交换文件中对所需访问的数据块进行定位，并把数据载入到内存中闲置的页面。然后， 操作系统对它内部的表项进行更新，以反映该块数据的虚拟内存地址现在已经被映射到了
第13章 Windows内存体系结构
内存中对应的物理内存地址。这时CPU会再次运行那条引发页面错误的指令，但和前一次 不同的是，这一次CPU能够将虚拟内存地址映射到物理内存地址并成功访问所需的数据。
线程试图访问\
图13・2把虚拟地址转换为物理存储器地址
系统需要在内存和页交换文件之间复制页面的频率越高，硬盘颠簸(thrash)得越厉害，系统 运行得也越慢。(颠簸是指操作系统把所有的时间都花在在页面文件和内存之间交换数据 上，导致没有时间运行程序。)通过给计算机添加更多的内存，我们可以减少应用程序运行 时可能产生颠簸的次数，从而极大地提高应用程序的性能。这里有一条经验法则：要让计 算机跑得更快，最好是增加内存。实际上，和换个更快的CPU相比，添加内存在大多数情 况下都会得到更好的性能提升。
378
不在页交换文件中维护的物理存储器
在读过上一节之后，读者可能会想，如果有许多程序同时运行，页交换文件可能会变得相 当大一尤其是每次运行一个程序时，系统都必须为该进程的代码和数据预订地址空间区 域，为这些区域调拨物理存储器，然后把硬盘上的程序文件中的代码和数据复制到页交换 文件中已调拨的物理存储器中去。
Endows核心编程（第5版）
事实上，系统并不会执行刚才所说的这些操作。如果系统确实这么做的话，那么载入一个 程序并让它运行起来会花费很长的时间。当用户要求执行一个应用程序时，系统会打开该 应用程序对应的.exe文件并计算出应用程序的代码和数据的大小。然后系统会预订一块地 址空间，并注明与该区域相关联的物理存储器就是.exe文件本身。是的，系统并没有从页 交换文件中分配空间，而是将.exe文件的实际内容（或文件映像，即file image）用作程序预 订的地址空间区域。这样一来，不但载入程序非常快，而且页交换文件也可以保持一个合 理的大小。
当把一个程序位于硬盘上的文件映像（即一个.exe或DLL文件）用作地址空间区域对应的物 理存储器时，我们称这个文件映像为内存映射文件（memory mapped file）。当载入一个.exe 或DLL时，系统会自动预订地址空间区域并把文件映像映射到该区域。但是，系统也提供 了一组函数，可以让开发人员把数据文件映射到地址空间。我们会在第17章详细讨论内存 映射文件。
Windows可以使用多个页交换文件。如果多个页交换文件位于不同的物理硬盘上，那么系 统就可以运行得更快，这是因为系统能同时写入多个硬盘。在控制面板里，我们可以通过 以下步骤来添加和删除页交换文件。
（1）	选择 Performance Information And Tools（性能信息和工具）。
（2）	单击Advanced Tools（高级工具）链接。
（3）	单击 Adjust The Apperance And Performance Of Windows（调整 Windows 的外观和性能） 链接。
（4）	选择Advanced（高级）选项卡，并在虚拟内存部分单击Change（更改）按钮。
下图显示了弹出的对话框。
第13章 Windows内存体系结构
说明 当Windows从软盘载入.exe或DLL文件时，系统会把整个文件从软盘复制到内存 中。此外，系统还会从页交换文件中分配足够的存储空间来存放文件映像。只有当 系统需要把一个页面换出内存，而页面又包含该文件映像的一部分时，系统才会写 入页交换文件。如果系统的内存负载很轻，那么文件总是从内存中直接运行。
Microsoft必须让在软盘上执行的文件以这种方式运行，因为只有这样安装程序才能 正常运行。通常，安装程序从第一张软盘开始运行，在安装过程中用户会取出该软 盘并插入其他软盘。如果系统需要再从第一张软盘去加载.exe或DLL的一部分代码, 那么很显然，第一张软盘可能已经不在软驱内了。但是，由于系统已经把文件复制 到了内存中（并以页交换文件为后备存储器），因此系统可以随时访问安装程序而且 不会遇到任何问题。
除非映像文件是用/SWAPRUN:CD或/SWAPRUN:NET开关链接的，否则系统不会 把位于其他可移动媒介（比如，光盘或网络驱动器）上的映像文件复制到内存中的。
380
13.6页面保护属性
我们可以给每个已分配的物理存储页指定不同的页面保护属性。表13-3列出了所有的页面 保护属性。
表13・3内存页面保护属性
保护属性	描述
PAGE NOACCESS	试图读取页面、写入页面或执行页面中的代码将引发访问违规
PAGE READONLY	试图写入页面或执行页面中的代码将引发访问违规
PAGE READWRITE	试图执行页面中的代码将引发访问违规
PAGE EXECUTE	试图读取页面或写入页面将引发访问违规
PAGE EXECUTE READ	试图写入页面将引发访问违规
PAGE EXECUTE READWRITE	对页面执行任何操作都不会引发访问违规
PAGE_WRITECOPY	试图执行页面中的代码将引发访问违规。试图写入页面将使系统为 进程单独创建一份该页面的私有副本（以页交换文件为后备存储器）
PAGE_EXECUTE_WRITECOPY	对页面执行任何操作都不会引发访问违规。试图写入页面将使系统为 进程单独创建-份该页面的私有副本（以页交换文件为后备存储器）
一些恶意软件将代码写入到用于数据的内存区域（比如线程栈上），通过这种方式让应用程 序执行恶意代码。Windows的数据执行保护（Data Execution Protection,后面简称为DEP） 特性提供了对此类恶意攻击的防护。如果启用了 DEP,那么只有对那些真正需要执行代码 的内存区域，操作系统才会使用PAGE_EXECUTE_*保护属性。其他保护属性（最常见的 就是PAGE_READWRITE）用于只应该存放数据的内存区域（比如线程栈和应用程序
indows核心编程(第5版)
的堆)。
如果CPU试图执行某个页面中的代码，而该页又没有PAGE_EXECUTE_*保护属性，那 么CPU会抛出访问违规异常。
系统还对Windows支持的结构化异常处理机制(structured exception handling mechanism)做 了更进一步的保护，结构化异常处理机制会在第23〜25章详细介绍。如果应用程序在链接 时使用了/SAFESEH开关，那么异常处理器会被注册到映像文件中一个特殊的表中。这样, 当将要执行一个异常处理器时，操作系统会先检查该处理器有没有在表中注册过，然后决 定是否允许它执行。
有关DEP的更多信息，请访问http://go.microsoft.com/fwlink/?LinkId=28022,可以在此找到
Microsoft 白皮书 “03_CIF_Memory_Protection.DOC”。
13.6.1	写时复制
在表13.3中列出的保护属性中，除最后两个属性PAGE_WRITECOPY和 PAGE_EXECUTE_WRITECOPY之外，其余的都不言自明。这两个应护属性存在的目的 是为了肯省内存和页交换文件的使用。Windows支持一种机制，允许两个或两个以上的进 程共享同一块存储器。因此，如果有10个记事本程序正在运行，所有的进程会共享应用程 序的代码页和数据页。让所有的应用程序实例共享相同的存储页极大地提升了系统的性能, 但另一方面，这也要求所有的应用程序实例只能读取其中的数据或是执行其中的代码。如 果某个应用程序实例修改并写入一个存储页，那么这等于是修改了其他实例正在使用的存 储页，最终将导致混乱。
为了避免此类混乱的发生，操作系统会给共享的存储页指定写时复制属性。当系统把一 个.exe或.dll映射到一个地址空间的时候，系统会计算有多少页面是可写的。(通常，包含 代码的页面被标记为PAGE_EXECUTE_READ ,而包含数据的页面被标记为 PAGE_READWRITE。燃后系统会从页交换文件中分配存储空间来容纳这些可写页面。 除非应用程序真的写入可写页面，否则不会用到页交换文件中的存储器。
当线程试图写入一个共享页面时，系统会介入并执行下面的操作。
(1)	系统在内存中找到一个闲置页面。注意，该闲置页面的后备页面来自页交换文件，它 是系统最初将模块映射到进程的地址空间时分配的。由于系统在第一次进行映射的时 候分配了所有可能需要的页交换文件空间，这一步不可能失败。
(2)	系统把线程想要修改的页面内容复制到在第1步中找到的闲置页面。系统会给该闲置 页面指定 PAGE_READWRITE 或 PAGE_EXECUTE_READWRITE 保护属性，系统 不会对原始页面的保护属性和数据做任何修改。
(3)	然后，系统更新进程的页面表，这样一来，原来的虚拟地址现在就对应到内存中一个 新的页面了。
第13章 Windows内存体系结构
系统在执行这些步骤之后，进程就可以访问它自己的副本了。第17章将进一步介绍存储器 共享和写时复制。
此外，在预订地址空间或调拨物理存储器时，不能使用PAGE_WRITECOPY或 PAGE_EXECUTE_WRITECOPY保护属性。这样做会导致调用VirtualAlIoc失败，此时 调用GetLastError会返回错误码ERROR_INVALID_PARAMETERo这两个属性是操作 系统在映射.exe或DLL映像文件时用的。
13.6.2	一些特殊的访问保护属性标志
除了己经介绍过的保护属性之外，另外还有3个保护属性标志：PAGE_NOCACHE, PAGE_WRITECOMBINE和PAGE_GUARD。使用这些标志时，只需将它们与除了 PAGE_NOACCESS之外的任何其他保护属性进行按位或操作即可。
第一个保护属性标志PAGE_NOCACHE,用来禁止对已调拨的页面进行缓存。该标志存在 的主要目的是为了让需要操京内存缓冲区的驱动程序开发人员使用，不建议将该标志用于 除此以外的其他用途。
第二个保护属性标志PAGE_WRITECOMBINE也是给驱动程序开发人员用的。它允许把 对单个设备的多次写操作组合在一起，以提高性能。
最后一个保护属性标志PAGE_GUARD,使应用程序能够在页面中的任何一个字节被写入 时得到通知。这个标志有一些巧妙的用法。Windows在创建线程栈时会用到它。有关该标 志的更多信息，请参阅第16章。
13.7实例分析
本节我们会把地址空间、分区、区域、块和页面集中起来讨论。最好的方式莫过于分析一 个虚拟内存映射的实例，看看进程地址空间中所有的区域到底是如何分配的。例子中的进 程正好是第14章中的示例程序VMMapo为了能够完整地理解进程地址空间，让我们先来 看一下VMMap在32位x86版本的Windows上运行的情况。表13V列出了一个地址空间 映射的实例。
表13Y 运行在32位x86版本的Windows上的一个地址空间映射的实例：区域
基地址	类型	大小	块数	保护属性	描述
00000000	Free	65536			
00010000	Mapped	65536	1	-RW-	
00020000	Private	4096	1	-RW-	
00021000	Free	61440			
画dows核心编程（第5版）
续表
基地址	类型	大小	块数	保护属性	描述
00030000	Private	1048576	3	-RW-	线程栈
00130000	Mapped	16384	I	-R—	
00134000	Free	49152			
00140000	Mapped	12288	1	-R—	
00143000	Free	53248			
00150000	Mapped	819200	4	-R-	
00218000	Free	32768			
00220000	Mapped	1060864	1	-R-	
00323000	Free	53248			
00330000	Private	4096	1	-RW-	
QO331OOO	Free	61440			
00340000	Mapped	20480	1	-RWC	\Device\HarddiskVolume 1 'Windows' System32\en-U S\user3 2.dll.mui
00345000	Free	45056			
00350000	Mapped	8192	1	-R-	
00352000	Free	57344			
00360000	Mapped	4096	1	-RW-	
00361000	Free	61440			
00370000	Mapped	8192	1	-R-	
00372000	Free	450560			
003E0000	Private	65536	2	-RW-	
003F0000	Free	65536			
00400000	Image	126976	7	ERWC	C:\Apps\14 VMMap.exe
0041F000	Free	4096			
00420000	Mapped	720896	1	-R-	
0O4D000O	Free	458752			
00540000	Private	65536	2	・RW・	
00550000	Free	196608			
00580000	Private	65536	2	-RW-	
00590000	Free	196608			
005C0000	Private	65536	2	-RW-	
005D0000	Free	262144			
00610000	Private	1048576	2	-RW-	•
00710000	Mapped	3661824	1	-R—	\Device\HarddiskVolumel\Windows\ System32\locale.nls
00A8E000	Free	8192			
第13章 Windows内存体系结构
续表
基地址	类型	大小	块数	保护属性	描述
OOA90000	Mapped	3145728	2	-R-	
00D90000	Mapped	3661824	I	-R—	\Device\HarddiskVolumel\Windows\ System32\locale.nls
0110E000	Free	8192			
01110000	Private	1048576	2	-RW-	
01210000	Private	524288	2	・RW・	
01290000	Free	65536			
012A0000	Private	262144	2	-RW-	
012E0000	Free	1179648			
01400000	Mapped	2097152	1	-R-	
01600000	Mapped	4194304	1	-R-	
0IA00000	Free	1900544			
01BD0000	Private	65536	2	-RW-	
01BE0000	Mapped	4194304	1	-R—	
OIFEOOOO	Free	235012096			
739B0000	Image	634880	9	ERWC	C:\Windows\WinSxS\x86_microsoft. vc80.crt_l fc8b3b9a 1 e 18e3b_8.0.5072 7.312_none_10b2ee7b9bffc2c7\MSV CR80.dll
73A4B000	Free	24072192			
75140000	Image	1654784	7	ERWC	C:\Windows\WinSxS\x86_microsoft. windows.common-controls_6595b64 I44ccf1 dC6.0.6000.16386_none_5dO 7289e07e 1 d 100\comctl32.dll
752D4000	Free	1490944			
75440000	Image	258048	5	ERWC	C:\Windows\system32\uxtheme.dll
7547F000	Free	15208448			
76300000	Image	28672	4	ERWC	C:\Windows\system32\PSAPI.dll
76307000	Free	626688			
763A0000	Image	512000	7	ERWC	C:\Windows\systemS2\USP 10.dll
7641D000	Free	12288			
76420000	Image	307200	5	ERWC	C:\Windows\system32\GD132.dll
7646B000	Free	20480			
76470000	Image	36864	4	ERWC	C:\Windows\system32\LPK.dll
76479000	Free	552960			
76500000	Image	348160	4	ERWC	C:\Windows\system32\SHLWAPI.dll
Endows核心编程（第5版）
续表
基地址	类型	大小	块数	保护属性	描述
76555000	Free	1880064			
76720000	Image	696320	7	ERWC	C:\Windows\system32\msvcrt.dll
767CA000	Free	24576			
767D0000	Image	122880	4	ERWC	C:\Windows\system32\IMM32.dll
767EE000	Free	8192			
767FOOOO	Image	647168	5	ERWC	C:\Windows\system32\USER32.dll
7688E000	Free	8192			
76890000	Image	815104	4	ERWC	C:\Windows\system32\MSCTF.dll
76957000	Free	36864			
76960000	Image	573440	4	ERWC	C:\Windows\system32\OLEAUT32.dll
769EC000	Free	868352			
76AC0000	Image	798720	4	ERWC	C:\Windows\system32\RPCRT4.dll
76B83000	Free	2215936			
76DA0000	Image	884736	5	ERWC	C :\Windows\system32\kemel32.d II
76E78000	Free	32768			
76E80000	Image	1327104	5	ERWC	C:\Windows\system32\ole32.dll
76FC4000	Free	11649024			
77AEOOOO	Image	1171456	9	ERWC	C:\Wi ndows\system32\ntdll.dll
77BFE000	Free	8192			
77COOOOO	Image	782336	7	ERWC	C:\Windows\system32\ADVAPI32.dll
77CBF000	Free	128126976			
7F6F0000	Mapped	1048576	2	-R-	
7F7F0000	Free	8126464			
7FFBOOOO	Mapped	143360	1	-R—	
7FFD3000	Free	4096			
7FFD4000	Private	4096	1	-RW-	
7FFD5000	Free	40960			•
7FFDF000	Private	4096	1	-RW-	
7FFE0000	Private	65536	2	-R—	
表13.4所示的地址空间映射列出了进程地址空间中各种各样的区域。表的每一行即一个区 域，每行又由6列组成。
最左边的第一列是区域的基地址。读者可能会注意到我们在遍历进程的地址空间时，从起 始地址为0x00000000的区域开始，到可用地址空间的最后一个区域为止，最后一个区域的 起始地址为OX7FFEOOOO。所有的区域都是连续的。读者可能还会注意到几乎所有非闲置区
第13章 Windows内存体系结构
域的基地址都是64 KB的整数倍。这是由系统的地址空间分配粒度决定的。如果一个区域 的基地址不是64 KB的整数倍，这意味着该区域是由操作系统以进程的名义分配的。
第二列是区域的类型，它可能是表13.5所列出的4种类型之一：闲置(free).私有(private). 映像(image)、已咻射(mapped)。
表13・5内存区域的类型	
类型	描述
闲置	区域的虚拟地址没有任何后备存储器。该地址空间尚未预订，应用程序既可以从基地址开 始预订区域，也可以从闲置区域内的任何地方开始预订区域
私有	区域的虚拟地址以系统的页交换文件为后备存储器
映像	区域的虚拟地址一开始以映像文件(比如.exe或DLL文件)为后备存储器，但此后不一定以 映像文件为后备存储器。例如，如果程序写入映像文件中的一个全局变量，那么写时复制 机制会改用页交换文件来作为后备存储器
己映射	区域的虚拟地址一开始以内存映射文件为后备存储器，但此后不一定以内存映射文件为后 备存储器。例如，内存映射文件可能会使用写时复制保护属性。任何写操作会使对应的页 面改用页交换文件来作为后备存储器
383T86
VMMap应用程序对该列的计算方式可能会引起一些误解。如果一个区域不是闲置的，那 么VMMap程序会猜测它应该是其余3种类型中的哪一种——这是因为我们无法调用相应 的函数来得知该区域的具体用途。程序对该列的计算方式是扫描区域中所有的块，并借此 进行推测。请仔细阅读第14章的代码，这样就能够更好地理解程序对该列的计算方式。
第3列是该区域预订的字节数。例如，系统将User32.dll的映像映射到内存地址Ox767FOOOO 处。当系统为该映像预订地址空间时，它需要预订647168字节。第3列的值始终是CPU 页面大小(对x86系统来说为4096字节)的整数倍。读者可能会注意到磁盘上的文件大小和 映射到内存所需要的字节数之间的差异。为了节省磁盘空间，链接器会尽可能地对所生成 的PE文件进行压缩。但是，当Windows将PE文件映射到进程的虚拟地址空间时，每一 段(section)必须另起一页，而旦起始地址必须是系统页面大小的整数倍。这意味着PE文件 所需虚拟地址空间的大小一般来说要大于文件本身的大小。
第4列是所预订区域内块的数量。一个块(block)是一些连续的页面，这些页面具有相同的 保护属性，并且以相同类型的物理存储器为后备存储器。本章的下一节会对此进行更进一 步的讨论。对闲置页面来说，由于不可能将存储器拨给它们，因此该值始终为0。(闲置页 面的第4列都是空白。)对非闲置页面来说，该值可以是从1到区域最大所能容纳页面的数 量之间的任何一个值。例如，内存起始地址为0x767F0000的区域的大小为647 168字节。
由于进程运行于x86 CPU上，即页面大小为4096字节，因此最多可能出现158块 (647168/4096)类型不同的物理存储器。映射表显示了该区域中共有5个块。
第5列显不了区域的保护属性。每个字母代表的意思是：E = execute, R = read, W = write,
I^^dows核心编程（第5版）
C = copy-on-writeo如果一个区域没有显示任何保护属性，那就表示该区域没有任何访问保 护。由于闲置区域没有与之相关联的保护属性，因此它们没有显示任何保护属性。 PAGE_GUARD和PAGE_NOCACHE标志在这里根本没有出现，这是因为这些标志只有 当用于物理存储时才有意义，对地址空间来说它们没有意义。给区域指定保护属性完全是 为了效率，如果同时给区域和物理存储器指定了保护属性，那么以后者为准。
第6列（即最后一列）是对该区域的描述。对闲置区域来说，该列始终都是空白。对私有区 域来说，该列通常都是空白的，因为VMMap无法知道应用程序预订这块地址空间区域的 目的到底是什么。但是，VMMap能够识别包含了线程栈的私有区域，这是因为线程栈的 物理存储器普遍都设置了 PAGE_GUARD标志。另一方面，如果线程栈已满，那么它就不 会有PAGE_GUARD标志，在这种情况下VMMap也无法检测出来。
对映像区域来说，VMMap显示了映射到该区域的文件的完整路径。VMMap通过PSAPI 函数（曾在第4章末尾提到过）得到这些信息。VMMap可以通过调用GetMappedFileName 函数来知道哪些区域以数据文件为后备存储器，也可以通过调用ToolHelp函数（也曾在第4 章介绍过）来知道哪些区域以可执行文件的映像为后备存储器。
媚387
区域内部
我们可以对表13.4中的区域进一步进行细分。表13.6显示的地址空间与表13V相同，但 它还列出了每个区域内所有的块。
表13书 运行在32位x86版本的Windows上的一个地址空间映射的实例：区域和块
基地址	类型	大小	块数	保护属性	描述
00000000	Free	65536			
00010000	Mapped	65536	1	-RW-	
00010000	Mapped	65536		-RW-—	
00020000	Private	4096	1	-RW-	
00020000	Private	4096		-RW- —	
00021000	Free	61440			
00030000	Private	1048576	3	-RW-	线程栈
00030000	Reserve	774144		-RW---・	
♦ • ♦		•・♦	・.・		...
00330000	Private	4096	1	-RW-	
00330000	Private	4096		-RW-—	
00331000	Free	61440			
00340000	Mapped	20480	1	-RWC	\Device\HarddiskVolumel'Windows' System32\en-US\user32.dll.mui
第13章 Windows内存体系结构
续表
基地址	类型	大小	块数	保护属性	描述
00340000	Mapped	20480		-RWC —	
•・•			• ♦ •		・• •
003FOOOO	Free	65536			
00400000	Image	126976	7	ERWC	C:\Apps\14 VMMap.exe
00400000	Image	4096		-R——	
00401000	Image	8192		ERW--—	
00403000	Image	57344		ERWC —	
00411000	Image	32768		ER—―	
00419000	Image	8192		-R……	
0041B000	Image	8192		-RW-—	
0O41D000	Image	8192			
0041F000	Free	4096			
• ••			...	...	...
739B0000	Image	634880	9	ERWC	C:\Windows\WinSxS\x86_microsoft. vc80.crt_l fc8b3b9a 1 e 18e3b_8.0.50727. 312_none_l Ob2ee7b9bffc2c7\MSVCR8 0.dll
739B0000	Image	4096		■R— ■—	
739B1000	Image	405504		ER……	
73A14000	Image	176128		■R—	
73A3F000	Image	4096		-RW-—	
73A40000	Image	4096		-RWC ---	
73A41000	Image	4096		-RW-—	
73A42000	Image	4096		-RWC -.・	
73A43000	Image	12288		-RW-―	
73A46000	Image	20480		■R — ...	
73A4B000	Free	24072192			
75140000	Image	1654784	7	ERWC	C:\Windows\WinSxS\x86_microsoft. windows.common-controls_6595b64144 ccfldf 6.0.6000.】6386 none 5d07289e 07eldl00\comctl32.dll
75140000	Image	4096		-R——	
75141000	Image	1273856		ER——	
75278000	image	4096		-RW- —	
75279000	Image	4096		-RWC ―	
7527A000	Image	8192		-RW-—	
lows核心编程（第5版）
续表
基地址	类型	大小	块数	保护属性	描述
7527C000	Image	40960		-RWC 一	
75286000	Image	319488		-R——	
752D4000	Free	1490944			
♦ • ♦			♦・♦		. • •
767F0000	Image	647168	5	ERWC	C:\Windows\system32\USER32.dll
767F0000	Image	4096		・R……	
767F1000	image	430080		ER		
7685A000	Image	4096		-RW- —	
7685B000	Image	4096		.RWC —	
7685C000	Image	204800		-R……	
7688E000	Free	8192			
...	・.•	• ♦ •	・• •		• ••
76DA0000	Image	884736	5	ERWC	C:\Windows\system32\kemel32.dll
76DA0000	Image	4096		-R……	
76DA1000	Image	823296		ER……	
76E6A000	Image	8192		-RW-―	
76E6C000	Image	4096		-RWC ―	
76E6DOOO	Image	45056		-R——	
76E78000	Free	32768			
	♦・•	• • •		•••	• • •
7FFDF000	Private	4096	1	-RW-	
7FFDF000	Private	4096		.RW-	
7FFE0000	Private	65536	2	-R—	
7FFEOOOO	Private	4096		-R……	
7FFE1000	Reserve	61440		R..	
388-390
当然，由于不会调拨存储器给闲置区域，因此闲置区域完全没有必要展开。每个块共有5 列，下面对它们进行介绍。
第1列显示的是具有相同状态和保护属性的一组页面的地址。例如，在内存地址0x676F0000 处已调拨了一个内存页面（4096字节），该页面具有只读保护属性。而在内存地址0X676F1000 处，有一个由105个已调拨的内存页面（430 080字节）组成的块，该块具有执行和读取属性。 如果两者具有相同的保护属性，那么在内存映射表中它们会合并在一起，构成一个包含106 个页面（434 176字节）的块。
第2列显示了所预订区域中的块以何种类型的物理存储器为后备存储器。这里有5种可能:
第13章 Windows内存体系结构
闲置(Free)、私有(Private)＞己映射(Mapped)＞映像(Image)或保留(Reserved)。私有、已映射 和映像分别表示该块以页交换文件、数据文件或加载的.exe或DLL文件为后备存储器。如 果该值为闲置或保留，那么表示该块没有任何后备的物理存储器。
大部分情况下，一个区域中所有已调拨的块都以相同类型的物理存储器为后备存储器。但 是，一个区域内己调拨的块以不同类型的物理存储器为后备存储器也是有可能的。例如， 内存映射文件会以.exe或DLL文件为后备存储器，如果程序试图写入区域中具有 PAGE_WRITECOPY或PAGE_EXECUTE_WRITECOPY属性的页面，那么系统会专门 为进程复制一份该页面。新页面不再以文件映像为后备存储器，而以页交换文件为后备存 储器。除了没有写时复制保护属性之外，新页面的其他属性与原始页面相同。
第3列是块的大小。一个区域中所有的块都是连续的，不会存在任何的间隙。
第4列是所预订区域内块的数量。
第5列显示了块的页保护属性和页保护属性标志。一个块的保护属性会优先于所属区域的 保护属性。一个块可能具有的保护属性与区域可能具有的保护属性相同，但是， PAGE_GUARD、PAGE_NOCACHE 和 PAGE_WRITECOMBINE 保护属性标志从来都 不会用于区域，它们只能用于块。
390
13.8数据对齐的重要性
对进程虚拟地址空间的讨论至此告一段落，本节我们将会讨论另一个重要的话题——数据 对齐。相较于操作系统的内存体系结构，数据对齐更多的是CPU体系结构的一部分。
只有当访问巳对齐的数据时，CPU的执行效率才最高。把数据的地址模除⑴数据的大小， 如果结果为0,那么数据就是对齐的。例如，一个WORD值的起始地址应该能被2整除， 一个DWORD值的起始地址应该能被4整除，以此类推。如果CPU要访问的数据没有对 齐，那么会有两种可能。第一种可能是CPU会引发一个异常，另一种可能是CPU会通过 多次访问已对齐的内存，来取得整个错位数据②。
下面的代码访问了错位数据：
VOID SomeFunc(PVOID pvDataBuffer) (
// The first byte in the buffer is some bye of information char c = * (PBYTE) pvDataBuffer；
// Increment past the first byte in the buffer pvDataBuffer = (PVOID)((PBYTE) pvDataBuffer + 1)；
// Bytes 2-5 contain a double-word value
①	洋注：A除以B并取其余数为结果，该运算被称为模除。
②	译注：即未经对齐的数据。
lows核心编程（第5娠）
DWORD dwX" * （DWORD *） pvDataBuffer;
--
// The line above raise a data misalignment exception on some CPUs
显然，如果CPU多次访问内存，那么肯定会影响到应用程序的性能。与访问已对齐的数据 相比，系统在最好的情况下也需要花两倍的时间来访问错位数据，而且情况可能还会更糟。 为了得到最佳的应用程序性能，我们在编写代码时应该尽量让数据对齐。
下面让我们来仔细看一下x86 CPU是如何处理数据对齐的。x86 CPU的EFLAGS寄存器内 有一个特殊的标志位，它被称为AC（alignment check,对齐检查）标志。在默认的情况下， 这个标志位在第一次给CPU通电时被清零。如果该标志为零，那么CPU会自动执行必要 的操作来访问错位数据。但是，如果该标志被设为1,那么一旦程序试图访问错位数据， CPU就会触发INT 17H中断。由于x86版本的Windows从来不会改变这个标志，因此当 应用程序在x86处理器上运行时，绝对不会发生数据错位的异常。当应用程序在AMD X86-64处理器上运行时，会得到相同的结果。这是因为在默认的情况下，CPU处理了数据 错位的错误。
现在让我们来看一下IA.64 CPUo IA-64 CPU不能自动处理数据错位的错误。当任何代码 要访问错位数据时，CPU会通知操作系统。Windows然后决定到底是应该抛出数据错位异 常，还是应该没有任何提示地执行额外的指令来修正错误并让代码继续执行。在默认的情 况下，IA.64版本的Windows操作系统会自动将数据错位的错误转换成一个 EXCEPTION_DATATYPE_MISALIGNMENT异常。但是，我们可以改变这种行为。我 们可以通过调用SetErrorMode函数，让操作系统为进程中的所有线程自动修正数据错位 的错误：
UINT SetErrorMode（UINT fuErrorMode）;
我们这里应该使用SEM_NOALIGNMENTFAULTEXCEPT标志。只要设置了该标志，系 统就会自动修正对错位数据的访问。一旦改变了该标志，就无法在进程的生命周期内再次 改变它。
注意，改变这个标志会影响到进程中所有的线程。换句话说，改变这个标志不会影响任何 其他进程中的线程。另外值得注意的一点是，进程的错误模式标志会被子进程继承。因此, 如果不希望让某个错误模式标志影响到子进程的话，可以在调用CreateProcess函数前将该 标志临时清零（虽然我们通常不会对SEM_NOALIGNMENTFAULTEXCEPT这样做，因 为该标志一旦设置之后就无法被清除）。
当然，我们可以在调用SetErrorMode时不管当前运行的CPU平台，而总是传递 SEM_NOALIGNMENTFAULTEXCEPT标志。但是，这样做的结果并不总是相同的。在 x86和x64系统上，该标志始终都是开启的而且无法被关闭。我们可以用Windows Reliability and Performance Monitor（可靠性和性能监视器）工具来查看系统每秒修正错位数据的次数。 下图显示了如何在Add Counters（添加计数器）对话框中将该计数器加到图表中。
第13章 Windows内存体系结构
这个计数器实际上显示的是每秒钟内CPU通知操作系统发生错位数据访问的次数。如果在 x86机器上观察该计数器，我们会发现它始终都是0。这是因为x86 CPU自己对错位数据 的访问进行了修正，所以没有通知操作系统。在x86平台下，由于是CPU而不是操作系统 对错误进行修正，因此它对性能的影响要优于以软件的方式(Windows操作系统的代码)来 对错误进行修正。我们可以看到，只需调用SetErrorMode就足以让应用程序正确运行了。 但这个解决方案的效率显然并不是最好的。
392
IA-64版本的Microsoft Visual C/C++编译器支持一个叫_unaligned的特殊关键字。除了 _unaligned修饰符只能用于指针变量之外，我们可以像使用const或volatile修饰符一样 来使用它。当通过一个^_unaligned修饰符的指针访问数据时，编译器会认为数据未经对 齐，并生成额外的CPU指令以访问数据。下面的代码是前面的代码经过修改后的版本。新 版本使用了_unaligned关键字：
VOID SomeFunc(PVOID pvDataBuffer) (
// The first byte in the buffer is some bye of information
char c = * (PBYTE) pvDataBuffer；
// Increment past the first byte in the buffer pvDataBuffer = (PVOID)((PBYTE) pvDataBuffer + 1);
idows核心编程(第5版)
// Bytes 2-5 contain a double-word value
DWORD dw = * (_unaligned DWORD *) pvDataBuffer;
// The line above causes the compiler to generate additional
// instructions so that several aligned data accesses are
// performed to read the DWORD.	.
// Note Chat a data misalignment exception is not raised.
与让CPU捕获对错位数据的访问并由操作系统来修正错误相比，让编译器生成额外代码来 修正错误的效率仍然要高得多。实际上，如果我们观察Alignment Fix叩s/sec计数器，会发 现通过未经对齐的指针访问数据并没有在图表中起什么作用。需要注意的是，即使在数据 已对齐的情况下，编译器也会生成额外的指令，使得代码的执行效率在这种情况下会有所 降低。
最后，x86版本的Microsoft Visual C/C++编译器不支持_unaligned关键字。我猜想可能是 因为CPU本身修正错误的速度很快，所以Microsoft认为没有必要再支持_unaligned关键 字。但这同时意味着x86版本的编译器在遇到_Unaligned关键字时会报错。因此，如果打 算在创建应用程序时使用同样的源代码，那么最好不要使用_Unaligned关键字，而是使用 UNALIGNED 和 UNALIGNED64 宏。UNALIGNED*宏在 WinNT.h 中的定义如下：
#if defined(_M_MRX000) I I defined(_M_ALPHA) I I defined(_M_PPC) It defined(_M_IA64) I I defined(_M_AMD64)
ttdefine ALIGNMENT_MACHINE
# de fine' UNALIGNED _unaligned
#if defined(_WIN64)
ttdefine UNALIGNED64 _unaligned
#else
#define UNALIGNED64
ttendif
#else
#undef ALIGNMENT_MACHINE
ttdefine UNALIGNED
#define UNALIGNED64
#endif

-m
296-
、、宫。0/ r
Air

第14
探索虚拟内存


14.3	NUMA机器中的内存管理
14；4确定地址空间的状志
第13章讨论了系统如何管理虚拟内存，每个进程如何得到自己专有的地址空间，以及进程 的地址空间看起来是什么样子。本章我们将从抽象转到具体，通过分析一些Windows函数 来了解与系统内存管理和进程中虚拟地址空间相关的信息。
14.1系统信息
操作系统中有许多值是由系统所运行的主机决定的，如页面大小和分配粒度等。我们绝对 不应该在代码中将这些值写死(将这些值硬编码到代码中)，而是应该在进程初始化时取得 这些值，然后在代码中使用它们。GetSystemlnfo函数用来取得与主机相关的值：
VOID GetSystemlnfo(LPSYSTEM_INFO psi);
我们需要传一个SYSTEMJNFO结构的地址给这个函数。该函数会对数据结构中的所有成 员进行初始化，然后返回。下面是SYSTEMJNFO数据结构的定义：
typedef struct _SYSTEM_INFO (
union {
struct {
WORD wProcessorArchitecture；
WORD wReserved;
};
);
DWORD dwPageSize；
LPVOID IpMinimumApplicationAddress;
LPVOID 1pMax i mumApp1i ca t i onAddre s s;
DWORD_PTR dwActiveProcessorMask;
DWORD dwNumberO £ Proces sors;
DWORD dwProcessorType；
DWORD dwAllocationGranularity;
WORD wProcessorLevel;
WORD wProcessorRevision；
} SYSTEM.INFO, *LPSYSTEM_INFO;
启动时，系统会确定这些值应该是多少。对一个给定的系统来说，由于这些值始终都是不
I^^dows垓心编程（第5版）	_
I 变的，因此在任何一个进程中只需调用该函数一次就足够了。正因为有了 GetSystemlnfo 函数，使得应用程序能够在运行的时候查询这些值。SYSTEMJNFO数据结构的所有成员 中，只有4个成员与内存有关。表14.1列出了这4个成员。
表 14-1 SYSTEMJNFO 的成员
成员	描述
dwPageSize	表示CPU页面的大小。在x86和x64机器中，该值为4096 字节，在IA-64机器中，该值为8192字节
IpMinimumApplicationAddress	给出每个进程可用地址空间中最小的内存地址。由于每个进 程的地址空间中最开始的64 KB始终是闲置的，因此该值为 65536,或 0x00001000
IpMaximumApplicationAddress	给出每个进程的私有地址空间中最大的可用内存地址
dwAllocationGranularity	表示用于预订地址空间区域的分配粒度。在写作本书时，该 值在所有Windows平台上都是65536
SYSTEM_INFO数据结构的其他成员与内存管理完全没有关系。出于完整性的考虑，我们 在表14-2中对它们进行介绍。
表14・2 SYSTEMJNF0中与内存无关的成员
成员	描述
wReserved	为今后扩展而保留，请勿使用
dwN u m berOfProcessors	表示机器中CPU的数量。注意，在装有双核处理器的机器上，该值为2
dwActiveProcessorMask	一•个位掩码，用来表示哪些CPU处于活动状态（可以用来运行线程）
dwProcessorType	巳经作废，请勿使用
wProcessorArchitecture	表示处理器的体系结构，比如x86、x64或IA-64
wProcessorLevel	进一步细分处理器的体系结构，比如表示Intel奔腾III或奔腾IV。如果需要 确定CPU支持哪些特性，我们应该调用IsProcessorFeaturePresent函数，而 不是使用这个字段
wProcessorRevision	进一步对wProcessorLevel进行细分
提示 如果想要得到机器中与处理器有关的详细信息，那么我们可以调用
GetLogicalProcessorlnformation函数，如下面这段代码所示：
void ShowProcessors() (
PSYSTEM_LOGICAL_PROCESSOR_INFORMATION pBuffer = NULL;
DWORD dwSize = 0;
DWORD procCoreCount；
BOOL bResult = GetLogicalProcessorInformation(pBuffer, &dwSize)； if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) (
(TEXT("Impossible to get processor information\n"))；
第14章探索虚拟内存
return；	・
}
pBuffer = (PS?STEM_LOGICAL_PROCESSOR_INFORMATION)malloc(dwSize); bResult =? rstLogicalProcessorInformation(pBuffer, &dwSize)； if (!bResuit) (
free(pBuffer);
__tprintf(TEXT("Impossible to get processor information\n"))； return；
}
procCoreCount = 0;
DWORD IpiCount = dwSize / sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION); for(DWORD current = 0； current < IpiCount； current++) (
if (pBuffer[current].Relationship == RelationProcessorCore) {
if (pBuffer[current].Processorcore.Flags == 1)(
_tprintf(TEXT(" + one CPU core (HyperThreading)\n"))；
} else (
_tprintf(TEXT(" + one CPU socket\n"))；
}
procCoreCount + +;
}
}
_tprintf(TEXT(" -> %d active CPU(s)\n"), procCoreCount);
free(pBuffer)；
)
为了让32位应用程序也能在64位版本的Windows上运行，Microsoft提供了一个称为 Windows 32-bit On Windows 64-bit的模拟层，又称WOW64。当32位应用程序通过WOW64 运行时,GetSystemlnfo返回的值和它在64位应用程序中运行所返回的值可能会有所不同。 例如，如果所运行的机器是IA-64,那么在前一种情况下，SYSTEM_INFO结构的 dwPageSize字段的值会是4 KB,而在后一种情况下，它的值会是8 KB。如果想要知道进 程是否在WOW64 ±运行，那么可以调用下面的函数：
BOOL IsWow64Process(
HANDLE hProcess,
PBOOL pbWow64Process)；
第一个参数是我们感兴趣的进程的句柄，比如GetCurrentProcess的返回值，也就是当前 正在运行的应用程序。如果IsWow64Process返回FALSE,那么最常见的原因就是把一些 无效的值用作了参数。如果函数返回TRUE,那么当32位应用程序在32位版本的Windows 下运行，或64位应用程序在64位版本的Windows下运行时，pbWow64Process参数指向 的布尔值会被设为FALSEo只有当32位应用程序在WOW64上运行时该布尔值才会被设 为TRUEo在这种情况下，我们需要调用GetNativeSystemInfo来取得原来的 SYSTEMJNFO 结构：
void GetNativeSystemInfo(
LPSYSTEM_INFO IpSystemlnfo);
我们也可以不调用IsWow64Process,而是调用ShlWApi.h中定义的IsOs函数，并以 OS_WOW6432为参数。如果IsOs返回TRUE,那么该32位应用程序是通过WOW64在

indows核心编程(第5版)
运行。如果返回值为FALSE,那么该32位应用程序是在32位Windows系统下以本机码 的方式运行。
说明 如果想进一步了解64位Windows提供的32位模拟层，建讲看一看以下网址提供的 Best Practices for WOW64 白皮书：
http://www.microsoft.com/whdc/system/platfbrm/64bit/ WoW64 bestprac.mspx
系统信息示例程序
下面列出了 Syslnfo.cpp的源代码，它是一个非常简单的程序，调用GetSystemlnfo并把返 回的SYSTEMJNFO结构显示出来，仅此而己。
这个应用程序的源代码和资源文件可以在与本书配套的网页下载，它在14-SysInfo目录中。 图14-1显示了 Syslnfb应用程序在不同平台上的运行结果。
Processor Architocture:
Processor tevet Processor revision: Number of proceuors: Active processor mask: Allocation granulemty: Page size: Minimum app. address Maximum app. address:
Intel Pentium Pro or Pentium II Model 13, Stepping 8 1 0x0000000000000001 65.536
4伽 00010000 7FFEFFFF
(a) 32位应用程序在32位Windows上运行
(b) 32位应用程序在一台装有双核处理器的
32位Windows机器上运行
Procettor Archlectue: Processor levet Processor revision: Number of processors: Active processor mask: Afocdbon granularity: Page 血 Mbwnum app. address: Maximum app. address:
Intel
Pentium 4
Model 12 Stepping。
1
0x0000000000000001
65,536
<096
00010000
7FFEFFFF
	
ProcetsorArcMecture:	AMD64
Procostoc lovot	15
rrocetMf revision.	Model M. Pan 0
Number of processors:	1
Active procettor matk:	0x0000000000000001
Alocdtion graniMy:	65^36
Page size:	<096
Mninxm 4pp. dddmsz	0000000000010000
Maximum app. address:	000007FFFFFEFFFF
(c) 32位应用程序在64位Windows上运行
(d) 64位应用程序在64位Windows上运行
图14・1不同平台上的运行结果
398
Syslnfo.cpp /***★***•******•******************** Module: Syslnfo.cpp
Notices： Copyright (c) 2008 Jeffrey
/* See Appendix A. */
#include .\CommonFiles\CmnHdr.h"
第14章探索虚拟内存
#include
#include #include #include
<windowsx.h>
<tchar.h> <stdio.h> "Resource.h"
#include <StrSafe.h>
///////////////////////////////////////////////////////////////////////////////
// This function accepts a number and converts it to a
// string, inserting commas where appropriate.
PTSTR BigNumToString(LONG iNum, PTSTR szBuf, DWORD chBufSize) (
.
TCHAR szNum[100];
StringCchPrintf(szNum, _countof(szNum), TEXT(, iNum);
NUMBERFMT nf;
nf.NumDigits = 0;
nf.LeadingZero = FALSE;
nf.Grouping = 3;
nf.IpDecimalSep = TEXT(".■);
nf.IpThousandSep = TEXT("<");
nf.Negativeorder = 0;
GetNumberFormat(LOCALE_USER_DEFAULT/ 0, szNum, &nf, szBuf, chBufSize); return(szBuf);
}
///////////////////////////////////////////////////////////////////////////////
void ShowCPUInfo(HWND hWndr WORD wProcessorArchitecture, WORD wProcessorLevel, WORD wProcessorRevision) {
TCHAR szCPUArch[64] = TEXT(-(unknown);
TCHAR szCPULevel[64] = TEXT("(unknown)");
TCHAR szCPURev[64] =. TEXT(*(unknown)");
switch (wProcessorArchitecture) (
// Notice that AMD processors are seen as PROCESSOR_ARCHITECTURE_INTEL.
// In the Registry, the content of the "VendorIdentifier" key under
// HKEY-LOCAL_MACHINE\HARDWARE\DESCRIPTION\System\CentralProcessor\0
// is either "Genuinelntel" or ■AuthenticAMD"
//
// Read http：//download.intel.com/design/Xeon/applnots/24161831.pdf
// for Model numeric codes.	、
// http：//www.amd.com/us-en/assets/content_type/white_jpapers_ancLtech_docs/ // 20734.pdf should be used for AMD processors Model numeric codes.
// ・
case PROCESSOR_ARCHITECTURE_INTEL s
_tcscpy_s(szCPUArch, __countof(szCPDArch), TEXT(■Intel■))； switch (wProcessorLevel) ( case 3: case 4:
StringCchPrintf(szCPULevel, _countof(szCPUL^vel), TEXT(■80%c86*), wProcessorLevel + '01)；
StringCchPrintf(szCPURev, _countofCazCPURev)> TEXT(・%c%d"), HIBYTE(wProcessorRevision) + TEXT(•A'),
LOBYTE (wProcessorRevision)拊：!、冗.！ < 心顼]	"技彖京
break ；	,	；' ' * :，;处：*
case 5:	'厂我
_tcscpy_s (szCPULevel, _countof (szCPULevej^&gXT( "Pentium-).力:： StringCchPrint f (szCPURev,
TEXT("Model %d. Stepping %d"),
HIBYTE(wProcessorRevision), LOBYTE(wProcessorRevision))；
jndows核心编程（第5版）
break；
客逐？心泰?"	茶!: M * • n：角世华 ,； , ： ； .*》/, £人.::勺命&「：.'：泌*": n牛艺勺%d«
case 6:	/
switch (HIBYTE(wProcessorRevision)) ( // Model case 1:
_tcscpy_s(szCPULevel, _countof(szCPULevel), TEXT("Pentium Pro"))；
break；
case 3:
case 5:
_tcscpy__s (szCPULevel, _countof (szCPULevel), TEXT("Pentium II*))；
break；
case 6:
_tcscpy_s(szCPULevel, _countof(szCPULevel), TEXT(-Celeron*))；
break；
case 7:
case 8：
case 11:
_tcscpy_s(szCPULevel, _countof(szCPULevel), TEXT(-Pentixim III-));
break；
case 9:
case 13：
X^tcscpy.s(szCPULevel, _countof(szCPULevel), TEXT(-Pentium M"));
break；
case 10：
_tcscpy__s (szCPULevel, _countof (szCPULevel), TEXT("Pentium Xeon*))；
break；
case 15： _tcscpy__s(szCPULevel, _countof (szCPULevel), TEXT("Core 2 Duo-));
break；
default:
_tcscpy_s(szCPULevel, _covmtof(szCPULevel), TEXT("Unknown Pentium*))； break；
}
StringCchPrintf(szCPURev, _countof(szCPURev), TEXT (-Model *d. Stepping 牝・)，	:
HIBYTE(wProcessorRevision), LOBYTE(wProcessorRevision))； break；
case 15：	W涉:盘.出_
_tcscpy_s(szCPULevel, _countof(szCPULevel), TEXT("Pentium 4-))；
StringCchPrintf (szCPURev,i _countof (szCPURev) > 7^4^ text (-Model %d, stepping	:瀚襟警j
HIBYTE(wProcessorRevision)S li BYTE(wProcessorRevision)); break；
break；
case PROCESSOR_ARCHITECTURE_IA64:	•盘
_tcscpy_s(szCPUArch, _countof(szCPUArchs, StringCchPrintf(szCPULevel, _countof
TEXT ("%d" ), wProcessorLevel) ；	»
StringCchPrintf(szCPURev, .countof(szCPURevf, TEXT(-Model %c. Pass %d"),
第14章探索虚拟内存
HIBYTE(wProcessorRevision) + TEXT(* A'), LOBYTE(wProcessorRevision));
break；
case PROCESSOICARCHITECTURE^AMD64:
_tcscpy_s(szCPUArch/ —countof(szCPUArch), TEXT(-AMD64-))； StringCchPrintf(szCPULevel, _countof(szCPULevel),
TEXT(), wProcessorLevel);
StringCchPrintf(szCPURev, _countof(szCPURev), TEXT("Model %cr Pass %d・)， HIBYTE(wProcessorRevision) + TEXT('A'),
LOBYTE(wProcessorRevision));
break;
case PROCESSOICARCHITECTURE_UNKNOWN: default:
_tcscpy_s(szCPUArch, _coimtof(szCPUArch), TEXT("Unknown"))； break；
)
SetDlgltemText(hWnd, IDC^PROCARCH, szCPUArch);
SetDlgltemText(hWnd, IDC_PROCLEVEL, szCPULevel);
SetDlgltemText(hWnd, IDC_PROCREV, szCPURev)；
}
void ShowBitness ^HWND hWnd) (
TCHAR szFullTitlellOO];
TCHAR szTitle[32);
GetWindowText(hWnd# szTitle, _countof(szTitle));
#if defined(_WIN32)
BOOL bISWow64 = FALSE;
if (IIsWow64Process(GetCurrentProcess(), &b!sWow64)) ( chFAIL("Failed to get WOW64 state.■)； return；
}
if (bIsWow64) (
StringCchPrintf(szFullTitle, __countof(szFullTitle), TEXT("32-bit %s on WOW64-), szTitle);
} else {
StringCchPrintf(szFullTitle, _countof(szFullTitle), TEXT(B32-bit %s on 32-bit Windows")/ szTitle)；
}
#elif defined(_WIN64)
// 64-bit applications can only run on 64-bit Windows, // so there is nothing special to check except the // _WIN64 symbol set by the compiler.
StringCchPrintf(szFullTitle, .countof(szFullTitle), TEXT("64-bit %s"), szTitle);
#endif
SetWindowText(hWnd, }
///////////////////////////////////////////^^l//////////////////////////////
bool Dlg_OnInitDialog(HWND hWnd, HWND hWndFocus, LPARAM 1Param) (
chSETDLGICC^S(hWnd# IDI_SYSINFO);
SYSTEM-INFO sinf; GetSystemlnfo(&sinf);
indows核心编程（第5版）
ShowCPUInfo(hWnd, sinf.wProcessorArchitecture, sinf.wProcessorLevel, sinf.wProcessorRevision)；
TCHAR szBuf[50];
SetDlgltemText(hWnd, IDC_PAGESIZE,
BigNumToString(sinf.dwPageSize, szBuf, _countof(szBuf)));
StringCchPrintf(szBuf, _countof(szBuf), TEXT("%p"), sinf.IpMinimumApplicationAddress)；
SetDlgltemText(hWnd, IDC_MINAPPADDR, szBuf);
StringCchPrintf(szBuf, _countof(szBuf), TEXT(■%p"), sinf.IpMaximumApplicationAddress)；
SetDlgltemText (hWnd, IDC__MAXAPPADDRr szBuf);
StringCchPrintf(szBuf, ..countof(szBuf)/ TEXT("0x%016l64XB),
(_int64) sinf.dwActiveProcessorMask)；
SetDlgltemText(hWnd, IDC_ACTIVEPROCMASK, szBuf);
SetDlgltemText(hWndr IDC_NUMOFPROCS,
BigNumToString(sinf.dwNumberOfProcessorsr szBuf, _countof(szBuf)))；
SetDlgltemText (hWnd, IDC-^ALLOCGRAN,
BigNumToString(sinf.dwAllocationGranularity, szBuf, _countof(szBuf)))；
ShowBitness(hWnd);
return (TRUE)；
}
///////////////////////////////////////////////////////////////////////////////
void Dlg_OnCommand(HWND hWnd, int id, HWND hWndCtl, UINT codeNotify) ( switch (id) (
case IDCANCEL：
EndDialog(hWnd, id)；
break；
}
///////////////////////////////////////////////////////////////////////////////
INT.PTR WINAPI Dlg_Proc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM iParam) ( switch (iiMsg) (
chHANDLE_DLGMSG(hDlg, WMLINITDIALOGr Dlg_OnInitDialog); chHANDLE_DLGMSG(hDlg, WWLCOMMAND, Dlg_OnCommand);
}
return (FALSE) ；	：
〃//////〃//////〃//////////〃///////〃//〃〃〃〃/〃/〃〃/〃切////////////////
int WINAPI _tWinMain(HINSTANCE hlnstExe/ HINSTANCE," PTSTR, int)畛.
DialogBox (hlnstExe r MAKEINTRESOURCE(IDD__sySWO>^ NULL, Dlg^Proc);
return(0) ；	" ％U 部拓:疆麟"[伊.:
第14章探索虚拟内存
//////////////////////////////// End of File //////////////////////////////////
/399~404 梦
14.2虚拟内存状态
A
Windows函数GlobalMemoryStatus可以用来取得当前内存状态的动态信息:
VOID GlobalMemoryStatus(LPMEMORYSTATUS IpBuffer)；
在我看来，这个函数的命名很糟糕 lobalMemoryStatus意味着该函数在某种程度上与 16位Windows中的全局堆有关。依我之见，它应该叫VirtualMemoryStatus之类的名字。
在调用GlobalMemoryStatus函数时，我们需要传一个MEMORYSTATUS结构的地址作 为参数。MEMORYSTATUS数据结构的定义如下：
typedef struct _MEMORYSTATUS {
DWORD dwLength；
DWORD dwMemoryLoad；
SIZE_T dwTotalPhys;
SIZE_T dwAvailPhys;
SIZE_T dwTotalPageFile;
SIZE..T dwAvailPageFile;
SIZE_T dwTotalVirtual;
SIZE_T dwAvailVirtual；
} MEMORYSTATUS, *LPMEMORYSTATUS;
在调用GlobalMemoryStatus函数之前，我们必须初始化dwLength成员，将其设为 MEMORYSTATUS结构的大小——即结构所占的字节数。这样的初始化使Microsoft能在 今后版本的Windows中给该结构添加更多的成员，而不必担心会破坏已有的应用程序。在 调用GlobalMemoryStatus时，该函数会对结构中的其他成员进行初始化，然后返回。下 一节的VMStat示例程序介绍了结构的各个成员及其含义。
如果预计应用程序会在装有4GB内存的机器上运行，或者页交换文件的大小可能会大于
4 GB,那么就应该调用新的GlobalMemoryStatusEx函数：
BOOL GlobalMemoryStatusEx(LPMEMORYSTATUSEX pmst);
404
我们需要传一个新的MEMORYSTATUSEX结构的地址作为参数:
typedef struct _MEMORYSTATUSEX { DWORD dwLength； DWORD dwMemoryLoad; DWORDLONG DWORDLONG DWORDLONG DWORDLONG DWORDLONG DWORDLONG DWORDLONG
} MEMORYSTATUSEX, *LPMEMORYSTATUSEX;
ullTotalPhys； ullAvailPhys； ullTotalPageFile； ullAvailPageFile； ullTotalVirtual; ullAvailvirtual； ullAvailExtendedVirtual；
除了所有表示大小的成员都变成了 64位，因而能够容纳大于4 GB的值之外，这个结构与
原来的MEMORYSTATUS完全相同。最后一个成员ullAvailExtendedVirtual表示的是在
indows核心编程(第5版)
当前进程的虚拟地址空间中尚未被预订的那一大块内存地址空间的大小。该成员只对特定 配置中特定类型的CPU体系结构才有意义。
14.3 NUMA机器中的内存管理
正如在第7章提到的，非统一内存访问(Non-Unifbrm Memory Access,后面简称为NUMA) 机器中的CPU既能访问自己节点的内存，也能访问其他节点的内存。但是，对CPU来说, 访问自己节点的内存比访问外节点的内存要快得多。在默认情况下，当线程调拨物理存储 器时，操作系统会尽量用CPU自己节点的内存来支持物理存储器，以提高内存访问的性能。 但是，如果没有足够的内存，那么Windows也会使用外节点的内存来支持物理存储器。
在调用GlobaiMemoryStatusEx函数时，在ullAvailPhys参数中返回的值是所有节点可用 内存的总量。如果要知道某个特定NUMA节点的内存数量，那么可以调用下面的函数：
BOOL GetNumaAvailableMemoryNode(
UCHAR uNode,
PULONGLONG pulAvailableBytes);
参数uNode用来标识节点，参数pulAvailableBytes所指向的LONGLONG变量用来返回 该节点的内存数量。只需调用GetNumaProcessorNode函数，我们就可以轻易地知道一个 CPU驻留在哪个NUMA节点中：
BOOL GetNumaProcessorNode(
UCHAR Processor,
PUCHAR NodeNumber);
可以通过调用下面的函数来得到系统中节点的总数：
BOOL GetNumaHighestNodeNumber(PULONG pulHighestNodeNumber)；
对任何一个指定节点来说，它的值介于0和pulHighestNodeNumber参数所指变量的值之 间。我们可以调用下面的函数来得到驻留在某个节点中的CPU列表：
BOOL GetNumaNodeProcessorMask(
UCHAR uNode,
PULONGLONG pulProcessorMask)；
参数uNode是节点的数字标识，参数pulProcessorMask所指向的LONGLONG变量用来 返回位掩码。如果某一位被设置，那么与该位对应的CPU就属于该节点。
正如前面已经说过，为了提高性能，Windows会自动地尽其所能将线程及其内存放在同一 个节点中。但是，Windows也提供了一些函数，供开发人员手工地控制线程和内存关联 (memory affinity)o (g多信息，请参阅第15章。)
要想进一步/解更多与Windows中的NUMA相关的信息，请参阅http://www.microsoft.com/ whdc/system/platfbrm/server/datacenter/numa_isv.mspx 处的“ Application Software Considerations for NUMA-Based Systems "和 MSDN 上的"NUMA Support ” (http://msdn2.microsoft.com/en-us/library/aa363804.aspx)o
第14章探索虚拟内存
示例程序：虚拟内存状态
VMStat应用程序（14-VMStat.exe）会显示一个对话框并列出调用GlobalMemoryStatus函数 的结果。对话框内的信息会每秒更新一次，因此你可以一边处理系统中的其他进程，一边 让它继续运行。这个应用程序的源代码和资源文件可以在与本书配套的网页下载，它在 14-VMStat目录中。下图显示了在装有1 GB内存的Windows Vista机器上，VMStat应用程 序的运行结果。
1	三—丁	
Memory load TotdPhy«: TotaPageFie: AvaiPageFile: TotaK/irtual: Ava»/irtuat	34 1072627712 698777600 24141127S8 1741586432 2147352576 2106437632
Workings et	4276 K
PrivateBytes:	1164K
dwMemoryLoad成员（显示为Memory Load）给出了一个大致估计，告诉我们内存管理系统 有多忙。它可以是从0〜100之间的任何数值。用来计算该值的算法在每个版本的Windows 中都有所不同。在实际情况中，这个值没有什么用处。
dwTotalPhys成员（显示为TotalPhys）表示物理内存的总量，以字节为单位。在这台装有1 GB 内存的机器上，它的值为1 072 627 712,正好比1 GB少了 1 114 112个字节。
GlobalMemoryStatus函数返回的物理内存数量之所以少于1 GB,是因为系统在启动过程 中会为非页面缓冲池保留一部分内存。甚至连内核都不能使用这些内存。dwAvaUPhys成 员（显示为AvailPhys）表示可分配的内存总量，以字节为单位。
dwTotalPageFHe成员（显示为TotalPageFile）表示硬盘上的页交换文件最多能存放多少字节 的数据。虽然VMStat显示页交换文件当前为2 414 112 768字节，但系统可以根据需要增 大或减小页交换文件。dwAvailPageFile成员（显示为AvailPageFile）表示页交换文件中的 1 741 586432字节尚未被调拨给任何进程，可供有需要的进程使用。
dwTotalVirtual成员（显示为TotalVirtual）表示地址空间中为各进程私有的那部分的字节数。 值2 147 352 576正好比2 GB 少了 128 KB。从0xOOOOOOOO〜OxOOOOFFFF和从Ox7FFFOOOO〜 0x7FFFFFFF的这两个分区，应用程序是不能访问的，这也解释了少掉的128 KB到哪里 去了。
对调用GlobalMemoryStatus函数的进程来说，最后一个成员dwAvailVirtual（显示为 AvaUVirtual）是数据结构中唯一与该进程有关的成员一一所有其他成员适用于整个系统， 也就是说无论哪个进程调用GlobalMemoryStatus函数，这些成员返回的值都是相同的。
核心编程（第5版）
为了计算这个成员的值，GlobalMemoryStatus会把调用进程的地址空间中所有闲置的区域 都加起来。dwAvailVirtual的值为2 106 437 632,表示还有这么多闲置的地址空间可供 VMStat使用。如果用dwTotalVirtual减去dwAvailVirtual,我们可以看到VMStat总共在 它的地址空间中预订了 40 914 944字节。
没有哪个成员能够表示当前进程正在使用的物理存储器的数量。我们把一个进程的地址空 间中被保存在内存里的那些页面称为它的工作集（workingset）o对一个给定进程来说，下面 的函数可以取得进程当前工作集的大小和最大工作集的大小，该函数在psapi.h中定义： BOOL GetProcessMemorylnfo（
HANDLE hProcesS/
PPROCESS_MEMORY_COUNTERS ppmc,
DWORD cbSize）;
hProcess是我们感兴趣的进程的句柄，该句柄必须具备PROCESS_QUERY_ INFORMATION和PROCESS_VM_READ访问权限。对当前正在执行的进程来说， GetCurrentProcess会返回一个满足此条件的伪句柄。参数ppmc指向一个 PPROCESS_MEMORY_COUNTERS结构，该结构的大小通过参数cbSize来指定。如果 GetProcessMemorylnfo返回TRUE,那么下面的结构会包含与指定进程有关的详细信息： typedef struct _PROCESS_MEMORY_COUNTERS_EX （
DWORD cb;
DWORD PageFauLtCount；
SIZE_T PeakWorkingSetSize;
SIZE_T WorkingSetSize；
SIZE_T QuotaPeakPagedPoolUsage；
SIZE_T QuotaPagedPoolUsage；
SIZE_T QuotaPeakNonPagedPoolUsage；
SIZE_T QuotaNonPagedPoolUsage;
SIZE_T Pagef ilellsage；
SIZE_T PeakPage f ileUsage;
SIZE_T Privateusage；
} PROCESS_MEMORY-COUNTERS_EX,
*PPROCESS_MEMORY_COUNTERS_EX;
407
WorkingSetSize 字段（显示为 WorkingSet）包含了当 GetProcessMemorylnfo 被调用时， hProcess所标识的进程正在使用的字节数。PeakWorkingSetSize字段包含了自该进程开始 运行以来，它曾使用过的内存数量的最大值。
知道进程的工作集的大小是极其有用的，因为它可以告诉我们一旦程序到达稳定状态会需 要使用多少内存。将应用程序的工作集减到最少有助于提高性能。正如我们可能知道的， 如果一个Windows应用程序运行得比较慢，那么为了提高它的性能，我们（作为一个最终 用户）所能采取的最好方法就是给机器添加内存。虽然Windows能够把内存页面换出到磁 盘，也能把磁盘上的页面换入到内存，但这是以牺牲性能为代价的。添加内存意味着 Windows可以减少换出和换入的次数，也就是提高了性能。作为一个开发人员，我们能够 控制我们的应用程序在任一时刻需要多少内存，削减程序对内存的需求将带来性能的提升。
在对应用程序的性能进行调整时，除了工作集之外，我们还应该知道自己的应用程序通过 调用new, malloc或VirtualAlloc函数，显式地分配了多少内存。这也正是PrivateUsage
第14章探索虚拟内存
字段(显示为PrivateBytes)所返回的数量。本章剩余的部分会介绍其他一些函数，它们能够 帮助我们更清楚地了解进程地址空间。
说明 如果希望进一步了解现有可以用来监视操作系统和进程内存的API,请参阅“Memory
Performance Infbrmation,\ 网址为 http://msdn2.microsoft.com/en-us/library/aa965225.aspXo
14.4确定地址空间的状态
Windows提供了一个函数，可以用来查询与地址空间中的内存地址有关的特定信息(比如大 小、存储器类型以及保护属性)。我们已在第13章中见过两个虚拟内存映射表(表13.4和 表13.6)。实际上，这两个表就是本章稍后所介绍的VMMap实例程序用这个函数生成的。 这个函数是VirtualQuery：
DWORD VirtualQuery(
LPCVOID pvAddress,
PMEMORY_BASIC_INFORMATION pmbi,
DWORD dwLength);
Windows同时还提供了另外一个函数，允许一个进程查询另一个进程的内存信息:
DWORD VirtualQueryEx(
HANDLE hProcess,
LPCVOID pvAddress,
PMEMORY_BASIC_INFORMATION pmbi,
DWORD dwLength)；

VirtualQueryEx允许我们传递一个进程句柄，以此来告诉函数要查询哪个进程的地址空 间。除此之外，前面两个函数完全相同。对于VirtualQueryEx函数，使用最频繁的莫 •过于调试器和一些工具软件——几乎其他所有应用程序只需要用到VirtualQueryo在调用
VirtualQuery(Ex)®数时，必须在参数pvAddress中给出需要查询的虚拟内存地址。参数 pmbi指向一个必须由调用者分配的MEMORY_BASIC_INFORMATION结构。该结构在 WinNT.h中定义如下：
cypedef struct _MEMORY_BASIC_INFORMATION (
PVOID BaseAddress;
PVOID AllocationBase；
DWORD AllocationProtect;
SIZE_T Regionsize;
DWORD State;
DWORD Protect；
DWORD Type;
) MEMORY_BASIC_INFORMATION, * PMEMORY_BASIC_INFORMATION;
最后一个参数dwLength用来指定 MEMORY_BASICJNFORMATION结构的大小。 VirtualQuery(Ex)的返回值是它复制到缓存中的字节数①。
礴409
①译注：即pmbi所指向的结构。
昂dows核心编程(第5版)
VirtualQuery(Ex)会在参数 pvAddress 指向的 MEMORY_BASIC_INFORMATION 结构中 填入与相邻页面区间有关的信息，这些相邻页面具有相同的状态、保护属性和类型。表14-3 对结构的各成员进行了介绍。
表 14-3 MEMORY_BASICJNFORMATION 结构的成员
成员	描述
BaseAddress	它的值等于将参数pvAddress向下取整到页面的大小
Allocation Base	标识出区域的基地址，该区域包含参数pvAddress所指定的地址
AllocadonProtect	标识出在最开始预订区域时为该区域指定的保护属性
RegionSize	标识出区域的大小，以字节为单位。区域的起始地址为BaseAddress,区域中的所 有页面拥有相同的保护属性、状态以及类型
State	标识出区域中页面的状态(MEM_FREE, MEM_RESERVE或MEM_COMMIT)。 如果状态为 MEM_FREE,那么 AllocationBase > AllocadonProtect s Protect 及 Type 成员都没有意义。如果状态为MEM RESERVE,那么Protect成员没有意义
Protect	针对所有相邻的页面(前提是其保护属性、状态和类型与其中包含pvAddress参数 中所指定地址的页面相同)，标识出它们的保护属性(PAGE*)
Type	标识出区域中页面的类型(MEM IMAGE, MEM MAPPED或MEM PRIVATE)
409涂
14.4.1	VMQuery 函数
刚开始学习Windows的内存体系结构时，我将VirtualQuery函数当作我的向导。事实上, 如果读者翻阅本书的第1版，会发现那时的VMMap示例程序比现在的版本简单得多。在 旧的版本中，我用了一个简单的循环来重复调用VirtualQuery,在每次调用后我会创建一 行，其中包含了 MEMORY__BASIC_INFORMATION结构的成员。然后我一边参考SDK 文档(当时还很糟糕)，一边斯结果进行分析，试图将整个内存管理体系结构拼起来。自那 以后我又学到了许多。虽然VirtualQuery和MEMORY_BASIC_INFORMATION结构能 够帮助我们更深刻地理解Windows的内存管理，但现在虱知道，它们提供的信息尚不足以 让我们透彻地理解。
问题在于MEMORY.BASICJNFORMATION结构并没有返回系统保存在内部的所有信 息。如果想要了解一些关于某个内存地址的简单信息，那么VirtualQuery就够用了。举个 例子，如果想要知道有没有给某个地址调拨物理存储器，或者是否能读取某个内存地址， 或者是否能写入某个内存地址，那么用VirtualQuery正好。但如果想知道某个已预订区域 的大小，或者某个区域中块的数量，或者某个区域是否包含有线程栈，那么光是调用 VirtualQuery是无法得到我们想要了解的信息的。
为了得到更完整的内存信息，我创建了自己的VMQuery函数：
BOOL VMQuery(
HANDLE hProcess,
第14章探索虚拟内存
LPCVOID pvAddress, PVMQUERY pVMQ);
这个函数与VirtualQueryEx相似，参数中都包含一个进程句柄(hProcess)> 一个内存地址 (pvAddress)以及一个用来返回信息的结构指针(pVMQ)o这个VMQUERY结构也是我自 己定义的：
typedef struct (
// Region information
PVOID pvRgnBaseAddress;
DWORD dwRgnProtection； // PAGE_*
SIZE_T RgnSize；
DWORD dwRgnStorage； // MEM_*: Free, Image, Mapped, Private
DWORD dwRgnBlocks；
DWORD dwRgnGuardBlks； // If > 0, region contains thread stack
BOOL bRgnlsAStack；	// TRUE if region contains thread stack
// Block information
PVOID pvBlkBaseAddress；
DWORD dwBlkProtection; // PAGE_*
SIZE_T BlkSize；
DWORD dwBlkStorage； // MEM_*: Free, Image, Mapped, Private
} VMQUERY, *PVMQUERY;
我们一眼就能看到，VMQUERY结构包含的信息比Windows的MEMORY_BASIC_ INFORMATION结构包含的信息更多。该结构由两个不同的部分组成：区域信息和块信 息。其中区域那部分用来描述与区域相关的信息，而块那部分用来描述与块相关的信息。 表14-4对VMQUERY结构的所有成员进行了介绍。
* 410M11 %
表14V VMQUERY结构的成员
成员	描述
pvRgnBaseAddress	表示虚拟地址空间区域的起始地址，该区域包含了参数pvAddress所指定的地址
dwRgnProtection	表示在最开始预订地址空间区域时为该区域指定的保护属性(PAGE*)
RgnSize	表示所预订区域的大小，以字节为单位
dwRgnStorage	表示用于区域中各块的物理存储器的类型。它可以是以下任一值：MEM_FREE, MEMJMAGE, MEM_MAPPED 或 MEM_PRIVATE
dwRgnBlocks	表示区域中块的数量
dwRgnGuardBlks	表示区域中具有PAGE_GUARD保护属性标志的块的数量。通常这个值要么是0, 要么是如果为1,那么这是个很好的指示，可以告诉我们该区域是为了线程 栈而预订的
bRgnlsAStack	表示该区域是否包含线程栈。该值是通过近似猜测得到的，因为没有任何方法能 够百分之百地肯定一个区域中是否包含线程栈
pvBlkBaseAddress	表示块的起始地址，该块包含了参数pvAddress所指定的地址
dwBlkProtection	表示块的保护属性
BlkSize	表示块的大小，以字节为单位
dwBlkStorage	表示块的存储器类型。它可以是以下任一值：MEM_FREE, MEM_RESERVE, MEMJMAGE, MEM MAPPED 或 MEM PRIVATE
阳dows核心编程（第5版）	.
亳无疑问，为了获得所有这些信息，VMQuery必须进行大量的处理，其中包括多次调用 VirtualQueryEx 这也意味着它执行起来要比VirtualQueryEx慢得多。由于这个原因， 在选择调用这两个函数中的哪一个时请仔细考虑。如果并不需要VMQuery提供的额外信 息，那么请调用 VirtualQuery 或 VirtualQueryExo
下面的VMQuery.cpp文件显示了该函数如何获得所有需要的信息，并根据它们来设置 VMQUERY结构的成员。VMQuery.cpp和VMQuery.h文件的源代码在本书配套网页的 14-VMMap目录中。我不打算在这里详细介绍如何对这些数据进行处理，贯穿在代码中的
注释足以说明问题。
VMQuery.cpp
/**********.**★★********.*★•**************************************.*************** Module: VMQuery,cpp
Notices： Copyright (c) 2008 Jeffrey Richter & Christophe Nasarre **************m*************************************** *★▲*•****•***** ** * /
#include ■..\CommonFiles\CmnHdr.h-	/* See Appendix A. */
#include <windowsx.h>
#include "VMQuery.h"
///////////////////////////////////////////////////////////////////////////////
// Helper structure
typedef struct (
SIZE_T RgnSize；
DWORD dwRgnStorage；	// MEM_*: Free, Image, Mapped, Private
'DWORD dwRgnBlocks；
DWORD dwRgnGuardBlks;	// If > 0, region contains thread stack
BOOL bRgnlsAStack；	// TRUE if region contains thread stack
} VMQUERY.HELP;
// This global, static variable holds the allocation granularity value for // this CPU platform. Initialized the first time VMQuery is called, static DWORD gs_dwAl1ocGran = 0;
///////////////////////////////////////////////////////////////////////////////
// Iterates through a region's blocks and returns findings in VMQUERY_HELP static BOOL VMQueryHeIp (HANDLE hProcess, LPCVOID 口丁上品
VMQUERY_HELP *pVMQHelp) (	成寒麝露翳味.
ZeroMemory (pVMQHelp, sizeof (
// Get address of region containing passed memory address.
MEMORY_BASIC_INFORMATION mbi;
BOOL bOk = (VirtualQueryEx(hProcess, pvAddress, &mbi, sizeof(mbi))
==sizeof (mbi))；	:株知.玲
if (!bOk)
return(bOk)；	// Bad memory address# return failure

// Walk starting at the region * s base address (which never changes) PVOID pvRgnBaseAddress = mbi.AllocationBase；
第14章探索虚拟内存
// Walk starting at the first block in the region (changes in the loop) PVOID pvAddressBlk = pvRgnBaseAddress;
// Save the memory type of the physical storage block. pVMQHelp->dwRgnStorage = mbi.Type；
for (;;) {
// Get in£o about the current block.
bOk = (VirtualQueryEx(hProcess, pvAddressBlk,	sizeof(mbi))
== sizeof(mbi));
if (!bOk)
break； // Couldn't get the information； end loop.
// Is this block in the same region?	粤
if (mbi.AllocationBase != pvRgnBaseAddress) break; // Found a block in the next region； end loop.
//We have a block contained in the region.
pVMQHelp->dwRgnBlocks+■♦-;	// Add another block to the region
pVMQHelp->RgnSize += mbi.Regionsize； // Add block's size to region size
// If block has PAGE_GUARD attribute, add 1 to this counter
if ((mbi.Protect & PAGE_GUARD) == PAGE_GUARD) pVMQHelp->dwRgnGuardBlks++；
// Take a best guess as to the type of physical storage committed to the // block. This is a guess because some blocks can convert from MEM_IMAGE //to MEM..PRIVATE or from MEMLMAPPED to ME1CPRIVATE; MEM^PRIVATE can // always be overridden by MEMLIMAGE or MEJCHAPPED.
if (pVMQHelp->dwRgnStorage == MEM_PRIVATE) pVMQHelp->dwRgnStorage = mbi.Type；
// Get the address of the next block.
pvAddressBlk = (PVOID) ((PBYTE) pvAddressBlk + mbi.Regionsize);
// After examining the region, check to see whether it is a thread stack // Windows Vista： Assume stack if region has at least 1 PAGE_GUARD block pVMQHeIp->bRgnIsAStack = (pVMQHeIp->dwRgnGuardBlks > 0);
return(TRUE);
///////////////////////////////////////////////////////////////////////////////
BOOL VMQuery(HANDLE hProcess, LPCVOID pvAddress, PVMQUERY pVMQ) (
(IbOk) return(bOk)
ZeroMemory(pVMQ, sizeof(*pVMQ))
SYSTEM_INFO sinf;
Get Sys temln fo(&sinf)； gs__dwAl locGran = sinf .dwAllocationGranularity
// Get the MEMORY_BASIC__INFORMATION for the passed address. MEMORY_BASIC_INFORMATION mbi;
BOOL bOk = (VirtualQueryEx(hProcess, pvAddress, &mbi, sizeof(mbi)) ==sizeof(mbi))；
indows核心编程（第5版）
// The MEMORY_BASIC_INFORMATION structure contains valid information.
// Time to start setting the members of our own VMQUERY structure.
// First# fill in the block members. We * 11 fill the region members later, switch (mbi.State) (
case MEM_FREE:	// Free block (not reserved)
pVMQ->pvB1kBaseAddres s = NULL;
pVMQ->BlkSize = 0;
pVMQ->dwBlkProtection = 0; pVMQ->dwBlkStorage = MEM_FREE; break；
case MEM_RESERVE： // Reserved block without committed storage in it. pVMQ->pvBlkBaseAddres s = mbi.BaseAddress;
pVMQ->BlkSize = mbi.Regionsize；
// For an uncommitted block, mbi.Protect is invalid. So we will JI show that the reserved block inherits the protection attribute // of the region in which it is contained.
pVMQ->dwBlkProtection = mbi.AllocationProtect；
pVMQ- >dwBl kSt orage = MEM^^RESERVE;
break；
case MEM_COMMIT:	// Reserved block with committed storage in it.
pVMQ->pvB1kBaseAddres s = mbi.BaseAddress;
pVMQ->BlkSize = mbi.Regionsize；
pV>^->dwBlkProtect ion = mbi.Protect； pVMQ->dwBlkStorage = mbi.Type； break；
default:
DebugBreak();
break；
// Now fill in the region data members. VMQUERY_HELP VMQHelp； switch (mbi.State) (
// Free
case MEbLFREE: pVMQ->pvRgnBaseAddress = pVMQ->dwRgnProtection = pVMQ->RgnSi z e	=
pVMQ->dwRgnStorage = pVMQ->dwRgnBlocks = pVMQ->dwRgnGuardBlks = pVMQ->bRgnIsAStack = break；
block (not reserved) mbi.BaseAddress;
mbi.AllocationProtect mbi.Regionsize； MEM__FREE;
0;
0;
FALSE;
case MEM_RESERVE:	// Reserved block without committed storage in it.
pVMQ->pvRgnBaseAddress = mbi.AllocationBase;
pVMQ->dwRgnProtection = mbi .AllocationProtect;.^
// Iterate through all blocks to get	~n.
VMQueryHelp(hProcess, pvAddress, &VMQHelp)；
=VMQHelp. RgnSize;.	:盘*
=VMQHelp. dwRgnSti(^嶙慈说匕湾蕊
=VMQHe Ip. dwRgnBl	砂涂筋麒粉瘢邑做
=VMQHelp.dwRgnGua诺眼，气野燃；铲” '，诚 =VMQHelp • bRgn—sASt 酒蕨?粼痹捋邀嵌;
pVMQ->RgnSize pVMQ->dwRgnStorage pVMQ->dwRgnBlocks pVMQ->dwRgnGuardBIks pVMQ->bRgnIsAStack break;
Reserved block with committed storage in it. 褰"':顼
case MEH_COMMIT:	//
pVMQ->pvRgnBaseAddres s = mbi.AllocationBase; pVMQ->dwRgnProt ect i on = mbi.AllocationProtect;
// Iterate through all blocks to get complete region iixferttation.
第14章探索虚拟内存
pvAddress, &VMQHelp);
VMQueryHelp(hProcess,
}
return(bOk)；
pVMQ->RgnSize pVMQ->dwRgnStorage pVMQ->dwRgnBlocks pVMQ->dwRgnGuardBlks pVMQ->bRgnIsAStack break；
VMQHeIp.RgnSize; VMQHelp.dwRgnStorage； VMQHelp.dwRgnBlocks； VMQHelp.dwRgnGuardBlks; VMQHelp.bRgnlsAStack；
default： DebugBreak()； break；
End of File ////////////////TV////////////////
14.4.2示例程序：虚拟内存映射
VMMap示例程序(14VMMap.exe)会遍历进程的地址空间，并列出区域及区域内的块。它的 源代码和资源文件在本书配套网页的14.VMMap目录中。程序启动后会显示下图所示的
窗口。
,00010000
00020000
00021000
00090000
00130000
00134000 100140000
00143000
001S0000
00151000
00160000
00165000
00170000
00172000
00180000
00181000 00190000 ;：00192000 ，001B0000
001C0000
OOIEOOOO 002E0000 003A8000 00400000 0041F000 :00420000 :0079E000
007A0000 |008A3000
008B0000 00BB0000 k00C30000 ，00C50000 .00C60000 I 00CD0000 -00CE0000
01Q5E000
pi 目 ipBplsiapapelpbp。!。 一arriarlaripaRarlarlarlirl
65S36 4096
61440
1048576 16384 491S2 12288 53248 4096
6aE P6P。« 1 0 i p a rMAaraAarrtrlrarl FIFMFWnFMPFFFPMFW
61440 20480 4S0S6 8192
57344 4096 61440 8192 122880 6S536 131072 1048576 819200 360448 126976 4096 3661824 8192
1060864
53248 3145728 524288 131072
65536 458752
65536 3661824 8192 r c c z
-RV-
-RVC
-R-
-RV
-R-
-RV
ERIC
—
-RV-
Thread Stack
-RV--RV-
\Devi cexHardd iskVolunelWi ndowsxSys tem3 2Xen-US\user 3 2
C：\Apps、14 VMMap.exe
\Devic©\HarddiskVoluMel\VindovsXSystt5M32\lcx^kle. nls
\Dev i coxHardd i skVoluael\VindowsxSyst ©m3 2\1ocale.nls

我就是根据VMMap运行的结果(即列表框中的内容)来生成表13.2和表13-3中所示的虚拟 内存映射表的。
Wows核心编程(第5版)
列表框中的每一行对应于一次调用VMQuery函数的结果。下面的这段代码就是主循环， 它在Refresh函数中：
BOOL bOk = TRUE;
PVOID pvAddress = NULL；
♦ ・ •
while (bOk) (
VMQUERY vmq；
bOk = VMQuery(hProcess, pvAddress, &vmq)；
if (bOk) (
// Construct Che line to be displayed, and add it to the list box.
TCHAR szLine[1024];.
ConstructRgnlnfoLine(hProcess, &vmq, szLine, sizeof(szLine));
ListBox_AddString(hWndLB, szLine)；
if (bExpandRegions) (
for (DWORD dwBlock = 0; bOk && (dwBlock < vmq.dwRgnBlocks)； dwBlock++) (
ConstructBlklnfoLine(&vmq, szLine, sizeof(szLine)); ListBox_AddString(hWndLB, szLine)；
// Get the address of the next region to test. pvAddress = ((PBYTE) pvAddress + vmq.BlkSize)； if (dwBlock < vmq.dwRgnBlocks - 1) (
// Don't query the memory info after the last block.
bOk = VMQuery(hProcess, pvAddress, &vmq)；
)
}
}
// Get the address of the next region to test. pvAddress = ((PBYTE) vmq.pvRgnBaseAddress + vmq.RgnSize);
)
)
整个循环从地址NULL开始，当VMQuery函数返回FALSE时结束，这表示该函数无法 再继续遍历进程的地址空间了。循环中的每一次迭代会调用ConstructRgnlnfoLine»用来 把与该区域有关的信息填写到一个字符缓冲区中。然后程序会把这些信息加到列表框中。
在主循环内还有一个嵌套循环，用来遍历区域内的每一块。循环中的每一次迭代会调用 ConstructBlklnfoLine,用来把区域中各块的信息填写到一个字符缓冲区中。然后程序会把 这些信息加到列表框中。我们可以看到，用VMQuery函数来遍历进程的地址空间非常容易。 在Windows Vista ±,如果在系统重启之后运行VMMap应用程序(或者比较VMMap应用 程序在两台不同的Windows Vista机器上的运行结果)，那么读者可能会发现有许多动态链 接库(dynamic-link library,后面简称为DLL)每次都会被载入到不同的地址。这是因为 Windows Vista 提供的一个名为地址空间布局随机化(Adilress Space Layout Randomization, 后面简称为ASLR)的新特性。该特性允许Windows在第一次载入一个DLL时，为它选择 一个不同的基地址。地址空间布局随机化的目的是为了让黑客们更难以发现常用系统DLL 的地址，以此来避免其中的代码被恶意软件利用。
例如，黑客们常常利用缓冲区溢出或栈溢出来强制程序跳转到系统DLL中一个已知的地 址。而有了 ASLR,这个地址碰巧正确的概率只有l/256o这显著降低了黑客们能够轻易地、
第14章探索虚拟内存
稳定地利用各种溢出的可能性。
在载入DLL时，系统内核会执行ASLR基地址重定位(ASLR rebase fixup),经过修改后的 页面为所有使用该DLL的进程所共享。也就是说，由于不需要对每个进程都执行ASLR基 地址重定位，因此内存的使用仍然是高效的。
说明 从Microsoft Visual Studio 2005 SP1开始，开发人员只要在构建自己的DLL和EXE 文件时使用/dynamicbase链接器开关，就能让它们也参与ASLR。事实上，如果预 计自己的DLL或EXE文件会被系统栽入到基地址以外的其他地址处，那么我建议 你使用这个开关，因为这种方法能让经过ASLR基地址重定位的页面为所有进程共 享，从而提高内存的使用率。
<415*416
第15章在应用程序中使用虚拟内存
虹垢心维聂■瓯23、鑫癌夜.瘗d 螭淆，；；；三.盘虞点容..,- ……― 本童内容	.,4*	/
»,*jf|*. <«MT,	f *fcI .» • • ' . ,»>• U 4 .,•« < w • •*.■?• Tfc^' ,« . V<r f. C 3k r； • -aw, tt .IC^. »1 ,, > • . « , • jTw •, • 。-— . • • <•	r	.
；3幼禺购赋曜心簸
15.2 萩M面•禳
源疝莉营注、"u”«
嚅！*病减赢i将矿f"字" f』；*. ” -
'气％5：5“ 赢甬宓赢航f最箱&' F "拈扳改变保护属性
15.7重置物理存储器的内容
15.8地址窗口扩展
Microsoft Windows提供了以下三种机制来对内存进行操控。
•	虚拟内存最适合用来管理大型对象数组或大型结构数组。
•	内存映射文件 最适合用来管理大型数据流（通常是文件），以及在同一机器上运行 的多个进程之间共享数据。
•	堆最适合用来管理大量的小型对象。
本章将讨论第一种方式，即虚拟内存。内存映射文件和堆将分别在第17章和第18章中进 行讨论。
Windows提供了一些用来操控虚拟内存的函数，我们可以通过这些函数直接预订地址空间 区域，给区域调拨（来自页交换文件的）物理存储器，以及根据自己的需要来设置页面的保 护属性。
15.1预订地址空间区域
我们可以调用VirtualAIloc函数来预订进程中的地址空间区域:
PVOID VirtualAIloc(
PVOID pvAddress,
SIZE_T dwSize,
DWORD fdwAllocationType,
DWORD fdwProtect);
第一个参数pvAddress是内存地址，用来告诉系统我们想要预订地址空间中的哪一块。由于 系统会记录所有闲置的地址区间，因此大多数时候我们只要给该参数传NULL就可以了。 这等于是告诉系统自动找一块闲置区域。系统可以在进程地址空间中的任何地方预订区域
第15章在应用程序中使用虚拟内存
——系统既不保证一定会从地址空间的底部往上分配，也不保证一定会从地址空间的顶部 往下分配。但是，通过使用本章稍后介绍的MEM_TOP_DOWN标志，我们可以在一定程 度上对地址空间区域的分配进行控制。
对大多数程序员来说，能够让系统在指定的内存地址预订区域是个不同寻常的概念。以前 分配内存时，为了满足我们的需要，操作系统会先找到一块足够大的内存并分配之，然后 返回这块内存的地址。但是由于现在每个进程有自己的地址空间，因此我们可以要求操作 系统在我们希望的内存地址预订区域。
举个例子，设想我们要在进程地址空间中第50 MB的地方分配区域。在这个例子中，我们 需要传52 428 800 (50 X 1024 X 1024)给pvAddress参数。如果这个内存地址有一块足够 大的闲置区域能满足我们的请求，那么系统会把这块区域一一也就是我们想要的区域—— 预订下来并返回。如果这个内存地址没有闲置区域，或者闲置区域不够大，那么系统将无 法满足我们的请求，这时VirtualAlloc会返回NULL。注意，传给pvAddress参数的地址 必须始终位于进程的用户模式分区中，否则VirtualAlloc会失败并返回NULL。
我们在第13章中已经提到过，系统始终都是按照分配粒度(到目前为止在所有Windows平 台上都为64KB)的整数倍来分配区域的。因此，如果我们想在进程地址空间中起始地址为 19 668 992 (300 X 65 536+ 8192)的地方预订区域，那么系统会把该地址向下取整到64 KB 的整数倍，也就是19 660 800(300 X 65 536),然后在取整后的地址预订区域。
如果VirtualAlloc能够满足我们的要求，那么它会预订一块区域并返回该区域的基地址。 如果我们还给VirtualAlloc指定了 pvAddress参数，那么VirtualAlloc的返回值就等于我 们传给pvAddress参数的值向下取整到64 KB的整数倍。
VirtualAlloc的第2个参数dwSize,用来指定我们想要预订的区域大小，以字节为单位。 由于系统始终都根据CPU页面大小的整数倍来预订区域，因此如果我们在页面大小为 4KB、8 KB或16 KB的机器上预订62 KB大小的区域的话，那么最终得到的区域大小会 是 64KBO
VirtualAlloc的第3个参数fdwAllocationType,用来告诉系统我们到底是要预订区域还是 要调拨物理存储器。(这种区分是必要的，因为VirtualAUoc也可以用来调拨物理存储器。) 要预订地址空间区域，我们就必须传MEM_RESERVE作为fdwAllocationType参数的值。
如果打算预订一块区域并且用很长一段时间，那么我们可能会希望系统从尽可能高的内存 地址来预订区域。这样，就可以防止在进程地址空间的中间预订区域，从而避免可能会引 起的内存碎片。
如果想让系统从尽可能高的内存地址来预订区域，那么我们必须传NULL给pvAddress参 数，同时对MEM_TOP_DOWN标志和MEM_RESERVE标志进行按位或操作，并把结果 作为fdwAllocationType参数传入。
最后一个参数fdwProtect,是给区域指定的保护属性。区域的保护属性对调拨给该区域的
Endows核心编程（第5版）
物理存储器不起任何作用。无论为区域指定什么保护属性，只要还没有给它调拨物理存储 器，试图访问区域内的任何内存地址都会引发访问违规。
在预订区域并指定保护属性时，应该考虑在调拨物理存储器时最常用的保护属性。例如， 如果我们想要使用PAGE_READWRITE保护属性来调拨物理存储器（到目前为止最常用的 保护属性），那么我们应该用PAGE.READWRITE保护属性来预订区域。当区域的保护属 性和将要调拨的物理存储器的保护属性相一致时，系统内部的处理效率会更高。
我们可以使用以下保护属性中的任何一个：PAGE_NO ACCESS, PAGE_RE AD WRITE, PAGE_READONLY, PAGE_EXECUTE, PAGE_EXECUTE_READ 或 PAGE_EXECUTE_ READWRITE o但是，我们既不能使用PAGE_WRFTECOPY属性，也不能使用 PAGE_EXECUTE_WRITECOPY属性。如果我们这样做的话，VirtualAUoc将不会预订 区域，而会返回NULLo同样，在预订区域时我们也不能使用保护属性标志PAGE_GUARD, PAGE_NOCACHE或PAGE_WRITECOMBINE——这些标志只能用来调拨物理存储器。
说明如果应用程序在非统一内存访问（NUMA）机器上运行，那么我们可以调用下面的函 数来强制系统在某个节点的物理内存中分配一部分虚拟内存，以此提升性能：
PVOID VirtualAllocExNuma（
HANDLE hProcess,
PVOID pvAddress,
SIZE_T dwSize,	'
DWORD fdwAllocationType,
DWORD fdwProtect,
DWORD dwPreferredNumaNode）；
VirtualAllocExNuma 函数有两个额外的参数 hProcess 和 dwPreferredNumaNode, 除此之外,它和VirtualAlloc函数完全相同。参数hProcess表示要给哪个进程预订 /调拨虚拟地址空间。（如果要对当前进程的虚拟地址空间进行操控，那么可以调用 GetCurrentProcess函数来得到当前进程的句柄。）参数dwPreferredNumaNode表 示应该使用哪个NUMA节点的物理内存。
有许多Windows函数可以帮助我们理清NUMA机器中节点和处理器之间的关系， 14.3节“NUMA机器中的内存管理”已经涵盖了这些函数。
15.2给区域调拨物理存储器
在预订了区域后，我们还需要给区域调拨物理存储器，这样才能访问其中的内存地址。系 统会从页交换文件中来调拨物理存储器给区域。在调拨物理存储器时，起始地址始终都是 页面大小的整数倍，整个大小也是页面大小的整数倍。
为了调拨物理存储器，我们必须再次调用VirtualAUoco但这次我们会传MEM_COMMIT 来作为第二个参数fdwAllocationType的值，而不是原来的MEM RESERVE在给物理
第15章 在应用程序中使用虚拟内存
存储器指定页保护属性的时候，通常我们使用的保护属性会和预订区域时相同(大多数情况 下是PAGE_READWRITE),但我们也可以指定一个完全不同的保护属性。
在己预订的区域中，我们“必须”告诉VirtualAlloc要调拨多少物理存储器给哪里。这是 •通过参数pvAddress和参数dwSize来指定的。前者表示想要调拨物理存储器给哪个内存地 址，后者表示物理存储器的数量，以字节为单位。值得注意的是，我们无须一下子给整个 区域都调拨物理存储器。
下面让我们来看一个如何调拨物理存储器的例子。假设我们的应用程序在x86 CPU上运行, 应用程序在地址5 242 880处预订了一块大小为512 KB的区域。现在我们希望给该区域从 2 KB地址开始的地方调拨6 KB的物理存储器。为了达到这个目的，我们使用 MEM_COMMIT标志来调用VirtualAlloc,如下所示：
VirtualAlloc((PVOID) (5242880 + (2 * 1024)), 6 * 1024,
MEM_COMMIT, PAGE_READWRITE);
在这种情况下，系统必须调拨8KB的物理存储器，它覆盖了从5 242 880到5 251 071 (5 242 880 + 8 KB - 1字节)之间的地址区间。这些调拨的页面都具有PAGE_READWRITE 保护属性。由于系统是基于整个页面来指定保护属性的，因此不可能出现同一物理存储页 面有不同保护属性的情况。但是，下面这种情况是完全有可能的，即区域中的一个页面有 一种保护属性(比如PAGE_READWRITE),而同一区域中的另一个页面有另一种不同的保 护属性(比如 PAGE_READONLY)。
15.3同时预订和调拨物理存储器
有时我们想要同时预订区域并给区域调拨物理存储器。只需调用VirtualAlloc 一次就能达 到这一目的，如下所示：
PVOID pvMem = VirtualAlloc(NULL, 99 * 1024,
MEM_RESERVE I MEM_COMMIT, PAGE_READWRITE);
这个调用要求预订一块大小为99 KB的区域，并给该区域调拨99 KB的物理存储器。系统 在处理这个调用时，会先搜索进程的地址空间，以找到一块足够大的闲置地址空间。在页 面大小为4KB的机器上，这总共需要25个页面，即100 KB；而在页面大小为8 KB的机 器上，这总共需要13个页面，即104KBo
系统需要搜索进程的地址空间，因为我们指定NULL作为参数pvAddress的值。如果我们 给参数pvAddress指定了一个内存地址，那么系统会检查该地址是否有足够的闲置地址空 间。如果系统无法找到足够闲置地址空间，VirtualAlloc会返回NULL。
如果系统能够找到一块合适的区域，就会预订区域并给整个区域调拨物理存储器。系统会 给区域和调拨的物理存储器都指定PAGE_READWRITE保护属性。
颤dows核心编程（第5版） 
Windows还提供了大页面支持，可以在处理大块内存的时候提升性能。这种情况下，系统 在分配内存时，不再使用GetSystemlnfo函数返回的SYSTEMJNFO结构中的dwPageSize 字段来作为分配粒度，而是使用下面的函数返回的大页面分配粒度：
SIZE_T GecLargePageMinimum（）；
注意，如果CPU不支持大页面分配，那么GetLargePageMinimum会返回0。如果要分配 的内存大于GetLargePageMinimum的返回值，那么就可以使用Windows大页面支持。只 要在分配内存时调用 VirtualAlloc 并将 MEM_LARGE_PAGE 标志与 fdwAllocationType 参数按位或起来即可。此外，还必须满足以下三个条件。
•	要分配的内存块的大小（即dwSize参数的值），必须是GetLargePageMinimum函数 的返回值的整数倍。
•在调用 VirtualAlloc 时，必须把 MEM_RESERVE | MEM_COMMIT 与 fdwAllocationType参数按位或起来。换句话说，我们必须同时预订和调拨内存， 我们不能先预订一块区域然后再给其中的一部分调拨物理存储器。
•	在用VirtualAlloc分配内存时必须传PAGE_READWRITE保护属性给fdwProtect 参数。
Windows认为用MEM_LARGE_PAGE标志分配得到的内存是不可换页的（unpagable）：也 就是说必须驻留在内存中。这也是为什么以这种方式分配得到的内存能提供更好的性能。 但由于内存是稀缺资源，用MEM_LARGE_PAGE标志调用VirtualAlloc需要调用方具有 内存中锁定页面（Lock Pages In Memory）的用户权限，否则函数调用会失败。默认情况下， 并不是任何用户或用户组都有这个权限的。如果想在一个交互式的应用程序中利用大页面, 那么在登录到计算机并运行应用程序之前，必须先让管理员分配这个权限。
要打开这个权限，可以执行以下操作。
（1）	在 Start（开始）菜单的 Administrative Tools（管理员工具）中打开 Local Security Policy（本地 安全策略）那一项。
（2）	在控制台左边的面板中，双击以展开以下各项：Security Settings（安全设置）和Local Policies（本地策略）。然后选择User Rights Assignment（用户权限分配）那一项。
（3）	在右边的面板中，选择Lock Pages In Memory（内存中锁定页面）属性。
（4）	从Action（操作）菜单中选择Properties（属性），以显示内存中锁定页面的属性对话框。单 击Add User Or Group（添加用户或组）按钮。对那些我们想要准许内存中锁定页面权限 的用户和/或用户组，可以使用Select Users Or Groups（选择用户或组）对话框来添加。 然后单击OK（确定）按钮退出各个对话框。
用户权限是在用户登录时给予的。如果管理员刚给予我们内存中锁定页面权限，那么我们 必须先退出登录，然后重新登录才能使之生效。请注意，除了在运行的时候启用了对应的 特权之外，应用程序必须通过提升运行权限的方式来运行，4.5节“管理员以标准用户权限 运行时”对此进行了详细介绍。
最后，VirtualAlloc会返回所预订区域的虚拟地址，这个地址随后被保存在pvMem变量中。
第15章在应用程序中使用虚拟内存
如果系统无法找到足够大的地址空间或无法调拨物理存储器，那么VirtualAlloc会返回 NULLo
当我们以这种方式来预订区域和调拨物理存储器时，给VirtualAlloc函数的pvAddress参 数指定一个地址仍然是可行的。当然我们也可以给pvAddress参数传NULL,并把 MEM_TOP_DOWN标志与fdwAllocationType参数按位或起来，这样就可以让系统从进 程地址空间的顶部向下寻找一块合适的区域。
15.4何时调拨物理存储器
假设我们正在实现一个电子表格应用程序，它支持200行、256列。对每一个单元格，我 们需要一个CELLDATA结构来描述单元格的内容。对二维数组单元格最简单的操作方法, 莫过于在我们的应用程序中声明下面的变量：
CELLDATA CellData[200][256];
如果CELLDATA结构的大小为128字节，那么这个二维数组将需要6 553 600 (200 X 256 X 128)字节的物理存储器。对一个电子表格应用程序来说，这意味着程序一开始运行就要 从页交换文件中分配大量的物理存储器。尤其是考虑到大多数用户只会在电子表格的少 数几个单元格中存放信息时，剩下的大部分单元格都没有用到。这样的内存使用率是非常 低的。
因此，一直以来，电子表格应用程序都是通过其他数据结构来实现的，比如链表。如果采 用链表这种方法，那么只有当电子表格的某个单元格中确实存放了数据时，才需要创建与 之对应的CELLDATA结构。由于电子表格中大多数的单元格都没有用到，因此这种方法 可以节省大量的物理存储器。但是，这种方法增大了读取单元格内容的难度。如果想要知 道位于第5行、第10列的单元格的内容，那么必须先遍历链表，找到对应的单元格，这使 得链表方法比直接声明数组的方法慢。
虚拟内存为我们提供了一种折衷方案。使用虚拟内存，我们既能享受数组方法所带来的快 速而便捷的访问，又能更好地节省存储器，就像使用链表技术那样。
为了能够利用虚拟内存技术，我们的程序需要执行以下步骤。
(1)	预订一块足够大的区域来容纳CELLDATA结构的整个数组。只预订区域是根本不会 消耗物理存储器的。
(2)	当用户在某个单元格中输入数据时，首先确定CELLDATA结构在区域中的内存地址。 当然，由于这时候还没有给该地址映射物理存储器，因此试图访问该内存地址将引发 访问违规。
(3)	给第2步中的内存地址调拨足够的物理存储器。(我们可以告诉系统只给区域中的某些 部分调拨物理存储器——区域既包含已映射到物理存储器的那部分，也包含尚未映射 到物理存储器的那部分。)
(4)	设置CELLDATA结构的成员。
idows核心编程（第5版）
现在物理存储器已经被映射到相应的位置，于是程序就可以访问存储器，而不必担心会引 发访问违规了。这项虚拟内存技术非常棒，因为只有当用户给电子表格单元格输入数据时 才会调拨物理存储器。由于电子表格中的大部分单元格都是空的，因此对所预订区域中的 大部分来说，不需要给它们调拨物理存储器。
虚拟内存技术存在的一个问题是，我们必须确定什么时候需要调拨物理存储器。如果用户 在一个单元格中输入数据，然后只是编辑或修改其中的数据，那么我们没有必要再调拨物 理存储器——因为在用户第一次输入数据时，我们己经给CELLDATA结构调拨了所需的 物理存储器。
另外，由于系统始终是按页面的粒度来调拨物理存储器的，因此当我们试图给一个 CELLDATA结构调拨物理存储器时（如前面第2步所示），系统实际上会给整个页面调拨物 理存储器。这听起来好像很浪费，但实际情况并非如此。给一个CELLDATA结构调拨物 理存储器相当于给其他相邻的CELLDATA结构调拨物理存储器。如果用户接着在相邻的 单元格中输入数据——通常都是这样——那么我们就不需要再调拨物理存储器了。 .
有以下四种方法可以用来确定是否需要给区域中的某一部分调拨物理存储器。
•	总是尝试调拨物理存储器。这种方法不检查区域中的某一部分是否已经映射了物理 存储器，而是每次都调用VirtualAlloc函数，尝试去调拨物理存储器。系统会先检 查是否已经调拨了物理存储器，如果是，它就不会再次调拨额外的物理存储器。这 种方法最简单，但它的缺点是每次对CELLDATA结构进行修改的时候都要多一次 函数调用，这降低了程序的性能。
•（使用VirtualQuery函数来）判断是否已经给CELLDATA结构调拨了物理存储器。 如果已经调拨过了，那么不需要做任何事情，但如果还没有调拨过，那么就调用 VirtualAlloc函数来调拨物理存储器。这种方法事实上比第一种方法还要糟糕：由 于额外调用了 VirtualQuery函数，它不但增加了程序的大小，而且还降低了程序
•的性能。
•	记录哪些页面己经调拨而哪些页面尚未调拨。这样可以使应用程序运行得更快：我 们不但避免了调用VirtualAlloc函数，而且能够比系统更快地判断是否已经调拨了 物理存储器。这种方法的缺点在于我们必须以某种方式记录页面的调拨信息，取决 于我们的实际情况，这可能非常简单，但也可能极其复杂。
•	使用结构化异常处理（structured exception handling,后面简称为SEH）-最佳方案。
SEH是操作系统的一项特性，它可以让系统在发生某种情况时通知我们的应用程 序。实质上，我们要做的就是给应用程序设置一个异常处理程序，然后当程序试图 访问尚未调拨物理存储器的内存地址时，系统会通知我们的应用程序。接着应用程 序就可以调拨物理存储器，并告诉系统再重新执行那条引发异常的指令。这时内存 访问会成功，程序继续运行，就仿佛从来没有发生过任何问题一样。由于这种方法 所需的工作量最少（意味着更少的代码），而且程序又能全速运行，因此该方法是最 佳的。第23〜25章对SEH机制做了完整的介绍。第25章中的电子表格示例程序
第15章在应用程序中使用虚拟内存
展示了如何使用虚拟内存，它采用的方法和刚才描述的方法完全一样。
15.5撤销调拨物理存储器及释放区域
要撤销调拨给区域的物理存储器，或是释放地址空间中的一整块区域，可以调用
VirtualFree 函数：
BOOL VirtualFree(
LPVOID pvAddress,
SIZE_T dwSize,
DWORD fdwFreeType)；
先来看一个简单的例子，用VirtualFree来释放己预订的区域。如果进程不再需要访问区域 中的物理存储器，那么我们只需调用VirtualFree一次，就能够释放整个区域以及调拨给该 区域的物理存储器。
在调用时，pvAddress参数必须是区域的基地址。该地址就是预订区域时VirtualAUoc返回 的地址。给定一个内存地址，系统可以知道位于该地址处的区域的大小，由于这个原因， 我们可以传0给dwSize参数。实际上，我们必须传。给dwSize参数，否则VirtualFree 会失败。我们必须传MEM_RELEASE给第3个参数fdwFreeType,来告诉系统撤销调拨 给该区域的所有物理存储器，并释放区域。当释放区域时，我们必须释放为该区域预订的 所有地址空间。例如，我们不能先预订128 KB的区域，然后释放其中的64KBO我们必须 释放整个128 KB的区域。
如果想要撤销调拨给区域的一部分物理存储器，但又不想释放整个区域，那么我们也还是 调用VirtualFree函数。为了撤销调拨物理存储器，我们必须传一个内存地址给VirtualFree 函数的pvAddress参数，用来告诉系统我们想要撤销调拨的第一个页面的地址。我们在 dwSize参数中指定想要释放的物理存储器的大小，并传MEM_DECOMMIT给 fdwFreeType 参数。
和调拨物理存储器一样，撤销调拨物理存储器也是基于页面粒度的。也就是说，如果给定 的内存地址位于一个页面的中间，那么系统会撤销调拨整个页面。同样，如果pvAddress + dwSize也位于一个页面的中间，那么系统会撤销调拨包含该地址的整个页面。因此，给定 地址区间pvAddress到pvAddress + dwSize,系统会撤销调拨覆盖该地址区间的所有页面。
如果dwSize为。而pvAddress又是区域的基地址，那么VirtualFree会撤销调拨给该区域 的所有页面。一旦系统撤销了调拨给页面的物理存储器，所释放的物理存储器就可以用于 系统中的其他进程，试图访问已撤销调拨的内存地址将引发访问违规。
15.5.1何时撤销调拨物理存储器
在实践中，想知道何时能够安全地撤销调拨物理存储器是需要一些技巧的。让我们再来看
indows核心编程（第5版）
一下电子表格示例。如果应用程序在x86机器上运行，那么存储页面的大小就是4KB,每 个页面可以存放32 （4096/128）个CELLDATA结构。如果用户删除了 CellData|0]|l]的内 容，只要CellData[0][0]到Ce】lDm[0][31|之间的所有单元格都不用了，我们就可以撤销调 拨该物理存储页。但我们怎样才能知道这些单元格还有没有用呢？我们可以通过下面几种 不同的方法来解决这个问题。
•	毫无疑问，最简单的解决方案就是将CELLDATA结构设计得正好等于一个页面的 大小。接下来，由于每个页面有且只有一个结构，因此当不再需要某个结构中的数 据时，我们就可以直接撤销调拨给该页面的物理存储器。在X86CPU上，即使我们 的数据结构是8KB或12 KB（我们很少会用到这么大型的结构），撤销调拨内存仍然 是相当容易的。当然，为了使用这种方法，我们必须在定义数据结构时使它的大小 跟目标CPU平台的页面大小相一致，但这通常不符合我们的编程习惯。
•	另一种更为实用的解决方案是记录哪些结构正在使用。为了节省内存，我们可以用 一个位图。如果有一个包含100个结构的数组，那么我们需要同时维护一个包含100 个位的数组。一开始，所有的位都被设为0,表示没有使用任何结构。当用到任何 结构时，我们把对应的位设为1。然后，当不再需要某个结构时，我们把对应的位 重新设为0。我们同时检查位于同一内存页面中的相邻结构所对应的各个位。如果 同一页面中所有的相邻结构都不需要了，那么我们就可以撤销调拨该页面。
•	最后一种解决方案是实现一个垃圾收集函数。这种方法依赖于一个事实，那就是系 统在第一次调拨物理存储器时，会把页面中所有的字节都清为0。为了使用这种方 法,我们必须在结构中留出一个BOOL成员（让我们称它为blnUse）。然后，每次 把结构放到己调拨的内存中时，我们需要确保把blnUse设为TRUE。
在应用程序运行的时候，会定期调用垃圾收集函数。该函数会遍历所有潜在的数据结构并 检查是否已经给各个结构调拨过物理存储器。如果己经调拨过，那么该函数会检查blnUse 成员，看是否为0。如果为0,这表示该结构没有被用到。如果blnUse成员的值为TRUE, 那么这表示该结构还在使用中。一旦垃圾收集函数检查完一个给定页面中的所有结构，并 发现所有的结构都没有被使用，那么它会调用VirtualFree来撤销调拨物理存储器。
每当我们觉得不再需要使用某个结构时，我们可以立即调用垃圾收集函数，但这样做可能 会耗费更多的时间，因为该函数会遍历所有结构。实现该函数的一种极佳的方式是让它作 为一个低优先级的线程来运行。在这种方式中，我们没有占用主应用程序运行的时间。当 主应用程序闲置时，或主应用程序的线程在执行文件操作时，系统就可以给垃圾收集函数 调度时间，并让它执行。
在刚才列出的所有方法中，前面两种方法是我个人最喜欢的。但是，如果结构比较小（小于 一个页面的大小），则建议使用最后一种方法。
15.5.2虚拟内存分配示例程序
VMAlloc.cpp代码清单展示了如何用虚拟内存技术来操控结构数组。应用程序的源代码和
第15章在应用程序中使用虚拟内存
资源文件在本书配套网页的15.VMAlloc目录中。启动该程序会显示下图所示的窗口。
Page size 4 KB [	i
Index(0-49). [oj [ 典 ][如b^ecotteci
Memory map
White: Free	Grey: Reserved Black Committed
刚开始，如图中的Memory Map部分所示，我们没有为数组预订任何的地址空间区域，所 有待预订的地址空间都还是闲置的。当单击Reserve Region (50, 2 KB Structures)按钮时， VMAlloc会调用VirtualAlloc函数来预订区域，并更新内存映射图以反映这一操作的结果。 当VirtualAlloc预订了区域后，剩下的各个按钮会被启用。
现在我们可以在编辑框中输入一个索引值，然后单击Use按钮。这相当于为指定的数组元 素所在的内存地址调拨物理存储器。当物理存储页调拨完成后，程序会重新绘制内存映射 图，以反映整个数组中所预订区域的状态。因此，如果在预订区域后单击Use按钮将元素 7和元素46标记为正在使用(in use),那么得到的窗口看起来会如下图所示(如果程序在页面 大小为4 KB的机器上运行)。
单击Clear按钮会清除任何被标记为正在使用的元素。但这样做并不会撤销调拨已经映射 到数组元素的物理存储器。这是因为每个页面可以容纳多个结构，只清除其中一个结构并 不代表页面中的其他结构也被清除了。假如程序真的撤销调拨内存的话，那么存放在其他 结构中的数据也会丢失。由于单击Clear按钮并不影响区域的物理存储器，因此程序在清 除数组元素时是不会更新内存映射图的。
但是，当清除一个结构时，它的blnUse成员会被设为FALSE。这样的设定是必要的，只 有这样垃圾收集函数才能遍历所有结构并撤销调拨不再使用的物理存储器。如果还没有猜 到的话，我现在可以告诉你，Garbage Collect按钮会让VMAlloc执行它的垃圾收集函数。 为了简单起见，我没有用另外一个单独的线程来实现垃圾收集函数。
为了演示--下垃圾收集函数，让我们清除索引值为46的数组元素。注意，内存映射图并没 有发生变化。现在单击Garbage Collect按钮。程序会撤销调拨给元素46的物理存储器，并
Endows核心编程（第5版）
更新内存映射图以反映这一操作的结果。现在的窗口看起来如下图所示。注意，由于作者 在实现这个函数时，特意让它能够处理由任何大小的数据结构所组成的数组，也就是说结 构的大小不必正好是页面的大小，因此读者可以轻易地将GarbageCollect函数用于自己的 应用程序。唯一的要求是结构的第一个成员必须是一个BOOL值，用来表示该结构是否正 在使用。
最后，虽然程序在关闭窗口时没有显示什么看得见的信息，但事实上它会撤销所有已调拨 的内存，并释放已预订的区域。
关于这个示例程序，我们还有一点尚未介绍，即程序会在下面三个地方确定地址空间区域 中内存的状态。
•	在更改索引后，程序需要启用Use按钮并禁用Clear按钮，反之亦然。
•	在垃圾收集函数中，程序在检查blnUse标志之前需要检查是否已经调拨了物理存 储器。
•	在更新内存映射图时，程序需要知道哪些页面是闲置的，哪些页面己预订，而哪些• 已经调拨物理存储器。
VMAHoc通过调用前一章所介绍的VirtualQuery函数来执行所有这些测试。
VMA11OC.CPP /********★*★*************************************★********************•***★**** Module： VMAlloc.cpp
Notices: Copyright (c) 2008 Jeffrey Richter & Christophe Nasarre
**m********************m********************m*************n*
#include •..\CommonFiles\CmnHdr.h-#include <WindowsX.h>
#include <tchar.h>
#include "Resource.h"
#include <StrSafe.h>
Z///////////Z//////////////////////////////////////////////////7///////////////
// The number of bytes in a page on this host machine. UINT g_uPageSize = 0;
t •* W-	.
移顶
// A dummy data structure used for the array. typedef struct {
BOOL blnUse；
第15章 在应用程序中使用虚拟内存
BYTE bOtherData[2048 - sizeof(BOOL)]; } SOMEDATA, *PSOMEDATA;
// The number of structures in the array
#define MAX_SOMEDATA (50)
// Pointer to an array of data structures
PSOMEDATA g_pSomeData = NULL；
// The rectangular area in the window occupied by the memory map RECT g_rcMemMap;
///////////////////////////////////////////////////////////////////////////////
BOOL Dlg_OnInitDialog(HWND hWnd, HWND hWndFocus, LPARAM 1Param) ( chSETDLGICONS(hWnd, IDI_VMALLOC);
// Initialize the dialog box by disabling all the nonsetup controls.
EnableWindow(GetDlgltem(hWnd, IDC_INDEXTEXT)r FALSE); EnableWijidow(GetDlgItem(hWnd, IDC_INDEX) z FALSE); EnableWihdowCGetDlgltemChWnd, IDC_USE), FALSE); EnableWindow(GetDlgltem(hWnd, IDC_CLEAR), FALSE); EnableWindow(GetDlgItem(hWnd, IDC_GARBAGECOLLECT), FALSE);
// Get the coordinates of the memory map display.
GetWindowRect (GetDlgltemChWnd, IDC_MEMMAP) , &g__rcMejnMap);
MapWindowPoints(NULL, hWnd, (LPPOINT) &g__rcMemMap, 2);
// Destroy the window that identifies the location of the memory map DestroyWindow(GetDlgItem(hWnd, IDC_J4EMMAP));
// Put the page size in the dialog box just for the user1s information. TCHAR szBuf[10];
StringCchPrintf(szBuf, _countof(szBuf), TEXT("%d KB"), g__uPageSize / 1024); SetDlgltemText(hWnd, IDC_PAGESIZE, szBuf);
// Initialize the edit control.
SetDlgltemlnt(hWnd, IDC_INDEX, 0, FALSE);
return(TRUE)；
}-
///////////////////////////////////////////////////////////////////////////////
void Dlg_OnDestroy(HWND hWnd) (
/ dwStructSize； UINT ulndexLast = ulndex + g_uPageSize / dwStructSize；
g__uPageSize; uPage++) (
UINT uMaxPages = dwNum * dwStructSize / for (UINT uPage = 0； uPage < uMaxPages； BOOL bAnyAlIocsInThisPage = FALSE; UINT ulndex = uPage * g_uPageSize
if (g_pSomeData != NULL)
VirtualFree(g_pSomeData, 0, MEM_RELEASE):
///////〃///////〃/////////////〃/////////〃////////////////7〃/〃Z/〃〃〃/〃//
VOID GarbageCollect (PVOID pvBase, DWORD dwNum, DWORD dwStructSizei.> '
..•I	rd： I	-
indows核心编程（第5版）
for (； ulndex < ulndexLast； ulndex++) ( MEMORY_BASIC_INFORMATION mbi;
VirtualQuery (&g__pSomeData [ulndex], &mbi, sizeof (mbi)); bAnyAllocsInThisPage = ((mbi.State == MEM_COMMIT) &&
* (PBOOL) ((PBYTE) pvBase + dwStrnctSize * ulndex));
// Stop checking this page, we know we can't decommit it. if (bAnyAllocsInThisPage) break；
}
if (!bAnyAllocsInThisPage) (
// No allocated structures in this page; decommit it.
VirtualFree(&g_pSomeData[ulndexLast - 1], dwStructSize, MEM_DECOMMIT)； }
}
}
///////////////////////////////////////////////////////////////////////////////
void Dlg_OnCommand(HWND hWndr int id, HWND hWndCtl, UINT codeNotify) (
UINT ulndex = 0；
switch (id)(
case IDCANCEL:
EndDialog(hWnd, id);
break；
case IDC_RESERVE:
// Reserve enough address space to hold the army of structures. g_j)SomeData = (PSOMEDATA) VirtualAlloc(NULL,
MAK-SOMEDATA * sizeof(SOMEDATA), MEM_RESERVE, PAGE^READWRITE);
// Disable the Reserve button EnableWindow(GetDlgItem(hWnd, EnableWindowCGetDlgltemfhWnd/ EnableWindow(GetDlgItem(hWnd, EnableWindow(GetDigitem(hWnd, EnableWindowfGetDlgltemfhWnd,
// Force the index edit contr< SetFocus(GetDlgItem(hWndr IDC.
and enable all the other controls. IDC_RESERVE),	FALSE);
IDC.INDEXTEXT),	TRUE);
IDC_INDEX),	TRUE);
IDC_USE),	TRUE);
IDC__GARBAGECOLLECT) , TRUE);
1 to have the focus.
INDEX));
// Force the memory map to update InvalidateRect(hWnd, &g_rcMemMap, FALSE); break;
case IDC_INDEX:
if (codeNotify != EN_CHANGE) break;
ulndex = GetDlgltemlnt(hWnd, id, NULL, FALSE); if ((g__pSomeData !=]
MEMORY_BASIC_INFORMATION mbi;	燮
VirtualQuery(&g_pSomeData[ulndex], &mbi, sizeof(mbi) BOOL bOk = (mbi.State == MEM_COMMIT);
if (bOk)
bOk = g__pSomeData [ulndex] .blnUse；
NULL) && chINRANGE(Or ulndex, MAXJ$OMEDA1«g^ J：(
EnableWindow(GetDlgltemfhWnd, EnableWindow(GetDlgltemfhWnd,
IDC^USE), IbOk); IDC_CLEAR), bOk);
} else (
EnableWindow(GetDlgItem(hWnd,
IDC_USE), FALSE);
==
第15章在应用程序中使用虚拟内存
EnableWindowfGetDlgltemthWnd, IDC^CLEAR), FALSE); } break;
case IDC_USE:
UIndex = GetDlgltemint(hWnd, IDC_TNDEX, NULL, FALSE);
// NOTE： New pages are always zeroed by the system VirtualAlloc(&g__pSomeData[ulndex], sizeof(SOMEDATA), MEM_COMMIT, PAGE顼EADWRITE);
g_pSomeData[ulndex].blnUse = TRUE;
EnableWindow(GetDlgltemfhWnd, IDC_USE),	FALSE);
EnableWindow(GetDlgItem(hWndr IDC__CLEAR) ,	TRUE);
// Force the Clear button control to have the focus. SetFocus(GetDlgItem(hWnd, IDC^CLEAR));
// Force the memory map to update InvalidateRect(hWnd, &g_rcMemMap, FALSE); break；
case IDC_CLEAR:
ulndex = GetDlgltemlnt(hWnd, IDC^INDEX, NULL, FALSE); g__pSomeData [ulndex] .blnUse = FALSE；
EnableWindow (GetDlgltemfhWnd, IDC^USE),	TRUE);
EnableWindow(GetDlgltem(hWndr IDC^CLEAR),	FALSE);
// Force the Use button control to have the focus.
SetFocus(GetDlgltem(hWnd, IDC_USE))k break；
case IDC_GARBAGECOLLECT:
GarbageCollect(g_pSomeData, MAX__SOMEDATA, sizeof(SOMEDATA));
// Force the memory map to update
InvalidateRect(hWnd, &g_rcMemMap, FALSE)； break;
}
}
///////////////////////////////////////////////////////////////////////////////
void Dlg_OnPaint (HWND hWnd) (	// Update the memory map
PAINTSTRUCT ps；
BeginPaint(hWnd, &ps)；
HINT uMaxPages = MAX_SOMEDATA * sizeof (SOMEDATA) / g_uPageSize; UINT uMemMapWidth = g_rcMemMap.right - g_rcMemMap.left；
if (g^pSomeData == NULL) (	'
// The memory has yet to be reserved.
Rectangle(ps.hdc, g_rcMemMap.left, g_rcMemMap.top, rcMemMap.right - uMemMapWidth % uMaxPages, g_rcMemMap.bottom);
} else (
// Walk the virtual address space, painting the memory map 专就 for (UINT uPage = 0； uPage < uMaxPages; uPage++) (
UINT ulndex = uPage * g_uPageSize / sizeof(SOMEDATA);
UINT ulndexLast = ulndex + g_uPageSize / sizeof(SOMEDATA);
lows核心编程（第5版）
for (; ulndex < ulndexLast; ulndex++) (
MEMORY_BASIC__INFORMATICW mbi;
VirtualQuery (&g__pSomeData[ulndex], &mbi, sizeof (mbi));
int nBrush = 0;
switch (mbi.State) {
case MEM_FREE: nBrush = WHITE_BRUSH; break; case MEM_RESERVE: nBrush = GRAY_BRUSH; break; case MEhLCOMMIT: nBrush = BLACJBRUSH; break;
}
Selectobject(ps.hdc, GetStockObject(nBrush))； Rectangle(ps.hdc,
g_rcMemMap.left + uMemMapWidth / uMaxPages * uPage, g_rcMemMap.top,
g^rcMemMap.left + uMemMapWidth / uMaxPages * (uPage + 1), g_rcMemMap. bottom);
}
)
}
EndPaint(hWnd, &ps);
///////////////////////////////////////////////////////////////////////////////
INT_PTR WINAPI Dlg_Proc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM 1Param) (
switch (uMsg) (
chHANDLEJDLGMSG(hWnd, WK.INITDIALOG, chHANDLEJDLGMSG(hWnd, WM_COMMAND, chHANDLEJDLGMSG (hWnd, WM__PAINT, chHANDLEJDLGMSG(hWnd, WH_DESTROY,
}
return(FALSE)；	,
Dlg_OnInitDialog)； Dlg_OnCommand); Dlg__OnPaint)； Dlg__OnDestroy);
///////////////////////////////////////////////////////////////////////////////
int WINAPI _tWinMain(HINSTANCE hlnstExe, HINSTANCE, PTSTR, int)(
// Get the page size used on this CPU.
SYSTEJC.INFO si;
GetSystemInfo(&si);
g_uPageSize = si.dwPageSize；
DialogBox (hlnstExe, MAKE〔NTRESOURCE(IDD_VMALLOC), NU讶噩舞g_Proc);	S
return(0);	. W	泠*跨评T
}	■-「"'"f，溪.
//////////////////////////////// End of File //////////////////////////////////
15.6改变保护属性
虽然在实际中很少需要改变已调拨的物理存储页的保护属性，但这样做仍然是可行的。比
第15章 在应用程序中使用虚拟内存
如，假设我们写了一段代码来管理一个链表，并把链表中的节点保存在一个巳预订的区域 中。我们可以这样设计链表的处理函数，让它们在每个函数的开头把物理存储页的保护属 性改成PAGE_READWRITE ,并在每个函数结束前再把保护属性改回 PAGE_NO ACCESS。
这样一来，我们就把链表数据保护起来，使它们避免受到程序中其他缺陷的影响。如果进 程中的其他代码试图用一个错误的指针来访问链表的数摒，将会引发访问违规。如果想要 在应用程序中定位一个很难发现的缺陷，不妨充分利用保护属性，它可能会发挥难以置信 的作用。
我们可以调用VirtualProtect函数来改变一个内存页面的保护属性：
BOOL VirtualProtect(
PVOID pvAddress,
SIZE_T dwSize,
DWORD fiNewProtect,
PDWORD pflOldProtect);
这里，pvAddress指向内存的基地址(必须位于进程中的用户分区)，dwSize表示要改变保 护属性的区域的大小，以字节为单位，ANewProtect可以是除了 PAGE_WRITECOPY和 PAGE_EXECUTE__WRITECOPY之外的任何PAGE_•保护属性。最后一个参数 pflOldProtect,是一个 DWORD 的地址，VirtualProtect 会在其中返回 pvAddress 地址原 来的保护属性。虽然许多应用程序并不需要该信息，但我们仍然必须传一个有效的地址给 pflOldProtect 参数，否则 VirtualProtect 函数会失败。
当然，保护属性是与整个物理存储页相关联的，我们不能给一个字节指定保护属性。因此, 如果我们在一台页面大小为4 KB的机器上用下面的代码调用VirtualProtect,那么我们实 际上是在给两个物理存储页指定PAGE_NOACCESS保护属性：
VirtualProtect(pvRgnBase + (3 * 1024), 2 * 1024z
PAGE_NOACCESS, &flOldProtect);
当若干连续的物理存储页跨越了不同的区域时，VirtualProtect是不能改变它们的保护属性 的。如果有相邻的区域，又想改变跨区域的连续页面的保护属性，那么必须调用 VirtualProtect 多次。
15.7重置物理存储器的内容
当我们修改物理存储页中的内容时，系统会尽量把改动保持在内存中。但是，当应用程序 在运行的时候，系统可能需要从.exe文件、DLL文件或页交换文件中载入新的页面到内存 里。为了满足最近的载入请求，系统会在内存中查找可用的页面，如果找到的页面已经被 修改过，那么系统还必须将它们换出到页交换文件中。
Windows提供了一项特性，使得应用程序能够提高自身的性能——这项特性就是重置物理 存储器。重置物理存储器的意思是，我们告诉系统一个或儿个物理存储页中的数据没有被 修改过。如果系统正在查找一页闲置内存并且找到了一个修改过的页面，那么系统必须把
j^^dows核心编程(第5版)	.
该内存页写入到页交换文件中。这个操作比较慢，会影响性能。对大多数应用程序来说， 我们都希望系统把修改后的页面保存到页交换文件中。	―一
但是，有些应用程序只需要在一小段时间内使用存储器，之后也不需要保留存储器中的内 容。为了提高性能，应用程序可以告诉系统不要在页交换文件中保存指定的存储页。这基 本上是应用程序用来告诉系统一个页面未被修改过的一种方法。因此，如果系统决定将一 个内存页挪作他用，那么它不会将页面的内容保存到页交换文件中，这样就提高了性能。 为了重置存储器，应用程序应该调用VirtualAlloc函数,并在第三个参数中传MEM_RESET 方志。
调用VirtualAlloc时，如果被引用到的页面在页交换文件中，那么系统会直接抛弃这些页 面。下次应用程序再访问存储器时，会使用新的、全部清零的内存页。如果重置的页面在 内存中，那么系统会将它们标记为没有修改过。这样一来，系统就绝对不会把它们写到页 交换文件中。注意，即使该内存页没有被清零，我们也不应该再继续读取其中的内容。如 果系统不需要用到该内存页，那么内存页会保持原来的内容不变。但是，如果系统需要用 到该内存页，那么它可以直接拿来用。之后当我们试图再访问该页面的内容时，系统会给 我们一个新的、全部清零的页面。由于系统的这一行为不在我们的掌控之下，因此我们必 须认为一旦重置了页面，其中的内容都将是垃圾。
在重置存储器时还需要紧记其他一些事项。首先，当调用VirtualAlloc时，基地址通常会 被向下取整到页面大小的整数倍，而大小则会被向上取整到页面大小的整数倍。在重置存 储器时，以这种方式对基地址和大小进行取整是非常危险的。有鉴于此，如果传入的是 MEM_RESET,那么VirtualAUoc会从相反的方向进行取整操作。例如，假设我们写了下 面的代码：
PINT pnData = (PINT) VirtualAlloc(NULL, 1024, MEM_RESERVE I MEM_COMMIT, PAGE_READWRITE); pnData[0] = 100; pnData[1] = 200； VirtualAlloc((PVOID) pnData, sizeof(int), MEM.RESET, PAGE_READWRITE);
这段代码先调拨了一页存储器，然后告诉系统最前面的4字节(sizeof(int))不再使用，可以 被重置。但是，和所有其他存储器操作一样，内存地址必须是页面大小的整数倍，大小也 必须是页面大小的整数倍。事实上是，重置存储器的调用会失败：VirtualAlloc会返回 NULL, GetLastError 会返回错误码 ERRORJNVALID_ADDRESS(在 WinError.h 中被定 义为487)O为什么呢？因为在传MEM_RESET给VirtualAlloc时，函数会把基地址向上 取整到页面大小的整数倍，其目的是确保即使在基地址之前的同一页面中还有其他重要数 据的情况下，也不会不小心把它们抛弃。在前面的例子中，把大小向下取整会得到0,而 重置0个字节是没有意义的。把大小向下取整到页面大小的整数倍也是出于同样的原因： 如果垃圾数据并未占满整个内存页，那么我们并不希望重置整个页面，因为其中可能还包 含有效数据。这样一来，操作系统就确保了只会重置整个页面都是垃圾数据的内存页。
第二点要记住的是MEM_RESET只能单独使用，不能将它和其他标志按位或起来。下面
第15章在应用程序中使用虚拟内存
的调用始终会失败并返回NULL：
PVOID pvMem = VirtualAlloc(NULL, 1024,
MEM_RESERVE I MEM_COMMIT I MEM_RESET, PAGE_READWRITE);
不管怎么说，把MEM_RESET标志和其他标志组合起来使用都是没有意义的。最后要注 意，在用MEM_RESET调用VirtualAlloc时，需要传一个有效的保护属性值，即使函数 实际上并没有用到这个值。
MemReset示例程序
MemResetxpp代码清单展示了 MEM_RESET是如何工作的。应用程序的源文件和资源文 件在本书配套网页的15-MemReset目录中。
MemResetcpp的源代码所做的第一件事情就是预订一块区域并为之调拨物理存储器。由于 传给VirtualAlloc的大小为1024,系统会自动将该值向上取整到系统的页面大小。然后程 序会调用_tcscpy_s函数把一个字符串复制到这块缓冲区中，也就是修改了页面中的内容。 如果系统稍后需要用到我们占用的这个页面，那么它会先把其中的数据写入到页交换文件 中。当应用程序以后再试图访问刚才写入的数据时，系统会自动地把页交换文件中的页面 重新载入到另一个内存页中，这样我们就能顺利地访问数据了。
在把字符串写入到存储器页面之后，程序会显示一个对话框，问用户是否以后还需要访问 该数据。如果用户单击No按钮(即回答不需要)，那么程序会用MEM_RESET标志来调用 VirtualAlloc,告诉系统该页面中的数据没有修改过。
为了演示该页面的确被重置过，我们需要给系统内存施加一些压力。可以通过下面的步骤 来达到这一目的。
(1)	调用GlobalMemoryStatus函数来得到机器中的内存总量。
(2)	调用VirtualAlloc函数来调拨存储器，调拨的数量为第1步中得到的数量。这个操作 非常快，这是因为除非进程试图去访问页面，否则系统是不会为页面分配内存的。如 果VirtualAlloc在最新型的机器上运行并返回NULL的话，请不必感到吃惊，这很可 能是因为机器中的内存总量比进程可用的地址空间还要多！
(3)	调用ZeroMemory函数以访问刚才调拨的内存。这会给系统的内存造成很大的压力， 并导致原来在内存中的一些页面被写入页交换文件。
如果用户表示以后还要使用该数据，那么程序就不会对页面进行重置。当程序后来再访问 该数据时，页面会被换入到内存中。但是，如果用户表示以后不再需要访问该数据了，那 么页面就会被重置，系统不会将其写入到页交换文件中，这样就提高了应用程序的性能。
当ZeroMemory返回后，程序会将页面中的数据与原先写入的字符串进行比较。如果页面 没寺•被重置过，那么内容应该是相同的。如果页面被重置过，那么两者的内容可能相同， 也可能不同。在MemReset程序中，由于所有的页面都被强制写入到页交换文件中，因此
■jndows核心编程（第5版）
两者的内容绝对不会相同。但是，如果pvDummy区域小于机器中的内存总量，那么原先 的内容可能还在内存中。这一点刚才己经提及，请务必小心！
MemReset.cpp
/*★*********★***★*****•**•****************************************************** Module: MemReset.cpp
Notices： Copyright (c) 2008 Jeffrey Richter & Christophe Nasarre ******************************************************************************/
#include "..\ConwionFiles\CmnHdr.h"	/* See Appendix A. */
#include <tchar.h>
///////////////////////////////////////////////////////////////////////////////
int WINAPI _tWinMain(HINSTANCE, HINSTANCE, PTSTR, int) (
TCHAR szAppName[] = TEXT("MEM_RESET tester*);
TCHAR szTestData[] = TEXT(■Some text data*);
// Commit a page of storage and modify its contents. PTSTR pszData = (PTSTR) VirtualAlloc(NULL, 1024,
MEM_RESERVE I MEM_COMMIT, PAGE_READWRITE);
_tcscpy_s(pszData, 1024, szTestData);
if (MessageBox(NULIi# TEXT(• Do you want to access this data later?"), szAppName, MB_YESNO) == IDNO) (
//We want this page of storage to remain in our process but the
// contents aren't important to us anymore.
II Tell the system that the data is not modified.
// Note： Because MEM_RESET destroys dataz VirtualAlloc rounds
// the base address and size parameters to their safest range.
// Here is an example：
// VirtualAlloc(pvData, 5000, MEHJRESET, PAGE_READWRITE)
// resets 0 pages on CPUs where the page size is greater than 4 KB // and resets 1 page on CPUs with a 4 KB page. So that our call to // VirtualAlloc to reset memory below always succeeds, VirtualQuery // is called first to get the exact region size. MEMORYJBASIC.INFORMATION mbi;
VirtualQuery(pszData,	sizeof(mbi))；
VirtualAlloc(pszData, mbi.RegionSize, MEM_RESET, PAGE^READWRITE)；
}
// Commit as much storage as there is physical RAM. MEMORYSTATUS mst;
GlobalMemoryStatus (&mst)；	威骚;
PVOID pvDximmy = VirtualAlloc (NULL, mst.dw^nLPhys,
MEM_RESERVE I MEht-COMMIT, PAGELREADWRI^^^^；
// Touch all the pages in the dumny region
// modified pages in RAM are written to the paging file.
if (pvDummy != NULL)	稣上 «	“	.>
ZeroMemory(pvDummy, mst.dwTotalPhys)；
// Compare our data page with what we original
if (_tcscnqp(pszData, szTestData) == 0) (	.；
// The data in the page matches what we originalthere.
// ZeroMemory forced our page to be written to the 熟孝际 MessageBox(NULL, TEXT("Modified data page was saved."), szAppName, MB_OK);
第15章在应用程序中使用虚拟内存
) else {
// The data in the page does NOT match what we originally put there // ZeroMemory didn't cause our page to be written to the paging file MessageBox(NULL, TEXT(-Modified data page was NOT saved."), szAppName, MB_OK);
} .
// Don't forget to release part of the address space.
// Note that it is not mandatory here since the application is exiting, if (pvDummy != NULL)
VirtualFree(pvDumny, 0, MEM_RELEASE);
VirtualFree(pszData, 0, MEM_RELEASE);
return(0);
//////////////////////////////// End of File //////////////////////////////////
■438T39 楙
15.8地址窗口扩展
随着时间的推移，应用程序需要越来越多的内存。服务器应用程序尤其如此：随着越来越 多的客户发请求到服务器，服务器的性能逐渐降低。为了提高性能，服务器应用程序需要 在内存中保持更多的数据以减少磁盘和内存间的页交换。其他类型的应用程序（比如数据 库、工程类、科学类）也需要能够操控大块的存储器。对这些应用程序来说，32位地址空间 还不够用。
为了帮助这些应用程序，Windows提供了一项特性，即地址窗口扩展（Address Windowing Extension,后面简称为AWE）。在创建AWE时，Microsoft有以下两个目标。
•	允许应用程序以一种特殊的方式分配内存，操作系统保证不会将以这种方式分配的 内存换出到磁盘上。
•	允许应用程序访问比进程地址空间还要多的内存。
基本上，AWE提供了一种方式，可以让应用程序分配一块或多块内存。当一开始分配时， 在进程的地址空间中是看不见这些内存块的。应用程序然后（通过调用VirtualAlloc）预订地 址空间区域，这就是地址窗口。应用程序然后调用一个函数，每调用一次把一块内存指定 到该地址窗口。把内存块指定到地址窗口是非常快的（通常是毫秒级的）。
很明显，通过同一个地址窗口，同一时间只能访问一块内存。由于开发人员必须在需要的 时候，显式地在代码中调用函数来把不同的内存块指定到地址窗口中，因此这使得代码更 难以编写。
下面的代码显示了如何使用AWEo
// First, reserve a 1MB region for the address window
ULONG_PTR ulRAMBytes = 1024 * 1024;
PVOID pvWindow = VirtualAlloc（NULL, ulRAMBytes,
MEM_RESERVE I MEM_PHYSICAL, PAGE_READWRITE）;
Endows核心编程（第5版）
// Get the number of bytes in a page for this CPU platform SYSTEM_INFO sinf;
GetSystemlnfo(&sinf);
// Calculate the required number of RAM pages for the
// desired number of bytes
ULONG_PTR ulRAMPages = (ulRAMBytes + sinf.dwPageSize - 1) / sinf.dwPageSize；
// Allocate array for RAM page's page frame numbers
ULONG_PTR* aRAMPages = (ULONG_PTR*) new ULONG_PTR[ulRAMPages];
// Allocate the pages of RAM (requires Lock Pages in Memory user right)
AllocateUserPhysicalPages(
GetCurrentProcess()# // Allocate the storage for our process &ulRAMPages, // Input: # of RAM pages, Output: # pages allocated aRAMPages); // Output: Opaque array indicating pages allocated
// Assign the RAM pages to our window
MapUserPhysicalPages(pvWindow, // The address of the address window ulRAMPages, // Number of entries in array aRAMPages); // Array of RAM pages
// Access Che RAM pages via the pvWindow virtual address
♦ • •
// Free the block of RAM pages
FreeUserPhysicalPages(
GetCurrentProcess(),	// Free the RAM allocated for our process
&ulRAMPages,	// Input: # of RAM pages, Output: # pages freed
aRAMPages)；	// Input: Array indicating the RAM pages to free
// Destroy the address window
VirtualFree(pvWindow, 0, MEM_RELEASE)；
delete[] aRAMPages；
正如我们所看到的，AWE的使用很简单。现在我们来看一下代码中几处有趣的地方。
程序通过调用VirtualAlloc函数来预订1MB的地址窗口。通常，地址窗口比这大得多。在 选择内存块的大小时，要根据应用程序的需要选择一个合适的大小。当然，进程的地址空 间中最大的、连续的闲置区域决定了我们所能创建的最大地址窗口。MEM_RESERVE标 志表示要预订一块地址区域。MEM_PHYSICAL标志表示该区域最终会以物理内存作为后 备。AWE的一个限制是所有映射到地址窗口的存储器必须是可读/写的。因此， PAGE_READWRITE是我们能传给VirtualAlloc的唯一有效的保护属性。另外，我们不能 使用VirtualProtect函数来改变页面的保护属性。
分配物理存储器只不过是调用一下AllocateUserPhysicalPages函数：
BOOL AllocateUserPhysicalPages(
HANDLE hProcess,
PULONG_PTR pulRAMPages, PULONG_PTR aRAMPages);
这个函数会根据pulRAMPages参数所指向的值来分配相应数量的内存页，然后将这些页 面分配给hProcess参数所标识的进程。
操作系统会给每个页面指定一个页框号(page frame number)o系统在分配内存页面时，会将 每个内存页面的页框号保存到aRAMPages参数所指向的数组中。页框号本身对应用程序 来说是没有什么用处的，因此我们没有必要也不应该去读取该数组中的内容，更不应该去
第15章在应用程序中使用虚拟内存
改变数组中的任何一个值。注意，我们既不知道哪个内存页面被分配给这块区域，也不关 心这个问题。当内存块中的页面通过地址窗口显示出来时，它们看起来就像是一块连续的 内存。这一方面减轻了开发人员的负担，因为我们不必理解系统内部到底在做些什么，另 一方面也使得内存更易于使用。
当该函数返回时，pulRAMPages指向的值表示函数成功分配的页面的数量。通常这个值和 传给该函数的值相同，但也有可能更小。
只有当前进程才能使用通过AllocateUserPhysicalPages分配得到的内存页面，AWE不允许 把内存页面映射到其他进程的地址空间中。因此，我们不能在进程间共享内存块。
说明 当然，物理内存是稀缺资源，应用程序只能分配那些尚未用到的内存。我们应该谨 慎使用AWE,否则会使自己的进程和其他进程过度地在磁盘和内存间进行页交换。 此外，较少的可用内存数量会影响到系统创建新的进程、线程以及其他资源的能力。 应用程序可以使用GlobalMemoryStatusEx函数来监视物理内存的使用情况。
为了保护内存的分配，AllocateUserPhysicalPages函数要求调用方必须具备并且启 用内存中锁定页面用户权限，否则函数调用会失败。关于如何在Windows Vista中 打开该用户权限，请参考15.3节“同时预订和调拨物理存储器”。
创建一个地址窗口并分配一块内存之后，接下来调用MapUserPhysicalPages把内存块指定 给地址窗口。
BOOL MapUserPhysicalPages(
PVOID pvAddressWindow,
ULONG_PTR ulRAMPages, PULONG_PTR aRAMPages);
第一个参数pvAddressWindow表示地址窗口的虚拟地址。第二个参数ulRAMPages表示 要通过该地址窗口看到多少个页面的内存。第三个参数aRAMPages表示要通过该地址窗 口看到哪些页面的内存。如果地址窗口的大小小于我们试图映射的页面数，函数调用会失 败。Microsoft创建这个函数的一个主要目标是使它能执行得飞快。一般来说， MapUserPhysicalPages能够在数亳秒内完成对内存块的映射。
说明 我们也可以通过在调用MapUserPhysicalPages时给aRAMPages参数传NULL的 方式来撤销指定当前的内存块。下面就是一个例子：
// Un-assign the RAM block from the address window
MapUserPhysicalPages(pvWindow, ulRAMPages, NULL)；
一旦将内存块指定到了地址窗口，就可以用一个相对于地址窗口基地址(也就是示例代码中 的pvWindow)的虚拟地址来引用其中的内存。
不再需要使用该内存块时，可以调用FreeUserPhysicalPages来释放它。
BOOL FreeUserPhysicalPages(
HANDLE hProcess,
dows核心编程(第5版)
PULONG_PTR pulRAMPages,
PULONG_PTR aRAMPages);
第一个参数hProcess表示要释放哪个进程的内存页面。第二个参数表示要释放多少个页面。 第三个参数表示要释放的那些页面的页框号。如果内存块目前巳经被映射到地址窗口，那 么系统会取消映射并释放内存块。
最后，为了完成清理工作，程序调用了 VirtualFree,传入地址窗口的虚拟地址，以。作为 区域的大小，并传入MEM_RELEASE标志。
这个简单的示例程序创建了一个地址窗口和一个内存块。这使得它访问的内存不需要和磁 盘进行页交换。但是，应用程序也可以创建多个地址窗口，并分配多个内存块。我们可以 把这些内存块指定给任何一个地址窗口，但系统不允许一个内存块同时出现在两个地址窗 口中。
64位Windows完全支持AWE,将一个使用AWE的32位应用程序移植到64位平台是件 简单明了的工作。但是，对64位应用程序来说，由于进程的地址空间非常之大，以致于 AWE的用处不是特别显著。即便如此，AWE还是有其用武之地的，因为它允许应用程序 分配不会和磁盘进行页交换的物理内存。
AWE示例程序
下面的代码清单所列出的AWE应用程序(15.AWE.exe),演示了如何创建多个地址窗口并 给它们指定不同的内存块。应用程序的源代码和资源文件在本书配套网页的15-AWE目录 中。程序启动时，会创建两个地址窗口并分配两块内存。
刚开始，程序会在第一块内存中写入字符串"Text in Storage。”，在第二块内存中写入字 符串"Text in Storage 1”。然后程序会把第一块内存指定给第一个地址窗口，把第二块内 存指定给第二个地址窗口。下图的应用程序窗口反映了当前的状态。
我们可以通过这个窗口来进行一些试验。首先，我们可以通过相应的组合框来把内存块指 定给各地址窗口。组合框同时提供了一个"No Storage”选项，可以用来撤销当前映射到地 址窗口的内存块。其次，我们可以编辑文本框中的文字来修改当前映射到各地址窗口的内 存块中的内容。
如果我们试图把同一块内存同时指定给两个地址窗口，那么会得到下图所示的消息框，因 为AWE不允许我们这么做。
第15章 在应用程序中使用虚拟内存
Thi$ storage can be mapped only once.
ks皴 I
这个示例程序的源代码非常清晰。为了更容易地使用AWE,我还创建了 3个C++类，它们 被包含在AddrWindows.h头文件中。第1个类是CSystemlnfo,它对GetSystemlnfo函数 进行了简单的封装。其他两个类各自创建了一个CSystemlnfo类的实例。
第2个类是CAddrWindow,它封装了地址窗口。基本上，Create方法用来预订地址窗口， Destroy方法用来销毁地址窗口，UnmapStorage方法用来撤销当前给地址窗口指定的内存 块，PVOID转型操作符用来返回地址窗口的虚拟地址。
第3个类是CAddrWindowStorage ,它对内存块进行了封装，可以把它指定给 CAddrWindow对象。AUocate方法会先启用内存中锁定页面用户权限，然后试图分配内存 块，然后再禁用该用户权限。Free方法用来释放内存块。HowManyPagesAllocated方法用 来返回己成功分配的页面的数量。MapStorage方法用来把内存块映射到一个 CAddrWindow对象，UnmapStorage方法用来撤销映射。
有了这些C++类，示例程序的实现就非常简单了。示例程序会创建两个CAddrWindow对 象和两个CAddrWindowStorage对象。其余的代码只不过是在合适的时间，用合适的对象 来调用相应的方法。
注意，我在这里为示例程序添加了一个组件清单(manifest),这样Windows就会始终都弹出 要求提升运行权限的窗口，我们已经在4.5.1节“自动提升进程的权限”对此进行了介绍。
AWB.Cpp
Module: AWE.cpp
Notices： Copyright (c) 2008 Jeffrey Richter & Christophe Nasarre
//////〃〃/〃//////////////〃////〃/////////〃////〃,
#include ♦include ♦include #include #include #include
■..\CommonFiles\CmnHdr.h" <Windowsx. h> <tchar.h>
■AddrWindow.h■
■Resource.h*
<StrSafe.h>
CAddrWindow g_aw(2];	// 2 memory addresiA
CAddrWindowStorage g__aws[2]；	// 2 storage blocks
const ULONG_PTR g_jiChars = 1024；	// 1024 character bu
const DWORD g_cbBufferSize = g_nChars ♦ sizeof(TCHAR)；
/* See Appendix A. */
〃〃/〃〃/〃〃/〃〃/
iiiiifiiiiiiiimiiiniiiHiuifiiti/iHiiiimiiimiiiiiirtfifitniiiiiiiiiii
Endows核心编程（第5版）
BOOL Dlg_OnInitDialog(HWND hWnd, HWND hWndFocus, LPARAM 1Param) (
chSETDLGICONS(hWnd, IDI.AWE);
// Create the 2 memory address windows chVERIFY(g__aw[0] .Create(g_cbBufferSize)); chVERIFY(g_aw[l] .Create(g__cbBufferSize))；
// Create the 2 storage blocks
if (!g_aws[0].Allocate(g_cbBufferSize)) (
chFAIL("Failed to allocate RAM.\nMost likely reason: ■
•you are not granted the Lock Pages in Memory user right.■)；
}
chVERIFY(g_aws[1].Allocate(g_nChars * sizeof(TCHAR)));
// Put some default text in the 1st storage block
g_aws[0].Mapstorage(g_aw(0])；
_tcscpy_s((PTSTR) (PVOID) g_aw(0), g_cbBufferSize, TEXT("Text in Storage 0*))；
// Put some default text in the 2nd storage block g__aws [1].Mapstorage(g_aw[0})；
_tcscpy_s((PTSTR) (PVOID) g_aw[0]/ g_cbBufferSize, TEXT("Text in Storage 1-))；
// Populate the dialog box controls
for (int n = 0； n <= 1； n++) (
// Set the combo box for each address window
int id = ((n == 0) ? IDC_WINDOWOSTORAGE : IDC_WINDOW1STORAGE);
HWND hWndCB = GetDlgltemfhWnd, id);
ComboBoK-AddString(hWndCB, TEXT("No storage■))；
ComboBox_AddString(hWndCB, TEXT(・Storage 0"))；
ComboBox^AddString(hWndCB, TEXT(■Storage I-))；
// Window 0 shows Storage 0, Window 1 shows Storage 1
ComboBox_SetCurSel(hWndCB, n + 1)；
FORWARD_WM_COMMAND(hWnd, id, hWndCB, CBN_SELCHANGE, SendMessage); Edit_LimitText (GetDlgItem(hWnd,
(n == 0) ? IDC_WINDOW0TEXT : IDC_WINDOW1TEXT), g_nChars);
}
return(TRUE);
}
///////////////////////////////////////////////////////////////////////////////
void Dlg_OnCommand(HWND hWnd, int id, HWND hWndCtl, UINT codeNotify) {
switch (id) (
case IDCANCEL:
EndDialog (hWnd, id);	，二订，七]
break;	' "彳上"！义；"沱二,；二
ft , , •	■' •甲
case IDC_WINDOWOSTORAGE:
case IDC.WINDOWlSTORAGE:	蹄瞬猝
if (codeNotify == CBN_SELCHANGE) (	L
// Show different storage in address window 9： £ * • int nWindow = ((id == IDC_WINDOW0STORAGE) ? 0 : 1);
int nStorage = ComboBox__GetCurSel (hWndCtl) - 1； v 脱：：'％ "顼
if (nStorage == -1) (	// Show no storage in this wiring"" 7•祇，《
chVERIFY(g_aw(nWindow).UnmapStorage())；
} else (
第15章在应用程序中使用虚拟内存
}
///〃///////〃///////////////////////////////////////////////〃///〃///////////
tpragma once
***** *** * *
DialogBox(hlnstExe, MAKEINTRESOURCE (IDD^WE), NULL, Dlg_Proc)席 return (0)；
}
case IDC_WINDOWOTEXT:
case IDC_WINDOW1TEXT:
if (codeNotify == EN_CHANGE) (
// Update the storage in the address window
int nWindow = ((id == IDC_WINDOWOTEXT) ? 0 : 1);
Edit_GetText(hWndCtl, (PTSTR) (PVOID) g_aw[nWindow], g_nChars); } break；
if (Ig_aws[nStorage].MapStorage(g_aw[nWindow])) {
// Couldn't map storage in window chVERIFY(g_aw[nWindow].UnmapStorage());
ComboBox_SetCurSel(hWndCtl, 0)； // Force "No storage" chMB("This storage can be mapped only once.");
II Update the address window1s text display
HWND hWndText = GetDlgltemChWnd,
((nWindow == 0) ? IDC_WINDOWOTEXT : IDC_WINDOW1TEXT)); MEMORY^BASIC_INFORMATION mbi; VirtualQuery (g_&w [nWindow], &mbi, // Note： mbi.State == MEM_RESERVE EnableWindow(hWndText, (mbi.State Edit_SetText(hWndText, IsWindowEnabled(hWndText)
? (PCTSTR) (PVOID) g_aw[nWindow] : TEXT(・(No storage)•));
sizeof(mbi));
if no storage is in address window ==MEM_COMMIT));
break；
INT.PTR WINAPI Dlg_Proc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM 1 Param) (
switch (uMsg) { chHANDLE_DLGMSG(hWnd, WM_INITDIALOG, Dlg_OnInitDialog); chHANDLE_DLGMSG(hWnd r WM_CC»1MAND,	Dlg_OnCommand);
return(FALSE);
///////////////////////////////////////////////////////////////////////////////
int WINAPI _tWinMain(HINSTANCE hlnstExe, HINSTANCE, PTSTR, i
//////////////////////////////// End of File //////////
AddzWl&dow.h /********************m**m*m***************，***.* * * * Modu1e: AddrWindow.h
Notices： Copyright (c) 2008 Jeffrey Richter & Christophe Nasarre
Endows核心编程（第5版）
////////////////////〃//〃//////////////〃〃////////〃/〃////////〃/////////〃/
#include •..\CommonFiles\CmnHdr.hB	/* See Appendix A. */
#include <tchar.h>
////////〃///〃///////〃〃///〃/////〃〃/////〃////〃〃/〃//〃〃〃//〃/////〃//
class CSysteminfo : public SYSTEWLINFO (
public：
CSystemlnfoC) { GetSystemlnfo(this); }
)7
///////////////////////////////////////////////////////////////////////////////
class CAddrWindow { public：
CAddrWindow()	( pvWindow = NULL; }
-CAddrWindow() { Destroy(); }
BOOL Create(SIZE_T dwBytes , PVOID pvPreferredWindowBase = NULL) { // Reserve address window region to view physical storage nupvWindow = VirtualAlloc(pvPreferredWindowBase, dwBytes, MEM_RESERVE I MEM_PHYSICAL, PAGE_READWRITE);
return (ntJpvWindow ! = NULL);
BOOL Destroy() (
BOOL bOk = TRUE;
if (ncpvWindow ! = NULL) (
// Destroy address window region
bOk = VirtualFree(nt-PvWindow, 0, MEM_RELEASE); m_pvWindow = NULL;
}
return(bOk)；
}
BOOL UnmapStorage() (
// Unmap all storage from address window region MEM0RY_3ASIC_INF0RMATI0N mbi;
VirtualQuery (nt-pvWindow, &mbi, sizeof (mbi))； return (MapUserPhysicalPages (ncpvWindow, mbi.RegionSize / sirusinf.dwPageSize, NULL));
}
// Returns virtual address of address window operator PVOID() { return(nupvWindow)； }
private:
PVOID m__pvWindow； // Virtual address of address window region static CSystemlnfo snusinf；
////////////////////////////////////////////////////////I////////////////////崖
CSystemlnfo CAddrWindow: : situs inf;
.「二着扑寺:参"m?；恶慰第 〃〃//〃〃〃〃//〃〃/〃〃/〃/〃〃〃力〃〃/宠/〃〃，7〃/〃//〃〃，藩赫翎
第15章在应用程序中使用虚拟内存
class CAddrWindowStorage {
public:
CAddrWindowStorage() { nt_ulPages = 0; nupulUserPfnArray = NULL； } -CAddrWindowStorage() ( Free(); ) 熊:声
BOOL Allocate (ULONG_PTR ulBytes)	牝"；玲至顼MM芝折*号瑚* :定
// Allocate storage intended for an address window
Free()； // Clean up this object's existing address window
// Calculate number of pages from number of bytes m_ulPages = (ulBytes + snusinf.dwPageSize - 1) / sm_sinf.dwPageSize；
// Allocate array of page frame number峪" nupulUserPfnArray = (PULONG_PTR)
HeapAlloc(GetProcessHeap(), 0, m_ulPages * sizeof(ULONG_PTR))；
BOOL bOk = (nupulUserPfnArray != NULL);
if (bOk) {
// The "Lock Pages in Memory" privilege must be enabled EnablePrivilege(SE^OCKJMEMORY-JIAME, TRUE^^ bOk = AllocateUserPhysicalPages(GetCurrentProcess(),
Pages, nL_pulUserPfnArray);
EnablePrivilege(SE_LOCK_MEMORY_NAME, FALSE);
}
return(bOk)；
}
BOOL Free() (
BOOL bOk = TRUE;
if (n\_pulUserPfnArray != NULL) (
bOk = FreeUserPhysicalPages(GetCurrentProcess(),
&HL.U1 Pages, m__pulUserPfnArray)；
if (bOk) (
// Free the array of page frame numbers
HeapFree(GetProcessHeap(), 0, ncpulUserPfnArray)； nuulPages = 0； in_pulUserPf nArray = NULL；
)
}
return(bOk);
}
ULONG_PTR HowManyPagesAllocated() ( return(n\_ulPages); }
BOOL MapStorage(CAddrWindow& aw) ( return(MapUserPhysicalPages(aw,
HowManyPagesAllocated(), ncpulUserPfnArray))； }
BOOL UnmapStorage(CAddrWindow& aw) ( return(MapUserPhysicalPages(aw, HowManyPagesAllocated(), NULL))；
private：
static BOOL EnablePrivilege(PCTSTR pszPrivName,
BOOL bOk = FALSE; // Assume function fails HANDLE hToken；
/ f
/ i
Try to open this process' access token (OpenProcessToken(GetCurrentProcess(), TOKEN-ADJUST_PRIVILEGES r &hToken))(
BOOL 衲甘笋质如E)
Mows核心编程（第5版）
伙嚣置气为 TCk PageS in MemOry" Privilege TOKEN.PRIVILEGES tp = { 1 };
LookupPrivilegevalue(NULL, pszPrivName, &tp.Privileges[0].Luid)； tp.Privileges[0].Attributes = bEnable ? SE_PRIVILEGE_ENABLED : 0; AdjustTokenPrivileges(hToken, FALSE, &tp/ sizeof(tp), NULL, NULL); bOk = (GetLastError() == ERROR_SUCCESS)； CloseHandle(hToken)；
}
return(bOk)；
Pnva"
ULONG_PTR nuulPages；

杼、'
Number•砂 storage pages %
PULONG_PTR m_jpulUserPfnArray； // Page frame number array
F 
///////////////////////////////////////////////////////////////////////////////
fo CAddrWindowStorage:: snusinf ；
................ .........
® M?项』.蓉菸曩"5E； ：W： *1殴n, #疽.容翎,，隧""w、；§f息等*毛懿感W?项"<.„..._ I.
//////////////////////////////// End of File //////////////////////////////////
本章内容
16.1	C/C++运行库的栈检查函数
16.2	Summation 示例程序
有时候系统会在用户进程的地址空间中预订区域。第13章已经提到过，系统在分配进程环 境块和线程环境块时会发生这种情况。系统在用户进程的地址空间中预订区域的另一种可 能是分配线程栈。	’	’	" r
当系统创建线程时，会为线程栈预订一块地址空间区域（每个线程都有自己的栈），并给区 域调拨一些物理存储器。默认的情况下，系统会预订1 MB的地址空间并调拨两个页面的 存储器。但是，在构建应用程序时开发人员可以通过两种方法来改变该默认值，一种方法 是使用Microsoft C++编译器的/F选项，另一种方法是使用Microsoft C++链接器的/STACK 选项：
/Preserve
/STACK:reserve[,commit]
在构建应用程序时，链接器会把想要的栈的大小写入到.exe或.dll文件的PE文件头中。当 系统创建线程栈的时候，会根据PE文件头中的大小来预订地址空间区域。但是，在调用 CreateThread ^.beginthreadex函数时，开发人员也可以另外指定需要在一开始就调拨的 存储器数量。这两个函数都有一个参数，可以用来指定一开始要调拨给线程栈的地址空间 区域的存储器的大小。如果将该参数设为0,那么系统会使用PE文件头中指定的大小。在 后面的讨论中，我们假设所使用的都是默认值：即区域大小为1 MB,每次调拨一个存储 页面。
图16-1显示了在一台页面大小为4 KB的机器上线程栈的地址空间区域（基地址为 0x08000000）o该线程栈的地址空间区域和所有调拨给该区域的物理存储器都具有 PAGE_READWRITE 保护属性。
在预订地址空间区域后，系统会给区域顶部（即地址最高）的两个页面调拨物理存储器。在 让线程开始执行之前，系统会把线程栈的指针指向区域顶部的那个页面的末尾（该地址非常 接近0x08100000）o这个页面就是线程开始使用栈的地方。区域顶部往下的第二个页面被称 为防护页面（guard page）,随着线程调用越来越多的函数，调用树也越来越深，线程也需要 越来越多的栈空间。
.45"
Windows核心编程（第5版）
内存地址	页面状态 -
0X080FF000	栈顶：已调拨的页面
0x080FE000	带保护属性标志的已 调拨的页面
OxOSOFDOOO	己预订的页面 •
一		—
0x08003000	已预订的页面
0x08002000 1	已预订的页面
0x08001000	已预订的页面
0x08000000	栈底：己预订的页面
图16・1线程栈的地址空间区域最初创建时的样子
当线程试图访问防护页面中的内存时，系统会得到通知。这时系统会先给防护页面下面的 那个页面调拨存储器，接着去除当前防护页面的PAGE_GUARD保护属性标志，然后给刚 调拨的存储页指定PAGE_GUARD保护属性标志。该项技术使得系统能够在线程需要的时 候才增大栈存储器的大小。如果线程的调用树不断加深，那么栈的地址空间区域看起来会 像图16-2那样。
内存地址	页面状态
0x080FFOO0	栈顶：己调拨的页面
0x080FE000 ——	己调拨的页面
0X080FD000	己调拨的页面 		
	—/
		
0x08003000	已调拨的页面 —g
0x08002000	带保护属性标志的已 调拨的页面
0x08001000	已预订的页面 • !
0x08000000	栈底：己预订的页面
图16・2即将用尽的栈地址空间区域
现在来看图16-20假设线程的调用树非常深，CPU的栈指针寄存器指向的内存地址为
第16章线程栈
0x08003004o现在，当线程调用另一个函数时，系统必须调拨更多的物理存储器。但是， 当系统给地址为0x08001000的页面调拨物理存储器时，它的做法和给区域中的其他部分调 拨物理存储器有所不同。图16・3显示了栈的地址空间区域目前的样子。
内存地址	页面状态
0x080FF000	栈顶：已调拨的页面 	
0x080FE0OO	已调拨的页面
OxOSOFDOOO	已调拨的页面 1
	
	 1	—1
0x08003000	已调拨的页面	1
0x08002000	已调拨的页面
0x08001000	已调拨的页面
0x08000000	栈底：已预订的页面 	
图16-3已用尽的栈地址空间区域
453
和我们预期的一样，系统会去除地址为0x08002000的页面的PAGE_GUARD保护属性标 志，然后给地址为0x08001000的页面调拨物理存储器。区别在于系统不会给刚调拨的物理 存储器（地址为0x08001000）指定防护属性。这意味着栈的地址空间区域已经放满了它所能 容纳得下的所有物理存储器。系统永远不会给区域底部的那个页面调拨存储器，具体的原 因我们马上就会看到。
当系统给地址为0x08001000的页面调拨物理存储器时，它会执行一个额外的操作一一抛出 EXCEPTION_STACK_OVERFLOW异常，该异常对应的值为0xCOOOOOFDo通过使用结 构化异常处理（structured exception handling,后面简称为SEH）,系统会在发生这一情况时 通知我们的程序，从而使程序能够得体地从这一异常情况下恢复。有关SEH的更多信息， 请参阅第23〜25章。
如果线程在引发栈溢出异常后继续使用栈，那么它会用尽地址为0x08001000的页面中的内 存，并试图访问地址为0x08000000的页面中的内存。当线程试图访问这个（尚未调拨物理 存储器）的页面时，系统会抛出访问违规异常。如果访问违规异常是在线程试图访问栈时所 引发的，那么线程的麻烦就大了。此时系统会收回控制权并将控制权交给Windows错误报 告服务（Windows Error Reporting service）,后者会弹出图16-4所示的对话框然后结束进程 ——不仅仅是当前线程，而是整个进程。
lows核心编程(第5版)
图16H错误报告
为了避免这种情况，应用程序可以调用SetThreadStackGuarante函数，借此来抛出前文所 提到的EXCEPTOU_STACK_OVER FLOW异常。该函数可以确保在Windows错误报告服 务接管并终止进程之前，地址空间中还有指定数量的内存可供使用，这使得应用程序能够 处理栈溢出异常并恢复运行。
重要提示 当线程访问最后一个防护页面时，系统会抛出EXCEPTION_STACK_ OVERFLOW异常。如果线程捕获了该异常并继续执行，那么系统将不会在 同一个线程中再次抛出EXCEPTION_STACK_OVERFLOW 异常，这是因 为后面再也没有防护页面了。如果希望在同一线程中继续收到 EXCEPTION_STACK_OVERFLOW 异常，那么应用程序必须重置防护页 面。这很容易办到，只需调用C运行库的_resetstkoflw函数(在malloc.h中 定义)。
454
现在让我们来看看为什么系统始终不给栈地址空间区域最底部的页面调拨物理存储器。这 样做的目的是为了保护进程使用的其他数据，使它们不会因为意外的内存写越界而遭到破 坏。我们知道，地址空间区域的地址0X07FFF000 位于0x08000000下方的一个页面)可 能已经调拨了物理存储器。如果地址为0x08000000的页面也调拨了物理存储器，那么系统 就无法捕捉到线程对栈外区域的访问。如果栈的增长越过了所预订的区域，那么线程就会 覆盖进程地址空间中的其他数据——像这种类型的缺陷是很难找到的。
另一种很难找到的缺陷是栈下溢(stack underflow)o为了理解什么是栈下溢，让我们看下面 的代码：
int WINAPI WinMain (HINSTANCE hlnstExe, HINSTANCE,
PTSTR pszCmdLine, int nCmdShow) (
BYTE aBytes[100]；
aBytes[10000] = 0; // Stack underflow
return(0);
}
执行到这个函数的赋值语句时，代码会试图访问线程栈之外的内存。当然，编译器和链接 器是无法发现代码中的此类缺陷的。这条语句有可能会引发访问违规，也可能不会，因为 紧接着线程栈的后面可能有另一块已调拨的地址空间区域。如果发生这样的情况，程序可
第16章线程栈
能会破坏属于进程另一部分的内存，而系统是无法检测到这种破坏的。下面这段代码中的 栈下溢总是会引起内存破坏，因为程序刚好在线程栈的后面分配了一块内存：
DWORD WINAPI ThreadFunc(PVOID pvParam) (
BYTE aBytes[OxlO];
// Figure out where the stack is in the virtual address space
// See Chapter 14 for more details about VirtualQuery
MEMORY_BASIC_INFORMATION mbi;
SIZE_T size = VirtualQuery(aBytes, &mbi, sizeof(mbi));
// Allocate a block of memory just after the 1 MB stack
SIZE_T s = (SIZE_T)mbi.AllocationBase + 1024*1024;
PBYTE pAddress = (PBYTE)s；
BYTE* pBytes = (BYTE*)VirtualAlloc(pAddress, 0x10000,
MEM_COMMIT I MEM_RESERVE, PAGE_READWRITE);
// Trigger an unnoticeable stack underflow
aBytes[0x10000] = 1; // Write in the allocated block, past the stack
return(0)；
16.1	C/C++运行库的栈检查函数
c/c廿的运行库中有一个栈检查函数。在编译源代码时，编译器会在必要时生成代码来调 用该函数。这个函数的目的是为了确保已经给线程栈调拨了物理存储器。让我们来看一个 例子。下面这个函数虽小，但它的局部变量却需要占用大量内存：
void SomeFunction () (
int nValues[4000];
// Do some processing with the array.
nValues[0] = 0； // Some assignment
}
这个函数至少需要16 000字节(4000Xsizeof(int);每个整型变量的大小为4字节)的栈空间 来容纳它的整型数组。通常情况下，编译器生成的用来分配栈空间的代码会直接把CPU的 栈指针减去16 000字节。但是，除非程序试图访问其中的数据，否则系统是不会给这块区 域调拨物理存储器的。
在页面大小为4KB或8 KB的系统中，这个限制可能会产生问题。如果第一次访问的地址 要低于防护页面(如前面代码中的赋值语句所示)①，那么线程会访问尚未调拨的内存并引发 访问违规。为了确保开发人员编写的类似于刚才的代码能够正常运行，编译器需要插入一 些代码来调用C运行库的栈检查函数。
编译器在编译程序的时候，己经知道目标系统的页面大小。x86/x64编译器知道页面大小为
①译注：nValue[0]是数组中地址最低的元素。
bws核心编程(第5版)
4KB,而IA.64编译器知道页面大小为8KB。当编译器在处理程序中的每个函数时，它会 算出函数需要多大的栈空间。如果需要的栈空间大于目标系统的页面大小，编译器就会自 动插入代码来调用栈检查函数。
下面的伪代码显示了栈检查函数到底在做些什么事情。之所以说它是伪代码，是因为通常 这个函数都是由编译器开发商用汇编语言来实现的。
// The C run-time library knows the page size for the target system.
#ifdef _M_IA64
#define PAGESIZE (8 * 1024) // 8-KB page
#else
#define PAGESIZE (4 * 1024) // 4-KB page
#endif
void StackCheck(int nBytesNeededFromStack) (
// Get the stack pointer position.
// At this point, the stack pointer has NOT been decremented
// to account for the function's local variables.
PBYTE pbStackPtr = (CPU's stack pointer);
while (nBytesNeededFromStack >= PAGESIZE) (
// Move down a page on the stack--should be a guard page.
pbStackPtr -= PAGESIZE；
// Access a byte on the guard page--forces new page to be
// committed and guard page to move down a page.
pbStackPtr[0] = 0；
// Reduce the number of bytes needed from the stack. nBytesNeededFromStack -= PAGESIZE;
)
// Before returning, the StackCheck function sets the CPU's
// stack pointer to the address below the function's
// local variables.
)
前面提到编译器会根据目标平台的页面大小，自动插入代码来调用StackCheck函数。为了 能让开发人员对所使用的页面大小的阈值进行控制，Microsoft Visual C++提供了/Gs编译器 开关。(有关这个编译器开关的详细信息，请访问http://msdn2.microsoft.com/en-us/ library/9598wk25(VS.80).aspxo )只有当我们确切地知道自己在做什么，而且又确实有这样 的特殊需要的时候，才应该使用这个编译器开关。百分之99.99999的应用程序或DLL是 不需要用到这个开关的。
说明 Microsoft C/C++编译器提供了一些编译器开关，可以帮助我们在运行的时候检测栈 有没有遭到破坏。在创建C++项目时，默认情况下DEBUG配置的/RTCsu编译器 开关(http://msdn2.microsoft.com/en-us/library/8wtf2dfz(VS.80).aspx)是打开的。如 果一个局部数组变量在运行过程中发生了写越界，那么编译器插入的代码将会发现 这种情况，并在函数返回的时候通知应用程序。只有DEBUG配置才能使用/RTC 开关。
但对RELEASE配置来说，我们应该使用/Gs编译器开关。这个开关告诉编译器在 调用任何函数之前，插入一些代码来把栈的当前状态作为cookie保存起来，然后在 函数返回后检查栈的完整性。恶意软件经常会试图制造缓冲区溢出来覆盖栈上的
第16章线程栈
返回地址，通过这种方式把程序的控制流转到自己的代码中。有了这些检查，代 码在用保存的cookie检查栈的状态时就会检测到这一意外情况并终止应用程序， 这样恶意软件的攻击就无法得逞。有关/Gs编译器开关的详尽分析，请参阅 http://www.symantec.com/avcenter/reference/GS_Protections_in_Vista.pdf 和“Compiler Security Checks In Depth ”(网址为 http://msdn2.microsoft.com/en-us/library/ aa290051(VS.71).aspx)o
16.2	Summation 示例程序
本章稍后介绍的Summation (16-Summation.exe)示例程序展示了如何使用异常过滤程序以 及异常处理程序来从栈溢出中得体地恢复并继续运行。示例程序的源代码和资源文件在本 书配套网页的16-Summation目录中。为了完全理解示例程序的工作机理，读者可能需要先 读一下与SEH有关的各章。
Summation示例程序把0到x之间的数全部加起来，其中的x由用户输入。当然，最简单 的方法就是创建一个名为Sum的函数并让它执行下面的计算：
Sum = (x * (x + 1) ) / 2;
但在这个例子中，Sum函数是通过递归的方式来实现的，这样只要用户输入一个很大的数, 函数就会使用大量的栈空间。
程序启动后，会显示下图所示的对话框。
Calculate the sum of the numbers from 0 through x, where x is:
我们可以在这个对话框的编辑框中输入一个数，然后单击Calculate按钮。这时程序会创建 一个新的线程，这个线程唯一的任务就是计算0〜x之间所有数的总和。当新线程开始运行 的时候，程序的主线程会以新线程的句柄为参数来调用WaitForSingleObject,并等待计算 的结果。当新线程结束运行的时候，系统会唤醒主线程。主线程可以通过调用 GetExitCodeThread来得到新线程的退出码(exit code),也就是计算得到的总和。最后一步, 也是极其重要的一步，主线程会关闭新线程的句柄，这样系统就可以完全销毁线程对象， 从而避免资源泄漏。
然后主线程会检查计算线程的退出码。如果退出码为UINT_MAX,那表示有错误发生—— 也就是计算线程在计算的过程中产生了栈溢出——主线程会显示一个对话框来告诉用户这 种情况。如果退出码不是UINT_MAX,那表示计算线程是正常结束的，退出码就是总和。 在这种情况下，主线程会把计算结果显示在主对话框中。
/Widows核心编程（第5版）	一
现在让我们来看一看计算线程。这个线程的主函数是SumThreadFunco当主线程创建它时, 会在它唯一的参数pvParam中传入用户输入的数值。该函数然后将uSum初始化为 UINT_MAX,表示函数还没有正常结束。接着SumThreadFunc会设置SEH,这样就能够 捕获线程在运行过程中可能会引发的任何异常。最后函数会调用递归版本的Sum函数来计 算总和。
如果一切顺利，SumThreadFunc会返回uSum变量的值，该返回值也就是线程的退出码。 但如果在Sum函数执行的过程中有异常发生，那么系统会立刻执行SEH的过滤器表达式。 换句话说，系统会调用FilterFunc函数，并传入对应异常的标识码。对栈溢出异常来说， 这个标识码是EXCEPTION_STACK_OVERFLOWo如果想看一下程序得体地处理栈异常 的情况，那么只需输入44 000就可以了。
FilterFunc函数很简单。它会检查有没有发生栈溢出异常，如果没有发生栈溢出异常， 那么它会返回 EXCEPTION_CONTINUE_SEARCH。否则过滤会返回 EXCEPTION_EXECUTE_HANDLERo这等于是告诉系统，过滤程序己经预料到可能会 发生该类异常，应该执行except代码块来对异常进行处理。在这个示例程序中，异常处理 程序没有进行任何特殊处理，但这已经足以让线程得体地退出并返回UINT_MAX（也就是 uSumNum中的值）。父线程会检测到这个特殊的返回值并给用户显示一条警告信息。
最后需要讨论的是为什么要在另一个线程中执行Sum函数而不是直接在主线程中设置 SEH代码块，并在try代码块中调用Sum函数。我之所以创建这个额外的线程，主要是出 于下面4个原因。
首先，当系统创建一个线程时，会给它分配1 MB的栈地址空间区域。如果在主线程内部 调用Sum函数，那么由于部分的栈空间已经被用掉了，因此Sum函数将无法用足1 MB 的栈空间。诚然，这个示例程序只是一个简单的程序，可能并不会用掉太多的栈空间，但 其他程序可能就比较复杂了。我们可以想象这样一种情形,一开始Sum函数能够计算从0〜 1000的总和。然后当再次调用Sum的时候，调用栈可能己经变得更深了，这使得Sum函 数只计算从0〜750的总和就会导致栈溢出。因此，在另一个线程执行Sum函数可以确保 栈空间不会被其他代码占用，从而使得Sum函数的表现更为一致。
第二个原因是每个线程只能收到一次栈溢出异常的通知。如果在主线程调用Sum函数并发 生栈溢出，程序可以捕获该异常并得体地处理。但是，此时栈的所有地址空间区域都已经 调拨了物理存储器，再也没有哪个页面的防护标志是打开的了。如果用户再执行一次求和 操作，那么即使Sum函数可能还会导致栈溢出，也不会再度引发栈溢出异常了。取而代之 的是，这种情况下会引发访问违规异常，但此时再想得体地处理就为时已晚了。当然，我 们可以通过调用C运行库函数—resetstkoflw来解决这个问题。
第三个原因是这样可以释放掉栈所占用的物理存储器。举个例子，用户先调用Sum函数来 计算从0〜30 000的总和。这使得系统要调拨相当多的物理存储器给栈的地址空间区域。 然后用户可能再次执行多次求和操作，但其中最大的数值可能只有5000。在这种情况下， 系统调拨给栈的地址空间区域的很大一部分存储器都用不到了。由于这些物理存储器是从
第16章线程栈
页交换文件中分配的，与其置这些己经调拨的存储器于不顾，不如将它们释放，这样系统 就可以将它们用于其他进程。当SumThreadFunc线程结束时，系统会自动收回调拨给栈 的地址空间区域的物理存储器。
最后一个原因是，当重复使用一个线程来进行所有的计算工作时，需要使用线程同步机制 来协调线程何时开始执行以及如何返回结果。对这个简单的应用程序来说，最简单的方法 莫过于每次创建一个新的线程，传入需要求和的数值，然后等待线程退出并得到结果。
#include #include #include #include #include
/* See Appendix A. */
■..\CommonFiles\CmnHdr.h" <windowsx.h> <limits.h> <tchar.h>
■Resource.h*
SuiDBation. cpp
/•*★**••****★★
Module： Summat ion.cpp
Notices： Copyright (c) 2008 Jeffrey Richter & Christophe Nasarre
******************************************************************************
///////////////////////////////////////////////////////////////////////////////
// An example of calling Sum for uNum = 0 through 9 // uNum: 0123456789...
// Sum： 0 1 3 6 10 15 21 28 36 45 ...
UINT Sum(UINT uNum) (
// Call Sum recursively.
return((xiNum == 0) ? 0 ： (uNum + Sum(uNum - 1)))； }
///////////////////////////////////////////////////////////////////////////////
LONG WINAPI FilterFunc(DWORD dwExceptionCode) {
return((dwExceptionCode == STATUS_STACK_OVERFLOW)
? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH); }
///////////////////////////////////////////////////////////////////////////////
// The separate thread that； is responsible for calculating the sum.
// I use a separate thread for the following reasons:
//	1. A separate thread gets its own 1 MB of stack space.
//	2. A thread can be notified of a st;<a0k overflow only once.
//	3. The stack's storage	whehVthe thread exits.
DWORD WINAPI SumThreadFunc (PVOID pvParam) {共一 .
// The parameter pvParam, contains the number of integers to sum.
UINT uSumNum = PtrToUlonglpvP&rem)	雄逐窸，早*
// uSum contains the summation of	from 0 through uSumNum.
// If the sum cannot be calculatUINT_MAX is returned. UINT uSum = UINT__MAX; 壮 ""牛 侦邓注
/indows核心编程（第5版）
_try {
//To catch the stack overflow exception, we must
// execute the Sum function while inside an SEH block. uSum = Sum(uSumNum);
}
_except (FilterFunc(GetExceptionCode())) (
// if we get in here, it's because we have trapped a stack overflow.
// We can now do whatever is necessary to gracefully continue execution
// This sample application has nothing to do, so no code is placed
// in this exception handler block.
}
// The thread's exit code is the sum of the first uSumNum
// numbers, or UINT_MAX if a stack overflow occurred. return(uSum)；
}
///////////////////////////////////////////////////////////////////////////////
BOOL Dlg_OnInitDialog(HWND hWnd, HWND hWndFocus, LPARAM 1Param) ( chSETDLGICONS(hWnd, IDI_SUMMATION);
// Don't accept integers more than 9 digits long Edit_LimitText(GetDlgltem(hWndz IDC_SUMNUM)r 9);
return(TRUE);
}
///////////////////////////////////////////////////////////////////////////////
void Dlg_OnCommand(HWND hWnd, int id, HWND hWndCtl# UINT codeNotify) ( switch (id) (
case IDCANCEL:
EndDialog(hWnd, id);
break；
case IDC^CALC:
// Get the number of integers the user wants to sum.
BOOL bSuccess = TRUE;
UINT uSum = GetDlgltemlnt(hWnd, IDC_SUMNUM, abSuccess, FALSE); if (!bSuccess) (
MessageBox(hWndr TEXT("Please enter a valid numeric value!"), TEXT("Invalid inputMB.ICONINFORMATION I MB_OK);
SetFocus(GetDlgltem(hWnd, IDC_CALC))；
break；
}
// Create a thread (with its own stack) that is
// responsible for performing the summation.
DWORD dwThreadld;
HANDLE hThread = chBEGINTHREADEX(NULL, 0, SumThreadFunc, (PVOID)	uSum, 0, &dwThreadId)；
// Wait for the thread to
WaitForSingleObject(hThread,
•,.：•'三‘ X 提	，
// The thread's exit code	resulting summation.
GetEx让CodeThreadUhThread, (PDW遵摩争Sum);
// Allow the system to destroy thte^imread kernel object CloseHandle (hThread):； '"
第16章线程栈
// Update the dialog box to show the result.
if (uSum == UINT.J4AX) {
// If result is UINT_MAX, a stack overflow occurred. SetDlgltemText(hWnd, IDC_ANSWERr TEXT("Error"));
chMB("The number is too big, please enter a smaller number-)； } else (
// The sum was calculated successfully; SetDlgltemlnt(hWnd, IDC_ANSWERr uSum, FALSE);
}
break；
}
}
///////////////////////////////////////////////////////////////////////////////
INT_PTR WINAPI Dlg_Proc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM IParam)( switch (uMsg) ( chHANDLE_DLGMSG(hWnd, WK-INITDIALOG, Dlg_OnInitDialog); chHANDLE_DLGMSG(hWnd, WM_COMMAND, Dlg_OnCommand);
}:
return(FALSE);
}
///////////////////////////////////////////////////////////////////////////////
int WINAPI _tWinMain(HINSTANCE hinstExe, HINSTANCE, PTSTR, int) (
DialogBox(hinstExe, MAKEINTRESOURCE(IDD_SUMMATION), NULL, Dlg_Proc); return (0)；
}
//////////////////////////////// End of File //////////////////////////////////
459-462
2二

E 0/
T8 十 / ALT Z9^
第17章内存映射文件

17.2
17.3
17.4
17.5
17.6
17.7
17.8
17.9
映射到内存的可执行文件和DEL 映射到内存的数据文件 使用内存映射文件 用内存映射文件来处理大文件 内存映射文件和一致性 给内存映射文件指定基地址 内存映射文件的实现细节
用内存映射文件在进程间共享数据 以页交换文件为后备存储器的内存映射文件
17.10 稀疏调拨的内存映射文件
几乎每个应用程序都需要处理文件，但要处理好却并不容易。应用程序到底是应该先打开 文件，再读取文件，最后关闭文件呢，还是应该先打开文件，再用一个缓存算法来读取和 写入文件的不同部分？ Microsoft Windows 我们提供了一种两全其美的方式，那就是内存 映射文件。
与虚拟内存相似，内存映射文件允许开发人员预订一块地址空间区域并给区域调拨物理存 储器。不同之处在于，内存映射文件的物理存储器来自磁盘上己有的文件，而不是来自系 统的页交换文件。一旦把文件映射到地址空间，我们就可以对它进行访问，就好像整个文 件都已经被载入内存一样。
内存映射文件主要用于以下三种情况。
•	系统使用内存映射文件来载入并运行.exe和动态链接库(DLL)文件。这大量节省了 页交换文件的空间以及应用程序启动的时间。
•	开发人员可以用内存映射文件来访问磁盘上的数据文件。这使得我们可以避免直接 对文件进行I/O操作和对文件内容进行缓存。
•	通过使用内存映射文件，我们可以在同一台机器的不同进程之间共享数据。 Windows的确提供了其他一些方法来在进程间传送数据，但这些方法都是通过内存 映射文件来实现的。因此，如果要在同一台机器的不同进程之间共享数据，内存映 射文件是最高效的方法。
第17章内存映射文件
本章我们将对内存映射文件的以上三种用法进行讨论。
[463 滕
17.1映射到内存的可执行文件和DLL
当一个线程在调用CreateProcess的时候，系统会执行以下步骤。
(1)	系统会先确定CreateProcess所指定的可执行文件所在的位置。如果无法找到该.exe文 件，那么系统将不会创建进程，这时CreateProcess会返回FALSE。
(2)	系统创建一个新的进程内核对象。
(3)	系统为新进程创建一个私有地址空间。
(4)	系统预订一块足够大的地址空间来容纳.exe文件。待预订的地址空间区域的具体位置 己经在.exe文件中指定。默认情况下，.exe文件的基地址是0x00400000o (对运行在64 位Windows下的64位应用程序来说，这个地址可能会有所不同。)但是，只需在构建 应用程序的・exe文件时使用/BASE链接器开关，我们就可以给自己的应用程序指定一 个不同的地址。
(5)	系统会对地址空间区域进行标注，表明该区域的后备物理存储器来自磁盘上的.exe文 件，而并非来自系统的页交换文件。
当系统把.exe文件映射到进程的地址空间之后，会访问.exe文件中的一个段，这个段列出 了一些DLL文件，它们包含该.exe文件调用到的函数。然后系统会调用LoadLibrary来载 入每个DLL,如果哪个DLL需要用到其他DLL,那么系统同样会调用LoadLibrary来载 入相应的DLLo系统每次调用LoadLibrary来载入一个DLL的时候，执行的操作与刚才 列出的第4步和第5步相似。
(1)	系统会预订一块足够大的地址空间区域来容纳DLL文件。待预订的地址空间区域的具 体位置已经在DLL文件中指定。默认情况下，Microsoft链接器将x86平台的DLL的 基地址设为0x10000000,将x64平台的DLL的基地址设为0x00400000。但是，只需 在构建DLL文件时使用/BASE链接器开关，我们就可以指定一个不同的基地址。所有 与Windows 一起发布的系统DLL都有不同的基地址，这样即使把它们载入到同一个 地址空间，也不会发生重叠。
(2)	如果系统无法在DLL文件指定的基地址处预订区域，这可能是因为该区域已经被另一 个DLL或.exe占用，也可能是因为区域不够大，这时系统会尝试在另一个地址来为 DLL预订地址空间区域。如果系统无法将DLL载入到指定的基地址，那么这种情况就 不太走运了。这有两个原因。首先，如果DLL不包含重定位信息，那么系统将无法载 入DLL。(当使用链接器的/FIXED开关来构建DLL时，可以从DLL中去除重定位信 息。这可以使DLL文件变得更小，但这也意味着DLL“必须”被载入到指定的基地址， 否则的话它将无法被载入。)其次，系统必须对DLL执行重定位操作。重定位不仅需 要占用页交换文件中额外的存储空间，而且会增加载入DLL所需的时间。
(3)	系统会对地址空间区域进行标注，表明该区域的后备物理存储器来自磁盘上的DLL文 件，而并非来自系统的页交换文件。如果由于Windows不能将DLL载入到指定的基 地址而必须执行重定位的话，那么系统还会另外进行标注，表明DLL中有一部分物理
鬲dows核心编程(第5版)
存储器被映射到了页交换文件。
奄464
如果因为某些原因系统无法将.exe文件和所需的DLL映射到地址空间区域，系统会先给用 户显示一个对话框，然后释放进程的地址空间和进程对象。这时CreateProcess会返回 FALSE,调用方可以通过调用GetLastError来查询为什么无法创建进程。
把所有的.exe文件和DLL文件都映射到进程的地址空间之后，系统会开始执行.exe文件的 启动代码。当完成对.exe文件的映射后，系统会负责所有的换页(paging)、缓存(buffering)> 以及高速缓存(caching)操作。例如，如果.exe文件中的代码跳转到一个指令地址，但该地 址尚未载入内存，那么会引发一个页面错误(page fault)o系统会检测到这个错误并自动将该 页代码从文件映像载入到内存中。然后系统会把该内存页映射到进程地址空间中的适当位 置，并让线程继续执行，就好像该页代码早已载入内存一样。当然，这一切对应用程序来 说都是透明的。每当线程试图访问尚未载入内存的代码或数据时，系统都会重复这一过 程。
17.1.1同一个可执行文件或DLL的多个实例不会共享静态数据
如果一个应用程序已经在运行，那么当我们为这个应用程序创建一个新的进程时，系统只 不过是打开另一个内存映射视图(memory-mapped view),创建一个新的进程对象，并(为主 线程)创建一个新的线程对象。这个新打开的内存映射视图隶属一个文件映射对象 (file-mapping object),后者用来标识可执行文件的映像。系统同时给进程对象和线程对象分 别指定新的进程ID(process id)和线程ID(thread id)o通过使用内存映射文件，同一个应用程 序的多个实例可以共享内存中的代码和数据。
注意，这里存在一个小问题。进程使用的是一个平面的地址空间。编译和链接程序的时候, 所有的代码和数据都被放在一个大的实体中。在.exe文件中，数据位于代码之后，它和代 码的分隔仅限于此。(详情请参阅后面的说明。)下图是一个简单的视图，它描绘了如何把 应用程序中的代码和数据载入到虚拟内存，并将它们映射到地址空间中。
磁盘上的可 执行文件
代码段包含3个 页面的代码
数据段包含2个 页面的数据
虚拟内存
代码页面2
代码页面1
数据页面2
代码页面3
数据页面1
应用程序的 地址空间
代码页面1
代码页面2
数据页面1
代码页面3
数据页面2
举个例子，假设应用程序的第二个实例现在开始运行。这时系统只不过是把包含应用程序 代码和数据的虚拟内存页面映射到第一：个实例的地址空间中，如下图所示。
465
虚拟内存
第一个实例的 地址空间
第二个实例的 地址空间
代码页面2
代码页面1
数据页面2
代码页面3
数据页面1
数据页面1
代码页面3
数据页面2
、/一 代码页面1
—~代码页面2
说明 实际上，文件的内容被分为段。代码在一个段中，而全局变量在另一个段中。段是 对齐到页面大小的整数倍。应用程序可以通过调用GetSystemlnfo来检测页面大小。 在.exe或DLL文件中，代码段通常在数据段的前面。
如果应用程序的一个实例修改了数据页面中的一些全局变量，那么应用程序所有实例的内 存都会被修改。由于这种类型的修改可能会导致灾难性的结果，因此必须避免。
系统通过内存管理系统的写时复制(copy-on-write)特性来防止这种情况的发生。任何时候当 应用程序试图写入内存映射文件的时候，系统会首先截获此类尝试，接着为应用程序试图 写入的内存页面分配一块新的内存，然后复制页面内容，最后让应用程序写入到刚分配的 内存块。最终的结果就是，应用程序的其他实例不会受到任何影响。下图描绘了当应用程 序的第一个实例试图修改数据页面2中的一个全局变量时，会产生怎样的结果。
虚拟内存
第二个实例的
地址空间
代码页面I
代码页面2
数据页面2
代码页面3
数据页面1
第一个实例的 地址空间
系统先分配了一页新的虚拟内存(在上图中被标记为“New page” ),然后把数据页面2中 的内容复制到新页面中。系统会更新第一个实例的地址空间，这样新的数据页面就会和原 始数据页面一样，映射到进程地址空间中的同一位置。现在系统不仅可以让进程修改全局 变量的值，而且也不用担心会修改到同一个应用程序的其他实例的数据了。
在调试应用程序的时候会发生类似的事件序列。假设我们已经运行了同一应用程序的多个 实例，现在想要调试其中的一个实例。我们用调试器在源代码的某一行设了一个断点。这 时调试器会修改我们的代码，把其中一条汇编语言指令改成一条激活调试器的指令。这样 我们又再次面临同样的问题。如果调试器直接修改代码，那么会导致应用程序的所有实例 在运行到修改后的指令时都去激活调试器。为了解决这个问题，系统再次使用写时复制内
OWS核心编程（第5版）
存。当系统发现调试器试图修改代码时，会分配一块新的内存，接着把原始页面中的指令 复制到新页面，然后就可以让调试器在页面的副本中对代码进行修改了。
说明 当系统创建一个进程时，会检查文件映像的所有页面。对那些通常需要用写时发制 属性进行保护的页面，系统会立即从页交换文件中调拨存储器。但系统只是调拨这 些页面，而不会实际载入页面的内容。当程序访问到文件映像中的一个页面时，系 统会载入相应的页面。如果该页从未修改过，那么可以舍弃其中的内容并在需要时 重新载入。但如果文件映像的该页面被修改过，那么系统必须把修改过的页面调换 到页交换文件中。
17.1.2在同一个可执行文件或DLL的多个实例间共享静态数据
默认情况下，同一个.exe文件或DLL的多个实例之间不会共享全局或静态数据，这样的设 计是最保险的。但是，有些情况下在同一个.exe文件或DLL的多个实例之间共享同一个变 量不仅有用，而且方便。例如，Windows没有提供一种简便的方法来检查用户是否在运行 同一个应用程序的多个实例。如果应用程序的所有实例能够共享同一个全局变量，那么我 们就可以用这个变量来保存正在运行的实例的数量。当用户启动应用程序的一个新的实例 时，新的实例只需检查这个（已经被另一个实例修改过的）全局变量的值，如果计数大于1, 那么第二个实例就可以先告诉用户同一时刻只能运行该应用程序的一个实例，然后再退出 运行。
本节讨论一项可以在同一个.exe文件或DLL的多个实例之间共享变量的技术。但在深入讨 论细节之前，我们还需要再多了解一点背景知识。
每个.exe文件或DLL文件映像由许多段组成。按照惯例，每个标准的段名都以点号开始。 例如，在编译程序的时候，编译器会将代码放在一个名叫.text的段中。此外，编译器还会 将未经初始化的数据放在.bss段中，将巳初始化的数据放在.data段中。
每个段都有一些与之相关联的属性，如表17-1所示。
表17-1段的属性
属性	含义
READ	可以从该段读取数据
WRITE	可以向该段写入数据
EXECUTE	可以执行该段的内容
SHARED	该段的内容为多个实例所共享（这个属性事实上关闭了写时复制机制）
我们可以用Microsoft Visual Studio的DumpBin .11具（需指定/Headers开关）来查看.exe或 DLL映像文件中的各个段。下面的内容摘录自对某个.exe文件运行DumpBin后所得到的
第17章内存映射文件
结果:
SECTION HEADER #1
.text name
11A70 virtual size
1000 virtual address 12000 size of raw data
1000
0
0
0
0
60000020
file pointer to raw data
file pointer to relocation table file pointer Co line numbers number of relocations
number of line numbers flags
Code
Execute Read
SECTION HEADER #2
.rdata name
1F6 virtual size 13000 virtual address 1000 size of raw data 13000
0
0
0
0
file pointer to raw data
file pointer to relocation table file pointer to line numbers number of relocations
number of line numbers
40000040 flags
Initialized Data
Read Only
SECTION HEADER #3
.data name
560 virtual size 14000 virtual address 1000 size of raw data 14000
0
0
0
0
C0000040 flags
Initialized Data Read Write
file pointer to raw data
file pointer to relocation table file pointer to line numbers number of relocations
number of line numbers
SECTION HEADER #4
.idata name
58D virtual size 15000 virtual address 1000 size of raw data 15000
0
0
0
0
C0000040 flags
Initialized Data Read Write
file pointer to raw data
file pointer to relocation table file pointer to line numbers number of relocations
number of line numbers
SECTION HEADER #5
.didat name
7A2 virtual size 16000 virtual address 1000 size of raw data 16000
0
0
0
file pointer to raw data
file pointer to relocation table file pointer co line numbers number of relocations
indows核心编程(第5版)
0 number of line numbers
C0000040 flags
Initialized Data
Read Write
SECTION HEADER #6
.reloc name
26D virtual size
17000 virtual address
1000 size of raw data
17000 file pointer to raw data
0 file pointer to relocation table
0 file pointer to line numbers
0 number of relocations
0 number of line numbers
42000040 flags
Initialized Data
Discardable
Read Only
Summary
1000 .data
1000 .didat
1000 .idata
1000 .rdata
1000 .reloc
12000 .text
探46翰69 c
表17.2列出了一些常用段的名字，并解释了每个段的用途。
表17・2可执行文件的常用段
段名	目的
.bss	未经初始化的数据
.CRT	只读的C运行时数据
.data	已初始化的数据
.debug	调试信息
.didata	延迟导入的名字表(Delay imported names table)
.edata	导出的名字表(Exported names table)
.idata	导入的名字表(Imported names table)
.rdata	只读的运行时数据
.reloc	重定位表信息
.rsrc	资源
.text	.exe文件或DLL的代码
.textbss	当启用增量链接(Incremental Linking)选项时，由C++编译器生成
.tls	线程本地存储(Thread-local storage)
.xdata	异常处理表
除了使用编译器和链接器所创建的标准段之外，我们还可以在编译的时候使用下面的编译 器指示符来创建自己的段：
第17章内存映射文件
#pragma data_seg("sectionname")
举个例子，我们可以用下面的代码来创建一个名为“Shared”的段，它只包含一个LONG 变量：
#pragma data_seg("Shared") LONG g_lInstanceCount = 0; #pragma data_seg()
当编译器编译这段代码的时候，会创建一个名为Shared的段，并将pragma指示符之间所 有带初始值的变量放到这个新的段中。在上面的例子里，这个变量就被放到了 Shared段中。 变量后面的#pragma data_seg()那一行告诉编译器停止把已初始化的变量放到Shared段中， 而是重新开始把它们放回到默认的数据段中。需要紧记的极其重要的一点是，编译器只会 将己初始化的变量保存在这个段中。假如我们从刚才的代码中去掉初始化的部分(如下面的 代码所示)，那么编译器就会将该变量放到Shared段以外的其他段中：
#pragma data_seg("Shared") LONG g_lInstanceCount;
#pragma data_seg()
但是，Microsoft Visual C++编译器也确实提供了一个 allocate 声明符(declaration specifier), 它允许我们将未经初始化的数据放到任何我们想要放的段中。让我们看一下下面的代码：
// Create Shared section & have compiler place initialized data in it. 'pragma data_seg(■Shared")
// Initialized, in Shared section int a = 0;
// Uninitialized, not in Shared section int b;
// Have compiler stop placing initialized data in Shared section. #pragma data_seg()
// Initialized, in Shared section
_declspec(allocate("Shared")) int c = 0；
// Uninitialized, in Shared section _declspec(allocate("Shared")) int d;
// Initialized, not in Shared section int e = 0;
// Uninitialized, not in Shared section int f ；
代码中的注释已经清楚地说明了哪个变量会放在哪个段中。为了让allocate声明符能够正 常工作，必须先创建相应的段。因此，如果把第一行#pragma data.seg删除，代码将无法 编译。
之所以要将变量放到一个单独的段中，最常见的原因也许就是为了在同一个.exe或DLL的 多个实例间共享变量。默认情况下，同一个.exe或DLL的每个实例都会有自己的一组变量。 但是，对那些想要在多个实例间共享的变量，我们可以把它们放到一个单独的段中。一旦 把变量放到单独的段中，系统就不会再在同一个可执行或DLL的每个实例中为它们创建新
j^^dows核心编程(第5版)
的实例了。
为了共享变量，仅仅告诉编译器把变量放到单独的段中是不够的。我们还必须告诉链接器 要共享这个段中的变量。这可以通过在链接器的命令行中使用/SECTION开关来实现： /SECTION：name/attributes
冒号后面用来指定想要改变哪个段的属性。在这里的例子中，我们想要改变Shared段的属 性，因此应该使用下面的链接器开关：
/SECTION:Shared,RWS
O
逗号后面用来指定想要的属性：R表示READ, W表示WRITE, E表示EXECUTE, S表 示SHARED。这个链接器开关表示Shared段中的数据不仅可读写，而且是共享的。如果想 要改变多个段的属性，必须在命令行中使用多个/SECTION开关，一个开关对应一个段。
我们也可以用下面的写法，直接把链接器开关嵌入到源代码中：
#pragma comment(linker, "/SECTION:Shared,RWS")
这行代码告诉编译器把其中的字符串嵌入到所生成的.Obj文件中的一个特殊的段中，这个 段名叫“.drectve”。当链接器把所有的.obj模块合并到一起的时候，链接器会检查每个.obj 模块的“.drectve”段，并将所有的字符串当作是传给链接器的命令行参数。我一直使用这 项技术，因为它太方便了——如果要把源文件加到一个新的项目里，也不必记着在Visual C++的项目属性中设置链接器开关。
虽然我们可以创建共享段，但Microsoft并不鼓励使用共享段。这出于两个原因。首先，以 这种方式共享内存可能会导致潜在的安全漏洞。其次，共享变量意味着一个应用程序中的 错误可能会影响到另一个应用程序，因为没有任何方法能够保护共享变量，使它们不会被 错误地改写。
假设我们正在开发两个应用程序，每个都需要用户输入密码。但是，为了方便用户的使用， 我们决定给应用程序增加一项特性：如果用户在其中一个应用程序已经运行的时候启动另 一个应用程序，那么第二个应用程序会检查共享内存的内容来得到密码。这样，如果用户 己经在使用其中一个应用程序，那么他就不必再次输入密码了。
这听起来似乎没有什么害处，毕竟只有我们自己的应用程序才会载入这个DLL,并且也只 有我们才知道密码放在共享段中的哪里。但是，黑客无处不在。如果想要得到密码，那么 他们只需要写一个小程序来载入我们的DLL并监视共享内存块就可以了。只要用户输入密 码，黑客的程序就可以得到密码。
另外，黑客的程序也可以不断地猜测密码并把它们写入到共享内存中。一旦程序猜对了正 确的密码，它就可以给我们两个应用程序中的任何一个发送各种命令了。如果有一种方法 能够只允许特定的应用程序载入一个DLL,那么也许这个问题可以解决。但目前这还行不 通——任何程序都可以调用LoadLibrary来显式地载入DLL。
第17章内存映射文件
17.1.3	Application Instances 示例程序
下面介绍的Application Instances示例程序(17-Applnst.exe)展示了应用程序如何知道在任一 时刻有多少个自己的实例正在运行。应用程序的源代码和资源文件在本书配套网页的 17-AppInst目录中。当Applnst启动时，会显示下图所示的对话框，表示应用程序有一个实 例正在运行。
u
©Application Instances	O 演
Number of instances running:	1
472
如果运行应用程序的第二个实例，那么两个实例的对话框都会更新，表示现在有两个实例 正在运行，如下图所示。
® Application Instances 圜回冒	
Number of instances running:	2	Number of instances running:	2
我们可以运行和关闭任何数量的Applnst实例，对话框中的数值会准确地显示当前正在运 行的实例的总数。
在Applnstxpp中接近顶部的的地方，可以找到如下代码：
// Tell the compiler to put this initialized variable in its own Shared
// section so it is shared by all instances of this application.
#pragma data_seg("Shared")
volatile LONG g_lApplicationInstances = 0;
#pragma data_seg()
// Tell the linker to make the Shared section
// readable, writable, and shared.
#pragma comment(linker, n/Section：Shared,RWS")
这些代码创建一个名叫Shared的段，它具有读、写和共享保护属性。在这个段中有一个变 量g_lApplicationInstances,应用程序的所有实例都会共享这个变量。注意，这个变量使用 了 volatile修饰符，这样可以避免让优化程序做一些我们不希望看到的优化。
当每个实例的_tWinMain函数运行的时候，g_lApplicationInstaiices变量会加1。在 jWinMain退出之前，该变量会减1。由于会有多个线程访问这个共享资源，因此程序使 用了 InterlockedExchangeAdd来修改变量的值。
当每个实例显示对话框的时候，会调用Dlg_OnInitDialog函数。该函数会给所有顶层窗口 (top-level window)广播一条窗口消息(该消息的标识号保存在g uMsgAppInstCountUpdate变 量中)：
PostMessage(HWND_BROADCAST, g_uMsgAppTnstCountUpdate, 0, 0)；
jndows核心编程（第5版）
除了示例程序的窗口，系统中的所有其他窗口会忽略这条窗口消息。当示例程序的窗口收 到这条消息的时候，Dlg_Proc中的代码会根据（保存在共享变量gJApplicationlnstances中 的）当前的实例数量来更新对话框中的数值。
473
Applnst.cpp /*★•********************★**************★*************************************** Module: Applnst.cpp
Notices: Copyright （c） 2008 Jeffrey Richter & Christophe Nasarre
#include •..\CommonFiles\CmnHdr.hB /* See Appendix A. */ #include <windowsx.h>
#include <tchar.h>
#include "Resource.h"
///////////////////////////////////////////////////////////////////////////////
// The system-wide window message, unique to the application UINT g_uMsgAppInstCoimtUpdate = WM_APP+123;
///////////////////////////////////////////////////////////////////////////////
// Tell the compiler to put this initialized variable in its own Shared
// section so it is shared by all instances of this application.
#pragma data_seg(■Shared■)
volatile LONG g_lApplicationinstances = 0;
#pragma data_seg()
// Tell the linker to make the Shared section readable, writable, and shared. #pragma comment(linker, "/Section：Shared,RWS")
///////////////////////////////////////////////////////////////////////////////
BOOL Dlg_OnInitDialog(HWND hWnd, HWND hWndFocus, LPARAM IParam) (
chSETDLGICONS (hWnd, IDI__APPINST);
// Force the static control to be initialized correctly. PostMessage(HWND_BROADCAST, g_uMsg^pInstCountUpdate, 0, 0); return(TRUE);
}
.. .y
///////////////////////////////////////////////////////////////////////////////
void Dlg_OnCommand(HWND hWnd, int id, HWND hWndCtl, UINT codeNotify) {
switch (id) {
case IDCANCEL:	",	%	'忘二.
EndDialog(hWnd, id)；
break；	眼	"
}
}
/////////////////////////////////////〃//〃/〃////////////////////〃///////////
第17章内存映射文件
INT.PTR WINAPI Dlg_Proc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM 1Param) ( if (uMsg == g_uMsgAppInstCountUpdate) (
SetDlgltemlnt(hWnd, IDC_COUNTr g_lApplicationinstances, FALSE);
switch (uMsg) {
chHANDLE_DLGMSG(hWndr W1C.INITDIAL0G, Dlg_OnInitDialog); chHANDLE_DLGMSG(hWnd, WH.COMMAND,	Dlg_OnCommand);
}
return(FALSE);
///////////////////////////////////////////////////////////////////////////////
int WINAPI _tWinMain(HINSTANCE hlnstExe, HINSTANCE, PTSTR, int) {
// Get the numeric value of the systemwide window message used to notify // all top-level windows when the module's usage count has changed. g__uMsgAppInstCountUpdate =
Reg i s t erW i ndowMe s s age(TEXT("MsgAppInstCountUpdate*))；
// There is another instance of this application running
InterlockedExchangeAdd(&g_lApplicationinstances, 1)；
DialogBox(hlnstExe, MAKEINTRESOURCE(IDD^APPINST), NULL, Dlg^Proc);
// This instance of the application is terminating
InterXockedExchangeAdd(&g_lApplicationinstances, -1)；
// Have all other instances update their display PostMessage(HWND__BROADCAST, g_uMsgApp!nstCountUpdate, 0, 0);
return(0)；
}
//////////////////////////////// End of File //////////////////////////////////
淑 474*475
17.2映射到内存的数据文件
Windows操作系统使我们能够把数据文件映射到进程的地址空间中，这样一来，对大型数 据流进行操控就非常容易。
为了理解以这种方式使用内存映射文件究竟能有多大的威力，让我们来看一个颠倒文件内 容的例子。我们可以通过4种方法来实现这个程序。
17.2.1方法1： 一个文件，一块缓存
第一种方法，也是理论上最简单的方法，是分配一块足够大的内存来存放整个文件。接着 打开文件，把文件内容读取到内存中，然后关闭文件。这时我们可以对内存中的文件内容
ows核心编程（第5版）
进行操作，把第一个字节和最后一个字节交换，把第二个字节和倒数第二个字节交换，以 此类推。交换操作一直继续，直到到达文件的中间。当所有的字节都交换完成后，我们就 可以再次打开文件并用内存中的文件内容覆盖掉原来的内容。
这种方法实现起来非常简单，但它有两个主要的缺点。首先，必须根据文件的大小来分配 一块内存。如果文件比较小，那么情况可能不会太糟，但如果文件其大无比怎么办——比 如说2 GB? 32位操作系统不允许应用程序调拨那么大的物理存储器。大文件需要用其他的 方法来处理。
其次，如果在把已经颠倒了顺序的文件内容写入到文件的过程中处理被中断，那么文件的 内容将被破坏。避免这种情况最简单的方法是，在颠倒文件内容之前先把原始文件复制一 份。如果整个过程成功完成，就可以删除文件的副本。但遗憾的是，这样的安全防范措施 需要占用额外的磁盘空间。
17.2.2方法2：两个文件，一块缓存
在第二种方法中，我们先打开已有的文件并在磁盘上创建一个长度为o的新文件。接着分 配一块较小的内部缓存，比如8KB。然后将文件指针定位到原始文件末尾减去8 KB的地 方，把最后8 KB的内容读取到缓存中，颠倒缓存的内容，将颠倒后的内容写入到新创建的 文件。这个定位文件指针、读取文件、颠倒缓存、写入文件的过程一直继续，直到到达原 始文件的起始位置。如果文件的长度不是8 KB的整数倍，那么需要一些特殊处理，但也不 算太麻烦。完全处理完原始文件后，把两个文件都关闭并删除原始文件。
与第一种方法相比，这种方法的实现要复杂一些。由于只分配了 8 KB的内存，因此它的内 存使用率更高。但这种方法同样存在两个问题。首先，由于每次在读取原始文件之前都必 须执行文件指针定位操作，因此它的处理速度比第一种方法慢。其次，这种方法可能会消 耗大量的磁盘空间。如果原始文件的大小为1GB,那么在处理的过程中新文件将逐渐增大 到1GB。在原始文件被删除之前，这两个文件将占用2GB的磁盘空间。与实际应该需要 的磁盘空间相比，这整整多了 1GB——正是这个缺点导致了第3种方法的产生。
17.2.3方法3： 一个文件，两块缓存
在这种方法中，我们在程序初始化的时候分配两块大小为8 KB的缓存。程序接着把文件开 始的8 KB内容读取到第一块缓存中，把文件末尾的8 KB内容读取到另一块缓存中。然后 把两块缓存的内容颠倒，并把第一块缓存的内容写回到文件的末尾，把第二块缓存的内容 写回到文件的开头。这个过程会一直继续，每次都把靠近文件头部的8 KB内容和靠近文件 尾部的8 KB内容相互交换。如果文件的大小不是16 KB的整数倍，那么最后两块8 KB的 缓存会有一部分内容重叠，这种情况需要进行特殊处理。与前一种方法相比，这里的特殊 处理要更加复杂，但也还不至于吓倒有经验的程序员。
第17章内存映射文件
与前两种方法相比，这种方法能更好地节省磁盘空间。由于所有的数据都读取自和写入到 同一个文件，因此不需要额外的磁盘空间。在内存使用方面，这种方法也不差，只使用了 16 KB内存。当然，这种方法可能是最难实现的。与第一种方法一样，如果处理过程被中 断，那么这种方法还可能会导致数据文件被破坏。
现在让我们来看一看如何用内存映射文件来实现整个处理过程。
17.2.4方法4： 一个文件，零个缓存
使用内存映射文件来颠倒文件内容时，我们先打开文件并向系统预订一块虚拟地址空间区 域。接着让系统把文件的第一个字节映射到该区域的第一个字节。然后就可以访问这块虚 拟内存区域，就好像它实际上包含了文件一样。事实上，如果要颠倒的是一个文本文件， 而且文件末尾的字节为o,则可以把这个文件当作内存中的一个字符串来处理，在这种情 况下，直接调用C运行库函数_tcsrev就能颠倒文件中的数据。
这种方法最大的优点在于让系统为我们处理所有与文件缓存有关的操作。我们不必再分配 任何内存，把文件中的数据载入内存，把数据写回文件、以及释放内存块。但遗憾的是， 使用内存映射文件的时候，如果操作过程被中途打断(比如电源断电)，仍然可能导致数据 被破坏。
17.3使用内存映射文件
要使用内存映射文件，需要执行下面三个步骤。
(1)	创建或打开一个文件内核对象，该对象标识了我们想要用作内存映射文件的那个磁盘 文件。
(2)	创建一个文件映射内核对象(file-mapping kernel object)来告诉系统文件的大小以及我 们打算如何访问文件。
(3)	告诉系统把文件映射对象的部分或全部映射到进程的地址空间中。
用完内存映射文件之后，必须执行下面三个步骤来做清理工作。
(1)	告诉系统从进程地址空间中取消对文件映射内核对象的映射。
(2)	关闭文件映射内核对象。
(3)	关闭文件内核对象。
下面将详细讨论了所有这些步骤。
477
Endows核心编程（第5版）
17.3.1第1步：创建或打开文件内核对象
我们总是通过调用CreateFile函数来创建或打开一个文件内核对象：
HANDLE CreateFile（
PCSTR pszFileName,
DWORD dwDesiredAccess,
DWORD dwShareMode,
PSECURITY_ATTRIBUTES psa,
DWORD dwCreationDisposition,
DWORD dwFlagsAndAttributes,
HANDLE hTemplateFile）；
CreateFile有许多参数，其中的大部分已经在第10章做了介绍。这里只集中讨论前3个参 数：pszFileName* dwDesiredAccess 和 dwShareMode。
正如读者可能猜到的那样，第一个参数pszFileName表示想要创建或打开的文件的名称（文 件名既可以包含路径，也可以不包含路径）。第二个参数dwDesiredAccess用来指定打算如 何访问文件的内容，这可以是表17-3中列出的4个值之一。
表17・3希望的文件访问权限
值	含义
0	既不能读取文件的内容也不能写入文件。如果只想取得文件 的属性，可以使用0
GENERIC READ	可以读取文件
GENERIC WRITE	可以写入文件
GENERIC READ | GENERIC WRITE	既可以读取文件，也可以写入文件
在创建或打开一个作为内存映射文件来使用的文件时，应该根据我们打算如何访问文件来 选择一个或一组最合适的标志。对内存映射文件来说，必须以只读方式或读/写方式来打开 文件，因此我们可以相应地使用 GENERIC_READ 或 GENERIC_READ | GENERIC_WRITEo
第3个参数dwShareMode告诉系统我们打算如何共享这个文件。它的值可以是表17-4中 列出的4个值之一。
表17»4文件共享模式
值	含义
0	其他任何试图打开文件的操作都会失败
FILE_SHARE_READ	其他任何试图通过GENERIC_WRITE来打开文件的 操作都会失败
第17章内存映射文件
	续表
值	含义
F!LE_SHARE_ WRITE	其他任何试图通过GENERIC_READ来打开文件的操 作都会失败
FILE SHARE READ | FILE SHARE WRITE	其他任何试图打开文件的操作都会成功
如果CreateFile成功地创建或打开了指定的文件，它会返回一个文件内核对象的句柄。否 则，它返回 INVALID HANDLE VALUEo
说明 大多数返回句柄的Windows函数会在失败的时候返回NULL。但CreateFile返回 的是 INVALID HANDLE VALUE,该值被定义为（（HANDLE） -1）。
17.3.2第2步：创建文件映射内核对象
调用CreateFile是为了告诉操作系统文件映射的物理存储器所在的位置。传入的路径是文 件在磁盘（也可以是网络或光盘）上所在的位置，文件映射对象的物理存储器来自该文件。 现在我们必须告诉系统文件映射对象需要多大的物理存储器。为了达到这一目的，必须调 用 CreateFileMapping：
HANDLE CreateFileMapping（
HANDLE hFile,
PSECURITY_ATTRIBUTES psa,
DWORD fdwProtect,
DWORD dwMax imumS i z eH i gh,
DWORD dwMaximumS i zeLow,
PCTSTR pszName）；
第1个参数hFile是需要映射到进程地址空间的文件的句柄。该句柄是前面调用CreateFile 的时候返回的。参数psa是一个指向SECURITY_ATTRIBUTES结构的指针，它用于文件 映射内核对象，一般来说传NULL就可以了（提供了默认的安全性，此外返回的句柄是不可 继承的）。
正如本章开头所指出的，创建一个内存映射文件相当于先预订一块地址空间区域，然后再 给区域调拨物理存储器。唯一的不同之处在于内存映射文件的物理存储器来自于磁盘上的 文件，而不是从系统的页交换文件中分配的。创建一个文件映射对象的时候，系统不会预 订一块地址空间区域并把文件映射到该区域中。（我们将在下一节讨论如何让系统执行这一 操作。）但是，当系统在映射进程地址空间的时候，它必须知道应该给物理存储器的页面指 定何种保护属性。CreateFileMapping的fdwProtect参数就是让我们指定保护属性的。大 多数情况下，我们会指定表17-5中列出的5种保护属性之一。
lows核心编程(第5版)
表17・5页面保护属性
保护属性	含义
PAGE_READONLY	完成对文件映射对象的映射时，可以读取文件中的数据。在调 用 CreateFile 时必须传 GENERIC READ
PAGE_READWRITE	完成对文件映射对象的映射时，可以读取文件中的数据并将数 据写入文件。在调用CreateFile时必须传GENERIC_READ | GENERIC WRITE
PAGE_WRITECOPY	完成对文件映射对象的映射时，可以读取文件中的数据并将数 据写入文件。写入操作将导致系统为页面创建一份副本。在调用 CreateFile 时必须传 GENERIC_READ 或 GENERIC_READ | GENERIC WRITE
PAGE_EXECUTE_READ	完成对文件映射对象的映射时，可以读取文件中的数据，也可 以运行其中的代码。在调用CreateFile时必须传 GENERIC READ 和 GENERIC EXECUTE
PAGE_EXECUTE_READWRITE	完成对文件映射对象的映射时，可以读取文件中的数据并将数据 写入文件，还可以运行其中的代码。在调用CreateFile时必须传 GENERIC READ、GENERIC WRITE 和 GENERIC EXECUTE
除了刚才提到的页面保护属性，我们还可以把5种段属性与CreateFileMapping的 fdwProtect参数按位或起来。“段”只不过是内存映射的另一种叫法，这种类型的内核对 象可 以通过 Process Explorer(http://www.microsoft.com/technet/sysintemals/Security/ ProcessExplorer.mspx)来查看。Process Explorer 由 Sysintemals 开发①。
这些段属性中的第一个是SEC_NOCACHE,它告诉系统不要对内存映射的页面进行缓存。 因此，如果把数据写入文件，那么与通常的情况相比，系统会更频繁地更新磁盘上的文件。 这个标志和PAGE_NOCACHE保护属性相似，主要是给驱动程序开发人员使用的，普通 应用程序一般不会用到。
第二个段属性是SECJMAGE,它告诉系统要映射的文件是一个PE文件映像。当系统把 文件映射到进程地址空间中的时候，系统会检查文件的内容并决定应该给各页面指定何种 保护属性。例如，PE文件的代码段(.text)一般用PAGE_EXECUTE_READ属性来映射， 而数据段(.data)一般用PAGE_READWRITE属性来映射。指定SEC_IMAGE属性相当于 告诉系统要映射文件的映像并给页面设置相应的保护属性。
接下来两个属性分别是SEC_RESERVE和SEC_COMMIT,它们不仅是互斥的，而且也 不适用于映射到内存的数据文件。这两个标志将会在17.10节“稀疏调拨的内存映射文件” 中讨论。创建内存映射数据文件的时候，不应该使用这两个标志中的任何一个， CreateFileMapping 会忽略它们。
① 译注：Sysintemals已被Microsoft收购。
第17章内存映射文件
最后一个属性是SEC_LARGE_PAGES,它告诉Windows要为内存映射文件使用大页面内 存。只有当用于PE映像文件或内存映射文件的时候，这个属性才是有效的。当我们把自 己的数据文件映射到内存的时候，是无法使用该属性的。正如15.3节“同时预订和调拨物 理存储器”中讨论VirtualAlloc时所述，要使用大页面内存必须满足下列条件。
•	在调用CreateFileMapping的时候，必须同时指定SEC_COMMIT属性来调拨内存。
•	映射的大小必须大于GetLargePageMinimum函数的返回值。(请参见稍后对 dwMaximumSizeHigh 和 dwMaximum 这两个参数的解释。)
•	必须用PAGE_READWRITE保护属性定义映射。
•	用户必须具有并启用内存中锁定页面用户权限，否则CreateFileMapping函数调用 将会失败。
CreateFileMapping的下面两个参数最重要，它们分别是dwMaximumSizeHigh和 dwMaximumSizeLowo CreateFileMapping函数的主要目的是为了确保有足够的物理存储 器可供文件映射对象使用。这两个参数告诉系统内存映射文件的最大大小，以字节为单位。 由于Windows支持的最大文件大小可以用64位整数表示，因此这里必须使用两个32位值, 其中参数dwMaximumSizeHigh表示高32位，而参数dwMaximumSizeLow则表示低32 位。对小于4 GB的文件来说，dwMaximumSizeHigh始终为0。
使用64位整数意味着Windows能够处理大到16 EB(exabyte)的文件。如果想要用当前的文 件大小创建一个文件映射对象，那么只要传0给这两个参数就可以了。如果想要读取文件 或在不改变文件大小的前提下访问文件，那么同样需要传。给这两个参数。如果想要给文 件追加数据，那么在选择文件最大大小的时候应该留有余地。如果当前磁盘上的文件大小 为 0 字节，就不能传两个 0 给 CreateFileMapping 的 dwMaximumSizeHigh 和 dwMaximumSizeLow参数。这样做相当于告诉系统我们想要一个大小为0的文件映射对 象。CreateFileMapping会认为这是错误的并返回NULL。
如果读者迄今为止一直都很专心的话，一定会认为有地方错得离谱。Windows支持的文件 和文件映射对象最大可以到16 EB,这很好，但32位进程的地址空间最大也只有4GB(其 中的一小部分甚至还不能用)，我们怎么才能把那么大的文件映射到相对较小的地址空间中 去呢？下一节将介绍具体的方法。当然，64位进程具有16 EB的地址空间，这样就可以处 理更大的文件映射，但如果文件超大，也同样存在类似的限制。
为了真正理解CreateFile和CreateFileMapping的工作方式，让我们来做下面的试验。在 开发环境中输入下面的代码，编译并链接，然后在调试器中运行。在单步跟踪每一条语句 的同时，打开一个命令行窗口，并在C:\目录下运行dir命令。随着每条语句在调试器中执 行，请留意目录中的内容有什么变化。
int WINAPI _tWinMain(HINSTANCE, HINSTANCE, PTSTR, int) (
// Before executing the line below, C:\ does not have
// a file called "MMFTest.Dat"
HANDLE hFile = CreateFile(TEXT("C：\\MMFTest.Dat■),
GENERIC_READ I GENERIC_WRITE,
FILE_SHARE_READ I FILE_SHARE_WRITE, NULL, CREATE_ALWAYS,
FILE_ATTRIBUTE_NORMAL, NULL);
Mows核心编程（第5版）
// Before executing Che line below, the MMFTest.Dat
// file does exist but has a file size of 0 bytes.
HANDLE hFileMap = CreateFileMapping(hFile, NULL, PAGE_READWRITE, 0, 100, NULL);
// After executing the line above, the MMFTest.Dat
// file has a size of 100 bytes.
// Cleanup
CloseHandle(hFileMap);
CloseHandle(hFile);
// When the process terminates, MMFTest.Dat remains
// on the disk with a size of 100 bytes.
return(0)；
如果调用CreateFUeMapping并传入PAGE_READWRITE,那么系统会进行检查，并确 保磁盘上对应文件的大小不小于dwMaximumSizeHigh和dwMaximumSizeLow参数指定 的大小。如果文件比指定的大小要小，那么CreateFileMapping会增大文件的大小。这个 增大文件大小的操作是必需的，其目的是为了保证当后来把文件用作内存映射文件的时候, 物理存储器已经准备就绪。如果文件映射对象是用PAGE_READONLY或 PAGE_WRITECOPY标志创建的，那么CreateFileMapping指定的大小必须不大于文件 在磁盘上的实际大小，因为我们不能给文件追加任何数据。
CreateFileMapping的最后一个参数pszName是一个以0为终止符的字符串，用来给文件 映射对象指定一个名称。这个名称用来在不同的进程间共享文件映射对象。（本章后面的一 个示例展示了这种用法。第3章也对内核对象的共享进行了深入细致的讨论。）通常我们并 不需要共享内存映射文件，因此只要传NULL给这个参数即可。
系统会创建文件映射对象并返回一个句柄给调用线程，这个句柄用来标识所创建的文件映 射对象。如果系统无法创建文件映射对象，那么会返回NULLo再次提醒一下，请记住当 CreateFile失败的时候返回的是INVALID_HANDLE_VALUE（被定义为-1）,而 CreateFileMapping失败的时候返回的则是NULL。不要把这两个错误码搞混了。
17.3.3第3步：将文件的数据映射到进程的地址空间
在创建了文件映射对象之后，还需要为文件的数据预订一块地址空间区域并将文件的数据 作为物理存储器调拨给区域。这可以通过调用MapViewOfFile来实现：
PVOID MapViewOfFile（
HANDLE hFileMappingObj ect,
DWORD dwDesiredAccess,
DWORD dwFileOffsetHigh,
DWORD dwFileOffsetLow,
SIZE_T dwNumberOfBytesToMap）;
参数hFileMappingObject是文件映射对象的句柄,它是之前调用CreateFileMapping或（本 章稍后介绍的）OpenFileMapping函数时返回的。参数dwDesiredAccess表示想要如何访问
第17章内存映射文件
数据。是的，我们必须再次指定我们打算如何访问文件的数据。我们可以指定表17.6中所 列出的5个值之一。
表17书内存映射文件访问权限
保护属性	含义
FILE_MAP_WRITE	可以读取和写入文件。在调用CreateFileMapping时必须传 PAGE READWRITE 保护属性
FILE_MAP_READ	可以读取文件。在调用 CreateFileMapping时可以传 PAGE_READONLY 或 PAGE_READWRITE 保护福性
FILE MAP ALL ACCESS	等同于 FILE MAP WRITE | FILE MAP READ | FILE MAP COPY
FILE_MAP_COPY	可以读取和写入文件。写入操作会导致系统为该页面创建一份副本。在 调用 CreateFileMapping 时必须传 PAGE WRITECOPY 保护属性
FILE_MAP_EXECUTE	可以将文件中的数据作为代码来执行。在调用CreateFileMapping时可 以传 PAG E_EXECUTE_READWRITE 或 PAGE_EXECUTE_READ 保 护属性
Windows要求我们一而再，再而三地设置这些保护属性，这显然很奇怪，也很烦人。我猜 测其目的是为了给应用程序以尽可能多的控制来保护数据。
剩下的3个参数与预订地址空间区域和给区域调拨物理存储器有关。当我们把一个文件映 射到进程的地址空间中的时候，不必一下子映射整个文件。可以每次只把文件的一小部分 映射到地址空间中。文件中被映射到进程地址空间中的部分被称为视图(view),其名称 MapViewOfFile 便缘于此。
把文件的一个视图映射到进程的地址空间中时，必须告诉系统两件事情。第一，我们必须 告诉系统应该把数据文件中的哪个字节映射到视图中的第一个字节。这是通过参数 dwFileOffsetHigh和dwFileOffsetLow来指定的。由于Windows支持的文件大小最大可以 到16 EB,因此编移量也必须用64位值来指定，其中高32位的部分由dwFileOffsetHigh 表示，而低32位的部分则由dwFneOffsetLow表示。注意，文件的偏移量必须是系统分配 粒度的整数倍。(到目前为止，在所有版本的Windows中，分配粒度全部都是64KBo )14.1 节“系统信息”介绍了如何取得一个给定系统的分配粒度。
第二，我们必须告诉系统要把数据文件中的多少映射到地址空间中去。这和预订地址空间 区域时需要指定区域的大小是一样的道理。参数dwNumberOfBytesToMap用来指定大小。 如果指定的大小为0,系统会试图把文件中从偏移量开始到文件末尾的所有部分都映射到 视图中。注意，无论整个文件映射对象有多大，MapViewOfFile R需要找到一块足够大的 地址空间区域来容纳指定的视图。
如果在调用MapViewOfFile的时候指定了 FILE_MAP_COPY标志，那么系统会从页交换
ows核心编程(第5版)
文件中调拨物理存储器。调拨的物理存储器的大小由dwNumberOfBytesToMap参数决定。 在对文件映射视图进行操作时，只要我们不执行读取数据之外的任何操作，系统就不会用 到从页交换文件中调拨的页面。但是，一旦哪个线程写入文件映射视图中的任何内存地址, 系统就会从页交换文件中已调拨的页面中选择一个页面，把原始数据复制到页交换文件中 的页面，然后把复制的页面映射到进程的地址空间中。此后，各线程都将访问数据的副本, 而不会访问或修改原始数据了。
系统对原始数据进行复制时，系统会把页面的保护属性从PAGE_WRITECOPY改成 PAGE_READWRITE。下面的代码段说明了整个过程：
// Open the file that we want to map.
HANDLE hFile = CreateFile(pszFileName, GENERIC_READ I GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL z NULL);
// Create a file-mapping object for the file.
HANDLE hFileMapping = CreateFileMapping(hFile, NULL, PAGE_WRITECOPY, 0, 0, NULL);
// Map a copy-on-write view of the file; the system will commit // enough physical storage from the paging file to accommodate // the entire file. All pages in the view will initially have // PAGE_WRITECOPY access.
PBYTE pbFile = (PBYTE) MapViewOfFile(hFileMapping, FILE_MAP_COPY, 0, Q, 0);
// Read a byte from the mapped view.
BYTE bSomeByte = pbFile[0];
// When reading, the system does not touch the committed pages in // the paging file. The page keeps its PAGE_WRITECOPY attribute.
// Write a byte to the mapped view.
pbFile[0] = 0;
// When writing for the first time, the system grabs a committed // page from the paging file, copies the original contents of the // page at the accessed memory address, and maps the new page // (the copy) into the process' address space. The new page has //an attribute of PAGE_READWRITE.
// Write another byte to the mapped view. pbFile[l] = 0;
// Because this byte is now in a PAGE_READWRITE page, the system // simply writes the byte to the page (backed by the paging file).
// When finished using the file's mapped view, unmap it.
// UnmapViewOfFile is discussed in the next section. UnmapViewOfFile(pbFile)；
// The system decommits the physical storage from the paging file.
// Any writes to the pages are lost.
// Clean up after ourselves.
CloseHandle(hFileMapping)；
CloseHandle(hFile);
■
说明 在NUMA机器上，通过把存放数据的内存与访问数据的线程所在的CPU保持在同 一节点中，我们可以提高应用程序的性能。默认情况下，当线程对内存映射文件的 视图进行映射时，Windows会自动地试图使用与线程所在CPU位于同一节点的内
第17章内存映射文件
存。但是，如果事先知道一个线程可能会转移到另一个节点的CPU上去，则可以调 用 CreateFileMappingNuma 并在最后一个参数(dwPreferredNumaNode)中显式地 指出应该从哪个NUMA节点中分配内存，这样就可以覆盖系统默认的行为：
HANDLE CreateFileMappingNuma(
HANDLE hFile,
PSECURITY_ATTRIBUTES psa,
DWORD fdwProtect z
DWORD dwMaximumS i zeH igh,
DWORD dwMax imumS i z e Low,
PCTSTR pszName,
DWORD dwPreferredNumaNode
);
现在，当MapViewOfFile被调用时，它会记得使用在调用CreateFileMappingNuma 时指定的节点。此外，Windows还提供了 MapViewOfFileExNuma函数，可以用它 来覆盖在 CreateFileMappingNuma时指定的 NUMA 节点。下面便是 MapViewOfFileExNuma 函数：
PVOID MapViewOfFileExNuma(
HANDLE hFileMappingObject,
DWORD dwDesiredAccess,
DWORD dwFileOffsetHigh,
DWORD dwFileOffsetLow,
SIZE_T dwNumberOfBytesToMap,
LPVOID lpBaseAddress,
DWORD dwPreferredNumaNode
);
14.3节“NUMA机器中的内存管理”介绍了一些能让我们决定NUMA节点和CPU 之间的关系的Windows函数。另外在15.1节“预订地址空间区域”的末尾，也有 一些有关NUMA支持如何对内存分配产生影响的信息。
17.3.4第4步：从进程的地址空间撤销对文件数据的映射
不再需要把文件的数据映射到进程的地址空间中时，可以调用下面的函数来释放内存区域: BOOL UnmapViewOfFile(PVOID pvBaseAddress);
这个函数唯一的参数pvBaseAddress用来指定区域的基地址，它必须和MapViewOfFile的 返回值相同。确定调用UnmapViewOfFile,如果不这样做，在进程终止之前，区域将得不 到释放。在调用MapViewOfFile的时候，系统总是会在进程的地址空间中预订一块新的区 域，它不会释放之前预订的任何区域。
出于速度上的考虑，系统会对文件数据的页面进行缓存处理，这样在处理文件映射视图的 时候就不需要随时更新磁盘上的文件。如果需要确保所做的修改已经被写入到磁盘中，那 么可以调用FlushViewOfFile,这个函数用来强制系统把部分或全部修改过的数据写回到磁 盘中：
BOOL FlushViewOfFile(
PVOID pvAddress,
SIZE_T dwNumberOfBytesToFlush);
indows核心编程（第5版）
第1个参数是内存映射文件的视图中第一个字节的地址。函数会把传入的地址向下取整到 页面大小的整数倍。第2个参数表示想要刷新的字节数。系统会把这个数值向上取整，使 总的字节数成为页面大小的整数倍。如果在没有修改过任何数据的情况下调用 FlushViewOfFile,那么函数不会把任何东西写到磁盘上，而是直接返回。
如果内存映射文件的物理存储器来自网络，那么FlushViewOfFile会保证从当前工作站写 入文件数据。但是，FlushViewOfFile无法保证远端的共享文件的服务器也会把数据写入到 磁盘上，因为服务器可能会对文件数据进行缓存。为了确保服务器也会把数据写入到磁盘 上，我们在创建文件映射对象并将它映射到视图中的时候，应该传 FILE_FLAG_WRITE_THROUGH 标志给 CreateFile 函数。
UnmapViewOfFile有一个特征需要牢记。如果视图最初是用FILE_MAP_COPY标志映射 的，那么对文件数据的任何修改实际上是对保存在页交换文件中的文件数据副本的修改。
如果在这种情况下调用UnmapViewOfFile,函数不需要对磁盘文件进行任何更新，但它会 释放页交换文件中的页面，从而导致数据丢失。
如果希望保留修改过的数据，必须自己进行额外的操作。例如，可以为同一个文件（用 PAGE_READWRITE标志）创建另一个文件映射对象，并用FILE__MAP_WRITE标志把 这个新的文件映射对象映射到进程的地址空间中。然后可以在第一个视图中查找具有 PAGE_READWRITE保护属性页面。只要找到一个具有该保护属性的页面，就可以对其 内容进行检查，并决定是否需要将修改过的数据写入文件。如果不想用新数据更新文件， 则可以继续在剩余页面中查找，直到文件的末尾。但如果想保存修改过的数据页面，那么 只需调用MoveMemory把该数据页面从第1个视图复制到第2个视图即可。由于第2个视 图是用PAGE_READWRITE保护属性映射得到的，因此MoveMemory函数会更新文件位 于磁盘上的实际内容。我们可以通过这种方法来检测修改和保存文件数据。
17.3.5第5步和第6步：关闭文件映射对象和文件对象
不用说，我们必须关闭自己打开的任何内核对象，不然会在进程继续运行的过程中引起资 源泄漏。当然，进程终止的时候，系统会自动关闭任何由进程打开但忘了关闭的对象。但 如果进程会运行一段比较长的时间，会使资源句柄越积越多。在编写代码的时候，坚持关 闭自己打开的任何对象，这样的代码才是“干净”的代码，才是“合格”的代码。要关闭 文件映射对象和文件对象，必须调用CloseHandle函数两次，每次关闭一个句柄。
486-487
现在仔细看一看这个过程。下面的伪代码是一个使用内存映射文件的例子:
HANDLE hFile = CreateFile(...)；
HANDLE hFileMapping = CreateFileMapping(hFile, ...)；
PVOID pvFile = MapViewOfFile(hFileMapping, ...);
// Use the memory-mapped file.
UnmapViewOfFile(pvFile)；
第17章内存映射文件
CloseHandle(hFileMapping);
CloseHandle(hFile);
刚才的代码展现的是操控内存映射文件的“标准”方法。但是，系统在调用MapViewOfFile 的时候还会增加文件对象和文件映射对象的引用计数，这一点在代码中并没有体现出来。
这个副作用非常重要，因为它意味着我们可以把前面的代码改写成下面这段代码：
HANDLE hFile = CreateFile(...);
HANDLE hFileMapping = CreateFileMapping(hFile,...)；
CloseHandle(hFile);
PVOID pvFile = MapViewOfFile(hFileMapping, ...);
CloseHandle(hFileMapping);
// Use the memory-mapped file.
UnmapViewOfFile(pvFile)；
在使用内存映射文件的时候，通常我们会打开文件，创建文件映射对象，然后用文件映射 对象把文件数据的一个视图映射到进程的地址空间中。由于系统会增加文件对象和文件映 射对象的内部引用计数，因此为了消除潜在的资源泄漏，我们可以在代码的开头就关闭这 些对象。
如果要用同一个文件创建多个文件映射对象，或为同一文件映射对象映射多个视图，那么 就不能过早地调用CloseHandle,因为以后在调用CreateFileMapping和MapViewOfFile 的时候，还会用到这些句柄。
17.3.6 File Reverse 示例程序
File Reverse应用程序(17-File Revexe)展示了如何使用内存映射文件来把一个ANSI或 Unicode文本文件的内容颠倒过来。应用程序的源文件和资源文件在本书配套网页的17-File Rev目录中。当程序启动时，会显示如下图所示的窗口。

「Reverse file conterjjT~| Type of charactert in fie: (unknown)
File Reverse应用程序让用户先选择一个文件。单击Reverse File contents按钮的时候，程序 会把文件中所有字符的顺序颠倒过来。程序能够正确地处理文本文件，但不能正确地处理 二进制文件°FileReverse函数通过调用IsTextUnicode函数(参见第2章)来检测一个文本文 件是ANSI格式还是Unicode格式。
用户单击Reverse File Contents按钮的时候，FileReverse会给指定的文件复制一份名为 FileRev.dat的副本。这样做的目的是为了避免原始文件因为内容被颠倒而不能再用了。接 着FileReverse会调用FUeReverse函数，该函数负责颠倒文件的内容。FileReverse函数会 调用CreateFile函数，以读/写方式打开FileRev.dat文件。
j^^dows核心编程(第5版)
正如前文所述，颠倒文件内容最简单的方法莫过于调用c运行库函数_strrev。对所有C语 言格式的字符串来说，字符串的最后一个字符必须是0,即字符串终止符。由于文本文件 并不是以字符0结尾的，因此FileReverse必须给文件末尾追加一个字符0。为了达到这个 目的，程序首先调用了 GetFileSize：
dwFileSize = GetFileSize(hFile, NULL)；
这样我们就知道了文件的长度，能够调用CreateFileMapping来创建文件映射对象了。在 创建文件映射对象的时候，所使用的长度是dwFileSize加一个宽字符的大小(用来存放字符 0)o在文件映射对象创建完成之后，程序会把文件映射对象的一个视图映射到FileReverse 的地址空间。变量pvFile保存了 MapViewOfFile的返回值，它指向文本文件的第一个字节。
下一步是把一个字符0写到文件的末尾并颠倒字符串：
PSTR pchANSI = (PSTR) pvFile;
pchANSI[dwFileSize / sizeof(CHAR)] = 0;
在一个文本文件中，每一行的末尾是一个回车符C\F)后跟一个换行符C\if)。不巧的是，当我 们调用_strrev来颠倒文件的时候，这些字符也会被颠倒。为了能用一个文本编辑器来打开 颠倒后的文本文件，必须把每一对“\n\r”转换回原来的“\r\n”顺序。这个转换是通过下 面的循环来完成的：
while (pchANSI != NULL) (
// We have found an occurrence....
*pchANSI + + = '\r'； // Change *\n* to '\r'.
*pchANSI++ = '\n'； // Change '\r' to '\n'. pchANSI = scrstr(pchANSI, "\n\rM)； // Find the next occurrence.
}
前面的代码非常简单，在对如此简单的代码进行分析的时候，我们很容易忘记自己实际上 正在对磁盘上的文件内容进行处理(这也展示了内存映射文件的威力)。
488
在把文件内容颠倒之后，FileReverse必须进行清理工作。清理工作包括撤销对文件映射对 象视图的映射，以及关闭所有内核对象的句柄。此外，FileRev必须把此前追加到文件末尾 的字符0去掉(记ft_strrev不会颠倒字符串终止符的位置)。如果不把字符0去掉，那么颠 倒后的文件会比原来的文件大一个字节，而且再次调用FileRev也无法使文件再恢复到原 来的样子。为了去掉末尾的字符0,我们必须退而使用文件管理函数，而不是通过内存映 射来对文件进行操控。
为了强制颠倒后的文件在一个指定的位置结束，我们需要先把文件指针定位到想要的位置 (即原始文件的末尾)，然后调用SetEndOfFile函数：
SetFilePointer(hFile, dwFileSize, NULL, FILE_BEGIN); SetEndOfFile(hFile);
说明 在调用SetEndOfFile之前必须撤销对视图的映射和关闭文件映射对象，否则函数将 返回 FALSE,这时调用 GetLastError 会返回 ERROR_USER_MAPPED_FILE。 这个错误码表示该文件已经关联到文件映射对象，不能改变文件的大小。
第17章内存映射文件
最后FileReverse会启动记事本，这样我们就可以查看颠倒后的文件。下图所示窗口显示了 用FileReverse来颠倒FileRev.cpp文件所得到的结果。
File Edit Format View
el1F f0 dnE
;'JOCnruter
；；COrP_glD ,LLUN ,)VERELIF_DDI(ECRUOSERTNIEKAM ,exEtsnlh(XOBgolaiD
{ .eniLdmczsp rtstp .ecnatsnih ,exEtsn1h ECNATSNiH(niaMniwt_ ipaniw tni
kaerb
))ESREVER_CDI ,dnwh(metlglDteGCsucoFtes JeliFrtspl.nfo ,emanelif_cdi ,dnwh(txeTmetIglDtes jnfoA(emaNellFnepoteG
TSIXETSUMELIF-NFO | R£ROLPXE_NFO = sgalF.nfo
；勿,少,^//〃〃///〃////〃〃/////〃/〃/〃〃/〃///〃〃//〃〃/////〃 打
:)ESLAF(nruter
fi }
•;)dnammocr)o_glD ,dnammoc_Mw ,dnwh(GSMGLD_£LDNAHhc
.?； )qolalDTinlnO_glD ,GOLAIDTINI_^W , dnwh(GSMGLD_ELDNAHhc
" ；gsMu( hctlws
{ )maraPl marapl .marapw marapw ,gsMu tniu ,dnwh dnwh(corP_glD
IPANIW RTP_TNI
«>〃〃〃〃〃〃〃〃〃〃〃〃〃〃〃〃〃〃〃〃〃〃〃〃〃〃〃〃
FileRev.cpp
/**★*******************★*********★********************************************♦
Module： FileRev.cpp
Notices: Copyright (c) 2008 Jeffrey Richter & Christophe Nasarre
******************************************************************************
strrev
#include #include #include #include #include #include
*..\CommonFiles\CmnHdr.h" <windowsx.h> <tchar.h> <coirandlg. h> <string.h>
■Resource.h"
///////////〃////////////////////////〃//〃///〃〃〃//〃///////////////////////
#define FILENAME TEXT("FileRev.dat•)
///////////////////////////////////////////////////////////////////////////////

BOOL FileReverse(PCTSTR pszPathname, PBOOL pblsTextUnicode) ( ♦pblsTextUnicode = FALSE； // Assume text is	七
// Open the file for reading and writing.
HANDLE hFile = CreateFile(pszPathname, GENERIC_WRITE I GENERIC_READr 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
如dows核心编程（第5版）
if (hFile == INVALID_HANDLE_VALUE) {
chMB("File could not be opened.")； return(FALSE);
)
// Get the size of the file (I assume the whole file can be mapped). DWORD dwFileSize = GetFileSize(hFile, NULL)；
// Create the file-mapping object. The file-mapping object is 1 character // bigger than the file size so that a zero character can be placed at the // end of the file to terminate the string (file). Because I don't yet know // if the file contains ANSI or Unicode characters, I assume worst case // and add the size of a WCHAR instead of CHAR.
HANDLE hFileMap = CreateFileMapping(hFile, NULL, PAGE_READWRITE,
0, dwFileSize + sizeof(WCHAR)< NULL);
if (hFileMap == NULL) (
chMB("File map could not be opened.•)；
CloseHandle(hFile)；
return(FALSE);
}
// Get the address where the first byte of the file is mapped into memory. PVOID pvFile = MapViewOfFile(hFileMap, FILELMAP..WRITE, 0, 0, 0);
if (pvFile == NULL) (
chMB("Could not map view of file.•);
CloseHandle(hFileMap)；
CloseHandle(hFile);
return(FALSE)；
)
// Does the buffer contain ANSI or Unicode?
int iUnicodeTestF1 ags = -1;	// Try all tests
♦pblsTextUnicode = IsTextUnicode(pvFile, dwFileSize, StiUnicodeTestFlags)；
if (!*pbIsTextUnicode) (
// For all the file manipulations below, we explicitly use ANSI // functions because we are processing an ANSI file.
// Put a zero character at the very end of the file. PSTR pchANSI = (PSTR) pvFile；
pchANSI(dwFileSize / sizeof(CHAR)] = 0;
// Reverse the contents of the file. _strrev(pchANSI);
// Convert all "\n\r" combinations // preserve the normal end-of-line pchANSI = strstr(pchANSI, "\n\r")；
back to B\r\n" to sequence・
// Find first "\r\n*.
.GjKvK'.SiSrf/.
while (pchANSI != NULL) (
// We have found an	理普
*pchANSI++ = '\r'；	// Change	'	■
*pchANSI++ = • \nf ；	// Change 感翊 Co』祕
pchANSI = strstr(pchANSI, ・\n\r・)；薛/ Find the next occurrence.

// For all the file manipulations below, we explicitly use Unicode // functions because we are processing a Unicode file.
(PWSTR) pvFile；
// Put a zero character at the very end of the file. PWSTR pchUnicode = pchUnicode[dwFileSize / sizeof(WCHAR)]=
0;

第17章内存映射文件
if ((iUnicodeTestFlags & IS_TEXT_tJNICODE_SIGNATURE) != 0) ( // If the first character is the Unicode BOM (byte-order-mark)/ // OxFEFF, keep this character at the beginning of the file. pchUnicode++；
}
// Reverse the contents of the file.
_wcsrev(pchUnicode);
// Convert all *\n\r" combinations back to B\r\nB to
// preserve the normal end-of-line sequence. pchUnicode = wcsstr(pchUnicode, L，\n\r,)；// Find first •\n\r'.
while (pchUnicode != NULL) {
// We have found an occurrence..,. *pchUnicode++ = L* \r , ；	// Change ' \n' to ' \r1.
♦pchUnicode-♦■+ = L' \n' ；	// Change ' \r' to ' \n'.
pchUnicode = wcsstr(pchUnicode, L"\n\r")； // Find the next occurrence. }
}
// Clean up everything before exiting.
UnmapViewOfFile(pvFile);
CloseHandle(hFileMap)；
// Remove trailing zero character added earlier. SetFilePointer(hFiler dwFileSize, NULL, FILE_BEGIN)； SetEndOfFile(hFile);
CloseHandle(hFile)；
return(TRUE)；
///////////////////////////////////////////////////////////////////////////////
BOOL Dlg_0nInitDialog(HWND hWnd, HWND hWndFocus, LPARAM 1Param) { chSETDLGICONS(hWnd, IDI_FILEREV);
// Initialize the dialog box by disabling the Reverse button EnableWindow(GetDlgltem(hWnd, IDC_REVERSE), FALSE);
return(TRUE)；
}
///////////////////////////////////////////////////////////////////////////////
void Dlg_OnConnnand (HWND hWhd, int id.
HWND hWndC^^O^deNot i fy) (
TCHAR szPathname(MAX_PATH];
switch (id) ( case IDCANCEL:
EndDialog(hWnd, id)； break；
case IDC_FILENAME: EnableWindow(GetDlgltem(hWnd, Edi t_GetTextLength(hWndCtl) break；
case IDC_REVERSE:
GetDlgltemText(hWnd, IDC.FILENAME, szPathname, Ifcountof(szPathname));

> 0);

lows核心编程（第5版）
// Make copy of input file so that we don*t destroy it if (!CopyFile(szPathname, FILENAME, FALSE)) ( chMB("New file could not be created.");
break；
}
BOOL blsTextUnicode;
if (FileReverse(FILENAME, &bIsTextUnicode)) ( SetDlgltemText(hWnd, IDCJTEXTTYPE, blsTextUnicode ? TEXT(■Unicode") : TEXT("ANSI"));
// Spawn Notepad to see the fruits of our labors. STARTUPINFO si = ( sizeof(si) }; PROCESS^INFORMATION pi;
TCHAR sz[] = TEXT("Notepad ") FILENAME; if (CreateProcess(NULL, sz,
NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) (
CloseHandle(pi.hThread)； CloseHandle(pi.hProcess)；
}
} break;
case IDC_FILESELECT:
OPENFILENAME ofn = { OPENFILENAME_SIZE_VERSION_400 }; ofn.hwndOwner = hWnd;
ofn.IpstrFile = szPathname； ofn.lpstrFile(0] = 0； ofn.nMaxFile = _countof(szPathname)； ofn.IpstrTitle = TEXT("Select file for reversing")； Ofn.Flags = OFN_EXPLORER I OFN_FILEMUSTEXIST; GetOpenFileName(&ofn)； SetDlgltemText(hWnd, IDC_FILENAME, ofn.IpstrFile); SetFocus(GetDlgltem(hWnd, IDC_REVERSE));
break；
}
)
///////////////////////////////////////////////////////////////////////////////
INT_PTR WINAPI Dlg_Proc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM 1Param) ( switch (uMsg) (
chHANDLE_DLGMSG(hWnd, WM^INITDIALOG, Dlg.OnlnitDialog); chHANDLE_DLGMSG(hWnd, WM_COMMANDr Dlg_OnCommand);
}
return(FALSE);
} •
///〃////////////////////////////〃///////〃〃////〃〃////〃/〃////////////////
int WINAPI _tWinMain(HINSTANCE hlnstExe, HINSTANCE, PTSTR, int) (
DialogBoxthlnstExe, MAKEINTRESOURCE(IDD_FILEREV)r NULL, Dlg_Proc); return(0)；
//////////////////////////////// End of File //////////////〃//〃〃//〃////////
4 490-494
第17章内存映射文件
17.4用内存映射文件来处理大文件
17.3节中我说过会介绍如何将一个16 EB的文件映射到一个较小的地址空间中。好吧，这 实际上是不可能的，不过有另一种方法可以达到类似的效果。这种方法就是只映射文件的 一个视图，而这个视图只包含文件的一小部分数据。一开始，我们应该把文件开头的部分 映射到视图中。完成对文件的第一个视图的访问后，我们可以撤销对文件这一部分的映射, 然后把文件的另一部分映射到视图中。我们一直重复这个过程，直到完成对整个文件的访 问。当然，这使我们对大型内存映射文件的处理变得不太方便，但好在大多数文件都比较 小，因此通常不会遇到这个问题。
让我们来看一个在32位地址空间中使用8 GB文件的例子。下面的函数用来统计一个二进 制文件中所有值为0的字节数，其中包含了许多步骤：
_int64 CountOs(void) (
// Views must always start on a multiple
// of the allocation granularity
SYSTEM_INFO sinf;
GetSystemlnfo(&sinf)；
// Open the data file.
HANDLE hFile = CreateFile(TEXT("C:WHugeFile.Big"), GENER1C_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
// Create the file-mapping object.
HANDLE hFileMapping = CreateFileMapping(hFile, NULL,
PAGE_READONLY, 0, 0, NULL);
DWORD dwFileSizeHigh;
_int64 qwFileSize = GetFileSize(hFile, &dwFileSizeHigh); qwFileSize += (((_int64) dwFileSizeHigh) << 32)；
// We no longer need access to the file object's handle. CloseHandle(hFile)；
_int64 qwFileOffset = 0, qwNumOfOs = 0;
while (qwFileSize > 0) (
// Determine the number of bytes to be mapped in this view
DWORD dwBytesInBlock = sinf.dwAllocationGranularity；
if (qwFileSize < sinf.dwAllocationGranularity) dwBytesInBlock = (DWORD) qwFileSize；
PBYTE pbFile = (PBYTE) MapViewOfFile(hFileMapping, FILE_MAP_READ,
(DWORD) (qwFileOffset » 32),	// Starting byte
(DWORD) (qwFileOffset & OxFFFFFFFF),	// in file
dwBytesInBlock)；	// # of bytes to map
// Count the number of Os in this block.
for (DWORD dwByte = 0; dwByte < dwBytesInBlock； dwByte++) (
if (pbFile[dwByte] == 0)
qwNumOf0s++;
// Unmap the view； we don't want multiple views // in our address space.
UrunapViewOfFile(pbFile);
eows核心编程(第5版)
// Skip to the next set of bytes in the file.
qwFileOffset += dwBytesInBlock; qwFileSize -= dwBytesInBlock；
)
CloseHandle(hFileMapping);
return(qwNumOfOs);
}
这个算法会映射许多小于或等于64 KB的视图(分配粒度的大小)。同时请记住， MapViewOfFile要求文件的偏移量必须是分配粒度的整数倍。随着一个一个的视图被映射 到地址空间中，统计过程会持续进行。完成对文件中每个64 KB块的映射和处理后，程序 就可以关闭文件映射对象来完成清理工作了。
17.5内存映射文件和一致性
系统允许我们把同一个文件中的数据映射到多个视图中。例如，我们可以先把一个文件的 前10 KB映射到一个视图中，然后再把同一个文件的前4 KB映射到另一个视图中。只要 我们映射的是同一个文件映射对象，那么系统会确保各视图中的数据是一致的。例如，如 果应用程序在一个视图中修改了文件的内容，那么系统会更新所有其他视图以反映修改后 的文件内容。这是因为即使该页面被多次映射到进程的虚拟地址空间中，系统也还是在同 一个内存页面中保存被映射的数据。如果多个进程把同一个数据文件映射到多个视图中， 那么数据也仍然会是一致的，这是因为数据文件中的每个页面在内存中只有一份——但这 些内存页面会被映射到多个进程的地址空间中，仅此而已。
说明 Windows允许我们以同一个数据文件为后备存储器来创建多个文件映射对象。 Windows并不保证这些不同的文件映射对象的各个视图是一致的。系统只保证在同 一文件映射对象的多个视图间保持一致。
在处理文件的时候，完全可有能出现这样的情况：一个应用程序想要调用CreateFile来打 开一个文件，但另一个进程已经映射了同一个文件。新的进程通过ReadFile和WriteFile 函数来对文件进行读写操作。当然，进程调用上述函数时，要么从内存缓存中读取数据， 要么把数据写入到内存缓存中。这个内存缓存必须是进程自己创建的，而不是内存映射文 件使用的内存。两个应用程序打开同一个文件时会引起一些问题：一个进程可以调用 ReadFile从文件的一部分读取数据，修改数据，然后调用WriteFile把数据写回文件，而 这时第二个进程的文件映射对象对第一个进程执行的操作却一无所知。出于这个原因，如 果打算将打开的文件用于内存映射，那么在调用CreateFile的时候最好是传0给 dwShareMode参数。这等于是告诉系统我们想要独占对文件的访问，使其他进程无法打开 同一个文件。
由于只读文件不存在一致性的问题，因此它们非常适合用于内存映射文件。我们绝对不应 该用内存映射文件来跨网络共享可写文件，因为系统无法保证数据视图的一致性。如果一
第17章内存映射文件
台机器更新了文件的内容，那么另一台机器将无法知道数据己经修改过，从而导致它继续 使用内存中的原始数据。
17.6给内存映射文件指定基地址
在调用VirtualAlioc的时候，我们可以建议系统在指定的基地址预订地址空间。同样，也 可以用MapViewOfFileEx函数来代替MapViewOfFile函数，这样就能建议系统把文件映 射到指定的地址：
PVOID MapViewOfFileEx(
HANDLE hFi1eMappingObj ect,
DWORD dwDesiredAccess,
DWORD dwFileOffsetHigh,
DWORD dwFileOf fsetLow,
SIZE_T dwNumberOfBytesToMap,
PVOID pvBaseAddress)；
除了最后一个参数pvBaseAddress ,这个函数的所有参数和返回值都与 MapViewOfFile函数完全相同。我们可以用这个参数来给要映射的文件指定一个目标 地址。同VirtualAlioc函数一样，指定的目标地址必须是分配粒度(64 KB)的整数倍。
否则MapViewOfFileEx将返回NULL,表示有错误发生，这时GetLastError会返回 1132(ERROR_MAPPED__ALIGNMENT)o
如果系统无法将文件映射到指定的地址(通常是由于文件太大，因此导致与其他已预订的地 址空间发生重叠)，那么函数会失败并返回NULLo MapViewOfFileEx不会尝试去找另一 个能够容纳文件的地址空间。当然，我们也可以传NULL给pvBaseAddress——在这种情 况下，MapViewOfFileEx的行为和MapViewOfFile完全相同。
495M96
使用内存映射文件跨进程共享数据的时候，MapViewOfFileEx非常有用。举个例子，如果 两个或多个应用程序要共享一组数据结构，而这些数据结构中有一些指针指向其他数据结 构，那么我们可能需要给内存映射文件指定一个地址。链表就是一个绝佳的例子。在一个 链表中，链表的每个元素(或节点)包含了链表中另一个元素的内存地址。要遍历链表，必 须先知道第一个元素的地址，然后再引用元素中指向下一元素的成员。在使用内存映射文 件的时候，这可能是个问题。
如果一个进程在内存映射文件中准备了一个链表，然后把这个内存映射文件共享给另一个 进程，那么第二个进程很可能会把内存映射文件映射到地址空间中一个完全不同的地方。
当第二个进程试图遍历链表的时候，它会先得到链表的第一个元素，然后取得下一个元素 的内存地址，并试图访问这个元素。但是，对第二个进程来说，这个地址是不正确的。
我们可以通过两种方法来解决这个问题。第一种方法是让第二个进程在把包含链表的内存 映射文件映射到自己的地址空间的时候，不要调用MapViewOfFHe ,而是调用 MapViewOfFileEx。当然，这种方法要求第二个进程知道第一个进程在构造链表的时候，把 内存映射文件映射到了哪个内存地址。如果两个应用程序已经被设计成能够协同工作——
Windows核心编程(第5版)
最有可能的就是这种情况——那么这就不成问题：两个程序既可以直接在代码中把地址写 死，也可以让一个进程通过另一种进程间通信机制来通知另一个进程，比如给一个窗口发 送消息。
第二种方法是让进程在创建链表的时候，在每个节点中保存一个偏移量，可以通过这个偏 移量在地址空间中找到下一个节点。这种方法要求应用程序在访问每个节点的时候，需要 把内存映射对象的基地址和偏移量加起来。这种方法不太好：一来比较慢，二来使程序变 得更大(因为需要额外的代码来执行所需的计算)，三来很容易搞错。但不管怎么样，这都 是一种可行的方法，而且Microsoft编译器还提供了一个_based关键字，用来协助开发人 员使用基地址指针。
说明 在调用MapViewOfFileEx的时候，指定的地址必须在进程的用户模式分区中，否则 MapViewOfFileEx 会返回 NULL。
17.7内存映射文件的实现细节
在进程能够从自己的地址空间中访问内存映射文件的数据之前，Windows要求进程先调用 MapViewOfFileo如果一个进程调用了 MapViewOfFile,那么系统会在该进程的地址空间 中为视图预订一块区域，任何其他进程都无法看到这个视图。如果另一个进程想要访问同 一个文件映射对象中的数据，那么第二个进程也必须调用MapViewOfFile,这样系统就会 在第二个进程的地址空间中为视图预订一块区域。
还有一点非常重要，即第一个进程调用MapViewOfFile时返回的内存地址，与第二个进程 调用MapViewOfFile时返回的内存地址，很可能是不相同的。即使两个进程都映射同一个 文件映射对象的视图，情况也还是如此。	一
现在让我们来看一看另一个实现细节。下面这个小程序映射了同一个文件映射对象的两个 视图：
int WINAPI _tWinMain (HINSTANCE, HINSTANCE, PTSTR, int) (
// Open an existing fmust be bigger than 64 KB.
HANDLE hFile = CreateFile(pszCmdLine, GENERIC_READ | GENERIC_WRITE,
0, NULL, OPEN_EX工STING, FILE_ATTRIBUTE_NORMAL, NULL);
// Create a file-mapping object backed by the data file.
HANDLE hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READWR］：TE, 0, 0, NULL);
// Map a view of the whole file into our address space.
PBYTE pbFile = (PBYTE) MapViewOfFile(hFileMapping, FILE_MAP_WRITE/ 0, 0, 0);
// Map a view of the file (starting 64 KB in) into our address space PBYTE pbFile2 = (PBYTE) MapViewOfFile(hFileMapping,
FILE_MAP_WRITE, 0, 65536, 0);
// Show that the two views are not 64 KB away from each other
第17章内存映射文件
// in the address space, meaning that there is no overlap.
int iDifference = int(pbFile2 - pbFile);
TCHAR szMsg[100];
StringCchPrintf(szMsg, _countof(szMsg),
TEXT("Pointers difference = %d KB"), iDifference / 1024)；
MessageBox(NULL, szMsg, NULL, MB_OK)；
UnmapViewOfFile(pbFile2)； UnmapViewOfFile(pbFile);
CloseHandle(hFileMapping)；
CloseHandle(hFile)；
return(0);
}
代码中对MapViewOfFile的两次调用使得Windows分别预订了两块不同的地址空间区域。 第一块区域的大小就是文件映射对象的大小，而第二块区域的大小则是文件映射对象的大 小减去64 KBo虽然它们是两个不同的区域，也互不重叠，但由于它们都是同一个文件映 射对象的视图，因此系统会保证其中的数据始终都是一致的。
17.8用内存映射文件在进程间共享数据
Windows提供了多种机制，使得应用程序之间能够快速、方便地共享数据和信息。一直以 来Windows在这方面做得都很不错。这些机制包括RPC、COM、OLE、DDE、Windows 消息(尤其是 WM_COPYDATA)、剪贴板、邮件槽(mailslot).管道(pipe)、套接字(socket) 等。在Windows中，在同一台机器上共享数据的最底层的机制就是内存映射文件。没错， 如果在同一台机器上的多个进程间进行通信的话，那么刚才提到的所有机制归根结底都会 用到内存映射文件。如果要求低开销和高性能，内存映射文件无疑是最好的选择。
498
这种数据共享机制是通过让两个或多个进程映射同一个文件映射对象的视图来实现的，这 意味着在进程间共享相同的物理存储页面。因此，当一个进程在文件映射对象的视图中写 入数据的时候，其他进程会在它们的视图中立刻看到变化。注意，对多个进程共享同一个 文件映射对象来说，所有进程使用的文件映射对象的名称必须完全相同。
让我们来看一个例子：启动应用程序。当一个应用程序启动时，系统会先调用CreateFile 来打开磁盘上的.exe文件。接着系统会调用CreateFileMapping来创建文件映射对象。最 后系统会以新创建的进程的名义调用MapViewOfFiieEx(并传入SECJMAGE标志)，这样 就把.exe文件映射到了进程的地址空间中。之所以调用MapViewOfFileEx而不是 MapViewOfFile,是为了把文件映射到指定的基地址，这个基地址保存在.exe的PE文件头 中。系统然后创建进程的主线程，在映射得到的视图中取得可执行代码的第一个字节的地 址，把该地址放到线程的指令指针中，最后让CPU开始执行其中的代码。
如果用户启动同一个应用程序的第二个实例，那么系统会发现该.exe文件已经有一个文件 映射对象，因此就不会再创建一个新的文件对象或文件映射对象。取而代之的是，系统会 再次映射.exe文件的一个视图，但这次是在新创建的进程的地址空间中。至此，系统已经
dows核心编程(第5版)
把同一个文件同时映射到了两个地址空间中。显然，由于物理内存中包含.exe文件可执行 代码的那些页面为两个进程所共享，因此内存的使用率更高。
同所有的内核对象一样，我们可以通过三种技术来跨进程共享对象：句柄继承、命名和句 柄复制。有关这三种技术的详细介绍，请参见第3章。
17.9以页交换文件为后备存储器的内存映射文件
到目前为止，可通过前面讨论的技术映射磁盘文件的视图。许多应用程序会在运行过程中 创建一些数据，并需要将这些数据传输给其他进程，或与其他进程共享这些数据。如果为 了共亨数据而必须让应用程序在磁盘上创建数据文件并把数据保存在文件中，那将非常不 方便。
Microsoft意识到了这一点，并加入了相应的支持，让系统能够创建以页交换文件为后备存 储器的内存映射文件，这样就不需要用磁盘上专门的文件来作为后备存储器了。这种方法 和为磁盘文件创建内存映射文件的方法几乎完全相同，甚至更简单。一方面，由于不必创 建或打开一个专门的磁盘文件，因此不需要调用CreateFileo我们只需要像原来那样调用 CreateFileMapping,并将 INVALID_HANDLE_VALUE 作为 hFile 参数传入。这告诉系 统我们创建的文件映射对象的物理存储器不是磁盘上的文件，而是希望系统从页交换文件 中调拨物理存储器。所需分配的存储器大小由CreateFileMapping的dwMaximumSizeHigh 和 dwMaximumSizeLow 参数决定。
一旦创建了文件映射对象，并把一个视图映射到了进程的地址空间中，我们就可以像使用 任何内存区域一样使用它了。如果想要和其他进程共享数据，那么可以在调用 CreateFileMapping的时候将一个以0为终止符的字符串作为pszName参数传入。这样其 他想要访问共享数据的进程就能够以同一个名称为参数来调用CreateFileMapping或 OpenFileMappingo
499
当一个进程不再需要访问文件映射对象的时候，应该调用CloseHandleo当所有句柄都已 关闭的时候，系统会从页交换文件中收回所有已调拨的存储器。
说明 这里有一个有趣的问题，一些不太细心的程序员曾遇到过这个问题，他们对此深感 意外。你能看出下面这段代码有什么问题吗？
HANDLE hFile = CreateFile(...)；
HANDLE hMap = CreateFileMapping(hFile, ...);
if (hMap == NULL)
return(GetLastError())；
如果调用CreateFile失败，函数会返回INVALID_HANDLE_VALUE。但是，写这 段代码的程序员不够细心，他没有检查文件的创建是否成功。在调用 CreateFileMapping 时，会将 INVALID_HANDLE_VALUE 作为 hFile 参数传入，
第17章内存映射文件
这使得系统在创建文件映射的时候以页交换文件为后备存储器，而不是所希望的磁 盘文件。所有涉及内存映射文件的代码将仍然可以正常工作。但是，当系统销毁文 件映射对象的时候，所有写入到文件映射对象的物理存储器(页交换文件)中的数据 也会被一起销毁。此时，这个程序员会坐在那里抓耳挠腮，苦思冥想到底哪里出了 问题！由于有许多原因可能会导致CreateFile失败，因此我们应该总是检查 CreateFile的返回值，以了解是否有错误发生。
Memory-Mapped File Sharing 示例程序
Memory-Mapped File Sharing应用程序(17-MMFShare.exe)展示了如何用内存映射文件来在 两个或多个进程之间传输数据。应用程序的源文件和资源文件在本书配套网页的 17・MMFShare目录中。
我们至少需要启动两个MMFShare的实例。每个实例都有自己的对话框，如下图所示。
Memory-Mapped File Sharing	盲IfiSj
[Oeate mapping of Dati]	Close mapping of Data :
DaU; Some te$t data
Open mappir^ and get Data ]
为了把数据从MMFShare的一个实例传输到另一个实例，我们先在Data编辑框中输入想要 传输的数据，然后单击Create Mapping Of Data按钮。这时 MMFShare会调用 CreateFileMapping来创建一个名为MMFSharedData的内存映射文件对象，它的大小为 4KB,以页交换文件为后备存储器。如果MMFShare发现同名的文件映射对象已经存在， 会显示一个对话框，告诉我们无法创建对象。但如果MMFShare能够成功地创建对象，会 继续把文件的视图映射到进程的地址空间中，并把数据从编辑框中复制到内存映射文件中。
在复制完数据之后，MMFShare会撤销对文件视图的映射，禁用C reate Mapping Of Data按 钮，并启用Close Mapping Of Data按钮。在这个时候，系统中的某处保存着一个名 为MMFSharedData的内存映射对象，没有任何其他进程把文件中的数据映射到自己的视 图中。
这时如果我们切换到MMFShare的另一个实例，并单击Open Mapping And Get Data按钮， MMFShare将调用OpenFileMapping,试图找到一个名为MMFSharedData的文件映射对 象。如果找不到，MMFShare会显示另一个消息框来告诉我们。如果MMFShare找到了该 文件映射对象，则会把对象的视图映射到进程的地址空间中，把数据从内存映射文件中复 制到对话框的编辑框中，然后撤销映射并关闭文件映射对象。瞧，我们成功地把数据从一 个进程传输到了另一个进程！
对话框中的Close Mapping Of Data按钮用来关闭文件映射对象，并释放页交换文件中的存
Widows核心编程（第5版）
储空间。如果文件映射对象不存在，那么MMFShare的其他实例就无法打开文件映射对象 并从中读取数据。此外，如果MMFShare的一个实例已经创建了内存映射文件，那么为了 避免覆盖文件中的数据，程序将禁止其他实例再创建另一个内存映射文件。
} else (
MMFShare.cpp
/*******★★★★
Module: MMFShare.cpp
Notices: Copyright (c) 2008 Jeffrey Richter & Christophe Nasarre
#include #include #include #include
"..\CommonFiles\CmnHdr.h" <windowsx.h> <tchar.h>
,Resource.h"
/* See Appendix A. */
///////////////////////////////////////////////////////////////////////////////
BOOL Dlg__OnInitDialog(HWND hWnd, HWND hWndFocus, LPARAM iParam) (
chSETDLGICONS(hWnd, IDI_MMFSHARE);
// Initialize the edit control with some test data. Edit_SetText(GetDlgItem(hWnd, IDC_DATA), TEXT("Some test data"));
// Disable the Close button because the file can't //be closed if it was never created or opened. Button_Enable(GetDlgItem(hWnd, IDC_CLOSEFILE), FALSE)； return(TRUE)；
}
//////////////////////////////////////////////////////////////////////////////I
void Dlg^OnCommand(HWND hWnd, int id, HWND hWndCtl, UINT codeNotify) (
HANDLE s_hFileMap = NULL;
// Handle of the open memory-mapped static
switch case
(id) ( IDCANCEL:
EndDialog(hWnd, id); break；
case IDC_CREATEFILE:
if (codeNotify != BN_CLICKED) break；
MMF to contain the, edjt control t^ext. is named MMFSharedData.
// Create a paging file-backed // The MMF is 4 KB at most and s_hFileMap = CreateFileMapping (IWALID_HANI>Ij^W»UErilS^X»I^ J* PAGE_READWRITE, 0, 4 • 1024, TEXT("MMFSharedData"));
if (s_hFileMap != NULL) (
if (GetLastErrort) == ERROR_ALREADY_EXISTS) {•蒸 chMB("Mapping already exists - not created.； CloseHandle(s_hFileMap)；
第17章内存映射文件
// File mapping created successfully.
// Map a view of the file into the address space.
PVOID pView = MapViewOfFile(s^hFileMap, FILE_MAP_READ I FILEJMAP_WRITEr 0, 0, 0);
if (pView != NULL) (
// Put edit text into the MMF.
Edit_GetText(GetDlgItem(hWnd, IDC_DATA),
(PTSTR) pView, 4 * 1024);
// Protect the MMF storage by unmapping it. UnmapViewOfFile(pView);
// The user can't create another file right now. Button_Enable(hWndCtl, FALSE);
// The user closed the file.
Button_Enable(GetDlgltemChWnd, IDC_CLOSEFILE), TRUE);
) else {
chMB("Can't map view of file.■);
}
)
) else (
chMB("Can't create file mapping.■)；
}
break;
.case IDC_CLOSEFILE:
if (codeNotify != BN_CLICKED) break；
if (CloseHandle(s_hFileMap)) (
// User closed the file, fix up the buttons.
Button_Enable(GetDlgltem(hWnd, IDC_CREATEFILE), TRUE); Button__Enabl e (hWndCt 1, FALSE);
}
break；
case IDC_OPENFILE:
if (codeNotify != BN_CLICKED) break;
// See if a memory-mapped file named MMFSharedData already exists. HANDLE hFileMapT = OpenFi1eMapping(FILE_MAP_READ I FILE_MAP_WRITE, FALSE, TEXT(-MMFSharedData"));
if (hFileMapT != NULL) (
// The MMF does exist, map it into the process * s address space. PVOID pView = MapViewOfFile(hFileMapT,
FILE_MAP_READ I FILE__MAP_WRITE, 0, 0, 0);
« •.
if (pView != NULL) (
// Put the contents of the MMF into the edit control. Edit_SetText(GetDlgltem(hWnd, IDC_DATA), (PTSTR) pView); UnmapViewOfFile(pView);
} else (	:4	:
chMB("Can't map view.")；
)
CloseHandle(hFileMapT)；
} else {
chMB(*Can't open mapping.■)；
indows核心编程(第5版)
) break;
}
}
///////////////////////////////////////////////////////////////////////////////
INT_PTR WINAPI Dlg_Proc(HWND hWnd, UINT uMsg, WPARAM wParam/ LPARAM 1Param) {
I
switch (uMsg) { chHANDLE_DLGMSG(hWnd r WM_INITDIALOG, Dlg_OnlnitDialog); chHANDLE_DLX3MSG(hWnd, WM^COMMAND, Dlg.OnCommand);
}
return(FALSE);
)
///////////////////////////////////////////////////////////////////////////////
int WINAPI _tWinMain(HINSTANCE hlnstExe, HINSTANCE, PTSTR, int) (
DialogBox(hlnstExe, MAKEINTRESOURCE(IDD_MMFSHARE), NULL, Dlg_Proc); return(0);
}
//////////////////////////////// End of File //////////////////////////////////
501-504
17.10稀疏调拨的内存映射文件
到目前为止，我们可以看到系统要求内存映射文件要么从磁盘上的数据文件中调拨，要么 从页交换文件中调拨。这意味着对存储器的使用可能并不如我们希望的那么高效。现在让 我们回到15.5.1节“何时撤销调拨物理存储器”中讨论的电子表格。假设我们想要与另一 个进程共享整个电子表格。如果使用内存映射文件，则需要为整个电子表格调拨物理存 储器：
CELLDATA CellData[200][256];
如果CELLDATA结构的大小是128字节，那么这个数组就需要6 553 600(200x256x128) 字节的物理存储器。正如我们当时就已经提到过，“对一个电子表格应用程序来说，这意 味着程序一开始运行就要从页交换文件中分配大量的物理存储器。尤其是，考虑到大多数 用户只会在电子表格的少数几个单元格中存放信息，也就是说剩下的大部分单元格都没有 用到。”
很显然，我们当然希望把电子表格作为一个文件映射对象来共享，但又不希望在一开始就 给它调拨所有的物理存储器。CreateFileMapping为我们提供了一种方法，即在fclwProtect 参数中指定SEC_RESERVE或SEC_COMMIT标志。
只有当以页交换文件为后备存储器来创建文件映射对象的时候，这些标志才有意义。
第17章内存映射文件
SEC_COMMIT标志让CreateFileMapping从页交换文件中调拨存储器，这和不指定任何 标志具有相同的效果。
如果在调用CreateFileMapping的时候传入SEC_RESERVE标志，那么系统不会从页交换 文件中调拨物理存储器，它只返回文件映射对象的句柄。现在我们可以调用MapViewOfFile 或 MapViewOfFileEx来给这个文件映射对象创建一个视图。MapViewOfFile和 MapViewOfFileEx会预订一块地址空间区域，但不会给区域调拨任何物理存储器。试图访 问区域中的内存地址将会引发访问违规。
4 504 陟
现在我们有了一块地址空间区域和一个用来标识该区域的文件映射对象的句柄。其他进程 可以用同一个文件映射对象来把同一块地址空间区域映射到自己的视图中。但由于我们还 没有给区域调拨物理存储器，因此如果其他进程试图访问映射到各自视图中的内存地址， 那么同样会引发访问违规。
现在，激动人心的时刻现在终于到了。为了给共享区域调拨物理存储器，我们只需要调用
VirtualAlloc：
PVOID VirtualAlloc(
PVOID pvAddress,
SIZE_T dwSize,
DWORD fdwA11oca c i onType,
DWORD fdwProtect);
第15章己经对这个函数进行了非常详细的介绍。无论区域是用VirtualAlloc和 MEM_RESERVE标志预订得到的，还是对内存映射文件进行映射得到的，给它们调拨物 理存储器的方法都是一样的，即VirtualAlloco正如我们可以只调拨部分存储器给用 VirtualAlloc预订的区域一样，我们也可以只调拨部分存储器给用MapViewOfFile或 MapViewOfFileEx 预订的区域。但是，一旦我们给用 MapViewOfFile 或 MapViewOfFileEx 预订的区域调拨了存储器，所有映射了同一个文件映射对象的视图的其他进程现在就可以 成功地访问已调拨的页面了。
通过使用SEC_RESERVE和VirtualAUoc,我们不仅能与其他进程共享电子表格的 CellData数组，而且还能高效地使用物理存储器。
说明 如果内存映射文件是通过SEC_RESERVE标志预订得到的，便不能用VirtualFree 来撤销调拨给它的存储器。
NT文件系统(NTFS)提供了对稀疏文件(sparse file)的支持。这是一项非常棒的特性。我们可 以用这项特性来创建和处理稀疏内存映射文件，这样一来，存储器就不必总是在页交换文 件中，而可以在普通的磁盘文件中。
下面让我们来看一看如何应用这项特性的一个例子：假设我们想要创建一个内存映射文件 来存储录音数据。当用户说话的时候，我们希望把数字音频数据写入到内存缓存中，并以. 磁盘文件为内存缓存的后备存储器。一个部分调拨的内存映射文件当然是最简单和最高效 的实现方式。问题在于我们并不知道用户在单击停止按钮之前会说多久，可能是五分钟，
而dows核心编程(第5版)
但也可能是5个小时，差距不可谓不大！我们需要一个足够大的文件来保存这些数据。但 是，在使用稀疏调拨的内存映射文件时，大小并没有多大的关系。
Sparse Memory-Mapped File 示例程序
后面的MMF Sparse应用程序(17WMFSparse.exe)展示了如何创建一个以NTFS稀疏文件为 后备存储器的内存映射文件。应用程序的源文件和资源文件在本书配套网页的 17-MMFSparse目录中。程序启动时，会显示下图所示的窗口。
505
当单击Create A 1MB (1024 KB) Sparse MMF按钮的时候，程序会试图在当前目录创建一个 名为MMFSparse的稀疏文件。如果当前的磁盘驱动器不是NTFS卷，那么这个操作会失 败，进程将终止。如果NTFS卷在另一个磁盘驱动器，那么必须修改源代码并重新构建应 用程序。
一旦创建了稀疏文件，程序会把它映射到进程的地址空间中。窗口底部的Allocated Ranges 编辑框会显示内存映射文件的哪些部分有实际的后备磁盘存储器。一开始，内存映射文件 没有占用任何存储器，编辑框中会显示"No allocated ranges in the file.”。
要读取一个字节，只需在Offset编辑框中输入一个偏移量并单击Read Byte按钮。程序会 把输入的数值乘以1024(1 KB),然后读取位于该处的数据，并把读取的数据放到Byte编辑 框中。如果想要读取的部分还没有后备存储器，则读取到的数据将始终是字节0o如果想 要读取的部分有后备存储器，则读取到的将是该处的实际数据。
要写入一个字节，只需在Offset编辑框中输入一个偏移量并在Byte编辑框中输入一个字节 值(0〜255)。然后，当单击Write Byte按钮的时候，程序会把偏移量乘以1024并把位于该 处的字节改成刚才指定的值。这个写入操作可能会使文件系统为文件的一部分调拨后备存
第17章内存映射文件
储器。在任何读/写操作之后，程序会对Allocated Ranges编辑框进行更新，以显示文件的 哪些部分有实际的后备存储器。在偏移量为1 024 000 (1000 x 1024)的地方写入一个字节 后，会出现下图所示的对话框。
在上图中，可以看到文件内只有一个逻辑偏移量为983 040的区间，并且系统为该区间分 配了大小为65 536字节的存储器。我们也可以用Windows资源管理器来找到这个文件并查 看它的属性页，如下图所示。
lows核心编程（第5版）
值得注意的是，属性页显示的文件大小为1 MB（这是文件的虚拟大小），但文件实际上只占 用64 KB的磁盘空间。
最后一个按钮Free AH Allocated Regions会让程序释放该文件所占用的所有■存储器，这个功 能用来释放磁盘空间并给文件中所有的字节清零。
现在让我们来讨论一下程序是如何工作的。为了使事情变得简单，我创建了一个名叫 CSparseStream的。++类（在SparseStream.h文件中实现）。这个类封装了可以用稀疏文件来 完成的一些任务。我在MMFSparse.cpp中创建了另一个名叫CMMFSparse的C++类，它 继承自CSparseStream。这样CMMFSparse对象不仅具有* CSparseStream的所有功能， 而且还有一些专门将稀疏文件用于内存映射文件的功能。代码中有一个CMMFSparse类型 的全局变量，名叫g_mmfo应用程序用这个全局变量来对稀疏内存映射文件进行操控。
在对WMJNITDIALOG消息进行处理的代码中，如果当前卷不支持稀疏文件（通过调用 CSparseStream::DoesFileSystemSupportSparseStreams 静态辅助函数来检查），程序会弹 出一个错误消息框并终止运行。如果用户单击了 Create A 1MB （1024 KB） Sparse MMF按 钮，程序会调用CreateFile来在NTFS磁盘分区上创建一个新的文件。这只是一个普通的 文件。然后代码会调用g_mmf对象的Initialize方法，并传入新文件的句柄和文件的最大 大小（1 MB）O在内部，Initialize会先调用CreateFileMapping,用指定的大小来创建文件映 射内核对象，然后调用MapViewOfFile来把稀疏文件的视图映射到进程的地址空间中。
Initialize函数返回的时候，会调用Dlg_ShowAllocatedRanges函数。这个函数在内部会调 用Windows函数来枚举稀疏文件内已经分配了实际存储器的逻辑区间。每个区间的起始偏 移量和长度都会显示在对话框底部的编辑框中。Lmmf对象刚初始化的时候，系统事实上 还没有为磁盘上的文件分配实际的物理存储器，编辑框可以反映出这一实际情况。
这时，用户既可以试着从稀疏内存映射文件中读取数据，也可以试着向文件中写入数据。 如果用户试图写入数据，那么程序会从相应的编辑框中得到偏移量和待写入的内容，然后 写入到g_mmf对象中的内存地址。对g_mmf执行写入操作会使系统为文件中相应的逻辑 部分分配物理存储器，但对应用程序来说这是透明的。
如果用户试图从g_mmf对象读取数据，那么稀疏内存映射文件中待读取的位置可能已经分 配了物理存储器，也可能尚未分配物理存储器。如果尚未分配物理存储器，那么读取操作 将返回字节值0。同样，这对应用程序来说是透明的。如果已经分配了物理存储器，那么 读取操作当然会返回实际的值。
应用程序展示的最后一点是如何重置文件，其目的是释放为文件分配的所有区间，使文件 无需再占用实际的磁盘空间。用户通过单击Free All Allocated Regions按钮来释放已分配的 区间。如果一个文件正用于内存映射文件，那么Windows是不会释放已分配的区间的，正 是由于这个原因，应用程序会调用g_mmf对象的ForceClose函数。ForceClose函数会在 内部先后调用UnmapViewOfFile和CloseHandle,并传入文件映射内核对象的句柄。
第17章内存映射文件
接下来，程序会调用DecommitPortionOfStream函数，释放为文件分配的所有存储器。为 了能让操作系统刷新稀疏文件的状态，我们必须关闭文件句柄。最后，程序会再次打开文 件并调用g_mmf对象的Initialize函数，也就是在进程的地址空间中重新对内存映射文件 进行初始化。为了验证所有•为文件分配的存储器都已经释放了，程序调用了 Dlg_ShowAllocatedRanges 函数，这样编辑框中将会显示 “No allocated ranges in the file”。 最后一件事情：如果要将稀疏内存映射文件用于实际的应用程序，那么在关闭文件的时候 可以考虑截断文件的逻辑大小。把稀疏文件的逻辑大小截断为0事实上并不会对磁盘空间 的实际大小产生任何影响，但这样做会比较好——Windows资源管理器和命令行窗口的 DIR命令就町以向用户报告一个更为真实的文件大小。为了设置文件的终止符，我们可以 先调用ForceClose函数，然后再分别调用SetFilePointer和SetEndOfFUe函数。
说明 我在1999年4月Microsoft System Journal的一篇问答中详细介绍了如何实现可增长
的内存映射文件，网址为 http://www.microsoft.com/msj/0499/win32/win320499.aspxo
MNPSparse.epp
/************★********
Module： MMFSparse.epp
Notices: Copyright (c) 2008 Jeffrey Richter & Christophe Nasarre
A*****************************************************************************
#include #include #include #include #include #include #include
"..\CommonFi1es\CmnHdr.h■ <tchar,h>
<WindowsX.h>
<WinIoCtl.h>
"Sparsestream.h" <StrSafe.h>
•Resource.h*
//////////////////////////////////////////////////////////////////////////////
// This class makes it easy to work with memory-mapped sparse files class CMMFSparse : public CSparseStream ( private：
HANDLE nuhFileMap； // File-mapping object
PVOID nupvFile；	// Address to start of mapped file
public：
// Creates a Sparse MMF and maps it in the process' address space. CMMFSparse(HANDLE hStream = NULL, DWORD dwStreamsizeMaxLow = 0, DWORD dwStreamsizeMaxHigh = 0);
// Closes a Sparse MMF
virtual -CMMFSparse() { ForceClose()； }
// Creates a sparse MMF and maps it in the process' address space. BOOL Initialize(HANDLE hStream, DWORD dwStreamsizeMaxLow,
DWORD dwStreamsizeMaxHigh = 0);
// MMF to BYTE cast operator returns address of first byte
// in the memory-mapped sparse file.
operator PBYTE() const ( return((PBYTE) nt_pvFile); }
indows核心编程（第5版）
if (m_hFileMap != NULL) ForceClose()；
// Allows you to explicitly close the MMF without having // to wait for the destructor to be called.
VOID ForceClose();
)；
///////////////////〃//////〃//////〃////〃〃////〃//////〃//〃//〃//////〃///
CMMFSparse::CMMFSparse(HANDLE hStream, DWORD dwStreamsizeMaxLow, DWORD dwStreams i z eMaxHi gh) (
Initialize(hStream. dwStreamsizeMaxLow, dwStreamSizeMaxHigh)；
//〃/////////〃//////////////////////////////////////〃////////////〃//////〃/
BOOL CMMFSparse::Initialize(HANDLE hStream, DWORD dwStreamSizeMaxLow, DWORD dwStreamSizeMaxHigh) (
// Initialize to NULL in case something goes wrong nuhFileMap = nupvFile = NULL;
BOOL bOk = TRUE; // Assume success
if (hStream != NULL) ( if ((dwStreamSizeMeixLow = DebugBreak(); // Illegal stream size
}
=0) && (dwStreamSizeMaxHigh == 0)) (
CSparseStream::Initialize(hStream)；
bOk = MakeSparse() ； // Make the stream sparse if (bOk) (
// Create a file-mapping object m_hFileMap = ::CreateFileMapping(hStream, NULL；. PAGE_READWRITE4 dwStreamSizeMaxHigh, dwStreamsizeMaxLow, NULL)育
if (nchFileMap != NULL) {
// Map the stream into the process * address space m_pvFile = ::MapViewOfFile(nL_hFileMap,
0);
FILE_J4AP_WRITE I FILE_>fAP_READ, 0, 0, } else (
// Failed to map the file, cleanup CSparseStream::Initialize(NULL);
ForceClose(); bOk = FALSE; }		
}		
}		
return(bOk);	ME	,瞄、瞟	J ；■/ J J*
///////////////////////////////////////////////////////^^^^^//////////
... "■"，**."**蹄.心莓曲盆建is；. M抑通醵岫通瞄
VOID CMMFSparse::ForceClose() {
// Cleanup everything that was done successfully if (m^pvFile != NULL) {
::UnmapViewOfFile(nupvFile);
m__pvFile = NULL;
第17章内存映射文件
}
if (m_hFileMap != NULL) (
::CloseHandle (nt_hFileMap); n\_hFileMap = NULL;
)
//////////////////////////////////////////////////////////////////////////////
#define STREAMSIZE (1 * 1024 * 1024)	// 1 MB (1024 KB)
HANDLE g_hStream = INVALID_HANDLE_VALUE;
CMMFSparse g_jnmf ；
TCHAR g_szPathname [MAX_PATH] = TEXT (■'()・)；
///////////////////////////////////////////////////////////////////////////////
BOOL Dlg_OnInitDialog(HWND hWnd, HWND hWndFocus, LPARAM 1Param) (
chSETDLGICONS(hWnd, IDI^MMFSPARSE);
// Initialize the dialog box controls.
EnableWindow(GetDlgltem(hWndr IDC_OFFSET), FALSE);
Edit_LimitText(GetDlgItem(hWnd, IDC_OFFSET), 4);
SetDlgltemlnt(hWnd, IDC_OFFSET/ 1000, FALSE);
EnableWindow(GetDlgltem(hWnd, IDC_BYTE), FALSE);
Edit_LimitText(GetDlgItem(hWnd, IDC_BYTE)r 3);
SetDlgltemlnt(hWnd, IDC_BYTE, 5, FALSE);
EnableWindow(GetDlgltem(hWnd, IDC_WRITEBYTE), FALSE);
EnableWindow(GetDlgltem(hWnd, IDC_READBYTE), FALSE);
EnableWindow(GetDlgItem(hWnd, IDC_FREEALLOCATEDREGIONS), FALSE);
// Store the file in a writable folder
GetCurrentDirectory(_countof(g_szPathname), g_szPathnaune)；
_tcscat_s(g_szPathname, _countof(g_szPathname), TEXT(■\\MMFSparse"))；
// Check to see if the volume supports sparse files
TCHAR szVolume[16];
PTSTR pEndOfVolume = __tcschr (g_szPathname, _T(' \\ '))；
if (pEndOfVolume == NULL) (
chFAIL("Impossible to find the Volume for the default document folder.•)； DestroyWindow(hWnd);
return(TRUE);
_tcsncpy_s (szVoliime/ _countof (szVolume),
g_szPathname, pEndOfVolume - g_szPathname + 1);
if (JCSparseStream：:DoesFileSystemSupportSparseStreams(szVolume)) { chFAIL("Volume of default document folder does not support sparse MMF.•)； DestroyWindow(hWnd)；
return(TRUE);	、	，	：？..'.
return(TRUE)； }
/////////////////////////////////////////////////////////////〃//〃/〃////〃///
void Dlg_ShowAllocatedRanges(HWND hWnd) (
// Fill in the Allocated Ranges edit control
lows核心编程（第5版）
DWORD dwNumEntries;
FILE_ALLOCATED_RANGE_BUFFER* pfarb =
g_mmf. QueryAl locatedRanges (&dWumEntries)；
if (dwNumEntries == 0) (
SetDlgltemText(hWndr IDC_FILESTATUS/
TEXT("No allocated ranges in the file*));
} else (
TCHAR sz[4096] = { 0 };
for (DWORD dwEntry = 0; dwEntry < dwNumEntries； dwEntry++) ( StringCchPrintf(_tcschr(sz, _T('\0')), _countof(sz) - _tcslen(sz), TEXT('Offset: %7.7u, Length: %7.7u\r\nB), pfarb[dwEntry].FileOffset.LowPart, pfarb[dwEntry].Length.LowPart);
)
SetDlgltemText(hWnd, IDC_FILESTATUS, sz)；
}
g_mmf.FreeAllocatedRanges(pfarb)；
)
///////////////////////////////////////////////////////////////////////////////
void Dlg_OnCommand(HWND hWnd, int id, HWND hWndCtl, UINT codeNotify) { switch (id) (
case IDCANCEL:
if (g_hStream != INVALID_HANDLE_VALUE)
CloseHandle(g_hStream);
EndDialog(hWnd, id);
break;
case IDC_CREATEMMF:
(
g_hStream = CreateFile(g_szPathname, GENERIC_READ I GENERIC__WRITEr 0, NULL, CREATE__ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
if (g_hStream == INVALID_HANDLE_VALUE) { chFAIL("Failed to create file.*)； return；
}
// Create a 1MB (1024 KB) MMF using the file if (.Initialize(g_hStreeun, STREAMSIZE)) ( chFAIL("Failed to initialize Sparse MMF.■)； CloseHandle(g_hStream);
g__hStream = NULL; return；
}
Dlg_ShowAllocatedRanges(hWnd)；
// Enable/disable the other controls.

EnableWindow(GetDlgItem(hWndz EnableWindow(GetDlgItem(hWnd, EnableWindow(GetDigitem(hWnd, EnableWindow(GetDlgltem(hWnd, EnableWindow(GetDlgItem(hWnd, EnableWindow(GetDlgltem(hWnd,
TRUE坨* trtoK-
TRUE);
TRUE)?
IDC_CREATEMMF), IDC_OFFSET), IDC_BYTE), IDC^WRITEBYTE), IDC_READBYTE), IDC^FREEALLOCATEDREGIOMSll； TRUbBO
// Force the Offset edit control to have the focus. SetFocus(GetDlgltem(hWnd, IDC_OFFSET))；
}
break;
case IDC_WRITEBYTE:
嫩嫁豚麻端!.西
* •	浜孕％整；::
BOOL bTranslated;
DWORD dwOffset = GetDlgltemlnt (hWnd, IDC_OFFSET, &bTranslated,
第17章内存映射文件
if (bTremslated) {
gjnmf[dwOffset * 1024] = (BYTE)
GetDlgltemlnt(hWnd, IDC_BYTE, NULL, FALSE); Dlg_ShowAllocatedRanges(hWnd);
}
}
break；
case IDC_READBYTE:
(
BOOL bTranslated;
DWORD dwOffset = GetDlgltemlnt(hWnd, IDC_OFFSET, &bTranslatedz FALSE); if (bTranslated) (
SetDlgltemlnt(hWnd, IDC_BYTE, [dwOffset * 1024], FALSE); Dlg__ShowAllocatedRanges (hWnd);
}
)
break;
case IDC^FREEALLOCATEDREGIONS:
// Normally the destructor causes the file-mapping to close.
// But, in this case# we want to force it so that we can reset
// a portion of the file back to all zeros. g_jnmf. ForceClose ();
//We call ForceClose above because attempting to zero a portion of //. the file while it is mapped, causes DeviceloControl to fail with // error ERRORU-USER_MAPPED_FILE ("The requested operation cannot // be performed on a file with a user-mapped section open.") g_mmf.DecoiranitPortionOfStream(0, STREAMSIZE)；
//We need to close the file handle and reopen it in order to // flush the sparse state.
CloseHandle(g_hStream)； g_hStream = CreateFile(g_szPathname, GENERIC^READ I GENERIC_WRITE,
0, NULL, CREATE^ALWAYS, FILE_ATTRIBUTE_-NORMAL, NULL);
if (g__hStream == INVALID_HANDLE_VALUE) ( chFAIL(■Failed to create file.■)； return；
}
// Reset the MMF wrapper for the new file handle. g_jranf.Initialize(g_hStream, STREAMSIZE);
// Update the UI.
DlgL-ShowAllocatedRanges(hWnd);
break；
}
)
///〃////〃///////////////////////////////〃///////////////〃〃〃/vzm
* .： . , I •-v：■-	" *	#, ,' • **：z J • 1*,• »•r * , •	:二，I	\ >*1 *• * |
<二 V	-- ' <>
'丁 、	.■ •. 土五♦：：,、,£，[	• f. ••• -3«,
INT_PTR WINAPI Dlg_Proc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM Ipardm)( switch (uMsg) (
chHANDLE_DLGMSG(hWnd, WK-INITDIALOG, Dlg_OnInitDialog); chHANDLE_DLGMSG(hWnd, WM^COMMAND, Dlg_OnCommand);
}
return(FALSE);
/////////////////////〃/////////////////////////////////////////////〃/〃//〃：〃
Endows核心编程(第5版)
int WINAPI _tWinMain(HINSTANCE hlnstExe, HINSTANCE, PTSTR pszCmdLine, int) {
DialogBox(hlnstExe, MAKEINTRESOURCE(IDD..MMFSPARSE), NULL, Dlg^Proc); return(0);
}
//////////////////////////////// End of File //////////////////////////////////
Sx>arseStreaai. h
Module： Sparsestream.h
Notices： Copyright (c) 2007 Jeffrey Richter & Christophe Nasarre
#include "..\CommonFiles\CmnHdr.h"	/* See Appendix A. */
#include <WinIoCtl.h>
///////////////////////////////////////////////////////////////////////////////
#pragma once
///////////////////////////////////////////////////////////////////////////////
class CSparseStream {
public:
static BOOL DoesFileSystemSupportSparseStreams(PCTSTR pszVol tune);
static BOOL DoesFileContainAnySparseStreams(PCTSTR pszPathname)；
public:
CSparseStream(HANDLE hStream = INVALID__HANDLE_VALUE) ( Initialize(hStream)；
}
* virtual -CSparseStream() { }
void Initialize(HANDLE hStream = INVALID_HANDLE_VALUE) ( nt_hStream = hStream；
}
public：
operator HANDLE() const { return(nuhStream)； }
public：
BOOL IsStreamSparse() const;
BOOL MakeSparse()；
BOOL DecommitPortionOfStream(
—int64 qwFileOffsetstart, _int64 qwFileOffsetEnd);
FILE_ALLOCATED_RANGE_BUFFER* QueryAllocatedRanges(PDWORD pdwNumEntries);
BOOL FreeAllocatedRanges (FILE_ALLOCATED_RANGE_BUFFER* pfarb);
private:
HANDLE m_hStream；	- " j
private:
static BOOL AreFlagsSet (DWORD fdwFlagBits, DWORD fFlagsToCheckf.J ( M return((fdwFlagBits & fFlagsToCheck) == fFlagsToCheck)；
}	霓壬;皓:
};
第17章内存映射文件
//////////////〃/////////////////////////〃////////////////////////////////////
inline BOOL CSparseStream：:DoesFileSystemSupportSparseStreams(
PCTSTR pszVolxune) (
DWORD dwFileSystemFlags = 0;
BOOL bOk = GetVolumelnformation(pszVolume, NULL, 0, NULL, NULL, &dwFileSystemFlags, NULL, 0);
bOk = bOk && AreFlagsSet(dwFileSystemFlags, FILE_SUPPORTS_SPARSE_FILES); return(bOk);
}
///////////////////////////////////////////////////////////////////////////////
inline BOOL CSparseStream::IsStreamSparse() const (
BY__HANDLE_FILE_INFORMATION bhfi;
GetFilelnformationByHandle(nchStream, &bhfi);
return(AreFlagsSet(bhfi.dwFileAttributes, FILE__ATTRIBUTE_SPARSE_FILE))；
///////////////////////////////////////////////////////////////////////////////
inline BOOL CSparseStream：:MakeSparse() (
DWORD dw;
return(DeviceloControl(nuhStream, FSCTL_SET_SPARSE, NULL, 0, NULL, 0, &dw, NULL));
}
///////////////////////////////////////////////////////////////////////////////
inline BOOL CSpar seStreeim: : Decommit Port ionOf Stream (
_int64 qwOffsetStart, _int64 qwOffsetEnd) (
// NOTE： This function does not work if this file is memory-mapped. DWORD dw；
FILE_ZERO_DATA_INFORMATION fzdi;
fzdi.FileOffset.QuadPart = qwOffsetstart;
fzdi.BeyondFinalZero.QuadPart = qwOffsetEnd + 1；
return(DeviceloControl(m_hStream, FSCTL_SET_ZERO_DATA, (PVOID) &fzdi, sizeof(fzdi), NULL, 0, &dw, NULL))；
}
///////////////////////////////////////////////////////////////////////////////
inline BOOL CSparseStream::DoesFileContainAnySparseStreams(
PCTSTR pszPathname) (
DWORD dw = GetFileAttributes(pszPathname); return((dw == Oxfffffff)
.? FALSE : AreFlagsSet (dw, FILE_ATTRIBUTE_.SPARSE_.FILE)); }
///////////////////////////////////////////////////////////////////////////////
lows核心编程（第5版）
inline FILELALLOCATED_RANGE_BUFFER* CSparseStream：:QueryAllocatedRanges( PDWORD pdwNumEntries) (
FILE_ALLOCATED_RANGE_BUFFER farb;
farb.FileOf fset.QuadPart = 0;
farb.Length.LowPart = GetFileSize(nuhStream, (PDWORD) &farb.Length.HighPart);
.// There is no way to determine the correct memory block size prior to // attempting to collect this data, so I just picked 100 * sizeof(*pfarb) DWORD cb = 100 * sizeof(farb);
FILE_ALLOCATED_RANGE_BUFFER* pfarb = (FILE__ALLOCATED_RANGE_BUFFER*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cb)；
DeviceloControl (心Stream, FSCTL_QUERY_ALLOCATED_RANGES,
&farb, sizeof(farb), pfarb, cb, &cb, NULL);
♦pdwNumEntries = cb / sizeof(*pfarb);
return(pfarb)；
///////////////////////////////////////////////////////////////////////////////
inline BOOL CSparseStream::FreeAllocatedRanges(
FILE_JkLLOCATED_RANGE_BUFFER* pfarb)(
// Free the queue entry's allocated memory return(HeapFree(GetProcessHeap(), 0, pfarb))； }
///////////////////////////////// End Of File /////////////////////////////////
509*518
i8.i	进程的默认堆
■额外的堆
up嚎k 创建额外的堆''n?w(msii^^^^w^flRmi?mww io- ■藏独雷昭〜"％专”	• "*'”事囊f!
第三种也是最后一种对内存进行操控的方法是使用堆。堆非常适合分配大量的小型数据。
例如，与第15章介绍的虚拟内存和第17章介绍的内存映射文件相比，堆是用来管理链表 和树的最佳方式。堆的优点是它能让我们专心解决手头上的问题，而不必理会分配粒度和 页面边界这类事情。堆的缺点是分配和释放内存块的速度比其他方式慢，而且也无法再对 物理存储器的调拨和撤销调拨进行直接控制。
在系统内部，堆就是一块预订的地址空间区域。刚开始，区域内的大部分页面都没有调拨 物理存储器。随着我们不断地从堆中分配内存，堆管理器会给堆调拨越来越多的物理存储 器。这些物理存储器始终是从页交换文件中分配的。释放堆中的内存块时，堆管理器会撤 销已调拨的物理存储器。
Microsoft并未在文档中记录堆在调拨和撤销调拨存储器时所遵循的确切规则。为了在保证 最佳安全性的前提下找到在大多数情况下最适用的规则，Microsoft 一直都在不断地进行压 力测试和模拟不同的场景。由于应用程序以及它们运行的硬件平台会发生变化，因此这些 规则也会发生变化。如果这些信息对所开发的应用程序来说至关重要，那么就不应该使用 堆，而应该使用虚拟内存他就是VirtualAlloc和VirtualFree),这样开发人员就可以自己 控制这些规则。
18.1进程的默认堆
进程初始化的时候，系统会在进程的地址空间中创建一个堆。这个堆被称为进程的默认堆 (default heap)o在默认的情况下，这个堆的地址空间区域的大小是1 MB。但是，系统可以 增大进程的默认堆，使它大于1 MBO我们也可以在创建应用程序的时候用/HEAP链接器 开关来改变默认的区域大小。由于动态链接库(DLL)没有与之关联的堆，因此在创建DLL 的时候不应该使用/HEAP开关。下面是/HEAP开关的使用方法：
J^idows核心编程(第5版)
/HEAP：reserve[,commit J
许多Windows函数要用到进程的默认堆。例如，Windows中许多最重要的函数都用Unicode 字符和Unicode字符串来执行它们所有的操作。如果我们调用的是一个函数的ANSI版本, 那么该函数的ANSI版本必须把ANSI字符串转换为Unicode字符串,然后再调用同一个函 数的Unicode版本。为了转换字符串，ANSI版本的函数需要分配一块内存来保存Unicode 版本的字符串。这块内存就是从进程的默认堆中分配的。许多其他的Windows函数需要用 到一些临时的内存块，这些内存块也是从进程的默认堆中分配的。此外，旧的16位Windows 下的函数LocalAlloc和GlobalAlloc也会从进程的默认堆中分配内存。
由于许多Windows函数用到了进程的默认堆，而且应用程序会有许多线程同时调用各种 Windows函数，因此对默认堆的访问必须依次进行。换句话说，系统保证不管在什么时候, 一次只让一个线程从默认堆中分配或释放内存块。如果两个线程同时想要从默认堆中分配 一块内存，那么只有其中一个线程能够分配内存，另一个线程必须等待第一个线程的分配 完成。只有当第一个线程的分配己经完成时，堆函数才会允许第二个线程分配内存。这种 依次访问会对性能产生轻微的影响。如果应用程序只有一个线程，而我们又希望以最快的 速度访问堆，那么我们应该创建自己的堆而不要使用进程的默认堆。但遗憾的是，我们无 法不让Windows函数使用默认堆，因此它们对堆的访问始终都是依次进行的。
一个进程同时可以有多个堆，进程在整个生命周期内可以创建和销毁这些堆。但是，默认 堆是在进程开始运行之前由系统自动创建的，在进程终止后会自动销毁。我们无法销毁进 程的默认堆。每个堆都有一个用来标识自己的堆句柄，所有分配和释放内存块的堆函数都 会在参数中用到这个堆句柄。
我们可以通过调用GetProcessHeap来得到进程的默认堆的句柄：
HANDLE GetProcessHeap();
18.2为什么要创建额外的堆
除了进程的默认堆，我们可以在进程的地址空间中创建额外的堆。由于以下原因，我们可 能希望在应用程序中创建额外的堆：
•	对组件进行保护
•	更有效的内存管理
•	局部访问
•	避免线程同步的开销
•	快速释放
下面让我们来一个一个地仔细分析。
快520
第18章堆
18.2.1对组件进行保护
假设应用程序需要处理两个组件：一个由NODE结构组成的链表和一个由BRANCH结构 组成的二叉树。我们有两个源文件：LinkList.cpp包含用来处理NODE链表的函数， BinTree.cpp包含用来处理BRANCH二叉树的函数。
如果NODE和BRANCH结构都保存在同一个堆中，那么这个混合的堆看起来会像图18-1 所描绘的那样。
图1&1在同一个堆中保存NODE和BRANCH结构
现在假如链表的代码有一个缺陷，会不小心覆盖NODE 1后面的8个字节，从而破坏了 BRANCH 3中的数据。BinTree.cpp中的代码后来在遍历二叉树的时候，很可能会由于这个 原因而失败。当然，这会造成一种假象，使我们觉得链表的代码有缺陷。由于不同类型的 对象混杂在同一个堆中，因此对缺陷进行跟踪和定位会非常困难。
通过创建两个独立的堆（一个用来保存NODE结构，另一个用来保存BRANCH结构），我 们就可以使问题局部化。链表中的一个小缺陷不会破坏二叉树的完整性，反之亦然。虽然 还存在另一种可能性（即有缺陷的代码写入到另一个堆中的内存），但这种nJ能性要小得多。
18.2.2更有效的内存管理
如果始终从堆中分配同样大小的对象，我们就可以对它们进行更加有效的管理。例如，假 设每个NODE结构需要24字节，每个BRANCH结构需要32字节，所有对象都从同一个 堆中分配。图18.2显示了一个堆，它已经完全被NODE和BRANCH对象占满。如果释放 NODE 2和NODE 4,那么堆中将出现内存碎片。这时如果我们想分配一个BRANCH结构,
Hows核心编程（第5版）
那么即使现在有48字节的可用空间而BRANCH只需要32字节，分配操作仍然会失败。
图18・2 一个带碎片的堆，其中包含NODE和BRANCH对象
如果每个堆只包含同样大小的对象，那么释放一个对象可以保证释放出的空间刚好能够容 纳另一个对象。
18.2.3使内存访问局部化
当系统必须把一个内存页面换出到页交换文件，或把页交换文件中的一个页面换入到内存 中的时候，会对性能产生非常大的影响。如果把内存访问局限在一个较小的地址区间内， 将降低系统需要在内存和磁盘之间进行交换的可能性。
因此，在设计应用程序的时候，一种很好的做法是把需要同时访问的对象分配在相邻的内 存地址。回到我们刚才的链表和二叉树的例子，遍历链表和遍历二叉树之间并不存在任何 关联。通过在（同一个堆中的）相邻的内存地址分配NODE对象，我们可以把NODE对象放 在邻近的页面中。事实上，很有可能多个NODE对象都在同一个物理内存页面中。这样在 遍历链表的时候，CPU就不需要在访问每个NODE的时候去访问内存中不同的页面了。
如果在同一个堆中分配NODE和BRANCH对象，那么各NODE对象不一定相邻。在最差 的情况下，每个内存页中可能只有一个NODE对象，内存页中剩下的部分都被BRANCH 对象占用。在这种情况下，遍历链表中的每个NODE都会引起页面错误，从而导致整个遍 历过程变得极其缓慢。
18.2.4避免线程同步的开销
后文马上就要提到，在默认情况下，对堆的访问是依次进行的，这样即使在同一时刻有多
第18章堆
个线程要访问堆，也不会出现数据被破坏的情况。但是，堆函数必须执行额外的代码来保 证堆的线程安全性(thread-safe)o如果从堆中进行大量的分配操作，那么执行这些额外的代 码会积少成多，并对应用程序的性能产生影响。如果选择创建一个新的堆，就可以告诉系 统只有一个线程会访问堆，这样就不必执行额外的代码了。但是，这时候要小心——现在 我们承担起了保证堆的线程安全性的责任，系统不再帮我们管这些事情了。

18.2.5快速释放
最后，把一些数据结构存入在一个专门的堆中还有另一个好处，即我们可以直接释放整个 堆而不必显式地释放堆中的每个内存块。例如，当Windows资源管理器在遍历硬盘上的目 录层次的时候，它必须在内存中建立一棵树。如果我们让Windows资源管理器刷新显示， 那么它会直接销毁包含整棵树的那个堆，然后再重来一遍(当然，我们这里假设它有一个专 门的堆，仅用于存放目录树的信息。)对许多应用程序来说，这不但极其方便，而且它们还 可以更快速地运行。
18.3如何创建额外的堆
我们可以调用HeapCreate来在自己的进程中创建额外的堆：
HANDLE HeapCreate(
DWORD fdwOptionS/
SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
第一个参数fdwOptions用来表示对堆的操作该如何进行。可以指定0、 HEAP NO SERIALIZE, HEAP GENERATE EXCEPTIONS, HEAP CREATE ENABLE
—	—	—	MM
EXECUTE或这些标志的组合。
在默认情况下，对堆的访问会依次进行，使多个线程可以从同一个堆中分配和释放内存块， 同时也不会存在堆数据被破坏的危险。当任何程序试图从堆中分配一块内存的时候， HeapAlloc函数(稍后会进行讨论)必须执行以下操作。
(1)	遍历已分配内存的链表和闲置内存的链表。
(2)	找到一块足够大的闲置内存块。
(3)	分配一块新的内存，也就是将刚找到的闲置内存块标记为已分配。
(4)	将新分配的内存块添加到已分配内存的链表中。
这里有一个例子，它解释了为什么我们应该避免使用HEAP_NO_SERIALIZE标志。假设 有两个线程试图在同一时刻从同一个堆中分配一块内存。线程1执行刚才列出的第(1)步和 第(2)步，得到了闲置内存块的地址。但是，当线程1准备执行第3步的时候，系统让线程 1暂停，这样线程2也有机会执行第1步和第2步。由于线程1还没有执行第3步，因此
常ndows核心编程(第5版)
线程2找到的闲置内存块与线程1相同。
两个线程都以为自己在堆中找到了一块闲置内存。线程1对链表进行更新，将新的内存块 标记为已分配。然后线程2也对链表进行更新，将同一块内存标记为已分配。到目前为止, 两个线程拿到的地址指向同一块内存，但谁都没有发现问题。
由于这种类型的缺陷不会立刻将问题暴露出来，因此是非常难以查获的。缺陷会一直潜伏 在后台，直到最不凑巧的时候才发作。它可能会导致以下这些问题。
•	内存块的链表被破坏。这个问题只有到下次分配或释放内存的时候才会被发现。
•	两个线程共享同一块内存。线程1和线程2可能都会写入信息到同一块内存中。当 线程1使用内存块中的内容时，它无法识别出由线程2写入的数据。
•	其中一个线程可能会使用内存块然后释放它，这使得另一个线程会覆盖己释放的闲 置内存，从而导致堆被破坏。
这些问题的解决方案是只允许一个线程独占对堆及其链表的访问，直到所有必需的操作都 已经完成。这也正是没有指定HEAP_NO_SERIALIZE标志时堆的行为。当且仅当进程满 足以下条件之一或更多的时候，使用HEAP__NO_SERIALIZE标志才是安全的。
(1)	进程中只有一个线程。
(2)	进程中有多个线程，但只有一个线程会访问这个堆。
(3)	进程中有多个线程，但进程使用了其他方式来管理对堆的独占访问，比如临界区(critical section)＞互斥量(mutex)、以及信号量(semaphore)(这些机制在第8章和第9章中进行 了介绍)。
如果不清楚到底应不应该使用HEAP_NO_SERIALIZE标志，那么就不要用。虽然这样做 会在调用堆函数的时候对性能产生轻微的影响，但这避免了堆和堆中的数据被破坏的危险。
HEAP_GENERATE_EXCEPTIONS标志告诉系统，每当在堆中分配或重新分配内存块失 败的时候，抛出一个异常。异常只不过是系统所使用的另一种方法，用来通知应用程序有 错误发生。在设计应用程序的时候，有时候捕获异常比检查返回值要容易。第23〜25章对 异常进行了详细的介绍。
说明 在默认情况下，调用Heap*函数的时候，如果操作系统发现堆被破坏(比如在写内存 时越界了)，那么除了程序在调试器中运行时会引发一个断言之外，不会发生什么特 别的事情。但是，在过去的几年中，对堆的内部结构进行破坏已经成为被黑客和恶 意软件大肆利用的一种手段，这迫使Microsoft给堆增加了更多的控制和检验，以便 尽早发现这种类型的破坏。
现在我们可以让堆管理器在任何Heap*函数中一旦发现堆破坏，就抛出一个异常。 下面就是我们需要添加和执行的代码：
HeapSetInformation(NULL, HeapEnableTerminationOnCorruption, NULL, 0)；
第一个参数是一个指向HeapSetlnformation结构的指针。如果给第二个参数传
HeapEnableTerminationOnCorruption,那么函数会忽略第一个参数。系统会将该
第18章堆
策略严格应用到进程中所有的堆。此外，一旦为进程中所有的堆启用了这项特性, 就再也无法禁用它了。
如果想在堆中存放可执行代码，则必须使用最后一个标志HEAP_CREATE_ ENABLE_EXECUTE。这对“数据执行保护”这项特性来说特别重要，详情可参见第13 章。如果不设置这个标志，那么当我们试图在来自堆的内存块中执行代码时，系统会抛出 EXCEPTION_ACCESS_VIOLATION 异常。
524-525
HeapCreate的第2个参数dwInitialSize表示一开始要调拨给堆的字节数。如果需要， HeapCreate会把这个值向上取整到CPU页面大小的整数倍。最后一个参数 dwMaximumSize表示堆所能增长到的最大大小(即系统为堆所预订的地址空间的最大大 小)。如果dwMaximumSize大于0,那么创建的堆会有一个最大大小。这时，如果试图分 配的内存块可能导致堆超过最大大小，分配操作会失败。
如果dwMaximumSize为0,那么创建的堆将是可增长的，它没有一个指定的上限。从堆 中分配内存会使堆不断增长，直到用尽所有的物理存储器为止。如果成功创建了堆，那么 HeapCreate会返回一个句柄，它标识了新创建的堆。其他的堆函数都会用到这个句柄。
18.3.1从堆中分配内存块
从堆中分配一块内存只不过是调用一下HeapAlloc函数：
PVOID HeapAlloc(
HANDLE hHeap,
DWORD fdwFlags,
SIZE_T dwBytes);
第1个参数hHeap是一个堆的句柄，表示要从哪个堆中分配内存。参数dwBytes表示要从 堆中分配多少个字节。中间的参数fdwFlags用来指定一些标志，这些标志会对分配产生影 响。目前，系统只支持3个标志：HEAP ZERO MEMORY, HEAP GENERATE EXCEPTIONS 和 HEAP_NO_SERIALIZEo
HEAP_ZERO_MEMORY标志的目的非常明显。它会让HeapAlloc在返回之前把内存块的 内容都清零。第2个标志HEAP_GENERATE_EXCEPTIONS用来告诉系统，如果堆中没 有足够的内存来满足内存分配请求，HeapAlloc就应该抛出异常。在调用HeapCreate来创 建堆的时候，也可以使用HEAP_GENERATE_EXCEPTIONS标志，这告诉系统在无法分 配内存块的时候抛出异常。如果在调用HeapCreate的时候指定了这个标志，在调用 HeapAlloc的时候就不需要再指定了。另一方面，我们可能希望在创建堆的时候不使用这 个标志。在这种情况下，在调用HeapAlloc的时候指定这个标志就只会影响到当前这次调 用，而不会影响到所有其他对HeapAlloc函数的调用。
如果HeapAlloc调用失败并抛出异常，那么抛出的异常将是表18-1中列出的两个异常之一。
bws核心编程(第5版)
表18-1 HeapAllo c抛出的异常
标识符	含义
STATUS NO MEMORY	分配失败的原因是因为内存不够
STATUS ACCESS VIOLATION	分配失败的原因是因为堆被破坏或传入的参数不正确
525	
如果分配成功，HeapAlloc将返回内存块的地址。如果没有指定HEAP_GENERATE_ EXCEPTIONS标志，那么当无法分配内存时HeapAlloc会返回NULL。
最后一个标志HEAP_NO_SERIALIZE用来强制系统不要把这次HeapAlloc调用与其他线 程对同一个堆的访问衣次弗列起来。在使用这个标志的时候应该极其小心，因为如果其他 线程也在同一时刻对堆进行操作，将破坏堆的完整性。在从进程的默认堆中分配内存的时 候，绝对不要使用这个标志，否则可能会破坏数据，因为进程中的其他线程可能会在同一 时刻访问堆。
说明 在分配大块内存(1 MB或更多)的时候应该避免使用堆函数，建议使用VirtualAlloc 函数。
如果分配大量不同大小的内存块，那么堆管理器内部用来处理分配请求的默认算法可能会 产生地址空间碎片：由于所有可用的内存块都不够大，因此系统将无法找到一块足够大的 闲置内存块。在Windows XP和Windows Server 2003之后的版本中，我们可以强制操作系 统在分配内存的时候使用一种叫低碎片堆(lowfragmentation heap)的算法。在多处理器的机 器上，低碎片堆的性能得到了极大的提高。下面的代码用来切换到低碎片堆：
ULONG HeapInformationValue = 2;
if (HeapSetlnformation(
hHeap, HeapCompatibilityInformation,
&HeapInformationValue, sizeof(HeapInformationValue)) (
// hHeap is turned into a low fragmentation heap
} else {
// hHeap can't be turned into a low fragmentation heap.
// Maybe because it has been created with the HEAP_NO_SERIALIZE flag
)
如果把GetProcessHeap的返回值传给HeapSetlnformation,默认堆就会变成一个低碎片 堆。如果传入的堆句柄标识的堆是用HEAP_NO_SERIALIZE标志创建的， HeapSetlnformation调用便会失败。值得注意的是，如果抱码在调试器下运行，那么有些 堆调试选项会阻碍堆变成一个低碎片堆。把环境变量_NO_DEBUG_HEAP设为1,就可以 关闭这些堆调试选项。另外还要注意，堆管理器自己也会对所有的Z)配请求进行监控并进 行一些内部优化。例如，如果堆管理器发现切换到低碎片堆会对应用程序有好处，那么它 可能会自动进行切换。
18.3.2调整内存块的大小
我们经常需要调整内存块的大小。有些应用程序会在一开始分配一块大于实际需要的内存
第18章堆
块，然后在把所有数据都放到这块内存中之后，再减小内存块的大小。有些应用程序一开 始分配一小块内存，然后在需要把更多数据复制到这块内存中的时候，再增大内存块的大 小。调整内存块的大小是通过调用HeapReAIloc函数来完成的：
PVOID HeapReAIloc(
HANDLE hHeap,
DWORD fdwFlags,
PVOID pvMem,
SIZE_T dwBytes);	___
和以前一样，hHeap用来标识需要调整大小的内存块属于哪个堆。参数fdwFlags用来指定 一些标志，HeapReAIloc会在调整内存块的大小的时候用到这些标志。有以下四个标志可 供我们使用：HEAP GENERATE EXCEPTIONS , HEAP NO SERIALIZE , HEAP_ZERO_MEMORV 和 HEAP_REALLOC_IN_PLACE_ONLY。
前两个标志的含义与它们用于HeapAlloc的时候相同。只有当增大内存块的大小时， HEAP_ZERO_MEMORY标志才有用。在这种情况下，内存中额外的字节会被清零。减小 内存块的大小时，这个标志不起任何作用。
在增大内存块的时候，HeapReAIloc可能会在堆内部移动内存块，而 HEAP_REALLOC_IN_PLACE_ONLY标志用来告诉HeapReAIloc不要移动内存块。如果 HeapReAIloc能够在不移动内存块的前提下让它增大，它将返回内存块原来的地址。另一 方面，如果HeapReAIloc必须移动内存块的内容，函数将返回一个新地址，指向一块更大 的内存块。如果要把内存块减小，那么HeapReAIloc会返回内存块原来的地址。如果一个 内存块是链表或树的一部分，则需要指定HEAP__REALLOC_IN_PLACE_ONLYo在这种 情况下，链表或树中的其他节点可能包含指向当前节点的指针，把节点移动到堆中其他的 地方会破坏链表或树的完整性。
剩下的两个参数pvMem和dwBytes,分别用来指定想要调整大小的内存块的当前地址，以 及内存块的新大小，以字节为单位。HeapReAIloc要么返回一个地址，指向调整大小后的 新内存块，要么返回NULL(如果不能调整内存块的大小的话)。
18.3.3获得内存块的大小
分配一块内存后，可以调用HeapSize函数来得到这块内存的实际大小：
SIZE_T HeapSize(
HANDLE hHeap,
DWORD fdwFlags,
LPCVOID pvMem);
参数hHeap用来标识堆，参数pvMem表示内存块的地址。参数fdwFlags可以是0或者
HEAP NO SERIALIZE o
B^^dows核心编程(第5版)
18.3.4释放内存块
不再需要一块内存的时候，我们可以调用HeapFree来释放它：
BOOL HeapFree(
HANDLE hHeap,
DWORD fdwFlags,
PVOID pvMem)；
o
HeapFree会释放内存块，如果操作成功，它会返回TRUE。参数fdwFlags可以是0或者 HEAP_NO_SERIALIZE°调用这个函数可能会使堆管理器撤销一些已经调拨的物理存储 器，但这并不是一定的。
18.3.5销毁堆
如果应用程序不再需要自己创建的堆，则可以调用HeapDestroy来销毁它：
BOOL HeapDestroy(HANDLE hHeap);
调用HeapDestroy会释放堆中包含的所有内存块，同时系统会收回堆所占用的物理存储器 和地址空间区域。如果函数调用成功，HeapDestroy将返回TRUE。如果我们不在进程终 止之前显式地销毁堆，那么系统会替我们销毁。但只有在进程终止的时候，系统才会这样 做。如果一个线程创建了堆，那么在这个线程终止的时候，堆是不会被销毁的。
在进程完全终止之前，系统不允许销毁进程的默认堆。如果把进程的默认堆的句柄传给 HeapDestroy,系统将直接忽略该调用并返回FALSEo
18.3.6 在C++中使用堆
运用堆的最佳方式莫过于将它们集成到已有•的C++程序中。在C廿中，我们调用new操作 符来分配类对象，而不是调用通常的C运行库函数malloc来分配类对象。然后，在不再需 要某个类对象的时候，我们调用delete操作符来释放它，而不是调用通常的C运行库函数 free来释放它。举个例子，假设要为一个名为CSomeClass的类分配一个实例，那么我们 可能会编写下面的代码：
CSomeClass* pSomeClass = new CSomeClass；
C++编译器编译这一行代码的时候，它会首先检查CSomeClass是否包含一个更载了 new 操作符的成员函数。如果找到，编译器将生成代码来调用这个成员函数。如果编译器无法 找到哪个函数重载了 new操作符，编译器将生成代码来调用C+4•的标准new操作符。
在用完对象之后，我们可以调用delete操作符来销毁该对象:
第18章堆
delete pSomeClass；
通过对C++类的new和delete操作符进行重载，我们可以非常容易地将堆函数加以运用。 我们可以在头文件中像下面这样定义CSomeClass类：
class CSomeClass (
private:
static HANDLE s_hHeap；
static UINT s_uNumAlIocsInHeap；
// Other private data and member functions
public:
void* operator new (size* size)；
void operator delete (void* p)；
// Other public data and member functions
• • •
};
528-529
这段代码定义了两个静态成员变量，它们分别是s_hHeap和s_iiN<imAllocsIiiHeap。由于 它们是静态变量，因此C++会让CSomeClass的所有实例共享这两个变量，也就是说，C++ 不会为每个CSomeClass的实例都分配一个s__hHeap和s_uNumAllocsInHeap变量。这对 我们来说非常重要，因为我们想从同一个堆中分配CSomeClass的所有实例。
变量s_hHeap用来保存堆句柄，所有CSomeClass对象都将从这个堆中分配。变量 s_uNumAllocsInHeap只不过是一个计数器，用来记录从堆中分配了多少个CSomeClass 对象。每次从堆中分配一个CSomeClass对象的时候，s_u Num Allocs In Heap会递增，每次 销毁一个 CSomeClass 对象的时候,s_uNumAllocsInHeap 会递减。当 s_uNumAllocsInHeap 到达0的时候，堆就没有用了，因此将被释放。我们可以在.cpp文件中编写如下代码来对 堆进行操控：
HANDLE CSomeClass::s_hHeap = NULL;
UINT CSomeClass：:s_uNumAlIocsInHeap = 0;
void* CSomeClass：：operator new (size_t size) (
if (s_hHeap == NULL) {
// Heap does not exist； create it.
s_hHeap = HeapCreate(HEAP_NO_SERIALIZE, 0, 0)；
if (s_hHeap == NULL)
return(NULL)；
}
// The heap exists for CSomeClass objects.
void* p = HeapAlloc(s_hHeap, 0, size)；
if (p != NULL) (
// Memory was allocated successfully; increment
// the count of CSomeClass objects in the heap.
s_uNumAllocsInHeap++；
}
// Return the address of the allocated CSomeClass object.
return(p)；
注意,代码一开始就定义了两个静态成员变量s__hHeap和s_uNumAllocsIiiHeap,并分别
:indows核心编程(第5版)
将它们初始化为NULL和Oo
C++的new操作符需要一个参数，叩sizeo这个参数表示需要多少个字节才能放得下一个 CSomeClass对象。我们重载new操作符的成员函数的第一项任务就是在还没有创建堆的 时候创建一个堆。这只不过是检查一下s_hHeap变量是否为NULL。如果为NULL,那么 代码会调用HeapCreate来创建一个新的堆，并把HeapCreate返回的句柄保存在s_hHeap 中。这样，下次调用new操作符的时候就不会再创建另一个堆了，而是使用刚才创建的堆。
/ 529*530 捞
前面的示例代码在调用HeapCreate函数时，使用了 HEAP_NO_SERIALIZE标志，因为 示例代码的剩余部分不支持多线程。传给HeapCreate函数的其他两个参数分别表示堆的 起始大小和最大大小，这里都传了 0。第一个0表示堆没有初始大小，第二个0表示堆可 以根据需要增大。我们可以根据需要改变其中任何一个参数的值。
读者可能会认为，把new操作符的size参数作为HeapCreate的第二个参数传入可以起到 帮助作用。这样就能使堆的起始大小至少可以容纳类的一个实例。然后当第一次调用 HeapAlloc的时候，程序可以运行得更快，因为堆不用再调整自己的大小来存放类的实例 了。但是问题在于，事情并不总是像我们想得那么简单。由于每次在堆中分配内存时都需 要占用一些额外的内存，因此HeapAlloc仍然需要调整堆的大小，这样才能容纳得下类的 一个实例以及额外需要的内存。
一旦创建了堆，就可以调用HeapAlloc来从堆中分配CSomeClass对象了。第1个参数是 堆的句柄，第2个参数是CSomeClass对象的大小。HeapAlloc会返回一个地址，指向刚分 配的那块内存。
分配操作成功完成之后，变量s_uNumAIlocsInHeap会递增以记录堆中又多分配了一块内 存。最后，new操作符会返回刚分配的CSomeClass对象的地址。
好了，创建一个新的CSomeClass对象就是这么简单。下面让我们来关注一下当应用程序 不再需要CSomeClass对象时如何销毁它。销毁CSomeClass对象是delete操作符的职责， 它的代码如下：
void CSomeClass：：operator delete (void* p) (
if (HeapFree(s_hHeap, 0, p)) (
// Object was deleted successfully.
s_uNumAllocsInHeap--;
)
if (s_uNumAllocsInHeap == 0) (
// If there are no more objects in the heap,
// destroy the heap.
if (HeapDestroy(s_hHeap)) (
// Set the heap handle to NULL so chat the new operator
// will know to create a new heap if a new CSomeClass
// object is created.
s_hHeap = NULL;
}
)
)
第18章堆
重载delete操作符的成员函数只有一个参数，即要释放的对象的地址。函数所做的第一件 事情就是调用HeapFree,传入堆句柄和要释放的对象的地址。如果对象被成功释放，则 s_uNumAllocsInHeap会递减，以表示堆中的CSomeClass对象又少了一个。接着函数会检 查s_uNumAllocsInHeapT是否为0。如果为0,函数将调用HeapDestroy并传入堆句柄。 如果堆被成功地销毁，代码将把s_hHeap设为NULL。这一步极其重要，因为程序在以后 仍然有可能会分配另一个CSomeClass对象。当这种情况发生的时候，new操作符会检查 s_hHeap并决定是应该使用已有的堆还是应该创建一个新的堆。
4 530*531 翰
这个例子展示了使用多个堆的方便机制。我们可以非常容易地将它用在其他的类中。但还 需要考虑继承的情况。如果以CSomeClass为基类派生一个新类，那么新类将继承 CSomeClass的new和delete操作符。这个新类同时还会继承CSomeClass的堆，这意味着 在调用派生类的new操作符时，会和CSomeClass—*样，从同一个堆中分配内存。取决于 实际情况，这可能是我们希望的，但也可能不是我们希望的。如果对象的大小相差非常大， 那么可能会在堆中造成严重的碎片。此外，正如在本章前面的1821节“对组件进行保护” 和1822节“更有效的内存管理”所述，这也可能会使追踪代码中的缺陷变得更加困难。
如果想在派生类中使用一个单独的堆，把CSomeClass类中的代码复制一份即可。说得再 具体一点，就是增加一组s_hHeap和s uNumAllocsInHeap变量，把new和delete操作符 的代码复制过去。在编译的时候，编译器会发现派生类也重载了 new和delete操作符，这 样它就会调用派生类的操作符，而不会调用基类的操作符。
不为每个类创建堆的唯一优势是不会有额外的性能和内存开销。但是，这些性能和内存开 销并不大，与潜在的回报相比，这很可能是值得的。一种折衷方案可能是让每个类使用自 己的堆，并让派生类与基类共享同一个堆，同时对应用程序进行充分测试以确保它能正式 发行。但即便如此，我们要意识到内存碎片可能还是个问题。
18.4其他堆函数
除了前面已经介绍过的堆函数之外，Windows还提供了其他一些堆函数。本节将简要介绍 一下这些堆函数。
ToolHelp函数(在第4章的结尾处介绍)允许我们枚举进程的堆以及堆中分配的内存块。更 详细的信息请参阅Platform SDK文档中的下列函数：Heap32First, Heap32Next, Heap32ListFirst 和 Heap32ListNext。
由于进程在自己的地址空间中可以有多个堆，所以GetProcessHeaps函数可以让我们得到 这些堆的句柄：
DWORD GetProcessHeaps(
DWORD dwNumHeaps,
•PHANDLE phHeaps)；
・5
Vindows核心编程(第5版)
为了调用GetProcessHeaps,我们必须先分配一个HANDLE数组，如卜'面的代码所示：
HANDLE hHeaps[25];
DWORD dwHeaps = GetProcessHeaps(25, hHeaps);
if (dwHeaps >25) {
// More heaps are in this process than we expected.
} else (
// hHeaps[0J through hHeap[dwHeaps - 1]
// identify the existing heaps.
)
注意，函数所返回的句柄数组中也包括进程的默认堆的句柄。HeapValidate用来验证堆的 完整性：
BOOL HeapValidate(
HANDLE hHeap,
DWORD fdwFlags,
LPCVOID pvMem);
通常在调用这个函数的时候，我们会传入一个堆句柄和一个标志0(除此之外唯-一个有效 的标志是HEAP_NO_SERIALIZE),并传NULL给pvMem。该函数会遍历堆中的各个内 存块，确保没有任何一块内存被破坏。为了让函数执行得更快，最好给pvMem参数传一 个指定内存块的地址。这样函数就只检查这一块内存的完整性。
为了让堆中闲置的内存块能重新接合在一起，并撤销调拨给堆中闲置内存块的存储器，可 以调用下面的函数：
UINT HeapCompact(
HANDLE hHeap,
DWORD fdwFlags)；
一般来说，我们会传。给fdwFlags参数，但也可以传HEAP_NO_SERIALIZE标志。
下而两个函数HeapLock和HeapUnlock要配对使用：
BOOL HeapLock(HANDLE hHeap)；
BOOL HeapUnlock(HANDLE hHeap);
这两个函数用于线程同步。当第一个线程调用HeapLock的时候，它就成为指定堆的所有 者。如果任何其他线程调用堆函数(并指定同一个堆句柄)，那么系统会暂停其他线程，只 有当第一-个线程调用了 HeapUnlock之后才会唤醒被暂停的线程。
为了确保对堆的访问是依次进行的，诸如HeapAlloc, HeapSize, HeapFree之类的函数会 在内部调用HeapLock和HeapUnlock。一般来说我们不需要自己去调用HeapLock和 HeapUnlocko
最后一个堆函数是HeapWalk,如下所示：
BOOL Heapwalk(
HANDLE hHeap, PPROCESS_HEAP_ENTRY pHeapEntry)；
这个函数只用于调试。它允许我们遍历堆的内容，在遍历的时候，需要多次调用该函数。 在每次调用的时候，必须分配并初始化一个PROCESS_HEAP_ENTRY结构，然后将该结
第18章堆
构的地址传给HeapWalk：
Cypedef struct _PROCESS_HEAP_ENTRY (
PVOID IpData;
DWORD cbData；
BYTE cbOverhead；
BYTE iRegionlndex；
WORD wFlags；
union {
struct (
HANDLE hMem;
DWORD dwReserved[ 3 ]；
} Block；
struct (
DWORD dwCommi c tedSize;
DWORD dwUnCommittedSize；
LPVOID IpFirstBlock;
LPVOID IpLastBlock;
} Region；	-
);
} PROCESS_HEAP_ENTRY, *LPPROCESS_HEAP_ENTRY, * PPROCESS_HEAP_ENTRY;
开始枚举堆中的内存块时，必须把IpData成员设为NULL。这向HeapWalk表明要初始化 结构中的成员。在每次成功调用HeapWalk之后，我们可以查看结构的成员。要得到堆中 的下一块内存，必须再次调用HeapWalk,并传入和上一次调用时相同的堆句柄和 PROCESS_HEAP_ENTRY结构的地址。当HeapWalk返回FALSE的时候，表示堆中己 经没有更多的内存块了。有关PROCESS_HEAP_ENTRV结构中各成员的详细介绍，请参 阅 Platform SDK 文档。
我们可以在HeapWalk循环的外部调用HeapLock和HeapUnlock函数，这样一来，在遍 历一个堆的时候，其他线程便无法从同一个堆中分配或释放内存了。
应533映
章章章章
9 0 12
12 2 2
85fXus 85f
DLL基础
DLL高级技术
线程局部存储区
DLL注入和API拦截
第19章DLL基础
本章内容二魏斯：瀛！*拦*?w矿松任•藤备撅..蕊如' m;;*基履套
19.1	DLL和进程的地址空间 "**	』寻.
19.2纵观全局
自从Microsoft Windows第一个版本的诞生之日起，动态链接库（dynamic-link librai云i元。 一直以来都是该操作系统的基石。Windows应用程序编程接口（application programming interface, API）提供的所有函数都包含在DLL中。其中三个最重要的DLL分别是： KemeI32.dll,包含的函数用来管理内存、进程以及线程：User32.dll,包含的函数用来执行 与用户界面相关的任务，如创建窗口和发送消息；GDI32.dll,包含的函数用来绘制图像和 显示文字。
Windows还提供了其他一些DLL,用来执行更加专门的任务。例如，AdvAPI32.dll包含的 函数与对象的安全性、注册表的操控以及事件口志有关。ComDlg32.dll包含了一些常用的 对话框（如打开文件和保存文件），ComCtl32.dll支持所有常用的窗口控件。
本章将介绍如何在自己的应用程序中创建DLL。下面是为什么要使用DLL的一些理由。
•	它们扩展了应用程序的特性由于DLL可以被动态地载入到进程的地址空间中，应 用程序可以在运行的时候检测应该执行何种操作，并在需要的时候载入DLL来执 行这些操作。例如，如果一家公司开发了一个产品并且想让其他公司对该产品进行 扩展，那么DLL就非常有用。
•	它们简化了项目管理 如果在开发过程中让不同的开发团队来开发不同的模块，那 么项目将更加易于管理。但是，应用程序应该发布尽可能少的文件。就笔者所知， 有一家公司发布的一个产品中包含了上百个DLL——平均每个程序员要负责5个 DLL之多。由于在程序能够真正开始运行之前，系统必须打开一百多个磁盘文件， 因此该应用程序的初始化时间慢得让人难以忍受。
•	它们有助于节省内存如果两个或两个以上的应用程序使用同一•个DLL,那么该 DLL只需载入内存一次，之后所有的应用程序就可以共享该DLL在内存中的页面。 C/C++运行库就是一个绝佳的例子。许多应用程序都会用到C/C++运行库，如果所 有的应用程序都链接到C/C++运行库的静态版本，那么诸如_tc$cpy, malloc之类的 函数会在内存中出现多次。但是，如果这些应用程序链接到C/C++运行库的DLL 版本，那么这些函数在内存中只会出现一次，这意味着内存的使用率更高。
•	它们促进了资源的共享DLL能够包含诸如对话框模板、字符串、图标以及位图之
Vindows核心编程(第5版)
类的资源。多个应用程序可以使用DLL来共享这些资源。
•	它们促进了本地化DLL常常用来对应用程序进行本地化。例如，一个应用程序可 以只包含代码但不包含用户界面组件，DLL用来存放本地化的用户界面组件，供应 用程序载入并使用。
•	它们有助于解决平台间的差异不同版本的Windows提供了不同的函数。如果可能 的话，开发人员常常想要调用新的函数。但是，如果源代码中包含对新函数的调用， 那么当我们想在不提供该函数的老版本Windows中运行应用程序时，操作系统的 加载程序将拒绝运行该应用程序。即使这个函数从来没有被调用到，情况也是这样。 但是，如果我们将这个新函数放到一个DLL中，那么应用程序就能够在老版本的 Windows中载入并运行。当然啦，我们仍然不可能成功地调用该函数。
•	它们可以用于特殊目的 Windows提供的某些特性只有DLL才能使用。例如，我们
可以(通过使用SetWindowsHookEx和SetWinEventHook来)安装某些挂钩函数， 但前提条件是必须将挂钩通知函数存放在DLL中。我们可以创建一个COM对象来 对Windows的资源管理器的外壳进行扩展，但该COM对象必须被存放在DLL中。 为了创建富网页(rich Web pages),我们需要开发一些能够为网页浏览器载入的 ActiveX控件，这些ActiveX控件仍然必须被存放在DLL中。	一
.537~538
19.1	DLL和进程的地址空间
创建DLL通常比创建应用程序容易，因为DLL通常由一组可供任何应用程序使用的独立 函数组成。在DLL中，通常没有用来处理消息循环或创建窗口的代码。DLL只不过是一组 源代码模块，每个模块包含一些可供应用程序(可执行文件)或其他DLL调用的函数。在所 有的源文件编译完成之后，链接器会像链接应用程序的可执行文件那样，对它们进行链接, 但在创建DLL的时候，我们必须给链接器指定/DLL开关。这个开关会使链接器在生成的 DLL文件映像中保存一些与可执行文件略微不同的信息，这样操作系统的加载程序就能够 将该文件映像识别为DLL,而不会将它识别为应用程序。
在应用程序(或其他DLL)能够调用一个DLL中的函数之前，必须将该DLL的文件映像映 射到调用进程的地址空间中。我们可以通过两种方法来达到这一目的：隐式载入时链接 (implicit load-time linking)或显式运行时链接(explicit run-time linking)o 本章稍后会介绍隐式 链接(implicit linking),显式链接(explicit linking)会在第 20 章介绍。
一旦系统将一个DLL的文件映像映射到调用进程的地址空间中之后，进程中的所有线程就 口J■以调用该DLL中的函数了。事实上，该DLL几乎完全丧失了它的DLL身份：对进程中 的线程来说，该DLL中的代码和数据就像是一些附加的代码和数据，碰巧被放在进程地址 空间中。当线程调用DLL中的一个函数的时候，该函数会在线程栈中取得传给它的参数， 并使用线程栈来存放它需要的局部变量。此外，该DLL中的函数创建的任何对象都为调用 线程或调用进程所拥有——DLL绝对不会拥有任何对象。
举个例子，如果DLL中的一个函数调用了 VirtualAlloc,系统就会从调用进程的地址空间
第19章DLL基础
中预订地址空间区域。如果稍后从进程的地址空间中撤销对DLL的映射，那么这块地址空 间区域仍将保持被预订状态，因为虽然该区域事实上是由DLL中的函数所预订的，但系统 并不会对此进行记录。被预订的区域为进程所拥有，只有当线程调用了 VirtualFree函数或 者当进程终止的时候，该区域才会被释放。
正如我们所知道的那样，如果运行同一个可执行文件的多个实例，这些实例将不会共享可 执行文件中的全局变量和静态变量o Windows通过使用第13章介绍的写时复制机制来保证 这一点。DLL中的全局变量和局部变量也是通过完全相同的方法来处理的。当一个进程将 一个DLL映像文件映射到自己的地址空间中时，系统也会为全局变量和静态变量创建新的 实例。
538
说明 我们必须理解一个地址空间是由一个可执行模块和多个DLL模块构成的，这一点非 常重要。这些模块中，有些可能会链接到C/C++运行库的静态版本，有些可能会链 接到C/C++运行库的DLL版本,还有一些可能根本就不需要C/C++运行库(如果模 块不是用C/C++编写的)。许多开发人员常犯的一个错误就是忘记一个地址空间中可 能会存在多个C/C++运行库。让我们来分析下面的代码：
VOID EXEFunc() {
PVOID pv = DLLFunc();
// Access the storage pointed to by pv...
// Assumes that pv is in EXE*s C/C++ run-time heap
free(pv)；
}
PVOID DLLFunc() (
// Allocate block from DLL's C/C++ run-time heap return(malloc(100))；
}
怎样？前面的代码能正常工作吗？ DLL中的函数分配的内存块是否能为EXE中的 函数所释放呢？答案是：也许。前面显示的代码没有给我们以足够的信息。如果EXE 和DLL都链接到C/C++运行库的DLL版本，那么代码将能够正常工作。但是，如 果其中之一或两个模块都链接到C/C++运行库的静态版本，free调用就会失败。开 发人员编写出与此类似的代码并深受其害，这样的事情我已经屡见不鲜。
这个问题有一个简单的解决办法，即：当一个模块提供一个内存分配函数的时候， 它必须同时提供另一个用来释放内存的函数。下面重写刚才那段代码：
VOID EXEFunc() (
PVOID pv = DLLFunc();
// Access the storage pointed to by pv...
// Makes no assumptions about C/C++ run-time heap DLLFreeFunc(pv);
}
PVOID DLLFunc() (
// Allocate block from DLL's C/C++ run-time heap
PVOID pv = malloc(100);
return(pv)；
}
BOOL DLLFreeFunc(PVOID pv) (
indows核心编程（第5版）
// Free block from DLL's C/C++ run-time heap return（free（pv））；
}
这段代码是正确的，并且始终都能够正常工作。在编写一个模块的时候，不要忘记 其他模块中的函数甚至可能不是用C/C++编写的，因此可能不会用malloc和free来 进行内存分配。请务必小心，不要在代码中做这样的假设。顺便提一句，同样的道 理也适用于Ch■的new和delete操作符，因为它们会在内部调用malloc和free。
• 539 »
19.2纵观全局
为了完全理解DLL的工作方式，了解我们和系统是如何使用DLL的，让我们先纵览一下 全局。图19-1概括了各组件是如何结合到一起的。
构建DLL
】）头文件,其中包含待导出面数的原型、 结构和符号的声明
2）	C/C++源文件，其中包含待导出函数的 实现和变鼠
3）	编译嚣为每个C/Ci源文件生成obj文件
4）	链接器将每个obj模块合并，从而生成 DLL
5）	如果至少导出了一个函数/变最，那么链 接器会同时生成lib文件
构建EXE
6）	头文件,其中包含待导出函数的原型、 结构和符号的声明
7）	C/Ci源文件，其中包含待导出函数 的实现和变最
8）	编译器为每个C/C++源文件生成obj文
9）	说接器将每个.obj模块合并，并使用.lib 文件来解析对导入的函数/变屈的引用， 从而生戚exe（它包含一个导入表，其中 列出了必需的DLL和导入的符号）
1山
6 Al
2巧2巧2刃
7d 7 凹 7d
巧译七编译器/编译器
3
4 V
隔链接器/
卷堆器,
3 1
1 8 侦 8 二
运行应用程序
10）	加载程序为.cxc创建地址空间
11）	加我程序将必需的DLL载入到地 址空间中
—进程的主线程开始执行，应用 程序开始运行
图19・1 DLL创建过程及应用程序隐式链接到DLL的过程
540
第19章DLL基础
就目前而言，我们将集中讨论可执行文件和DLL模块是如何隐式地链接到一起的。隐式链 接是迄今为止最常见的链接类型。此外，Windows还支持显式链接(会在第20章进行介绍)。
在图19-1中我们可以看到，当一个模块(比如一个可执行文件)用到了一个DLL中的函数或 变量的时候，会牵涉到许多文件和组件。为了便于讨论，我们将从一个DLL中导入函数和 变量的模块称为“可执行模块”，将导出函数和变量以供可执行文件使用的模块称为“DLL 模块”。但请注意，DLL模块也可以(而且经常会)导入一些包含在其他DLL模块中的函数 和变量。
如果一个可执行模块需要从另一个DLL模块中导入函数和变量，我们必须先构建该DLL 模块，然后再构建该可执行模块。
构建DLL需要以下步骤。
(1)	必须先创建一个头文件，在其中包含我们想要在DLL中导出的函数原型、结构以及符 号。为了构建该DLL, DLL的所有源文件需要包含这个头文件。正如我们稍后可以看 到，在构建可执行文件的时候需要用到同一个头文件。
(2)	创建C/C++源文件来实现想要在DLL模块中导出的函数和变量。由于在构建可执行模 块的时候不需要这些源文件，因此创建该DLL的公司可以将这些源代码作为公司的 机密。
(3)	在构建该DLL模块的时候，编译器会对每个源文件进行处理并产生一个.obj模块(每个 源文件对应一个.obj模块)。
(4)	当所有.obj模块都创建完毕后，链接器会将所有.obj模块的内容合并起来，产生一个单 独的DLL映像文件。这个映像文件(或模块)包含DLL中所有的二进制代码以及全局/ 静态变量。为了执行可执行模块，这个文件是必需的。
(5)	如果链接器检测到DLL的源文件输出了至少一个函数或变量，那么链接器还会生成一 个.lib文件。这个.lib文件非常小，这是因为它并不包含任何函数或变量。它只是列出 了所有被导出的函数和变量的符号名。为了构建可执行模块，这个文件是必需的。
一旦构建了 DLL模块，我们就可以通过下列步骤来构建可执行模块。
(1)	在所有引用了导出的函数、变量、数据结构或符号的源文件中，必须包含由DLL的开 发人员所创建的头文件。
(2)	创建C/C++源文件来实现想要包含在可执行模块中的函数和变量。当然，代码可以引 用在DLL的头文件中定义的函数和变量。
(3)	在构建可执行模块的时候，编译器会对每个源文件进行处理并产生一个.obj模块(每个 源文件对应一个.obj模块)。
(4)	当所有.obj模块都创建完毕后，链接器会将所有.obj模块的内容合并起来，产生一个单 独的可执行映像文件。这个映像文件(或模块)包含了可执行文件中所有的二进制代码 以及全局/静态变量。该可执行模块还包含一个导入段(import section),其中列出了所 有它需要的DLL模块的名称。(有关段的更多信息，请参阅第17章。)此外，对列出的 每个DLL,该段还记录了可执行文件的二进制代码从中引用的函数和变量的符号名。
■^^dows核心编程（第5版）
操作系统的加载程序会解析这个导入段，我们一会就会看到。
一旦DLL和可执行模块都己构建完毕，进程就可以执行了。当我们试图运行可执行模 块的时候，操作系统的加载程序会执行下面的步骤。
（5）加载程序先为新的进程创建一个虚拟地址空间，并将可执行模块映射到新进程的地址 空间中。加载程序接着解析可执行模块的导入段。对导入段中列出的每个DLL,加载 程序会在用户的系统中对该DLL模块进行定位，并将该DLL映射到进程的地址空间 中。注意，由于DLL模块可以从其他DLL模块中导入函数和变量，因此DLL模块可 能有自己的导入段并需要将它所需的DLL模块映射到进程的地址空间中。我们叮以看 到，初始化一个进程可能会耗费很长的时间。
一旦加载程序将可执行模块和所有DLL模块映射到进程的地址空间之后，进程的主线程可 以开始执行，这样应用程序就能够运行了。接下来的几节我们将进一步分析这个过程。
礴 541-542
19.2.1	构建DLL模块
在创建一个DLL的时候，我们事实上是在创建一组可供一个可执行模块（或其他DLL）调用 的函数。一个DLL可以导出变量、函数或C++类来供其他模块使用。在实际开发中，我们 应该避免从DLL中导出变量，因为这等于是去掉了代码中的一个抽象层，从而使得DLL 的代码更加难以维护。此外，只有当导出C++类的模块使用的编译器与导入C++类的模块 使用的编译器由同一家厂商提供时，我们才可以导出C++类。因此，除非知道可执行模块 的开发人员与DLL模块的开发人员使用的是相同的工具包，否则我们应该避免从DLL中 导出C++类。
在创建DLL的时候，我们应该首先创建一个头文件来包含想要导出的变量（类型和名称）和 函数（原型和名称）。这个头文件还必须定义导出的函数或变量所用到的任何符号和数据结 构。DLL的所有源文件都应该包含这个头文件。另外，我们必须分发这个头文件，这样任 何可能需要导入这些函数或变量的源文件就可以包含该头文件。让DLL的构建者和可执行 模块的构建者使用同一个头文件可以使维护变得更加容易。
542
下面的代码展示了我们应该如何编写这个头文件，以便让可执行模块和DLL的源文件都能 够包含它：
/***********************************★*******★************★***********★******
Module: MyLib.h
***************************************************************************/
#ifdef MYLIBAPI
// MYLIBAPI should be defined in all of the DLL's source
// code modules before this header file is included.
// All functions/variables are being exported.
第19章DLL基础
#else
// This header file is included by an EXE source code module.
// Indicate that all functions/variables are being imported.
#define MYLIBAPI extern "C" _declspec(dllimport)
#endif
////////////////////////////////////////////////////////////////////////////
// Define any data structures and symbols here.
////////////////////////////////////////////////////////////////////////////
// Define exported variables here. (NOTE： Avoid exporting variables.)
MYLIBAPI int g_nResult;
////////////////////////////////////////////////////////////////////////////
// Define exported function prototypes here.
MYLIBAPI int Add(int nLeft, int nRight);
////////////////////////////// End of File /////////////////////////////////
543
在DLL的每个源文件中七必须包含该头文件，如下面的代码所示：

Module： MyLibFilel.cpp

// Include the standard #include <windows.h>
Windows and C-Runtime header files here.
// This DLL source code file exports functions and variables.
#define MYLIBAPI extern "C" _declspec(dllexport)
// Include the exported data structures, symbols, functions, and variables. #include "MyLib.h"
////////////////////////////////////////////////////////////////////////////
// Place the code for this DLL source code file here.
int g_nResult；
int Add(int nLeft, int nRight) ( g_nResult = nLeft + nRight; return(g_nResult)；
}
////////////////////////////// End of File /////////////////////////////////
在编译前面的DLL源文件的时候，MYLIBAPI在包含MyLib.h头文件之前被定义为 _declspec(dllexport)o如果编译器看到一个变量、函数或C++类是用_declspec(dllexport)
①祥注：应该是每个需要引用到导出符号的源文件。
■^^kdows核心编程(第5版)
修饰的，那么它就知道应该在生成的DLL模块中导出该变量、函数或C++类。注意，对那 些要被导出的变量和函数，我们必须在头文件中的变量和函数定义的前面加上MYLIBAPI 标识符。
另外要注意的是，在源文件中(MyLibFilel.cpp),不必在要被导出的变量和函数前面加 MYLIBAPI标识符。这里不需要MYLIBAPI标识符的原因是编译器在解析头文件的时候 会记住应该导出哪些变量或函数。
读者还会注意到MYLIBAPI符号包含了 extern	修饰符。只有在编写C++代码的时候,
才应该使用这个修饰符，在编写C代码的时候不应该使用该修饰符。C++编译器通常会对 函数名和变量名进行改编(mangle),这在链接的时候会导致严重的问题。举个例子，假设一 个DLL是用C++编写的，而可执行文件是用C编写的。在构建DLL的时候，编译器会对 函数名进行改编，但在构建可执行文件的时候，编译器不会对函数名进行改编。当链接器 试图链接可执行文件的时候，会发现口J执行文件引用了一个不存在的符号并报错。extern 用来告诉编译器不要对变量名或函数名进行改编，这样用C、C++或任何编程语言编写 的可执行模块都可以访问该变量或函数。
现在我们已经看到了 DLL的源文件应该如何使用这个头文件，那么可执行文件的源文件又 如何呢？可执行文件不应该在包含这个头文件之前定义MYLIBAPIo由于MYLIBAPI未 定义，因此头文件会将MYLIBAPI定义为_declspec(dHimport),这样编译器就知道该可 执行文件的源文件要从DLL模块中导入一些变量和函数。
如果查看Microsoft提供的标准Windows头文件，比如WinBase.h,那么我们会发现Microsoft 所采用的技术与刚才介绍的技术基本相同。
1.何为导出
.
前一节介绍的最有意思的内容，莫过于_declspec(dllexport)修饰符了。当Microsoft的 C/C++编译器看到用这个修饰符修饰的变量、函数原型或C++类的时候，会在生成的.obj 文件中嵌入一些额外的信息。当链接器在链接DLL所有的.obj文件时，会解析这些信息。
在链接DLL的时候，链接器会检测到这些与导出的变量、函数或类有关的嵌入信息，并生 成一个.lib文件。这个.lib文件列出了该DLL导出的符号。在链接任何可执行模块的时候， 只要可执行模块引用了该DLL导出的符号，那么这个.lib文件当然是必需的。除了创建这 个.lib文件之外，链接器还会在生成的DLL文件中嵌入一个导出符号表。这个(按字母顺序 排列的)导出段(export section)列出了导出的变量、函数和类的符号名。链接器还会保存相对 虚拟地址(relative virtual address, RVA),表示每个符号口J以在DLL模块中的何处找到。
我们可以使用Microsoft Visual Studio提供的DumpBin.exe I具(加上.exports开关)来查看 一个DLL的导出段。下面是Kemel32.dll的导出段中的一小部分。(为了避免占用书中太多 的篇幅，我删除了 DUMPBIN的输出中的无关部分。)
V第19章©DLL基础
C:\Windows\System32>DUMPBIN -exports
Microsoft (R) COFF/PE Dumper Version Copyright (C) Microsoft Corporation.
Kernel32.DLL
8.00.50727.42
All rights reserved.
Dump of file Kernel32.DLL
File Type： DLL
Section contains the following exports for KERNEL32.dll
00000000 characteristics
4549AD66 time date stamp Thu Nov 02 09:33:42 2006
0.00 version
1 ordinal base
1207 number of functions
1207 number of names
ordinal
hint
RVA
name
5678910
2
3
4
5
6
7
12
13
AcquireSRWLockExclusive (forwarded to NTDLL.RtlAcquireSRWLockExclusive) AcquireSRWLockShared (forwarded to NTDLL.RtlAcquireSRWLockShared) 0002734D ActivateActCtx = _ActivateActCtx@8 000088E9 AddAtomA = _AddAtomA@4 0001FD7D AddAtomW = _AddAtomW@4 0Q0A30AF AddConsoleAliasA = _AddConsoleAliasA@12 000A306E AddConsoleAliasW = _AddConsoleAliasW@12 00087935 AddLocalAlternateComputerNameA = _AddLocalAlternateComputerNameA@8 0008784E AddLocalAlternateComputerNameW = _AddLocalAlternateComputerNameW@8 00026159 AddRefActCtx = _AddRefActCtx@4 00094456 AddSIDToBoundaryDescriptor = _AddSIDToBoundaryDescriptor®8
1205
1206
1207
0004328A
0004328A
4B4
4B5
4B6 00049D35
Istrlen = _lstrlenA@4
IstrlenA = _lstrlenA@4
IstrlenW = _lstrlenW@4
3
0
4
1
8
9 A
Summary
3000
A000
1000
C9000
.data .reloc .rsrc .text
545-546 鳞
我们nJ以看到，符号是按字母顺序排列的，RVA这一列中的数值表示一个偏移量，导出的 符号位于DLL文件映像中的这个位置。ordinal这一列是为了与16位Windows源代码保持 向后兼容而保留的，现在的应用程序不应该再使用。hint这一列是系统用来提高性能的， 对我们这里的讨论来说无关紧要。
说明 许多开发人员，尤其是那些有16位Windows开发背景的人，习惯通过指定序号的 方式来导出DLL函数。但是，Microsoft并未公开系统DLL的序号。当我们把任何 Windows函数链接到可执行文件或DLL的时候，Microsoft希望我们用符号名来链 接。如果用序号来链接，我们将面临应用程序无法在新版本的Windows中运行的 风险。
「indows核心编程(第5版)
我曾就Microsoft为什么不再使用序号一事询问Microsoft,并得到了下面的回答： "我们认为可移植可执行文件格式(Portable Executable file format)不仅提供了序号 的优点(查找迅速)，而且提供了名称导入的灵活性。我们可以在任何时候添加新的 函数。在有多个实现的大型项目中，序号非常难以管理。”
我们可以在自己创建的DLL中使用序号，并让可执行文件通过序号链接到这些 DLL。Microsoft保证即便在今后版本的操作系统中，这种方法将仍然能够正常工作。 但就笔者而言，我将从现在开始就避免在自己的工作中使用序号，并始终通过名称 来链接。
2.为非Visual C++工具包创建DLL
如果在创建DLL和可执行文件的时候使用的都是Microsoft Visual C++,那么读者可以略过 这一节而且不必担心会漏掉重要内容。但是，如果用Visual C++创建的DLL要与用其他厂 商的工具包构建的可执行文件链接，就必须做一些额外的工作。
如前所述，在混合使用C和C++编程的时候，要使用extern”。，修饰符。我们还提到过， 由于C++类的名称改编问题，我们必须使用同一家编译器厂商提供的工具包。即使完全用 C来编程，但使用了不同厂商提供的工具包，还是会遇到另外一个问题。这个问题就是， 即使根本没有用到C++, Microsoft的C编译器也会对C函数的名称进行改编。只有当我们 的函数使用了_stdcall (WINAPI)调用约定的时候，才会发生这种情况。但不巧的是，这个 调用约定是最常用的类型。当使用_stdcall来导出C函数的时候，Microsoft的编译器会对 函数名进行改编，具体的方法是给函数名添加下划线前缀和一个特殊的后缀，该后缀由一 个@符号后跟作为参数传给函数的字节数组成。例如，下面的函数在DLL的导出段中被导 出为—MyFunc@8。
_declspec(dllexport) LONG _stdcall MyFunc(int a, int b)；
如果用另一家厂商提供的工具包来构建可执行文件，链接器将试图链接到一个名为 MyFunc的函数，由于该函数在Microsoft编译器生成的DLL中并不存在，因此链接会 失败。
为了用Microsoft的工具包来构建一个能与其他编译器厂商的工具包链接的DLL,我们必须 告诉Microsoft编译器不要对导出的函数名进行改编。我们可以通过两种方法来达到这一目 的。第一种方法是为我们的项目创建一个.def文件，并在.def文件中包含一下类似下面的 EXPORTS 段：
EXPORTS
MyFunc
当Microsoft链接器解析这个.def文件的时候，会发^_MyFunc@8和MyFunc都被导出。 由于这两个函数名是匹配的(不考虑改编)，因此链接器会用.def文件中定义的名称，也就是 MyFunc来导出函数，而根本不会用_MyFunc@8来导出函数。
现在读者可能会想，在用Microsoft的工具包来构建可执行文件并链接到一个DLL的时候,
第19章DLL基础
如果该DLL包含的符号名未经改编，那么由于链接器会试图链接到名为_MyFunc@8的函 数，因此链接将会失败。值得庆幸的是，在这种情况下，Microsoft的链接器能够做出正确 的选择并将可执行文件链接到名为MyFunc的函数。
如果不想使用.def文件，那么我们还可以用第二种方法来导出未经改编的函数名。我们可 以在DLL的源文件中添加一行类似下面的代码：
#pragma comment(linker, "/export：MyFunc=_MyFunc@8")
这行代码会使得编译器产生一个链接器指示符，该指示符告诉链接器要导出一个名为 MyFunc的函数，该函数的入口点与_MyFunc@8相同。与第一种方法相比，第二种方法 相对来说不太方便，因为在写这行代码的时候，我们必须自己对函数名进行改编。另外， 在使用这种方法的时候，DLL实际上导出了两个符号，即MyFunc和_MyFunc@8,它们 都对应于同一个函数，而第一种方法则只导出了 MyFunc符号。第二种方法并没有特别之 处，它只不过能让我们避免使用.def文件而己。
岂547魅
19.2.2构建可执行模块
下面这段代码显示了一个可执行模块的源文件，它导入了一个DLL导出的符号，并在代码 中引用了这些符号：
/****************************************************************** *********
Module： MyExeFilel.cpp
// Include the standard Windows and C-Runtime header files here.
#include <windows.h>
#include <strsafe.h>
#include <stdlib.h>
// Include the exported data structures, symbols, functions, and variables.
#include •MyLibM^Lib.h"
////////////////////////////////////////////////////////////////////////////
int WINAPI .tWinMainfHINSTANCE, HINSTANCE, LPTSTR, int) (
int nLeft = 10, nRight = 25;
TCHAR sz[100];
StringCchPrintf(sz, _countof(sz), TEXT(■%d + %d = %d"),
nLeft, nRight, Add(nLeft, nRight));
MessageBox(NULL, sz, TEXT("Calculation"), MB_OK)；
StringCchPrintf(sz, _countof(sz),
TEXT("The result from the last Add is： %dH), g_nResult)；
MessageBox(NULL, sz, TEXT("Last Result"), MB_OK); return(0);
)
////////////////////////////// End of File /////////////////////////////////
Endows核心编程(第5版)
在编写可执行模块的源文件的时候，我们必须包含DLL的头文件。如果不这样做，导入的 符号将得不到定义，编译器会产生大量的警告和错误。
可执行模块的源文件不应该在包含DLL的头文件之前定义MVLIBAPL在编译前面这个 可执行模块的源文件时，MYLIBAPI在MyLib.h中被定义为_declspec(dllimport)0如果 编译器看到一个变量、函数或C++类是用_declspec(dllimport)来修饰的，那么它会知道应 该从某个DLL模块中导入该符号。编译器不知道，也不需要知道具体的DLL模块是哪一 个。编译器只想确认我们以正确的方式来访问这些导入的符号。现在我们就可以在源代码 中使用导入的符号了，一切都将如我们预计地那样正常工作。
接下来，为了创建可执行模块，链接器必须将所有的.obj模块合并到一起。由于链接器必 须确定代码中引用的导入符号来自哪个DLL,因此我们必须将DLL的.lib文件传给链接器。 正如我们前面已经提到ii, .lib文件只不过是列出了 DLL模块导出的符号。链接器只想知 道被引用的符号确实存在，以及该符号来自哪个DLL模块。如果链接器能够解决(resolve) 对所有外部符号的引用，那么它将生成可执行模块。
何为导入
前一小节提到了 _declspec(dllimport)修饰符。在导入符号的时候，不必使用 _declspec(dllimport)关键字，而可以直接使用标准C语言的extern关键字。但是，如果 编译器能够提前知道我们引用的符号是从一个DLL的.lib文件中导入的，那么它将能够产 生略微高效的代码。有鉴于此，我建议读者在导入函数和数据符号的时候使用 _dedspec(dllimport)关键字。如果调用的是标准的Windows函数，那么Microsoft已经替 我们准备好了。
当链接器在解决导入符号的时候，会在生成的可执行模块中嵌入一个特殊的段，它的名字 叫导入段(import section)。导入段列出了该模块所需的DLL模块，以及它从每个DLL模块 中引用的符号。
我们可以使用Visual Studio的DumpBin.exe工具(加上-imports开关)来查看一个模块的导入 段。下面是Calc.exe的导入段中的一小部分。(为了避免占用书中太多的篇幅，我再次删除 了 DUMPBIN的输出中的无关部分。)
C:\Windows\System32>DUMPBIN -imports Calc.exe
Microsoft (R) COFF/PE Dumper Version 8.00.50727.42
Copyright (C) Microsoft Corporation. All rights reserved.
Dump of file calc.exe
File Type： EXECUTABLE IMAGE
Section contains the following imports:
SHELL32.dll
10010CC Import Address Table
1013208 Import Name Table
FFFFFFFF time date stamp
第19章DLL基础
FFFFFFFF Index of first forwarder
766EA0A5 110 ShellAboutW
ntdll.dll
77E01890 77E47B0D 77E2AA46 77E0918D
reference
reference
Summary
2000
2000 16000 13000
.data .reloc .rare .text
ADVAPI32.dll
1001000 Import Address Table 101313C Import Name Table FFFFFFFF time date stamp FFFFFFFF Index of first forwarder
77CA8229	236
77CC802D	278
77CD632E	268
77CD64CC	22A
RegCreateKeyW RegSetValueExW RegQueryValueExW RegCloseKey
1001250 Import Address Table
101338C Import Name Table FFFFFFFF time date stamp FFFFFFFF Index of first forwarder
77F0850D	548 WinSqmAddToStreain
KERNEL32.dll
1001030 Import Address Table 101316C Import Name Table FFFFFFFF time date stamp FFFFFFFF Index of first forwarder
24F GetSystemTimeAsFileTime 1AA GetCurrentProcessid 170 GetCoinmandLineW 230 GetProfilelntW
Header contains
Bound
Bound
Bound
Bound
Bound
Bound
Bound
Bound
Bound
the following bound import information:
to SHELL32.dll [4549BDB4] Thu Nov 02 10:43:16 2006 to ADVAPI32.dll [4549BCD2] Thu Nov to OLEAUT32.dll [4549BD95] Thu Nov to ole32.dll [4549BD92] Thu Nov 02 to ntdll.dll [4549BDC9] Thu Nov 02 to KERNEL32.dll [4549BD80] Thu Nov to GDI32.dll (4549BCD3) Thu Nov 02
[4549BDE0] Thu Nov 02 10:44:00 2006 [4549BD61] Thu Nov 02 10:41:53 2006
02 10:39:30 2006 02 10:42:45 2006 10:42:42 2006 10:43:37 2006
02 10:42:24 2006
10:39:31 2006
to USER32.dll to msvcrt.dll
我们可以看到，Calc.exe所需的每个DLL在该段中都有一项与之对应：Shell32.dll, AdvAPI32.dll, OleAut32.dll, OIe32.dll, Ntdll.dll, Kemel32.dll, GDI32.dll, User32.dll 以及 MSVCRT.dllo在每个DLL模块名的下面，列出了 Calc.exe从该模块中导入的符号。例如, Calc 调用了 包含在 Kemel32.dll 中的下列函数：GetSystemTimeAsFileTime , GetCurrentProcessid, GetCommandLineW, GetProfilelntW,等等。
符号名左边的数值表示符号的hint值，它与我们的讨论没有什么关系。每一行符号最左边
「indows核心编程（第5版）
的数值是一个内存地址，表示该符号在进程的地址空间中位于何处。只有当可执行模块己 经被绑定的时候，才会显示这个内存地址。在DumpBin的输出中靠近最后的地方，我们可 以看到与绑定有关的一些额外信息。（绑定将在第20章讨论。）
19.2.3运行可执行模块
启动一个可执行模块的时候，操作系统的加载程序会先为进程创建虚拟地址空间，接着把 可执行模块映射到进程的地址空间中。之后加载程序会检查可执行模块的导入段，试图对 所需的DLL进行定位并将它们映射到进程的地址空间中。
由于导入段只包含DLL的名称，不包含DLL的路径，因此加载程序必须在用户的磁盘上 搜索DLLo下面是加载程序的搜索顺序。
\7 \J/
1 2 3 4 5 6 z(\ z(\ z(\ /(V z(\ Z4\
包含可执行文件的目录。
Windows的系统目录，该目录可以通过GetSystemDirectory得至U。 16位的系统目录，即Windows目录中的System子目录。
Windows目录，该目录可以通过GetWindowsDirectory得到。 进程的当前目录。
PATH环境变量中所列出的目录。
注意，对应用程序当前目录的搜索位于Windows目录之后。这个改变始于Windows XP SP2, 其目的是为了防止加载程序在应用程序的当前目录中找到伪造的系统DLL并将它们载入， 从而保证系统DLL始终都是从它们在Windows目录中的正式位置载入的。MSDN联机帮 助提到 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager 注 册表项中的一个DWORD值可以用来改变这个搜索顺序，但如果不想让恶意软件危害我们 的机器，那么我们绝对不应该设置这个DWORD值。另外请注意，还有其他一些东西可能 会对加载程序如何搜索DLL产生影响。（更多信息请参阅第20章。）
随着加载程序将DLL模块映射到进程的地址空间中，它会同时检查每个DLL的导入段。 如果一个DLL有导入段（通常如此），那么加载程序会继续将所需的额外DLL模块映射到进 程的地址空间中。由于加载程序会对载入的DLL模块进行记录，因此即使多个模块用到了 同一个模块，该模块也只会被载入和映射一次。
如果加载程序无法对所需的一个DLL模块进行定位，那么用户会看到下图所示的消 息框。
第19章DLL基础
当加载程序将所有DLL模块都载入并映射到进程的地址空间中后，它开始修复所有对导入 符号的引用。为了完成这一工作，它会再次查看每个模块的导入段。对导入段中列出的每 个符号，加载程序会检查对应DLL的导出段，看该符号是否存在。如果该符号不存在（这 种情况实属罕见），那么加载程序会显示类似于下图所示的消息框。
如果该符号存在，那么加载程序会取得该符号的RVA并给它加上DLL模块被载入到的虚 拟地址（从而得到符号在进程的地址空间中的位置）。接着加载程序会将这个虚拟地址保存 到可执行模块的导入段中。现在，当代码引用到一个导入符号的时候，会查看调用模块的 导入段并得到被导入符号的地址，这样就能够成功地访问被导入的变量、函数或C++类成 员函数了。看——动态链接就这样完成了，进程的主线程开始执行，应用程序最终运行起 来了！
加载程序要载入所有这些DLL模块，并用所有导出符号的正确地址来修复每个模块的导入 段，这自然需要相当多的时间。由于这项工作是在进程初始化的时候完成的，因此它不会 对应用程序的性能产生影响。但是，对许多应用程序来说，初始化过程太慢也是不可接受 的。为了减少应用程序的载入时间，我们应该对自己的可执行模块和DLL模块进行基地址 重定位和绑定。这两项技术极其重要，但不幸的是，很少有开发人员知道该如何应用它 们。如果每家公司都应用这两项技术，那么整个系统会运行得更好。事实上，我认为操作 系统应该发布一个工具来自动地执行这些操作。我们将在第20章对基地址重定位和绑定进 行介绍。

20.3	延迟载入DLL
20.4	'我洛发器
20.5	已知的DLL
20.6	DLL重定向
20.7	模块的基地址重定位
20.8	模块的绑定
第19章讨论了 DLL链接的基本知识并集中讨论了隐式链接，这也是到目前为止最常用的 DLL链接形式。对大多数应用程序来说，第19章的内容就已经足够了。但是，我们还可 以用DLL做更多的事情。本章我们将讨论与DLL相关的各种技术。虽然大多数应用程序 不需要这些技术，但它们极其有用，因此我们还是应该对这些技术有所了解。我建议读者 至少要阅读本章中的20.7节“模块的基地址重定位”和20.8节“模块的绑定”，因为这两 节介绍的技术可以显著地提高整个系统的性能。
20.1	DLL模块的显式载入和符号链接
为了让线程能够调用DLL模块中的一个函数，我们必须将DLL的文件映像映射到调用线 程所在进程的地址空间中。我们可以通过两种方式来达到这一目的。第一种方式是直接让 应用程序的源代码引用DLL中所包含的符号，这使得加载程序会在应用程序运行的时候隐 式地载入（并链接）所需的DLLo
第二种方式是让应用程序在运行的过程中，显式地载入所需的DLL并显式地与想要的输出 符号进行链接。换句话说，当应用程序在运行的时候，其中的一个线程能够决定它想要调 用一个DLL中的一个函数。该线程可以显式地将该DLL载入到进程的地址空间中，得到 DLL所包含的一个函数的虚拟内存地址，然后用该内存地址来调用这个函数。这项技术的 美妙之处在于，这一切都是在应用程序运行的时候完成的。
图20-1显示了应用程序如何显式地载入一个DLL并与DLL的符号进行链接。
第20章DLL高级技术
构建DLL
1）	头文件，其中包含待导出函数的原型、 结构和符号的声明
2）	C/C++源文件，其中包含待导出函数的 实现和变量
3）	编译器为每个C/C++源文件生成obj文件
4）	链接器将每个obj模块合并，从而生成DLL
5）	如果至少导出了一个函数/变员，那么链接 器会同时生成lib文件
注意：在显式链接的时候，没有用到这个 .lib文件
构建EXE
6）	头文件，其中包含待导出函数的族型、 结构和符号的声明
7）	C/C++源文件，其中包含待导出函数的 实现和变量
8）	编译器为每个C/CI■源文件生成obj文件
9）	链接器将每个obj模块合并，从而生成exe 注意：由于没有直接引用该DLL导出的符 号，因此这里不需要它的lib文件。生成的 exe文件中不包含导入表

6的
2 C*^ 2	2
7 C*^ 7	7
H译"编译以＞ 编译器/
编译器，/编竺/编译器/
3 J1 3 口
8 二 8 J) 8 J]
链接器/
链接器/
4 -ii S
运行应用程序
10）加载程序为.exe创建地址空间。 进程的主线程开始执行，应用 程序开始运行
9
显示地载入DLL
11）线程调用 L oadLibrary（Ex）来将 DLL 载入到进程的地址空间中。
---►各线程现在可以调用GetProcAddress 来间接地引用该DLL导出的符号
7
图20-1 DLL的创建过程以及应用程序显式链接到DLL的过程
20.1.1显式地载入DLL模块
在任何时候，进程中的一个线程可以调用下面两个函数来将一个DLL映射到进程的地址空 间中：
HMODULE LoadLibrary(PCTSTR pszDLLPathName)；
HMODULE LoadLibraryEx(
PCTSTR pszDLLPathName,
indows核心编程（第5版）
HANDLE hFile,
DWORD dwFlags）；
这两个函数会（根据第19章介绍的搜索算法）在用户的系统中对DLL的文件映像进行定位， 并试图将该文件映像映射到调用进程的地址空间中。两个函数返回的HMODULE表示文 件映像被映射到的虚拟内存地址。注意，这两个函数返回的是HMODULE值。这个 HMODULE类型等价于HINSTANCE,两者可以换用。本章后面介绍的DllMain入口点 所接收的HINSTANCE参数也同样是文件映像被映射到的虚拟内存地址。如果无法将DLL 映射到进程的地址空间，那么函数会返回NULLo为了得到相关的错误信息，我们可以调 用 GetLastError。
注意，LoadLibraryEx函数有两个额外的参数：hFile和dwFlagSo参数hFile是为将 来扩充所保留的，现在必须将它设为NULL。参数dwFlags可以被设为0,或下列标志 的组合：DONT_RESOLVE_DLL_REFERENCES, LOAD_LIBRARY_AS_DATAFILE, LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE, LOAD__LIBRARY_AS_IMAGE_RESOURCE, LOAD_WITH_ALTERED_SEARCH_PATH 以及 LOADJGNORE_CODE_AUTHZ__LEVELo 下面我们对这些标志做一个简要介绍。
1.	DONT_RESOLVE_DLL_REFERENCES 标志
DONT_RESOLVE_DLL_REFERENCES标志告诉系统只需将DLL映射到调用进程的地 址空间。正常情况下，£系统将一个DLL映射到进程的地址空间中的时候，系统会调用 DLL中一个指定的函数来对DLL进行初始化，该函数通常是DllMain（本章稍后会进行介 绍）。DONT_RESOLVE_DLL_REFERENCES让系统只映射文件映像，但不要调用 DllMain o
此外，一个DLL可能会导入一些包含在另一个DLL中的函数。当系统将一个DLL映射到 进程的地址空间中的时候，会检查该DLL是否还需要其他额外的DLL,并同时将它们自动 载入。如果指定了 DONT_RESOLVE_DLL_REFERENCES,那么系统不会将这些额外的 DLL自动载入到进程的地址空间中。
因此，在调用从该DLL导出的任何函数时，我们将面临很大的风险：代码所依赖的内部数 据结构可能尚未初始化，或者代码所引用的DLL尚未载入。这些原因已经足以让我们避免 使用这个标志了。如果需要了解更多的细节，请参阅Raymond Chen"在他的博客中撰写的 文章，名为 LoadLibraryEx（DONT_RESOLVE_DLL_REFERENCES） is fundamentally flawed, 文章的地址是 http://blogs.msdn.com/oldnewthing/archive/2005/02/14/372266.aspx。
2.	LOAD_L旧RARY_AS_DATAFILE 标志
LOAD_LIBRARY_AS_DATAFILE标志告诉系统将DLL作为数据文件映射到进程的地址 空间中。就只对文件进行映射这一点而言，它与DONT_RESOLVE_DLL_REFERENCES
① 洋注：《The Old New Thing》- -书的作看.
第20章DLL高级技术
相似，系统不会花费额外的时间来准备执行文件中的任何代码。例如，当系统将一个DLL 映射到进程的地址空间中的时候，会检查DLL中的一些信息来决定应该给文件中不同的段 指定何种页面保护属性。如果我们不指定LOAD_LIBRARY_AS_DATAFILE标志，那么 系统会认为需要执行文件中的代码，并用相应的方式来设置页面保护属性。举个例子，如 果一个DLL是用这个标志载入的，那么当我们对这个DLL调用GetProcAddress的时候， 返回值将是 NULL,而 GetLastError 将会返回 ERROR_MOD_NOT_FOUND。
出于几个原因，这个标志非常有用。首先，如果我们有一个DLL,其中只包含资源而 不包含函数，那么我们可以指定这个标志来将DLL的文件映像映射到进程的地址空间 中。然后我们可以使用LoadLibraryEx函数返回的HMODULE值，来调用载入资源 的函数。另外，如果想要使用一个.exe文件中包含的资源，那么我们可以使用 LOAD_LIBRARY_AS_DATAFILE标志。通常，载入一个.exe文件会启动一个新的进程， 但我们也可以使用LoadLibraryEx函数来将一个.exe文件的映像映射到进程的地址空间 中。有了.exe文件映射后的HMODULE/HINSTANCE值，我们就可以访问其中的资源了。 由于.exe文件没有DllMain函数，因此在调用LoadLibraryEx来载入.exe文件的时候，必 须指定 LOAD_LIBRARY_AS_DATAFILE 标志。
3.	LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE 标志
这个标志与LOAD_LIBRARY_AS_DATAFILE相似，唯一的不同之处在于DLL文件 是以独占访问模式打开的，从而禁止任何其他应用程序在当前应用程序使用该DLL文 件的时候对其进行修改。与LOAD_LIBRARY_AS_DATAFILE标志相比，这个标志 可以为我们的应用程序提供更好的安全性，正因为如此，我建议除非想让其他应用程 序能够对DLL文件的内容进行修改，否则我们应该在应用程序中使用 LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE 标志。
4.	LOAD_LIBRARY_AS_IMAGE_RESOURCE 标志
LOAD LIBRARY AS IMAGE RESOURCE 标志与 LOAD LIBRARY AS DATAFILE ~~	~~ ••	•—	SMB
相似，但有一点略有不同：当系统载入DLL的时候，会对相对虚拟地址(relative virtual address,后面简称为RVA)进行修复，第19章对相对虚拟地址做了详细的介绍。这样，RVA 就可以直接使用，而不必再根据DLL载入到的内存地址来对它们进行转换了。当需要对 DLL进行解析来遍历其中的PE(portable executable)段时，这个标志特别有用。
5.	LOAD_WITH_ALTERED_SEARCH_PATH 标志
LOAD_WITH_ALTERED_SEARCH^PATH 标志用来改变 LoadLibraryEx 在对指定的 DLL进行定位时所使用的搜索算法。通常，LoadLibraryEx会根据“运行可执行模块”中 所列的顺序来搜索文件。但是，如果指定了 LOAD_WITH_ALTERED_SEARCH_PATH 标志，那么LoadLibraryEx会根据传给pszDLLPathName参数的值，用三种不同的算法 来搜索文件。
(1)如果pszDLLPathName不包含'字符，那么将使用第19章列出的标准搜索路径来对
indows核心编程(第5版)
DLL进行搜索。	___
556
(2)如果pszDLLPathName包含'字符，那么取决于该路径是全路径还是相对路径， LoadLibraryEx的行为会有所不同，具体如下。
①	如果传入的参数是全路径或网络共享路径(比如C:\Apps\Libraries\MyLibrary.dll或 Wserver\share\MyLibrary.dll),那么 LoadLibraryEx 会试图直接载入该 DLL 文件。 如果对应的文件不存在，那么函数将不再搜索其他地方而是返回NULL,这时 GetLastError 会返回 ERROR_MOD_NOT_FOUND。
②	否则，在试图将对应的文件作为DLL载入时，函数会将下列文件夹与 pszDLLPathName 连接起来：
a.	进程的当前目录
b.	Windows的系统目录①
c.	16位Windows系统目录-即Windows目录下的System子目录
d.	Windows 目录
e.	PATH环境变量中列出的目录
注意，如果pszDLLPathName参数中出现或，那么在搜索过程中的每 一个步骤都会将它们考虑在内来构建一个相对路径。例如，如果将TEXT (“..\\MyLibrary.dll”)作为参数传入，那么LoadLibraryEx会在下列位置搜索 MyLibrary.dll：
a.	包含当前目录的文件夹
b.	包含Windows的系统目录的文件夹(即Windows目录)
c.	包含16位Windows系统目录的文件夹
d.	包含Windows目录的文件夹(通常是磁盘的根目录)
e.	PATH环境变量中列出的每个目录的上一层文件夹
一旦从以上文件夹中载入了一个有效的DLL,那么整个搜索过程随即停止。
⑶ 在构建应用程序的时候，如果不希望用LOAD_WITH_ALTERED_SEARCH_PATH 标志来调用LoadLibraryEx,或者不希望改变成用程序的当前目录，而是希童让它从 一个众所周知的文件夹中动态地载入DLL,那么我们应该调用SetDUDirectory,并将 程序库所在的文件夹作为参数传入。这个函数告诉LoadLibrary和LoadLibraryEx在 搜索的时候使用下面的算法：
a.	进程的当前目录
b.	通过SetDllDirectory所设置的文件夹
c.	Windows的系统目录
d.	16位Windows系统目录
e.	Windows 目录
f.	PATH环境变量中列出的目录
① 译注：即Windows目录下的System32子目录。
第20章DLL高级技术
该搜索算法允许我们将应用程序和共享的DLL保存在一个预先定义好的目录中，由于应用 程序的当前目录是可以设置的，比如在快捷方式中，因此该算法可以避免从应用程序的当 前目录中意外地载入同名DLL的风险。注意，如果用一个空字符串——即TEXT(””)—— 作为参数来调用SetDUDirectory,那等于是将当前路径从搜索步骤中删除。如果传入的参 数为NULL,那么会恢复使用默认的算法。最后，GetDllDirectory可以用来返回这个特定 目录当前的值。
6.	LOAD_IGNORE_CODE_AUTHZ_LEVEL 标志
LOAD_IGNORE_CODE_AUTHZ_LEVEL 标志用来关闭 WinSafer(又称 Software Restriction Policies或Safer)所提供的验证，它是在WindowsXP中引入的，其设计目的是 为了对代码在执行过程中可以拥有的特权加以控制。在Windows Vista中，第4章介绍的 用户帐户控制(User Account Control, UAC)特性己经取代了这项特性(更多的信息请参阅 http://technet.microsoft.com/en-us/windowsvista/aa940985.aspx) o
20.1.2显式地卸载DLL模块
当进程不再需要引用DLL中的符号时，我们应该调用下面的函数来显式地将DLL从进程 的地址空间中卸载：
BOOL FreeLibrary(HMODULE hlnstDll);
我们必须传入一个HMODULE值，用来标识我们想要卸载的DLLo这个值是先前调用 LoadLibrary(Ex)时返回的。
我们还可以调用下面这个函数来将一个DLL模块从进程的地址空间中卸载：
VOID FreeLibraryAndExitThread(
HMODULE hlnstDll,
DWORD dwExitCode)；
这个函数在Kemel32.dll中被实现如下：
VOID FreeLibraryAndExiCThread(HMODULE hlnstDll, DWORD dwExitCode) {
FreeLibrary(hlnstDll)；
Ex i t Th r ead(dwEx i t Code)；
}
乍一看，这好像没有什么大不了的，读者可能会奇怪Microsoft为什么要特意创建 FreeLibraryAndExitThread函数。其原因是为了下面的情形：假设我们正在编写一个DLL, 在一开始被映射到进程的地址空间中时，这个DLL会创建一个线程。当线程完成了它的工 作后，可以先后调用FreeLibrary和ExitThread,来从进程的地址空间中撤销对DLL的 映射并终止线程。
但如果线程分别调用FreeLibrary和ExitThread,那么会出现一个严重的问题。这个问题 就是FreeLibrary会立即从进程的地址空间中撤销对DLL的映射。当FreeLibrary调用返
・■一
lows核心编程(第5版)
回的时候，调用ExitThread的代码已经不复存在了，线程试图执行的是不存在的代码。这 将引发访问违规，并导致整个进程被终止！
但是，如果线程调用FreeLibraryAndExitThread,那么这个函数会调用FreeLibrary,这 使得对DLL的映射会立即被撤销。要执行的下一条指令仍在Kemel32.dll中，而不是在已 经被撤销映射的DLL中。这意味着线程可以继续执行并调用ExitThreado ExitThread会 使线程终止并且不再返回。
实际上，每个DLL在进程中有一个与之对应的使用计数，LoadLibrary和LoadLibraryEx 函数会递增该使用计数，而FreeLibrary和FreeLibraryAndExitThread会递减该使用计数。 例如，当我们第一次调用LoadLibrary来载入一个DLL的时候，系统会将DLL的文件映 像映射到调用进程的地址空间中，并将DLL的使用计数设为1。如果同一个进程中的一个 线程后来再调用LoadLibrary来载入同一个DLL文件映像的时候，系统不会再次将DLL 的文件映像映射到进程的地址空间中。它只是将进程中与该DLL对应的使用计数递增。
为了从进程的地址空间中撤销对该DLL文件映像的映射，进程中的线程必须调用 FreeLibrary两次——第一次调用只是将DLL的使用计数递减为1,第二次调用将DLL的 使用计数递减为0。当系统发现DLL的使用计数己经为0时，会从进程的地址空间中撤销 对该DLL文件映像的映射。如果任何线程再试图调用该DLL中的函数，那将引发访问违 规，因为原来被映射到进程的地址空间中的代码已经不复存在了。
系统会在每个进程中为每个DLL维护一个使用计数，也就是说，如果进程A中的一个线 程执行了下面的代码，然后进程B中的一个线程执行了同样的代码，那么MyLib.dll会被 映射到两个进程的地址空间中——该DLL在进程A和进程B中的使用计数都是U HMODULE hlnstDll = LoadLibrary(TEXT("MyLib.dll"))；
如果进程B中的一个线程后来执行了下面的代码，那么该DLL在进程B中的使用计数将 变成0,系统会从进程B的地址空间中撤销对该DLL映射。但是，这对映射到进程A的地 址空间中的DLL丝毫没有影响，该DLL在进程A中的使用计数仍然是1。
FreeLibrary(hlnstDll);
线程可以通过调用GetModuleHandle函数来检测一个DLL是否已经被映射到了进程的地 址空间中：
HMODULE GetModuleHandle(PCTSTR pszModuleName)；
例如，只有当MyLib.dll尚未被映射到进程的地址空间中时，下面的代码才会将它载入：
HMODULE hlnstDll = GetModuleHandle(TEXT("MyLib")); // DLL extension assumed
if (hlnstDll == NULL) {
hlnstDll = LoadLibrary(TEXT("MyLib"))； // DLL extension assumed
}
如果传NULL给GetModuleHandle,那么函数会返回应用程序的可执行文件的句柄。
第20章DLL高级技术
如果只有一个DLL(或.exe)的HINSTANCE/HMODULE ,那么我们同样可以通过 GetModuleFileName函数来得到该DLL的全路径：
DWORD GetModuleFileName(
HMODULE hlnstModule,
PTSTR pszPathName,
DWORD cchPath)；
第1个参数是该DLL(或.exe)的HMODULE。第2个参数pszPathName是一个缓存的地址, 函数会将文件映像的全路径保存到这个缓存中。第3个参数cchPath用来指定缓存的大小, 以字符为单位。如果传NULL给hlnstModule参数，那么GetModuleFileName会在 pszPathName参数中返回当前正在运行的应用程序的可执行文件的文件名。4.1节更详细 地介绍了这些方法、_ImageBase伪变量以及GetModuleHandleEx函数。
混用LoadLibrary和LoadLibraryEx可能会导致将同一个DLL映射到同一个地址空间中 的不同位置。例如，让我们看下面的代码：
HMODULE hDlll = LoadLibrary(TEXT("MyLibrary.dll"));
HMODULE hD112 = LoadLibraryEx(TEXT("MyLibrary.dll"), NULL,
LOAD_LIBRARY_AS_IMAGE_RESOURCE);
HMODULE hD113 = LoadLibraryEx(TEXT("MyLibrary.dll'), NULL, LOAD_LIBRARY_AS_DATAFILE);
读者认为hDlll,hDH2和hD113的值分别是什么？显然,如果载入的是同一个MyLibrary.dll, 那么它们的值应该相同。但如果改变代码的顺序，变成下面这样，就不那么明显了：
HMODULE hDlll = LoadLibraryEx(TEXT("MyLibrary.dll"), NULL,
LOAD_LIBRARY_AS_DATAFILE);
HMODULE hD112 = LoadLibraryEx(TEXT("MyLibrary.dll"), NULL, LOAD_LIBRARY_AS_IMAGE_RESOURCE);
HMODULE HD113 = LoadLibrary(TEXT("MyLibrary.dll■))；
在这种情况下，hDlll, hD112和hD113各不相同！当我们用LQAD_LIBRARY_AS_DATAFILE, LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE 或 LOAD_LIBRARY_AS_IMAGE_RESOURCE 标志调用LoadLibraryEx的时候，操作系统会先检测该DLL是否已经被LoadLibrary或 LoadLibraryEx(但没有使用这些标志)载入过。如果巳经被载入过，那么函数会返回地址空 间中DLL原先已经被映射到的地址。但是，如果DLL尚未被载入，那么Windows会将该 DLL载入到地址空间中一个可用的地址，但并不认为它是一个完全载入的DLL。这时如果 用这个模块句柄来调用GetModuleFileName,那么得到的返回值将为0。这是一种非常好 的方法，可以让我们知道与一个DLL相对应的模块句柄并不包含动态函数，因此无法通过 GetProcAddress来得到函数地址并对函数进行调用，下一节会对此进行更详细的介绍。
始终应该记住的是，即便LoadLibrary和LoadLibraryEx载入的DLL理应是磁盘上的同 一个文件,我们也不能将它们返回的映射地址互换使用气
① 译注：如果在调用LoadLibraryEx时不使用任何标志，那么它等价于LoadLibraryo否则，用两者来载入DLL所得到的句柄 是不等价的。
lows核心编程(第5版)
20.1.3显式地链接到导出符号
一旦显式地载入了一个DLL模块，线程必须通过调用下面的函数来得到它想要引用的符号 的地址：
FARPROC GetProcAddress(
HMODULE hlnstDll,
PC STR ps z Sy mbo 1 Name);
参数hlnstDIl用来指定包含符号的DLL的句柄，它是先前调用LoadLibrary(Ex)或 GetModuleHandle所返回的。参数pszSymbolName nf以有两种形式。第一种形式是用符 号名来指定我们想要得到哪个符号的地址，符号名通过一个以字符零为终止符的字符串来 表示：
FARPROC p£n = GetProcAddress(hlnstDIl, "SomeFuncInDll")；
注意，参数pszSymbolName在函数原型中的类型为PCSTR,而不是PC7STR。这意味着 GetProcAddress函数只能接受ANSI字符串——我们从来不会传Unicode字符串给这个函 数，这是因为编译器/链接器始终都是将符号的名称以ANSI字符串的形式保存在DLL的导 出段中的。
参数pszSymbolName的第二种形式是用序号来指定我们想要得到哪个符号的地址：
FARPROC pfn = GetProcAddress(hlnstDIl, MAKEINTRESOURCE(2))；
这种用法假定我们知道DLL的创建者给我们想要的符号名指定的序号为2o再强调一次， Microsoft强烈反对使用序号，因此我们不会经常看到GetProcAddress的第二种用法。
两种形式都能够从DLL中得到我们想要的符号的地址。如果DLL模块的导出段中不包含 指定的符号，那么GetProcAddress会返回NULL,表示调用失败。
应该意识到的是，调用GetProcAddress的第一种方法要比第二种方法慢，因为系统必须根 据传入的符号名来执行字符串比较和搜索。如果使用第二种方法，即使传入的序号并没有 任何导出函数与之相对应，GetProcAddress也可能会返回一个非NULL值。这个返回值会 让我们的应用程序误以为我们得到了一个有效的地址，但事实上却并非如此。试图调用这 个地址几乎肯定会引发访问违规。在我早期的Windows编程生涯中，我并不完全理解这种 行为，也多次为其所害一一因此请读者务必小心。(这种行为也是我们应该优先使用符号名 而避免使用序号的另一个原因。)
在能够用GetProcAddress返回的函数指针来调用函数之前，我们需要将它转型为与函数 的签名相匹配的正确类型。例如，typedef void (CALLBACK *PFN_DUMPMODULE) (HMODULE hModule)；是与 void DynamicDumpModule(HMODULE hModule)函数相对 应的回调函数的类型签名。下面的代码显示了如何动态地调用这个导出自某DLL的函数： PFN_DUMPMODULE pfnDumpModule =
(PFN_DUMPMODULE)GetProcAddress(hDl1, "DumpModule")；
第20章DLL高级技术
if (pfnDumpModu1e != NULL) ( p f nDumpModu1e(hDl1);
20.2	DLL的入口点函数
一个DLL可以有一个入口点函数。系统会在不同的时候调用这个入口点函数，具体什么时 候我们马上就会介绍。这些调用是通知性质的，通常被DLL用来执行一些与进程或线程有 关的初始化和清理工作。如果DLL不需要这些通知，那么我们可以不必在源代码中实现这 个入口点函数。例如，如果要创建一个只包含资源的DLL,那么我们就不需要实现这个函 数。如果想要在DLL中接收通知，那么我们可以像下面这样来实现入口点函数：
BOOL WINAPI DUMain (HINSTANCE hlnstDU, DWORD fdwReason, PVOID flmpLoad) (
switch (fdwReason) {
case DLL_PROCESS_ATTACH:
// The DLL is being mapped into the process' address space, break;
case DLL_THREAD_ATTACH:
// A thread is being created, break；
case DLL_THREAD_DETACH:
// A thread is exiting cleanly, break；
case DLL_PROCESS_DETACH:
// The DLL is being unmapped from the process * address space. break；
)
return(TRUE); // Used only for DLL_PROCESS_ATTACH
}
说明 函数名DUMain是区分大小写的。许多开发人员不小心将这个函数拼写为DLLMain。 这是一个非常容易犯的错误，因为术语DLL经常会用全部大写字母表示。如果我 们将入口点函数命名为DUMain之外的其他名称，那么虽然代码仍然能够编译和链 接，但我们的入口点函数将永远不会被调用，DLL也永远不会进行初始化。
参数hlnstDU包含该DLL实例的句柄。与jWinMain的hlnstExe参数相似，这个值表示 一个虚拟内存地址，DLL的文件映像就被映射到进程地址空间中的这个位置。我们通常将 这个参数保存在一个全局变量中，这样在调用资源载入函数(比如DialogBox和LoadString) 的时候，我们就可以使用它。如果DLL是隐式载入的，那么最后一个参数flmpLoad的值 将不为零，如果DLL是显式载入的，那么flmpLoad的值将为零。
参数fdwReason表示系统调用入口点函数的原因。这个参数可能是下列4个值之一： DLL PROCESS ATTACH, DLL PROCESS DETACH, DLL THREAD ATTACH 或 DLL_THREAD_DETACH。下面几节就会对它们进行介绍。
562
indows核心编程(第5版)
说明 必须记住，DLL使用DllMain函数来对自己进行初始化。DllMain函数执行的时候， 同一个地址空间中的其他DLL可能还没有执行它们的DllMain.这意味着它们尚未 初始化，因此我们应该避免调用那些从其他DLL中导入的函数。此外，我们应该避 免在DIlMain中调用LoadLibrary(Ex)和FreeLibrary,因为这些函数可能会产生循 环依赖。
Platform SDK文档说DllMain函数只应该执行简单的初始化，比如设置线程局部存 储区(参见第21章)，创建内核对象，打开文件，等等。我们必须避免调用User, Shell, ODBC, COM, RPC以及套接字函数(或其他调用了这些函数的函数)，这是因为包 含这些函数的DLL可能尚未初始化完毕，或者函数可能会在内部调用 LoadLibrary(Ex),从而产生循环依赖。
另外值得注意的是，如果要创建全局或静态C++对象，会存在同样的问题，因为在 DllMain函数被调用的同时，这些对象的构造函数和析构函数也会被调用。
DllMain入口点函数在执行的时候存在一些限制，这些限制与获取进程范围内的加 载程序锁(loader lock)有关。具体的细节请参阅“Best Practices for Creating DLLs”文 档，网址为 http://www.microsoft.com/whdc/driver/kemel/DLL bestprac.mspXo
20.2.1	DLL_PROCESS_ATTACH 通知
当系统第一次将一个DLL映射到进程的地址空间中时，会调用DllMain函数，并在 fdwReason参数中传入DLL_PROCESS_ATTACH。只有当DLL的文件映像第一次被映射 的时候，才会这样。如果之后一个线程再调用LoadLibrary(Ex)来载入一个已经被映射到 进程的地址空间的DLL,那么操作系统只不过是递增该DLL的使用计数，而不会再次用 DLL_PROCESS_ATTACH 来调用 DllMain 函数。
当一个DLL在处理DLL__PROCESS_ATTACH的时候，应该根据包含在DLL中的函数的 需要，来执行与进程相关的初始化。举个例子，这个DLL中可能包含一些函数，这些函数 需要使用自己的堆(在进程的地址空间中创建)。该DLL的DllMain函数可以在处理 DLL_PROCESS_ATTACH通知的时候调用HeapCreate来创建所需的堆。为了让DLL中 的函数能够访问刚才创建的堆的句柄，我们可以将它保存在一个该DLL函数能访问到的全 局变量中。
当DllMain处理DLL_PROCESS_ATTACH通知的时候，DllMain的返回值用来表示该 DLL的初始化是否成功。例如，如果调用HeapCreate成功，那么DllMain应该返回TRUE。 如果无法创建堆，那么应该返回FALSE o如果fdwReason是任何其他的值 (DLL_PROCESS_DETACH, DLL_THREAD__ATTACH 以及 DLL_THREAD_DETACH), 那么系统将忽略DllMain的返回值。
当然，系统中的某个线程必须负责执行DllMain函数中的代码。创建新的进程时，系统会 分配进程地址空间并将.exe的文件映像以及所需DLL的文件映像映射到进程的地址空间 中。然后，系统将创建进程的主线程并用这个线程来调用每个DLL的DllMain函数，同时
第20章DLL高级技术
传入DLL_PROCESS_ATTACH。当所有己映射的DLL都完成了对该通知的处理后，系统 会先让进程的主线程开始执行可执行模块的C/C++运行时的启动代码(startup code),然后执 行可执行模块的入口点函数Ctmain或_tWhiMaiii)。如果任何一个DLL的DllMain函数返 回FALSE,也就是说初始化没有成功，那么系统会把所有的文件映像从地址空间中清除， 向用户显示一个消息框来告诉用户进程无法启动，然后终止整个进程。下图就是Windows Vista显示的消息框。
563*564
现在让我们来看一看显式载入DLL的时候会发生什么情况。进程调用LoadLibrary(Ex)的 时候，系统会对指定的DLL进行定位，并将该DLL映射到进程的地址空间中。然后系统 会用调用LoadLibrary(Ex)的线程来调用DLL的DllMain函数，并传入 DLL_PROCESS_ATTACH值。当DLL的DllMain函数完成了对通知的处理后，系统会 让LoadLibrary(Ex)调用返回，这样线程就可以继续正常执行。如果DllMain函数返回 FALSE,也就是说初始化不成功，那么系统会自动从进程的地址空间中撤销对DLL文件 映像的映射，并让LoadLibrary(Ex)返回NULL。
20.2.2	DLL__PROCESS_DETACH 通知
当系统将一个DLL从进程的地址空间中撤销映射时，会调用DLL的DHMain函数，并在 fdwReason参数中传入DLL_PROCESS_DETACH。当DLL处理这个通知的时候，应该执 行与进程相关的清理工作。举个例子，DLL可能会调用HeapDestroy来销毁它在处理 DLL_PROCESS_ATTACH通知的时候创建的堆。注意，如果DllMain函数在处理 DLL_PROCESS_ATTACH 的时候返回 FALSE ,那么 DllMain将不会收到 DLL_PROCESS_DETACH通知。如果撤销映射的原因是因为进程要终止，那么调用 ExitProcess函数的线程将负责执行DllMain函数的代码。在正常情况下，这个线程就是应 用程序的主线程。当我们的入口点函数返回到C/C—运行时的启动代码后，启动代码会显 式地调用ExitProcess来终止进程。
如果撤销映射的原因是因为进程中的一个线程调用了 FreeLibrary或 FreeLibraryAndExitThread,那么发出调用的线程将执行DllMain函数中的代码。如果调 用的是FreeLibrary,那么在DllMain处理完DLL_PROCESS_DETACH通知之前，线程 是不会从该调用中返回的。
注意，DLL可能会阻碍进程的终止。例如，当DllMain收到DLL PROCESS DETACH
Ldows核心编程（第5版）
通知的时候，有可能会进入无限循环。只有当每个DLL都处理完 DLL_PROCESS_DETACH通知之后，操作系统才会真正地终止进程。
说明 如果进程终止是因为系统中的某个线程调用了 TerminateProcess,系统便不会用 DLL_PROCESS_DETACH来调用DLL的DllMain函数。这意味着在进程终止之 前，已映射到进程的地址空间中的任何DLL将没有机会执行任何清理代码。这可能 会导致数据丢失。因此，除非万不得已，我们应该避免使用TerminateProcess函数。
图20-2显示了线程调用LoadLibrary时系统执行的步骤。图20-3显示了当线程调用 FreeLibrary时系统执行的步骤。
图20-2线程调用LoadLibrary时系统执行的步骤

第20章DLL高级技术
递减DLL的 使用计数
调用DLL 的 DllMain 函数并传入DLL_ PROCESS_DETACH
返回TRUE
从进程的地址 空间中撤销对
DLL的映射
图20-3线程调用FreeLibrary时系统执行的步骤
20.2.3	DLL_THREAD_ATTACH 通知
当进程创建一个线程的时候，系统会检查当前映射到该进程的地址空间中的所有DLL文件 映像，并用DLL_THREAD__ATTACH来调用每个DLL的DUMain函数。这告诉DLL需 要执行与线程相关的初始化。新创建的线程负责执行所有DLL的DllMain函数中的代 码。只有当所有DLL都完成了对该通知的处理之后，系统才会让新线程开始执行它的线程 函数。
当系统将一个新的DLL映射到进程的地址空间中时，如果进程中已经有多个线程在运行， 那么系统不会让任何已有的线程用DLL_THREAD_ATTACH来调用该DLL的DllMain 函数。如果在创建新线程的时候DLL已经被映射到进程的地址空间中，那么只有在这种情 况下系统才会用DLL_THREAD_ATTACH来调用DLL的DllMain函数。
indows核心编程（第5版）
另外要注意的是,系统不会让进程的主线程用DLL_THREAD_ATTACH值来调用DUMain 函数。在进程创建的时候被映射到进程地址空间中的任何DLL会收到 DLL_PROCESS_ATTACH 通知，但不会收到 DLL_THREAD_ATTACH 通知。
20.2.4	DLL_THREAD_DETACH 通知
让线程终止的首选方式是让它的线程函数返回。这会使得系统调用ExitThread来终止线 程。ExitThread告诉系统该线程想要终止，但系统不会立即终止该线程，而会让这个即将 终止的线程用DLL_THREAD_DETACH来调用所有己映射DLL的DllMain函数。这个通 知告诉DLL执行与线程相关的清理。例如，C/C++运行库会在这个时候释放那些用来管理 多线程应用程序的数据块。
注意，DLL可能会妨碍线程的终止。例如，当DllMain收到DLL_THREAD_DETACH 通知的时候，有可能会进入无限循环。只有当每个DLL都处理完DLL_THREAD_DETACH 通知之后，操作系统才会真正地终止线程。
说明 如果线程终止是因为系统中的某个线程调用了 TerminateThread,那么系统不会用 DLL_THREAD_DETACH来调用所有DLL的DllMain函数。这意味着在线程终止 之前，已映射到进程的地址空间中的任何DLL将没有机会执行任何清理代码。这可 能会导致数据丢失。因此，与TerminateProcess一样，除非万不得已，我们应该避 免使用 TerminateThread 函数。
如果在撤销对一个DLL的映射时还有任何线程在运行，那么系统不会让任何这些线程用 DLL_THREAD_DETACH 来调用 DllMain。我们可能想要在自己处理 DLL_PROCESS_DETACH的代码中对此进行检查，这样就能够进行任何必要的清理。
前面提到的这些规则可能会导致下面的情况：进程中的一个线程调用LoadLibrary来载入 一个DLL,这使得系统用DLL_PROCESS_ATTACH来调用该DLL的DllMain函数。（注 意该线程不会得到DLL_THREAD_ATTACH通知。）接着，载入该DLL的线程退出，这 使得系统再次调用DllMain函数---S这次传入的是DLL_THREAD_DETACH。注意，
虽然当系统将该线程连接到该DLL的时候，不会向该DLL发送DLL_THREAD_ATTACH 通知，但是当系统将该线程与DLL解除连接的时候，却会向该DLL发送 DLL_THREAD_DETACH通知。由于这个原因，我们在进行与线程相关的清理时必须极 其小心。幸运的是，在大多数程序中，调用LoadLibrary的线程与调用FreeLibrary的线 程是同一个线程。
20.2.5	DllMain的序列化调用
系统会将对DLL的DllMain函数的调用序列化。为了理解序列化的确切含义，让我们考虑 下面的情形。一个进程有两个线程：线程A和线程B。进程的地址空间中还映射了另一个
第20章DLL高级技术
名为SomeDLL.dll的DLL。两个线程都准备调用CreateThread函数来创建另外两个线程: 线程C和线程D。
567
当线程A调用CreateThread来创建线程C的时候，系统会用DLL_THREAD_ATTACH 来调用SomeDLL.dll的DllMain函数。当线程C执行DHMain函数中的代码时，线程B调 用CreateThread来创建线程D。系统必须再次用DLL_THREAD_ATTACH来调用 DllMain，但这次是让线程D来执行其中的代码。但是，系统会将对DllMain的调用序列 化，它会将线程D挂起，直到线程C执行完DllMain中的代码并返回为止。
当线程C执行完DllMain中的代码后，可以开始执行它的线程函数。现在系统将唤醒线程 D并让它执行DllMain中的代码。当函数返回后，线程D可以开始执行它的线程函数。
通常我们根本不会考虑DllMain的这种序列化调用。之所以在这里专门提到这个问题，是 因为我曾经与别人共事，看到过一个由DllMain的序列化调用而导致的缺陷。有缺陷的代 码看起来大致如下：
BOOL WINAPI DllMain(HINSTANCE hlnstDll, DWORD fdwReason, PVOID flmpLoad) (
HANDLE hThread；
DWORD dwThreadld；
switch (fdwReason) (
case DLL_PROCESS_ATTACH：
// The DLL is being mapped into the process' address space.
// Create a thread to do some stuff.
hThread = CreateThread(NULL, 0, SomeFunction, NULL,
0, &dwThreadId);
// Suspend our thread until the new thread terminates.
WaitForSingleObject(hThread, INFINITE)；
// We no longer need access to the new thread.
CloseHandle(hThread);
break；
case DLL_THREAD_ATTACH:
// A thread is being created.
break;
case DLL_THREAD_DETACH:
// A thread is exiting cleanly.
break；
case DLL_PROCESS_DETACH:
// The DLL is being unmapped from the process' address space.
break；
)
return(TRUE);
}
我们花了数小时才发现代码中的问题。你看出来了吗？当DllMain收到 DLL_PROCESS_ATTACH通知的时候，会创建一个新的线程。系统必须用 DLL_THREAD_ATTACH来再次调用DUMaino但是，老线程在创建新线程的时候，会 导致系统向新线程的DllMain发送DLL_PROCESS_ATTACH通知，由于这时老线程尚未
（indows核心编程（第5版）
完成对DIlMain的处理，因此新线程会被挂起。问题出在对WaitForSingleObject的调用。 这个函数会把当前正在执行的线程挂起，直到新的线程结束运行为止。但是，由于新线程 为了等待当前线程退出DIlMain函数而被挂起，因此它从来没有机会运行，更别提运行结 束了。这是一个死锁的情形，两个线程都将永远处于挂起状态！
568*9
当我开始考虑如何解决这个问题的时候，发现了 DisableThreadLibraryCalls函数:
BOOL DisableThreadLibraryCalls(HMODULE hlnstDll)；
DisableThreadLibraryCalls告诉系统，我们不想让系统向某个指定DLL的DIlMain函数 发送DLL_THREAD_ATTACH和DLL_THREAD_DETACH通知。我觉得如果告诉系统 不要向该DLL发送DLL通知，就不会发生死锁的情形。但是，当我对这个方案进行测试 的时候，随即发现这并不能解决问题。下面就是这个方案：
BOOL WINAPI DllMain(HINSTANCE hlnstDll, DWORD fdwReason, PVOID flmpLoad) (
HANDLE hThread; DWORD dwThreadld;
switch (fdwReason) (
case DLL_PROCESS_ATTACH:
// The DLL is being mapped into the process' address space. // Prevent the system from calling DIlMain
// when threads are created or destroyed. DisableThreadLibraryCalls(hlnstDll);
// Create a thread to do some stuff.
hThread = CreateThread(NULL, 0, SomeFunction, NULL,
0, &dwThreadId)；
// Suspend our thread until the new thread terminates. WaitForSingleObject(hThread, INFINITE)；
// We no longer need access to the new thread.
CloseHandle(hThread)； break；
case DLL_THREAD_ATTACH:
// A thread is being created, break;
case DLL_THREAD_DETACH:
// A thread is exiting cleanly, break；
case DLL_PROCESS_DETACH:
// The DLL is being unmapped from the process * address space. break；
}
return(TRUE);
)
I可题在于:当系统创建进程的时候，会同时创建一个锁（在Windows Vista中是一个关键段）。 每个进程都有自己的锁——多个进程不会共享同一个锁。当进程中的线程调用映射到进程 地址空间中的DLL的DIlMain函数时，会用这个锁来同步各个线程。注意，在今后版本的 Windows中，这个锁可能会消失。
第20章DLL高级技术
在程序调用CreateThread的时候，系统首先会创建线程内核对象和线程栈。然后系统会在 内部调用WaitForSingleObject函数，并传入进程的互斥量对象的句柄。当新线程得到互 斥量的所有权后，系统会让新线程用DLL_THREAD>TTACH来调用每个DLL的 DllMain函数。只有在这个时候，系统才会调用ReleaseMutex来放弃对进程的互斥量对象 的所有权。由于系统是以这种方式运作的，因此添加DisableThreadLibraryCalls调用并不 能防止线程死锁。我唯一能想到的能够防止线程被挂起的方法，就是重新设计这部分源代 码，不要在 DLL 的 DllMain 函数中调用 WaitForSingleObjecto
20.2.6	DllMain 和 C/C++运行库
在刚才对DllMain函数的讨论中，我假设读者是用Microsoft Visual C++编译器来构建DLL 的。在编写一个DLL的时候，可能需要C/C++运行库在启动方面给予我们一些帮助。举个 例子，假设我们正在构建的DLL包含一个全局变量，这个全局变量是一个C廿类的实例。 在我们能够在DllMain函数中安全地使用该全局变量之前，必须保证它的构造函数己经被 调用过。这就是C/C++运行库的DLL启动代码的工作。
在链接DLL的时候，链接器会将DLL的入口点函数的地址嵌入到生成的DLL文件映像中。 我们可以用链接器的/ENTRY开关来指定入口点函数的地址。在默认的情况下，如果用的 是Microsoft链接器并指定了/DLL开关，那么链接器会认为入口点函数的函数名是 _DllMainCRTStartuPo这个函数包含在C/C++运行库中，在链接DLL的时候会被静态地 链接到DLL的文件映像。（即便用的是C/C++运行库的DLL版本，对这个函数的链接仍然 会是静态的。）
系统将DLL的文件映像映射到进程的地址空间中时,实际上调用的是—DllMainCRTStartup 函数，而不是我们的DllMain函数。在将所有的通知都转发到_DllMainCRTStartup函数 之前，为了支持/GS开关所提供的安全性特性，_DllMainCRTStartup函数会对 DLL_PROCESS_ATTACH 通知进行处理。_DllMainCRTStartup 函数会初始化 C/C++运 行库，并确保在_DlIMainCRTStartup收到DLL_PROCESS__ATTACH通知的时候，所有 全局或静态C++对象都已经构造完毕。在C/C++运行时的初始化完成之后， _DllMainCRTStartup函数会调用我们的DllMain函数。
当 DLL收到 DLL_PROCESS_DETACH 通知的时候，系统会再次调用 _DllMainCRTStartup函数。这一次，该函数会调用我们的DllMain函数，当DUMain返 回的时候，_DllMainCRTStartup会调用DLL中所有全局或静态C++对象的析构函数。 当接收到 DLL_THREAD_ATTACH 或 DLL_THREAD_DETACH 通知的时候， _DllMainCRTStartup不会做任何的特殊处理。
前面已经提到过在DLL的源代码中实现DllMain函数并不是必需的。如果没有自己的
①译注：请注意函数名中的双下划线。
西dows核心编程(第5版)	.
DllMain函数，那么我们可以使用C/C++运行库提供的DllMain函数，它的实现看起来大 致如下(如果静态链接到C/C++运行库)：
BOOL WINAPI DllMain(HINSTANCE hlnstDll, DWORD fdwReason, PVOID flmpLoad) {
if (fdwReason == DLL_PROCESS_ATTACH)
DisableThreadLibraryCalls(hlnstDll)； return(TRUE)；
)
在链接DLL的时候，如果链接器无法在DLL的.obj文件中找到一个名为DllMain的函数, 那么它会链接C/C++运行库的DllMain函数。如果不提供自己的DUMain,那么C/C++运 行库会认为我们并不关心DLL_THREAD_ATTACH和DLL_THREAD_DETACH通知。
于是为了提升创建线程和销毁线程的性能，C/C++运行库在它提供的DllMain函数中调用 了 DisableThreadLibraryCalls。
20.3延迟载入DLL
为了让DLL更易于使用，Microsoft Visual C++提供了一项很棒的特性，即延迟载入DLL。 一个延迟载入的DLL是隐式链接的，系统一开始不会将该DLL载入，只有当我们的代码 试图去引用DLL中包含的一个符号时，系统才会实际载入该DLL。延退载入DLL在下列 情况下非常有用。
•	如果应用程序使用了多个DLL,那么它的初始化可能会比较慢，因为加载程序要将 所有必需的DLL映射到进程的地址空间中。缓解这个问题的一种方法是将DLL 的载入过程延伸到进程的执行过程中。延迟载入DLL可以让我们很容易地实现这 —点。
•	如果我们在代码中调用一个新的函数，然后又试图在一个不提供该函数的老版本的 操作系统中运行该应用程序，那么加载程序会报告一个错误并且不允许应用程序运 行。我们需要一种方法来让应用程序执行，如果(在运行的时候)发现应用程序正在 老的操作系统下运行，那么就不调用这个不存在的函数。举个例子，假设应用程序 想在Windows Vista下使用新的线程池函数，在老的操作系统下则使用老的函数。 当应用程序初始化的时候，可以调用GetVersionEx来检查操作系统的版本，并调 用相应的函数。由于Windows Vista之前的Windows版本还没有这个函数，因此在 老版本的Windows下运行这个应用程序会导致加载程序显示一条错误消息。延迟 载入DLL同样可以让我们很容易地解决这个问题。
我花了相当多的时间来研究Visual C++的延迟载入特性，我必须声明的是，Microsoft非常 好地实现了这一特性。它不仅提供了许多特性，而且在所有版本的Windows上都能非常好 的工作。
但是，它仍然存在一些局限性，值得在此一提，具体如下。
第20章DLL高级技术
•	一个导出了字段①的DLL是无法延迟载入的。
•	Kemel32.dll模块是无法延迟载入的，这是因为必须载入该模块才能调用 LoadLibrary 和 GetProcAddress。
•	不应该在DIIMain入口点函数中调用一个延迟载入的函数，因为这样可能会导致程 序崩溃。
要进一步了解延迟载入的局限性，请参阅题为u Constraints of Delay Loading DLLs”的文章, 网址为 http://msdn2.microsoft.com/en-us/library/yx 1 x886y(VS.80).aspx。
让我们先从简单的任务开始：让延迟载入DLL能够正常工作。首先，创建一个DLL,再创 建一个可执行文件，这些都和以往没有任何不同。但在链接可执行文件的时候，我们必须 修改一些链接器开关。下面是需要增加的两个链接器开关：
•	/Lib:DelayImp.lib
•	/DelayLoad:MyDll.dll
警告/DELAYLOAD和/DELAY链接器开关是不能在源代码中通过#pragma comment(linker,来设置的。我们需要在项目属性中设置这两个链接器开关。
“Delay Loaded DLLs” 选项是通过 Configuration Properties/Linker/Input 属性页来设置的, 如下图所示。
"Delay Loaded DLL” 选项是通过 Configuration Properties/Linker/Advanced 属性页来设置 的，如下图所示。
572
①译注：或数据，亦即全局变量•
ndows核心编程（第5版）
/Lib开关告诉链接器要将指定的函数_delayLoadHelper2嵌入到我们的可执行文件中。第 二个开关告诉链接器下列事项。
•	将MyDll.dll从可执行模块的导入段中去除，这样当进程初始化的时候，操作系统 的加载程序就不会隐式地载入该DLL。
•	在可执行模块中嵌入一个新的延迟载入段（即Delay Import section,称为.didata）来表 示要从MyDll.dll中导入哪些函数。
•	通过让对延迟载入函数的调用跳转到_delayLoadHelper2函数，来完成对延迟载入 函数的解析。
应用程序运行的时候，对延迟载入函数的调用实际上会调用_delayLoadHelperl函数。这 个函数会引用那个特殊的延迟载入段，并会先后调用LoadLibrary和GetProcAddresSo 一 旦得到了对应的延迟载入函数的地址，_delayLoadHe!per2会修复对该函数的调用，这样 今后的调用将直接调用该延迟载入函数。注意，同一个DLL中的其他函数仍然必须在第一 次被调用的时候修复。另外请注意，我们可以多次指定/DelayLoad链接器开关——每个开 关对应一个我们想要延迟载入的DLL。
好了，就这么多了。就是这么简单！虽然延迟载入函数的使用的确非常简单，但我们还应 该考虑其他一些问题。通常，当操作系统的加载程序载入我们的可执行文件时，会试图载 入必需的DLL。如果无法载入一个DLL,那么加载程序会显示一条错误消息。但对延退载 入的DLL来说，在初始化的时候加载程序不会检查该DLL是否存在。如果当一个延迟载 入函数被调用的时候加载程序无法找到该DLL,那么_delayLoadHelper2函数会抛出一个 软件异常。我们可以使用结构化异常处理（structured exception handling ,后面简称为SEH） 来捕捉到这个异常并让应用程序继续运行。如果不捕捉该异常，那么进程将会终止。（SEH 在第23〜25章中介绍。）
如果_delayLoadHelper2能够找到DLL,但无法在DLL中找到我们试图调用的函数，那
第20章DLL高级技术
么会产生另一个问题。举个例子，如果加载程序找到的是该DLL的一个老版本，就会发生 这种情况。在这种情况下，_delayLoadHelper2也会抛出一个软件异常，刚才提到的规则 在此同样适用。下一节展示的示例程序显示了如何编写正确的SEH代码来对这些错误进行 处理。
我们会发现示例程序的代码中有许多与SEH错误处理无关的其他内容，这些内容与延迟载 入DLL提供的一些额外的特性有关，我们马上就会对这些特性进行介绍。如果不需要这些 更加高级的特性，那么我们可以删除相应的代码。
可以看到，Visual C++ 定义了两个软件异常码(exception code): VcppException (ERROR_SEVERITY_ERROR , ERROR_MOD_NOT_FOUND)和 VcppException (ERROR_SEVERITY_ERROR, ERROR_PROC_NOT_FOUND)。它们分别表示 DLL 模 块未找到或函数未找到。异常过滤函数DelayLoadDllExceptionFilter会对这两个异常码进 行检查。如果抛出的异常不是其中的任何一个，那么同任何合格的过滤器一样，该过滤器 会返回EXCEPTION_CONTINUE_SEARCHo (我们绝对不应该吞掉那些不知道该如何处 理的异常。)但是，如果抛出的异常是两者之一，那么_delayLoadHelper2函数会提供一个 指向DelayLoadlnfo结构的指针，其中包含了一些额外的信息oDelayLoadlnfo结构在Visual C++的Delaylmp.h中定义如下：
typedef struct DelayLoadlnfo ( DWORD	Cb;	//
PCImgDelayDescr pidd；	//
FARPROC *	ppfn；	//
LPCSTR	szDll;	//
DelayLoadProc dip;	//
HMODULE	hmodCur；	//
FARPROC	pfnCur；	//
DWORD	dwLastError; //
} DelayLoadlnfo, * PDelayLoadlnfo
Size of structure
Raw data (everything is there)
Points to address of function to load Name of dll
Name or ordinal of procedure hlnstance of loaded library Actual function that will be called Error received
这个数据结构是由_delayLoadHelper2函数来分配和初始化的。在函数动态地载入DLL 并取得被调用函数的地址的过程中，它会填写结构中的成员。在我们的SEH过滤器内部， 成员szDII指向我们试图载入的DLL的名字，我们试图查找的函数的名字在dip成员中。 由于我们可以通过序号或通过名字来查找函数，因此dip成员的类型看起来像下面这样： typedef struct DelayLoadProc (
BOOL fImportByName;
union {
LPCSTR szProcName；
DWORD dwOrdinal;
}；
} DelayLoadProc;
如果成功地载入了 DLL,但其中不包含想要的函数，我们还可以查看hmodCur成员来知 道DLL被载入到内存地址中的何处。我们还可以查看dwLastError成员来知道是什么错误 引发的异常，但对异常过滤器来说可能没有这个必要，因为异常码已经告诉了我们到底发 生了什么。成员pfnCur包含了想要查找的函数的地址。在异常过滤器中，这个值始终都 是NULL,这是因为_delayLoadHelper2无法找到该函数的地址。
师dows核心编程(第5版)
剩下的成员中，cb用于版本控制，pidd指向嵌入在模块中的延迟载入段，其中包含了延迟 载入DLL和延迟载入函数的列表。成员ppfn是一个地址，若函数查找成功，则其地址会 保存在这个成员中。最后两个成员＞_delayLoadHelper2函数内部使用的，它们用于非常 高级的用途，我们基本上不需要查看或理解它们。
到目前为止，我们已经讲述了使用延迟载入DLL并从错误情况中恢复的基本知识。但是， Microsoft实现的延迟载入DLL提供了更多的特性。例如，应用程序可以将一个延迟载入的 DLL卸载。假设我们的应用程序必须要用一个指定的DLL来打印用户文档。这个DLL是 延迟载入DLL的一个绝佳选择，因为大多数时候它都不会被用到。但是，如果用户选择打 印命令，那么我们可以调用DLL中的一个函数，这样系统就会自动载入该DLLo这非常好, 但当文档打印完毕后，用户可能不会立刻再打印另一份文档，因此为了释放系统资源，我 们可以将该DLL卸载。如果用户决定再打印另一份文档，那么系统会在需要的时候再次载 入该DLL。
为了卸载一个延迟载入的DLL,我们必须做两件事情。首先，必须在构建可执行文件的时 候指定一个额外的链接器开关(/Delay:unload)o其次，必须修改源代码，在我们想要卸载 DLL 的地方调用_FUnloadDelayLoadedDLL2 函数：
BOOL _FUnloadDelayLoadedDLL2(PCSTR szDll)；
链接器开关/Delay:unload告诉链接器在文件中嵌入另一个段。这个段包含必要的信息，来 重置我们己经调用过的函数，这样当程序调用这些函数的时候，会再次调用 _delayLoadHelper2函数。调用_FUnloadDelayLoadedDLL2的时候，需要传入我们想要 卸载的延退载入的DLL的名字。该函数会引用文件的卸载段，将该DLL所有的函数地址 重置。然后_FUnloadDelayLoadedDLL2 会调用 FreeLibrary 来卸载该 DLL。
有一些要点需要指出。第一，我们要确保自己不是通过调用FreeLibrary来卸载DLL的， 否则函数地址将不会被重置，这样当我们下一次试图调用DLL中的函数时，就会引发访问 违规。第二，当我们调用_FUnloadDelayLoadedDLL2的时候，我们传入的DLL的名字不 应该包含路径，而且名字中字母的大小写必须和传给/DelayLoad链接器开关的DLL名字的 大小写完全相同，否则，_FUnloadDelayLoadedDLL2将会失败。第三，如果根本不打算 卸载一个延迟载入的DLL,那么就不必指定/Delay:unload链接器开关，这样还可以减小可 执行文件的大小。最后，如果在一个模块中调用_FUnloadDelayLoadedDLL2,但该模块 在构建的时候没有使用/Delay:unload开关，那么也不会发生什么不好的事情： _FUnloadDelayLoadedDLL2 会什么也不做并返回 FALSE。
延迟载入DLL的另一项特性是，在默认的情况下，我们调用的函数会被绑定到进程地址空 间中的一个内存地址上，这个地址是系统认为该函数应该在的位置。(本章稍后会对绑定进 行介绍。)由于创建可绑定的延迟载入DLL段会增加可执行文件的大小，因此链接器也支 持一个/Delay:nobind开关。因为通常情况下绑定都是需要的，因此大多数应用程序不应该 使用这个链接器开关。
575*576
第20章DLL高级技术
延迟载入DLL的最后一项特性是为高级用户设计的，它也真正显示了 Microsoft对细节的 关注。当_delayLoadHelper2执行的时候，可以调用一些我们提供的挂钩函数(hook function)o这些函数可以接收_delayLoadHelperl的进度通知和错误通知。此外，这些函 数还可以改变载入DLL以及得到函数虚拟地址的方式。
为了得到通知或覆盖默认的行为，我们必须在源代码中做两件事情。首先，必须编写一个 挂钩函数，它与DelayLoadApp.cpp中的DliHook函数相似。DliHook骨架函数并不会影响 _delayLoadHelper2的操作。为了改变它的作为，在DliHook骨架函数的基础上，根据需 要对它进行修改，然后告V5_delayLoadHelper2要查找的函数的地址。
在Delaylmp.lib静态链接库的内部，定义了两个全局变量：_pfnDliNotifyHook2和 _ fnDliFailureHook20这两个变量的类型都是PfnDliHook：
typedef FARPROC (WINAPI *PfnDliHook)(
unsigned dliNotify,
PDelayLoadinfo pdli)；
我们可以看到，这个数据类型是一个函数，它与DliHook函数的原型相符。Delaylmp.lib 在内部将这两个函数初始化为NULL,这告诉_delayLoadHelper2不要调用任何挂钩函数。 为了让系统调用我们的挂钩函数，我们必须将这两个变量之一设为挂钩函数的地址。在示 例程序的代码中，我在全局作用域内添加了下面两行代码：
PfnDliHook   fnDliNotifyHook2	= DliHook；
PfnDliHook __fnDliFailureHook2 = DliHook；
我们可以看到，_delayLoadHelper2实际上用到了两个回调函数，一个用来报告通知，另 一个用来报告失败。由于这两个函数的原型完全相同，而且第一个参数dliNotify可以告诉 我们函数被调用的原因是什么，因此为了方便起见，我总是创建一个函数并让两个变量都 指向这个函数。
提示 www.DependencyWalker.com提供的DependencyWalker工具可以让我们列出链接时 的依赖关系——既包括静态载入，也包括延迟载入。但它也可以在运行的时候记录 对LoadLibrary/GetProcAddress的调用，这完全要归功于它的剖析(profiling)特性。
DelayLoadApp示例程序
本节稍后列出的DelayLoadApp应用程序(20-DelayLoadApp.exe),展示了为了充分利用延迟 载入DLL,我们需要做的一切。为了演示的需要，示例程序只使用了一个DLL,该DLL 的代码在本书配套网页的20-DelayLoadLib目录中。
由于示例程序会自己载入20-DelayLoadLib模块，因此当我们运行示例程序的时候，加载 程序不会将该模块映射到进程的地址空间中。示例程序会定期调用IsModuleLoaded,这个 函数用来显示一个消息框，告诉我们模块是否已经被载入到进程的地址空间中，仅此而已。 当应用程序一开始启动的时候，不会载入20-DelayLoadLib模块，因此程序会显示图20-4
Endows核心编程（第5版）
所示的消息框。
Module H20-DelayLoadLib" is not loaded.
图 20-4 DelayLoadApp 表示 20-DelayLoadLib 模块尚未被载入
应用程序然后调用一个从DLL中导入的函数，这使得_delayLoadHelper2函数自动地载入 该DLL。当函数返回的时候，会显示图20.5所示的消息框。
图 20-5 DelayLoadApp 表示 20-DelayLoadLib 模块已经被载入
当这个消息框消失的时候，示例程序会调用DLL中的另一个函数。由于这个函数在同一个 DLL中，因此系统不会将该DLL再次载入到进程的地址空间中，而会解析得到新函数的地 址并用该地址来调用新函数。
这时，示例程序调用了_FUnloadDelayLoadedDLL2来将20-DelayLoadLib模块卸载。
IsModuleLoaded调用会再次显示图20.4所示的消息框。最后，示例程序又会调用一个导 入函数，这使得系统会重新载入20-DelayLoadLib模块，这样最后那个IsModuleLoaded调 用会显示图20-5所示的消息框。
如果一切正常，那么示例程序会按照刚才描述的方式运行。但是，如果我们在示例程序开 始运行之前删除20-DelayLoadLib模块，或者该模块中不包含其中的一个导入函数，那么 系统会抛出异常。示例程序显示了如何“得体地”从这种情况下恢复。
最后，示例程序还显示了如何设置延迟载入挂钩函数。虽然DliHook骨架函数并没有做什 么有意思的事情，但它捕捉了各种通知并说明了在收到这些通知的时候我们可以做些
什么。
DelayLoadApp. cpp
/********************m******m**f***.*****_)M*********4**** ***** ★*••***
Module： DelayLoadApp.cpp Notices： Copyright (c) 2008 Jeffrey Richter & ********************************★*******〕
#include ■..\CommonFiles\CmnHdr.h" #include <Windowsx.h>
#include <tchar.h>
七四；以电瑜标晦Nasftrre
*	淋* 书射**何舒** ••*•**★*•★
/* See Appendix A. */
第20章DLL高级技术
#include <StrSafe.h>
///////////////////////////////////////////////////////////////////////////////
#include <Delayiznp.h> // For error handling & advanced features
#include "..\20-DelayLoadLib\DelayLoadLib.h"	// My DLL function prototypes
///////////////////////////////////////////////////////////////////////////////
// Statically link ___delayLoadHelper2/__FUnloadDelayLoadedDLL2 ♦pragma comment(lib, •Delayimp.lib*)
// Note： it is not possible to use #pragma comment(linker, ”,) // for /DELAYLOAD and /DELAY
// The name of the Delay-Load module (only used by this sample app) TCHAR g_szDelayLoadModuleName[] = TEXT(-20-DelayLoadLib-);
///////////////////////////////////////////////////////////////////////////////
// Forward function prototype
LONG WINAPI DelayLoadDl1ExceptionFi11er(PEXCEPTION_POINTERS pep);
///////////////////////////////////////////////////////////////////////////////
void IsModuleLoaded(PCTSTR pszModuleName) (
HMODULE hmod = GetModuleHandle(pszModuleName);
char sz[100]；
#ifdef UNICODE
StringCchPrintfAfsz, _countof(sz), "Module \"%S\W is %Sloaded."# pszModuleName# (hmod == NULL) ? LBnot " : h・・)；
#else
StringCchPrintfA(szr _coixntof (sz), "Module \"%s\" is %sloaded. *, pszModuleName, (hmod == NULL) ? "not " : ■");
#endif
chMB(sz);
}
//////////////////•////////〃//////////〃/〃////〃/////////〃///////////////////
int WINAPI ^tWinMain(HINSTANCE hlnstExe, HINSTANCE, PTSTR pszCmdLine, int) {
// Wrap all calls to delay-load DLL functions inside SEH
—try (	；	-
int x = 0;
// If you•re in the debugger, try the new Debug.Modules menu item to // see that the DLL is not loaded prior to executing the line below IsModu1eLoaded(g_szDelayLoadModuleName)；
x = fnLibO ; // Attempt to call delay-load function ；
// Use Debug.Modules to see that the DLL is now loaded IsModuleLoaded (g_szDelayLoadModuleNeime)；
Endows核心编程（第5版）
x = fnLib2(); If Attempt to call delay-load function
// Unload the delay-loaded DLL
// NOTE: Name must exactly match /DelayLoad:(DllName)
_FUnloadDelayLoadedDLL2("20-DelayLoadLib.dll");
// use Debug.Modules to see that the DLL is now unloaded IsModuleLoaded (g__szDelayLoadModuleName);
x = fnLib(); // Attempt to call delay-load function
// Use Debug.Modules to see that the DLL is loaded again IsModuleLoaded(g_szDelayLoadModuleName);
}
_except (DelayLoadDllExceptionFilter(GetExceptionlnformationO)) ( // Nothing to do in here, thread continues to run normally
}
// More code can go here
return(0);
}
///////////////////////////////////////////////////////////////////////////////
LONG WINAPI DelayLoadDllExceptionFilter(PEXCEPTION_POINTERS pep)(
// Assume we recognize this exception
LONG iDisposition = EXCEPTIQN_EXECUTE_HANDLER;
// If this is a Delay-load problem. Exceptionlnformation[0] points
// to a DelayLoadlnfo structure that has detailed error info PDelayLoadinfo pdli =
PDelayLoadlnfo(pep->Except ionRecord->Except ioninformat ion[0])；
// Create a buffer where we construct error messages
char sz[500] = { 0 };
switch (pep->ExceptionRecord->ExceptionCode) {
case VcppException(ERROR_SEVERITY_ERROR, ERROR_J4OD_NOT_FOUND):
// The DLL module was not found at runtime
StringCchPrintfA(szr _countof(sz)/ "Dll not found: %s", pdli->szDll); break;
case VcppExcept ion(ERROR_SEVERITY_ERROR, ERROR_PROC顼OT_FOUND):
// The DLL module was found, but it doesn't contain the function
if (pdli->dlp.fImportByName) ( StringCchPrintfA(sz, _countof(sz), "Function %s was not found in %s"# pdli->dlp. szProcNeune, pdli->szDll);
} else {	s.	- -■
StringCchPrintfA(sz, _countof (835>> ■'• Function ordinal %d was not found in %s", pdli->dlp.dwOrdinal, pdli->szDll)察-:寸蜩对:K 欢七
} break ；	.
default：
//We don't recognize this exception
IDisposition x EXCEPTION^CONTINUE^SEARCH;	； %£、"	• 知；
break；	；，…八，：.： W"-	'• >
•	. f *, A' • * • I. 、 C •	v -I.* .. "	. V" . . " 1 " .	• " 1,
if (IDisposition == EXCEPTION_EXECUTE__HANDLER) {	亏：
//We recognized this error and constructed 'a message, show it
chMB(sz);	•，；'、"	'
第20章DLL高级技术
return(IDisposition); }
////////////////〃/////////////////////////////////////////////////〃//////////
// Skeleton DliHook function that does nothing interesting FARPROC WINAPI DIiHook(unsigned dliNotify, PDelayLoadInfo pdli) {
FARPROC fp = NULL; // Default return value
// NOTE: The members of the DelayLoadlnfo structure pointed // to by pdli show the results of progress made so far.
switch (dliNotify) (
case dliStartProcessing：
// Called when _delayLoadHelper2 attempts to find a DLL/function // Return 0 to have normal behavior or nonzero to override
II everything (you will still get dliNoteEndProcessing) break；
case dliNotePreLoadLibrary:
// Called just before LoadLibrary
// Return NULL to have _delayLoadHelper2 call LoadLibary
//or you can call LoadLibrary yourself and return the HMODULE fp = (FARPROC) (HMODULE) NULL;
break；
case dliFailLoadLib:
// Called if LoadLibrary fails
// Again, you can call LoadLibary yourself here and return an HMODULE // If you return NULL, _delayLoadHelper2 raises the
// ERROR_MODJNOT_FOUND exception
fp = (FARPROC) (HMODULE) NULL;
break；
case dliNotePreGetProcAddress:
// Called just before GetProcAddress	・
// Return NULL to have _de1ayLoadHeIper2 call GetProcAddress, // or you can call GetProcAddress yourself and return the address fp = (FARPROC) NULL;
break;
case dliFailGetProc:
// Called if GetProcAddress fails
II You can call GetProcAddress yourself here and return an address
// If you return NULL, _delayLoadHelper2 raises the
// ERROR_PROCJ?JOT_FOUND exception fp = (FARPROC) NULL;
break；
case dliNoteEndProcessing:
// A simple notification that _delayLoadHeIper2 is done
// You can examine the members of the DelayLoadlnfo structure
// pointed to by pdli and raise an exception if you desire break；
)
return(fp)；
///////////////////////////////////////////////////////////////////////////////
// Tell __delayLoadHelper2 to call my hook function
mdows核心编程（第5版）
PfnDliHook __ fnDliNot i fyHook2 = DliHook;
PfnDliHook _ fnDliFailureHook2 = DliHook;
//////////////////////////////// End of File //////////////////////////////////
DelayLoadLib・ cpp
/*****************************•*****•************************************•*****
Module: DelayLoadLib.cpp
Notices: Copyright (c) 2008 Jeffrey Richter & Christophe Nasarre
******************************************************************************y
#include •..\CommonFiles\CmnHdr.h"	/* See Appendix A. */
#include <Windowsx.h>
#include <tchar.h>
///////////////////////////////////////////////////////////////////////////////
#define DELAYLOADLIBAPI extern ・C" _declspec(dllexport) #include "DelayLoadLib.h"
///////////////////////////////////////////////////////////////////////////////
int fnLib() ( return(321)；.
}
///////////////////////////////////////////////////////////////////////////////
int fnLib2() {
return(123);
}
//////////////////////////////// End of File //////////////////////////////////
DelayLoadLib•h
/***★***********************************************************•************** Module: DelayLoadLib.h
Notices: Copyright (c) 2008 Jeffrey Richter & Christophe Nasarre
****★****•*******.************•*******************★**.*********************•****/
#ifndef DELAYLOADLIBAPI
#define DELAYLOADLIBAPI extern "C" _deOlspec(dllimport)
#endif	.	；■. .	,:.
///〃/////////////////////////〃/////////〃〃/〃〃///〃/〃//〃/〃/〃///////////
DELAYLOADLIBAPI int fnLib();
DELAYLOADLIBAPI int fnLib2();
//////////////////////////////// End of File //////////////////////////////////
578-583
第20章DLL高级技术
20.4函数转发器
函数转发器(function forwarder)是DLL输出段中的一个条目，用来将一个函数调用转发到另 ―个DLL中的另一个函数。例如，如果用Visual C++的DumpBin工具来查看Windows Vista 的Kemel32.dll,那么我们会看到类似下面的输出：
C:\Windows\System32>DumpBin -Exports Kernel32.dll (some output omitted)
75	49 CloseThreadpoolIo (forwarded to NTDLL.TpReleaseloCompletion)
76	4A	CloseThreadpoolTimer (forwarded to NTDLL.TpReleaseTimer)
77	4B	CloseThreadpoolWait (forwarded to NTDLL.TpReleaseWait)
78	4C	CloseThreadpoolWork (forwarded to NTDLL.TpReleaseWork)
(remainder of output omitted)
这个输出显示了 4个被转发的函数。如果应用程序调用了 CloseThreadpoolIo, CloseThreadpoolTimer, CloseThreadpoolWait 或 CloseTh readpool Work» 那么我们的可 执行文件会被动态地链接到Kemel32.dllo当可执行文件运行的时候，加载程序会载入 Kemel32.dll并发现被转发的函数实际上是在NTDLL.dll中，然后它会将NTDLL.dll模块也 一并载入。当可执行文件调用CloseThreadpoolIo的时候，它实际上调用的是NTDLL.dll 中的TpReleaseloCompletion函数。CloseThreadpoolIo函数在系统中根本不存在！
如果我们调用CloseThreadpoolIo,那么GetProcAddress会先在Kemel32的导出段中查找， 并发现CloseThreadpoolIo是一个转发器函数，于是它会递归调用GetProcAddress,在 NTDLL.dll 的导出段中查找 TpReleaseloCompletion。
我们也可以在自己的DLL模块中使用函数转发器。最简单的方法是使用pragma指示符， 如下面所示：
// Function forwarders to functions in DllWork
#pragma comment(linker, "/export:SomeFunc=DllWork.SomeOtherFunc")
这个pragma告诉链接器，正在编译的DLL应该输出一个名为SomeFimc的函数，但实际 实现SomeFunc的是另一个名为SomeOtherFunc的函数，该函数被包含在另一个名为 DllWork.dll的模块中。我们必须为每个想要转发的函数单独创建一行pragmao
583部
20.5已知的DLL
系统对操作系统提供的某些DLL进行了特殊处理，这些DLL被称为已知的DLL(known DLL)。除了操作系统在载入它们的时候总是在同一个目录中查找之外，它们与其他的DLL 并没有什么不同。在注册表中有这么一个注册表项：	，
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\
Session Manager\KnownDLLs
用RegEdit.exe工具在我的计算机上查看这个注册表项所得到的结果，如下图所示。
indows核心编程（第5版）
i.					
We (die View Fwonta，Help					
e & SecurePipeSeivcrj		Nim«	Type	D«t*	
人 ServiceCurrent
，SeiviceGroupOrder t> ▲ ServiceProvider ■ & Session Minager
▲	AppCompatCache
▲	Configuration Manager
:▲ DOSDtvKes
—Environment
▲	Executc/e FileRenimeOperabons
r-X VO System :.•山 kernel
A KnownDLLs
> A Memory Management ".① Power
X QuoU Syittm
:b & Subitems
4 A WPA
>	X SNMP
Stilllm&ge
④ Stonge
▲ Syrttmlnform»tJon A M S^itemRcjources TibletPC
>	Jg Terminil Seiver
: & TimeZontlnformabon 0	usbflags
r>	VAN
t> ▲ Video
疫(DefEt) *^«dv»pi32 .土 clbcatq **»)COMDLG32 -t!f|DIIDirectory 4gd,32 ^lERTUTIL
IMAGEHIP j £lMM32 土 kernel £ipk 疫|MSCTF &MWCRT /NORMAUZ 岌nsi 4] ole” *^OLEAUT32 ，/rpcrt4 罚 Setup”] 欢 SHEIL32 巡]SHLWAPI 败 URLMON 凹 user” ^USPIO 土 WIMNET 或 WIOAP32 凹 WS2_32
REG.SZ
RfG.SZ
REG.SZ
REG.SZ
REG.eXPAND.SZ
RfG.SZ
RfG.SZ
REG.SZ
REG.SZ
R£G.SZ
REG.SZ
REG.SZ
REG.SZ
REG.SZ
RIG.SZ
REG.SZ
REG.SZ
REG.SZ
REG.SZ
REG.SZ
REG.SZ
REG.SZ
REG.SZ
RfG.SZ
RfG.SZ
REG.SZ
REG.SZ
MHie not set) a(Mp・32MI clbcatq.dil COMDLG)2.dN %SyrtemRoot%\jy5tem32 gdi32.dll lERTUTU.dll IMAGEHlP.dN MM32.dll kemel32.dll LPK.dll MSCTF.dll MSVCRT.dll NORMAlIZ.dll N9.dll oleJZ.dH OLEAUT32.dll rpcrt4.dll Setupapi.dll SHELL32.dll SHlWAPLdll URLMON.dll U5er32.dll USPlO.dH WMNET.dll WlDAP32.dll WS2J2.dll

我们可•以看到，这个注册表项包含了一组值名①，这些值名是一些DLL的名称。每个值名 的数据正好等于值名加上.dll扩展名。（但这并不是必须的，在后面的一个例子中我们马上 就会看到。）当LoadLibrary或LoadLibraryEx被调用的时候，函数首先会检查我们传入 的DLL的名字是否包含了.dll扩展名。如果没有包含，那么函数会用正常的搜索规则来搜 索这个DLL。
如果我们指定了.dll扩展名，那么这两个函数会先将扩展名去掉，然后再在KnownDLLs 注册表项中搜索，看其中是否有与之相符的值名。如果没有值名与之相符，那么函数会使 用正常的搜索规则。但是，如果找到了与之相符的值名，那么系统会查看与值名相对应的 数据，并试图用该数据来载入DLL。系统还会从这个注册表项的DllDirectory值所表示的 目录中开始搜索 DLL o在 Windows Vista中，DllDirectory的默认值为 %SystemRoot%\System32。
为了举例说明这一过程，假设我们在KnownDLLs注册表项中添加了下列值：
Value name: SomeLib
Value data： SomeOtherLib.dl1
584
调用F面的函数时，系统会用正常的搜索规则来对这个DLL进行定位：
LoadLibrary（TEXT（"SomeLib"））；
但是，如果调用下面的函数，那么系统会发现有一个与之相符的名称。（记住，当系统在检
①译注：value name,即注册表项中-•个值的名称。
第20章DLL高级技术
查注册表的值名时，会将.dll扩展名去掉。)
LoadLibrary(TEXT("SomeLib.dll"))；
因此系统试图载入的DLL是SomeOtherLib.dll,而不是SomeLib.dll o它首先会在 %SystemRoot%\System32目录中查找SomeOtherLib.dllo如果在这个目录中找到了该文件， 那么系统就会将它载入。如果系统未能在这个目录中找到该文件，那么LoadLibrary(Ex)会 失败并返回 NULL,这时调用 GetLastError 将返回 2(ERROR_FILE_NOT_FOUND)。
20.6 DLL重定向
最初开发Windows的时候，内存和磁盘空间都非常宝贵。因此为了节约这些宝贵的资源， Windows的设计目标是尽可能地共享资源。出于这样的考虑，Microsoft建议将多个应用程 序所共享的所有模块放在Windows的系统目录中，这使得系统能够方便地定位和共享文件。 C/C++运行库以及Microsoft Foundation Classes(MFC)就是很好的例子。
随着时间的推移，这成为了一个严重的问题，这是因为安装程序可能会用老版本的文件覆 盖这个目录中的文件，或用不完全兼容的新版本的文件覆盖这个目录中的文件，从而妨碍 用户的其他应用程序的正常运行。今天，硬盘不仅容量大而且价格很便宜，内存也够用而 且相对来说价格比以前要便宜很多。因此Microsoft现在强烈建议开发人员将应用程序的文 件放到自己的目录中，并且绝对不要碰Windows系统目录中的任何东西。这样既可以防止 我们的应用程序妨碍其他应用程序，也可以避免其他应用程序妨碍我们的应用程序。
为了帮助开发人员，Microsoft自Windows2000开始新增了一项DLL重定向特性。这项特 性强制操作系统的加载程序首先从应用程序的目录中载入模块。只有当加载程序无法找到 要找的文件时，才会在其他的目录中搜索。
为了强制加载程序总是先检查应用程序的目录，我们所要做的就是将一个文件放到应用程 序的目录中。这个文件的内容无关紧要，但它的文件名必须是AppName.locaL举个例子， 如果我们有一个名为SuperApp.exe的可执行文件，那么重定向文件的名称必须是 Super App.exe.local o
LoadLibrary(Ex)在内部做了修改，来检查这个文件存在与否。如果应用程序的目录中存在 这个文件，那么系统会载入这个目录中的模块。如果应用程序的目录中不存在这个文件， 那么LoadLibrary(Ex)的工作方式与以往相同。注意，除了创建一个.local文件，我们还可 以创建一个名为.local的文件夹。在这种情况下，我们可以将自己的DLL保存在这个文件 夹中，让Windows能够轻易地找到它们。
对已注册的COM对象来说，这项特性极其有用。它允许应用程序将它的COM对象DLL 放在自己的目录中，这样注册了同一个COM对象的其他应用程序就不会妨碍到我们的应 用程序。
®585»
lows核心编程(第5版)
注意，为了安全性的缘故，Windows Vista中这项特性在默认情况下是关闭的——因 为它可能会使系统从应用程序的文件夹中载入伪造的系统DLL,而不是从Windows 的系统文件夹中载入真正的系统DLLo为了打开这项特性，我们必须在 HKLM\Software\Microsoft\WindowsNT\CurrentVersion\Image File Execution Options 注册表 项中增加一个条目DWORD DevOverrideEnable,并将它的值设为1。
说明 自从Windows XP开始并随着Microsoft .NET应用程序的兴起，即使在非托管代码 中，我们也可以充分利用应用程序隔离(isolated application)和并列程序集 (side-by-side assembly)。具体的细节请参阅题为"Isolated Applications and Side-by-side Assemblies” 的文章，网址为 http://msdn2.microsoft.com/en-us/library/aa375193.aspxo
20.7模块的基地址重定位
每个可执行文件和DLL模块都有一个首选基地址(preferred base address),它表示在将模块 映射到进程的地址空间中时的最佳内存地址。当我们在构建一个可执行模块的时候，链接 .器会将模块的首选基地址设为0x004000000对DLL模块来说，链接器会将首选基地址设 为 0x10000000o 我们可以用 Microsoft Visual Studio DumpBin 工具(加上/headers 开关)来查 看文件映像的首选基地址。下面是使用DumpBin来转储(dump)它自己的文件头信息。
C:\>DUMPBIN /headers dumpbin.exe
Microsoft (R) COFF/PE Dumper Version 8.00.50727.42
Copyright (C) Microsoft Corporation. All rights reserved.
Dump of file dumpbin.exe
PE signature found
File Type: EXECUTABLE IMAGE
FILE HEADER VALUES
14C machine (i386)
3 number of sections
4333ABD8 time date stamp Fri Sep 23 09:16:40 2005
0 file pointer to symbol table
0 number of symbols
E0 size of optional header
123 characteristics
Relocations stripped
Executable
Application can handle large (>2GB) addresses
32 bit word machine
OPTIONAL HEADER VALUES
10B magic # (PE32)
8.00 linker version
1200 size of code
800 size of initialized data 0 size of uninitialized data 170C entry point (0040170C)
1000 base of code
3000 base of data
400000 image base (00400000 to 00404FFF) <- Module's preferred base address 1000 section alignment
第20章DLL高级技术
200 file alignment
5.00 operating system version
8.00 image version
4.00 subsystem version
0 Win32 version
5000 size of image
400 size of headers
1306D checksum
3 subsystem (Windows CUI)
8000 DLL characteristics
Terminal Server Aware
100000 size of stack reserve
2000 size of stack commit
100000 size of heap reserve
1000 size of heap commit
0 loader flags
10 number of directories
当操作系统运行这个可执行模块的时候，加载程序会为新的进程创建一个虚拟地址空间。 然后加载程序会将可执行文件映射到内存地址0x00400000处，将DLL模块映射到内存地 址0x10000000处。为什么首选基地址如此重要？看一看下面的代码便知：
int g_x；
void Func() (
g_x = 5； // This is the important line.
}
当编译器处理Func函数的时候，编译器和链接器会生成类似下面的机器码：
MOV (0x00414540), 5
换句话说，编译器和链接器在生成机器码的时候，将g_X变量的地址固定死了，也就是 0x00414540o这个地址是机器码中的地址，它完金标识了 gjc变量在进程地址空间中所处 的位置。但显然，当且仅当该可执行文件被载入到它的首选基地址0x00400000的时候，这 个内存地址才是正确的。
如果一个DLL模块中包含完全相同的代码，那又会如何？在这种情况下，编译器和链接器 会生成类似下面的机器码：
MOV [0x10014540], 5
我们再一次注意到DLL的g_x变量的虚拟内存地址被固定死了，并被保存在磁盘上的文件 映像中。同样，只有当DLL被载入到它的首选基地址的时候，这个内存地址才是绝对正 确的。
587
好了，假设我们现在正在设计一个应用程序，该应用程序需要两个DLL。在默认的情况下， 链接器会将.exe模块的首选基地址设为0x00400000,并将两个DLL的首选基地址都设为 0x10000000o如果我们试图运行该.exe文件，那么加载程序会创建一个虚拟地址空间，并 将.exe模块映射到内存地址0x00400000处。然后加载程序会将第一个DLL映射到内存地 址0x10000000处。但是现在，当加载程序试图将第二个DLL映射到进程的地址空间中时， 它不可能将该模块映射到其首选基地址上。加载程序必须对第二个DLL模块进行重定位，

Endows核心编程（第5版）
把它放到别的地方。
对-个可执行文件（或DLL）模块进行重定位绝对是一个痛苦的过程，我们应该想方设法避 免这个过程。让我们来看一看为什么。假设加载程序将第二个DLL重定位到地址 0x20000000处，那么将g^x变量修改为5的代码应该是：
MOV [0x20014540], 5
但文件映像中的代码却是：
MOV [0x10014540], 5
如果直接让文件映像中的代码执行，那么第一个DLL模块中的一个4字节值将被数值5所 覆盖。由于加载程序不可能允许这种情况的发生，因此它必须通过某种方式来对代码进行 修正。当链接器在构建我们的模块时，会将重定位段（relocation section）嵌入到生成的文件 中。这个段包含一个字节偏移量的列表，每个字节偏移量表示一条机器指令所使用的一个 内存地址。如果加载程序能够将模块载入到它的首选基地址，那么系统就不会访问模块的 重定位段。我们当然希望这样——我们绝对不会希望系统去使用模块的重定位段。
但另一方面，如果加载程序无法将模块载入到它的首选基地址，那么系统会打开模块的重 定位段并遍历其中所有的条目。对每一个条目，加载程序会先找到包含机器指令的那个存 储页面，然后将模块的首选基地址与模块的实际映射地址之间的差值，加到机器指令当前 正在使用的内存地址上。
因此，在前面的例子中，第二个DLL被映射到0x20000000,而它的首选基地址是 0x10000000o这样两个地址的差值就是0x10000000,将这个差值加到机器指令使用的地址 上，就得到下面的代码：
MOV （0x20014540], 5
现在，第二个DLL中的这条指令就能够正确地引用到它自己的g_x变量了。
当一个模块无法被载入到它的首选基地址时，存在以下两个主要的缺点。
•	加载程序必须遍历重定位段并修改模块中大量的代码。这个过程不仅是一大性能杀 手，而且也确实会损害应用程序的初始化时间。
•	当加载程序写入到模块的代码页面中时，系统的写时复制机制会强制这些页面以系 统的页交换文件为后备存储器。
588
第二点真的很糟糕。它意味着系统不能再抛弃模块的代码页面，并重新载入模块在磁盘上 的文件映像。取而代之的是，系统必须在需要的时候将内存页面换出到系统的页交换文件, 并将页交换文件中的页面换入到内存。这同样会损害性能。但等一下，还有更糟糕的。由 于页交换文件是所有模块的代码页面的后备存储器，因此这会减少可供系统中所有进程使 用的存储器的数量。这限制了用户的电子表格的大小、字处理文档的大小、CAD制图的大 小、位图的大小，等等。
顺便提一下，我们也可以创建一个不包含重定位段的可执行文件或DLL模块。在构建模块
第20章DLL高级技术
的时候使用/FIXED开关就能够达到这个目的。这个开关可以让模块的大小变小，但它同时 意味着模块无法被重定位。如果模块无法被载入到它的首选基地址，那么它将完全不会被 载入。如果加载程序必须对模块进行重定位，但模块中不包含重定位段，那么加载程序会 终止整个进程并向用户显示一条"进程非正常终止（Abnormal Process Termination）v消息。
对一个资源DLL来说，这是一个问题。一个资源DLL不包含任何代码，因此在链接的时 候使用/FIXED开关是非常合理的。但是，如果一个资源DLL无法被载入到它的首选地址, 那么该模块将根本不会被载入。这简直是可笑！为了解决这个问题，链接器允许我们在创 建模块的时候在文件头中嵌入一些信息，来表示该模块之所以不包含重定位信息，是因为 没有这个必要。Windows的加载程序会使用文件头中的这些信息，并能够在不牺牲性能和 页交换文件空间的前提下，将资源DLL载入。
为了创建一个不包含任何重定位信息的映像，应该用/SUBSYSTEMiWINDOWS, 5.0开关 或/SUBSYSTEM:CONSOLE,5.0开关，而不要指定/FIXED开关。如果链接器检测到模块 中没有东西需要进行重定位修正，那么它会将模块中的重定位段省略掉，并在文件头中关 闭一个特殊的IMAGE_FILE_RELOCS_STRIPPED标志。当Windows载入该模块的时候, 会发现该模块可以重定位（因为IMAGE_FILE_RELOCS_STRIPPED被关闭），但它实际上 并不包含重定位信息（因为重定位段不存在）。注意，这是Windows 2000加载程序的一项新 特性，因此/SUBSYSTEM开关的最后一部分必须是5.0也就不足为奇了。
我们现在已经理解了首选基地址的重要性。因此，如果要将多个模块载入到同一个地址空 间中，那么我们必须给每个模块指定不同的首选基地址。Visual Studio的Project Properties 对话框使我们能够非常容易地对首选基地址进行设置，我们要做的就是先选中 Configuration Properties\Linker\Advanced 属性页，然后在 Base Address 一栏中输入一个数值， 默认情况下这一栏是空白的。在下图中，我将自己的DLL模块的基地址指定为0x20000000。
589
indows核心编程（第5版）
顺便提一下，为了减少地址空间碎片，我们应该总是先从高内存地址开始载入DLL,然后 再到低内存地址。
说明 首选基地址必须从分配粒度的边界开始。在时至今日的所有平台中，系统的分配粒 度都是64KB,但今后这有可能会发生变化。第13章更详细地讨论了分配粒度。
好了，这听起来不错。但如果我们要在一个地址空间中载入大量的模块，那该怎么办呢？ 如果有一种简单的方法，能让我们给所有模块设置不错的首选基地址，岂不很好？！幸运的 是，这样的方法是存在的。
Visual Studio提供了一个名为Rebase.exe的工具。如果在运行Rebase的时候不指定任何命 令行参数，那么它会显示下面的信息，告诉我们它的用法：
usage: REBASE [switches)
[-R image-root [-G filename] [-0 filename] [-N filename)] image-names...
One of -b and -i switches are mandatory.
[-a] Does nothing
[-b InitialBase] specify initial base address
[-c cof fbase__f ilename] generate cof fbase. txt
-C includes filename extensions, -c does not
[-d] top down rebase
[-e SizeAdjustment] specify extra size to allow for image growth
[-f] Strip relocs after rebasing the image
[~i coffbase_filename) get base addresses from coffbase_filename [-1 logFilePath] write image bases to log file.
[-p] Does nothing
[-q] minimal output
[-s] just sum image range
[-u symbol_dir] Update debug info in .DBG along this path
(-v] verbose output
[-x symbol_dir] Same as -u
[-z] allow system file rebasing
[-?] display this message
(-R image_root] set image root for use by -G, -0, -N
(-G filename] group images together in address space
[-0 filename] overlay images in address space
(-N filename] leave images at their original address
-G, -0, -N, may occur multiple times. File ■filename" contains a list of files (relative to "image-roof)
• image-names' can be either a file (foo.dll) or files (*.dll) or a file that lists other files (0files.txt). If you want to rebase to a fixed address (ala QFE) use the iles.txt format where files.txt contains address/size combos in addition to the filename
.591
Platform SDK文档对Rebase工具进行了介绍，因此这里我就不再赘述。但是，通过调用 ImageHlp API提供的ReBaseimage函数，我们也可以实现自己的重定位工具：
BOOL ReBaseimage(
PCSTR CurrentImageName, // Pathname of file to be rebased
第20章DLL高级技术
// Symbol file path so debug info
// is accurate
// TRUE to actually do the work; FALSE
// to pretend
// FALSE to not rebase system images
// TRUE to rebase the image below
// an address
// Maximum size that image can grow to (zero if don' t care) //	Receives	original image	size
//	Receives	original image	base	address
//	Receives	new image size
//	Receives	new image base	address
// New timestamp for imaae if non zero
PCSTR SymbolPath,
BOOL bRebase,
BOOL bRebaseSysFileOk,
BOOL bGoingDown,
ULONG CheckImageSize,
ULONG* pOldlmageSize,
ULONG* pOldlmageBase,
ULONG* pNewImageSize,
ULONG* pNewImageBase/
ULONG Timestamp);
如果在执行Rebase工具的时候传给它一组映像文件名，那么它会执行下列操作。
(1)	它会模拟创建一个进程地址空间。
(2)	它会打开应该被载入到这个地址空间中的所有模块，并得到每个模块的大小以及它们 的首选基地址。
(3)	它会在模拟的地址空间中对模块重定位的过程进行模拟，使各模块之间没有交叠。
(4)	对每个重定位过的模块，它会解析该模块的重定位段，并修改模块在磁盘文件中的 代码。
(5)	为了反映新的首选基地址，它会更新每个重定位过的模块的文件头。
594592
Rebase是一个很棒的工具，我极力推荐读者使用它。读者应该在自己的构建过程的后期， 等应用程序所有的模块都已经构建完成后运行它。另外，如果用了 Rebase,那么我们可以 忽略Project Properties对话框中的基地址设定。链接器会给DLL指定基地址0x10000000, 但Rebase会覆盖这个地址。
顺便说一句，我们从来不需要而且也不应该对随操作系统一起发布的任何模块进行重定位。 Microsoft在发布Windows之前己经用Rebase工具对操作系统提供的所有文件进行了重定 位，这样即使我们将操作系统中的所有模块都映射到同一个地址空间中，也不会发生交叠 的情况。
我给第4章介绍的Processlnfo.exe示例程序添加了一个特殊的特性。这个工具能够列出位 于一个进程的地址空间中的所有模块。在BaseAddr列的下面，我们可以看到各模块被载入 到的虚拟内存地址。BaseAddr列的右面是ImagAddr列。通常该列是空白的，表示模块被 载入到它的首选基地址。我们当然希望所有模块都是这样，但如果看到一个地址显示在括 号内，那说明该模块没有被载入到它的首选基地址，括号内的地址表示从该模块的磁盘文 件的文件头中读取的首选基地址。
下图展示了用Processlnfo.exe I具来查看devenv.exe进程所得到的结果。注意，有一个模 块没有被载入到它的首选基地址。我们还注意到这个模块的首选基地址是0x00400000, 即.exe的默认基地址。这说明这个模块的创建者们并不担心重定位问题——我为他们感到 害臊。
/indows核心编程（第5版）
I.
Proces心 Modulesl VMMapI
line: devenv.exe
0000960, ParentPID-00000628, PriorityClass-8, Threads-15, Heaps-34 Xvista-CNxcnasarre
国
Inforaation:
BaseAddr(IaagAddr)	S	
00400000	460
76EE0000	1.144
75930000	864
76D50000	764
76E10000	780
00020000(00400000)	44
76A60000	680
76C70000	340
Module
C: \Prograa FilesXMicrosof t Visual Studio 8xCoMMon7MDExdevenv. exe C;Windovs\systeM32\ntdll .dll
C：\VindogXsysteB32\kem©132 .dll
C:xWindowsxsystea32xADVAPI32.dll
C:\Vindovs\systeM32\RPCRT4.dll
C:\PrograM FilesXMicrosoft Visual Stxidio 8xCoMMon7MDE\custsat.dll C: Windovs	2\»svcrt.dll
C:\Uindovs	2xSHLWAPI.dll
C

20.8模块的绑定
基地址重定位非常重要，能够显著地提高整个系统的性能。但是，我们甚至还能再进一步 提高性能。假设我们己经对应用程序的所有模块进行了基地址重定位。第19章讨论了加载 程序如何查找所有导入符号地址，现在再让我们来回想一下。加载程序将符号的虚拟地址 写入到可执行文件模块的导入段中。这使得在程序引用导入的符号时，实际上引用的是正 确的内存地址。
让我们想一想这个过程，如果加载程序将导入符号的虚拟地址写入到.exe模块的导入段， 那么会写入导入段的后备存储页面。由于这些页面具有写时复制属性，因此它们以页交换 文件为后备存储器。所以我们会遇到一个与基地址重定位相似的问题：系统必须将映像文 件的一部分从内存换出到页交换文件，并从页交换文件换入到内存，而不能直接抛弃内存 中的页而并在需要的时候再从文件的磁盘映像中重新读取。另外，加载程序必须解析（所有 模块的）所有导入符号的地址，这可能会耗费很长的时间。
592*593
我们可以采用模块绑定技术，这样应用程序就可以更快地初始化并使用更少的存储器。对 一个模块进行绑定，是用该模块导入的所有符号的虚拟地址，来对该模块的导入段进行预 处理。当然，为了减少初始化的时间并使用更少的存储器，我们必须在载入模块之前执行 这一操作。
Visual Studio提供了另一个名为Bind.exe的工具，如果在运行的时候不指定任何命令行参 数，那么它会显示下面的信息，告诉我们它的用法：
usage： BIND [switches] image-names...
[-?] display this message
[-c] no caching of import dlls
[-o] disable new import descriptors
[-p dll search path]
（~s Symbol directory] update any associated .DBG file
[-u] update the image
[-v] verbose output
[-x image name） exclude this image from binding
[-yl allow binding on images located above 2G
第20章DLL高级技术
Platform SDK文档对Bind工具进行了介绍，因此这里我就不再赘述。但是，与Rebase相 似，我们也可以通过调用ImageHlp API提供的BindlmageEx函数来实现相同的特性。
BOOL BindlmageEx( DWORD dwFlags, PCSTR pszImageName, PCSTR pszDHPath, PCSTR pszSymbolPath,
// Flags giving fine control over the function
// Pathname of file to be bound
// Search path used for locating image files
// Search path used to keep debug info accurate
PIMAGEHLP_STATUS_ROUTINE pfnStatusRoutine); // Callback function
最后一个参数pfnStatusRoutine是一个回调函数的地址，BindlmageEx会定期调用这个回 调函数，这样我们就能够对绑定过程进行监控。下面是该回调函数的原型：
BOOL WINAPI StatusRoutine(
IMAGEHLP_STATUS_REASON Reason, PCSTR pszImageName,
PCSTR pszDUName,
ULONG_PTR VA,
ULONG_PTR Parameter);
// Module/procedure not found, etc.
// Pathname of file being bound
// Pathname of DLL
// Computed virtual address
// Additional info depending on Reason
如果在执行Bind工具的时候传给它一个映像文件名，它会执行下列操作。
(1)	它会打开指定的映像文件的导入段。
(2)	对导入段中列出的每个DLL,它会查看该DLL文件的文件头，来确定该DLL的首选 基地址。
(3)	它会在DLL的导出段中查看每个符号。
(4)	它会取得符号的RVA,并将它与模块的首选基地址相加。它会将计算得到的地址，也 就是导入符号预期的虚拟地址，写入到映像文件的导入段中。
(5)	它会在映像文件的导入段中添加一些额外的信息。这些信息包括映像文件被绑定到的 各DLL模块的名称，以及各模块的时间戳。
593-594
在第19章中，我们用DumpBin I具来查看了 Calc.exe的导入段。在程序的输出信息的底 部，显示的是与被绑定模块相关的导入信息，这些信息是在第5步中添加的。下面是输出 信息的相关部分：
Header contains the following bound import information： SHELL32.dll [4549BDB4] Thu Nov 02 10:43:16 2006 ADVAPI32.dll [4549BCD2] Thu Nov OLEAUT32.dll [4549BD95] Thu Nov ole32.dll [4549BD92] Thu Nov 02 ntdll.dll [4549BDC9] Thu Nov 02 KERNEL32.dll [4549BD80] Thu Nov GDl32.dll (4549BCD3] Thu Nov 02
USER32.dll [4549BDE0] Thu Nov 02 10:44:00 2006 msvcrt.dll [4549BD61] Thu Nov 02 10:41:53 2006
Bound Bound Bound Bound Bound Bound Bound Bound Bound
to to to to to to to to to
02 10:39:30 2006 02 10:42:45 2006 10:42:42 2006 10:43:37 2006
02 10:42:24 2006
10:39:31 2006
我们可以看到Calc.exe模块被绑定到哪些模块，方括号中的数值表示Microsoft构建各DLL 模块的时间。为了便于我们阅读，DumpBin工具在方括号后面把这个32位的时间戳展开 成了字符串的形式。
在整个过程中，Bind做了以下两个重要假设。
• 当进程初始化的时候，所需的DLL实际上被载入到它们的首选基地址。我们可以 通过使用前面介绍的Rebase工具来保证这一点。
Mindows核心编程（第5版）
• 自从绑定完成之后，DLL导出段中所引用的符号的位置没有发生变化。加载程序会 通过检查每个DLL的时间戳来验证这一点，这个时间戳是在前面提到的第5步中 保存的。
当然，如果加载程序检测到以上两个假设之一不成立，那么Bind等于是做了无用功，这时 加载程序必须手动修正可执行模块的导入段，就像平常一样。如果加载程序发现模块已经 绑定过了，所需的DLL也确实被载入到了它们的首选基地址，而且时间戳也吻合，那么它 实际上就不需要再做任何事情了。它不必再对任何模块进行重新定位，它也不必再查看任 何导入函数的虚拟地址。应用程序可以直接开始执行！
此外，应用程序也不必占用系统页交换文件中的存储器。这简直是太棒了——我们得到了 最理想的情况。但令人惊讶的是，如今发布的商业应用程序中有那么多的应用程序都没有 进行基地址重定位和绑定。
好了，现在我们知道了应该在发布应用程序之前对所有的模块进行绑定。但我们应该在什 么时候进行绑定呢？如果我们在公司内部对模块进行绑定，那么会将它们绑定到我们安装 的系统DLL,而这些DLL很可能与用户安装的系统DLL不同。由于我们不知道用户运行 的操作系统是Windows XP, Windows 2003,或者是Windows Vista,以及操作系统有没有 安装补丁，因此我们应该在应用程序的安装过程中来进行绑定。
当然，如果用户的系统可以双重启动Windows XP和Windows Vista,那么绑定过的模块在 其中一个操作系统中将是不正确的。另外，如果用户先在Windows Vista下安装我们的应 用程序，然后再安装操作系统补丁，那么绑定也将失效。在这些情形下，我们和用户都没 有什么选择。Microsoft应该随操作系统发布一个工具，这个工具可以在操作系统升级后自 动对每个模块重新进行绑定。但令人叹息的是，这样的工具并不存在。
595
e	有时将数据与一个对象的实例关联起来是帮助的。比如，窗口附加字节（window extra bytes）
招"隔过使用SetWindowWord和SetWindowLong函数来将数据莺一个指定的窗口关联起来。
我们可以使用线程局部存储区（Thread Local Storage,后面简称为TLS）来将数据与一个正在 执行的指定线程关联起来。例如，我们可以将创建线程的时间与线程关联起来，然后当线 程终止的时候，我们就可以确定线程运行的时间长度。
C/C++运行库使用了 TLSo由于C/C++运行库是在多线程应用程序出现的许多年之前设计 的，因此运行库中的大多数函数是为单线程应用程序设计的。Jcstok_s函数就是一个绝佳 的例子。当应用程序第一次调用_tcstok_s的时候，该函数会将传入的字符串地址保存在它 自己的静态变量中。当我们后来再调用Jcstok_s并传入NULL的时候，该函数会去引用保 存下来的字符串地址。
在多线程环境中，一个线程可能会调用_tcstok_s,然后在它再次调用该函数之前，另一个 函数口J能也会调用_tcstok_So在这种情况下，第二个线程会导致_tcstok_s用新的字符串地 址来覆盖它的静态变量，而第一个线程对此却一无所知。第一个线程以后再调用_tcstok_s 的时候，用的是笫二个线程的字符串，从而引起各种各样的难以查获和修复的缺陷。
为了解决这个问题，C/C++运行库使用了 TLS。C++运行库会为每个线程分配独立的字符串 指针，专供_tcstok_s函数使用。同样享受这一特殊待遇的其他C/C++运行库函数还包括 asctime 和 gmtime。
如果应用程序高度依赖全局变量或静态变量，那么TLS可以成为我们的救生符。好在开发 人员都倾向于最大限度地减少对此类变量的使用，并更多地依赖于自动变量（栈上的变量） 和通过函数参数传入的数据。这是件好事，因为栈上的变量始终都是与某个特定的线程相 关联的。
各编译器厂商已经一而再，再而三地实现了标准C/C++运行库，如果一个C/C++编译器连 C/C++运行库都不包括，那么它就根本不值得购买。程序员们已经使用C/C"运行库许多 年了，而且还将继续使用下去，这也意味着诸如_tcstok_s之类的函数的原型和行为必须与 标准C/C++程序库完全保持一致。如果我们今天再来回过头来重新设计C/C++运行库，那
^^idows核心编程(第5版)	_
么一定会考虑到支持多线程应用程序的环境，而且会尽一切可能避免使用全局变量和静态 变量。
在我自己的软件项目中，我尽量避免使用全局变量。如果读者的应用程序使用了全局变量 和静态变量，那么我强烈建议你对每个变量进行分析，并研究将它们改成栈上的变量的可 能性。如果想在应用程序中添加更多的线程，那么这项工作能够帮你节省大量的时间，不 仅如此，甚至单线程应用程序也能从中受益。	一__
597-598
我们可以在应用程序和DLL中使用本章介绍的两项TLS技术——动态TLS和静态TLS。 但一般来说，这两项技术在创建DLL的时候更加有用，这是因为DLL通常并不知道它们 被链接到的应用程序的结构是什么样的。但是，在编写应用程序的时候，我们一般都知道 自己要创建多少线程，自己会如何使用这些线程。然后我们就可以设计一些替代方案来为 每个线程关联数据，或者设计得好一点的话，可以使用基于栈的方法(局部变量)来为每个 线程关联数据。尽管如此，应用程序的开发人员仍然能从本章提供的信息中受益。
21.1	动态 TLS
应用程序通过调用一•组4个函数来使用动态TLS,这些函数实际上最经常为DLL所使用。 图21-1显示了 Microsoft Windows用来管理TLS的内部数据结构。
进程
线程本地存储区的位标志：O-(TLS_M1N!MUM_AVAILABLE-1)
线程2
索引0
索引I
索引2
索引3
索引4
a 索 |TLS_MINIMUM_ AVAILABLE-2
索引 TLS_MINIMUM.,AVMLABLE-]
图21-1用来管理TLS的内部数据结构
系统中的每个进程都有一组正在使用标志(in-use flag),如图2I.1所示。每个标志可以被设 为FREE或INUSE,表示该TLS元素是否正在使用。Microsoft保证至少有
第21章线程局部存储区
TLS_MINIMUM_AVAILABLE 个位标志口丁供使用。顺便说一下，TLS_MINIMUM_
AVAILABLE在WinNT.h中被定义为64,系统会在需要的时候分配更多的TLS元素，最 多可达1000多个！这对任何应用程序来说都应该足够了。
要使用动态TLS,我们必须先调用TlsAlloc：
DWORD TlsAlloc();
这个函数让系统对进程中的位标志进行检索并找到一个FREE标志。然后系统会将该标志 从FREE改为INUSE并让TlsAlloc返回该标志在位数组中的索引。一个DLL(或应用程序) 通常将这个索引保存在一个全局变量中。由于这个值会在整个进程范围内使用，而不是在 线程范围内使用，因此这种情况下全局变量是一个更好的选择。
如果TlsAlloc无法在列表中找到一个FREE标志，那么它会返回 TLS_OUT_OF_INDEXES(在 WinBase.h 中被定义为 OxFFFFFFFF)。当 TlsAlloc 第一次被 调用的时候，系统会发现第一个标志为FREE,于是将该标志改为INUSE,并让TlsAlloc 返回0。这就是TlsAlloc 99%的工作内容。剩下的1%我们会在稍后进行讨论。
当系统创建一个线程的时候，会分配TLS__MINIMUM_AVAILABLE个PVOID值，将它 们都初始化为0,并与线程关联起来。如图21.1所示，每个线程都有自己的PVOID数组, 数组中的每个PVOID可以保存任意值。
在能够将信息保存到线程的PVOID数组中之前，我们必须知道数组中的哪个索引可供使 用——这正是前面调用TlsAlloc的目的。从概念上讲，TlsAlloc为我们预订了一个索引。
如果TlsAlloc返回的索引为3,那等于是说索引3己经被我们预订了，无论是进程中当前 正在运行的线程，还是今后可能会创建的线程，都不能再使用索引3。
为了把一个值放到线程的数组中，我们应该调用TlsSetValue函数：
BOOL TlsSetValue(
DWORD dwTlsIndex,
PVOID pvTlsValue);
这个函数把pvTlsValue参数所标识的一个PVOID值放到线程的数组中，参数dwTlsIndex 标识一个索引值，表示在数组中的具体位置。pvTlsValue值会与TlsSetValue的调用线程 关联起来。如果调用成功，那么TlsSetValue函数会返回TRUE。
当一个线程调用TlsSetValue的时候，会修改自己的数组。但它无法修改另一个线程的TLS 值。我希望有另一个Tls函数，能够让一个线程将数据保存到另一个线程的数组中去，但 这样的函数不存在。现在，从一个线程传数据到另一个线程的唯一简单方法，就是在调用 CreateThread或_beginthreadex的时候传一个值给它们，这两个函数会接着把传入的值再 作为唯一的参数传给线程函数。否则，我们就必须使用第8章和第9章介绍的线程同步机 制来确保所交换的数据的一致性。
在调用TlsSetValue的时候，我们应该总是传入前面在调用TlsAlloc时返回的索引。为了 让这些函数运行得尽可能的快，Microsoft在实现它们的时候牺牲了错误检查。即使传入的
%
^dows核心编程(第5版)
索引值不是由TlsAlloc调用分配得到的，系统仍然会将值保存到线程的数组中去——因为 没有进行错误检查的缘故。
为了从线程的数组中取回一个值，我们应该调用TlsGetValue：
PVOID TlsGeCValue(DWORD dwTlsIndex)；
这个函数会返回在索引为dwTIsIndex的TLS元素中保存的值。与TIsSetValue相似的是， TlsGetValue R会查看属于调用线程的数如TlsGetValue还会检查传入的索引是否在已分 配的区间内，这一点也与TIsSetValue相似，但两者的不同之处在于，应用程序有责任在 使用该TLS元素的内容之前确保该内容是有效的。
当我们不再需要一个已经预订的TLS元素时，应该调用TlsFree：
BOOL TlsFree(DWORD dwTIsIndex)；
这个函数告诉系统己经预订的这个TLS元素现在不需要了。函数会将进程内的位标志数组 中对应的INUSE标志重新设回FREE,这样以后再有线程调用TlsAlloc的时候就还可以分 配该标志。此外，函数还会将所有•线程中该元素的内容设为Oo如果调用成功，那么TlsFree 会返回TRUEo试图释放一个尚未分配的TLS元素将导致错误。
使用动态TLS
通常，如果DLL要使用TLS,那它会在DllMain函数处理DLL_PROCESS_ATTACH的 时候调用 TlsAlloc,在 DllMain 处理 DLL_PROCESS_DETACH 的时候调用 TlsFree。而 对TIsSetValue和TlsGetValue的调用则最有可能发生在DLL所提供的其他函数中。
向应用程序中添加TLS的一种方法是直到需要的时候才添加。例如，我们的DLL中可能 有一个类似于_tcstok_s的函数。调用者第一次调用这个函数的时候，会传入一个指针，指 向一个40字节大小的结构。我们必须将这个结构保存起来，这样才能在今后再引用它。我 们可能会像下面这样编写这个函数：
DWORD g_dwT1sIndex；	// Assume that this is initialized
// with the result of a call to TlsAlloc.
• • •
void MyFunction(PSOMESTRUCT pSomeStruct)(
if (pSomeStruct != NULL) (
// The caller is priming this function.
// See if we already allocated space to save the data.
if (TlsGetValue(g_dwTlsIndex) == NULL) (
// Space was never allocated. This is the first
// time this function has ever been called by this thread. TIsSetValue(g_dwTlsIndex,
HeapAlloc(GetProcessHeap(), 0, sizeof(*pSomeStruct))；
}
// Memory already exists for the data；
// save the newly passed values.
memcpy(TlsGetValue(g_dwTlsIndex), pSomeStruct,
sizeof(*pSomeStruct))；
第21章 线程局部存储区
} else (
// The caller already primed the function. Now it
// wants to do something with the saved data.
// Get the address of the saved data.
pSomeStruct = (PSOMESTRUCT) TlsGetValue(g_dwTlsIndex);
// The saved data is pointed to by pSomeStruct; use it.
• • ・
}
如果应用程序中的一个线程从来没有调用过My Function,那么我们根本就不会为线程分配 一块内存。
<600-601
读者可能会觉得64个TLS已经用之不竭了。但是，请记住应用程序可能会动态地链接到 许多DLL。一个DLL可能会分配10个TLS索引，第二个DLL可能会分配5个，等等。 因此，我们最好是采用与MyFunction相同的方法来减少需要的TLS索引的数量。当然， 我们也可以将所有40个字节分别保存在多个TLS索引中，但这样做不仅浪费，而且数据 也不容易处理。取而代之的是，我们应该为数据分配一块内存，然后将指针保存在TLS索 引中，就像MyFunction所做的那样。我们在前面已经提到过，如果起始的64个TLS元素 不够用，那么Windows会在需要的时候动态分配TLS元素。Microsoft之所以提高这个上 限，是因为许多开发人员在使用TLS元素的时候太过慷慨，这使得其他DLL没有足够的 TLS元素可供使用，从而导致它们失败。
我们前面在介绍TlsAlloc函数的时候，己经介绍了它99%的工作内容。为了帮助读者理解 剩下的1%,让我们来看一看下面这段代码：
DWORD dwTlsIndex；
PVOID pvSomeValue；
• • • •
dwTlsIndex = TlsAlloc()；
TlsSetValue(dwTlsIndex, (PVOID) 12345)；
TlsFree(dwTlsIndex)；
// Assume that the dwTlsIndex value returned from
// this call to TlsAlloc is identical to the index
// returned by the earlier call to TlsAlloc.
dwTlsIndex = TlsAlloc();
pvSomeValue = TlsGetValue(dwTlsIndex)；
这段代码执行后，读者认为pvSomeValue包含什么值？ 12345?答案是0。TlsAlloc在返回 之前，会遍历进程中的每个线程，并根据新分配的索引，在每个线程的数组中把对应的元 素设为0o
这是一件好事，因为应用程序可能会调用LoadLibrary来载入一个DLL,而该DLL可能 会调用TlsAlloc来分配一个索引。然后线程可能会调用FreeLibrary来卸载DLL,这时该 DLL应该调用TlsFree来释放它分配的索引，但谁知道DLL的代码在线程的数组中放了些 什么值呢？接着一个线程调用LoadLibrary来将另一个不同的DLL载入内存，这个DLL 在启动的时候也调用了 TlsAlloc并得到与前面那个DLL刚释放的索引。如果TlsAlloc在返
Windows核心编程(第5版)
回该索引之前不对相应的数组元素进行设置，那么一个线程就可能会取得老的值，代码的 执行可能会不正确。
例如，这个新的DLL可能想要通过调用TlsGetValue来检查是否已经为一个线程分配了内 存，就像刚才那段代码那样。如果TIsAlloc不把每个线程中相应的数组元素清干净，那么 第一个DLL中的老数据就会遗留在那里。如果一个线程调用MyFunction,那么MyFunction 会认为内存己经分配过了，于是调用memcpy来将新数据复制到这块内存中去。这可能会 导致灾难性的后果，但好在TIsAlloc对数组元素进行了初始化，因此这样的灾难不会发生。
21.2	静态 TLS
与动态TLS相似，静态TLS也将数据与线程关联起来。但是，由于使用的时候不必在代码 中调用任何函数，因此静态TLS更容易使用。
假设想将应用程序创建的每个线程与该线程的启动时间关联起来。我们要做的就是像下面 这样声明一个启动时间：
_declspec(thread) DWORD gt_dwStartTime = 0;
_declspec(thread)前缀是Microsoft为Visual C++编译器增加的一个修饰符。它告诉编译器 应该在可执行文件或DLL文件中，把对应的变量放到它自己的段中。_declspec(thread) 后面的变量必须被声明为全局变量或静态变量(既可以在函数内，也可以在函数外)。我们 不能将局部变量声明为_declspec(thread)类型。这应该不是什么问题，因为局部变量无论 如何都是与特定的线程相关联的。我用gt_前缀来表示全局TLS变量，用st_来表示静态 TLS变量。
当编译器对程序进行编译的时候，会将所有TLS变量放到它们自己的段中，这个段名为.tls。 链接器会将所有对象模块中的.tls段合并成一个大的.tls段，并将它保存到生成的可执行文 件或DLL文件中。
为了让TLS能够正常工作，操作系统也必须参与进来。当系统将应用程序载入到内存的时 候，会查看可执行文件中的.tls段，并分配一块足够大的内存来保存所有的静态TLS变量。 每当应用程序中的代码引用到这些变量之一时，相应的引用会被解析到刚分配的这块内存 中的一个位置。因此，编译器必须生成额外的代码来引用静态TLS变量，这使得应用程序 不仅变得更大，而目.执行起来也更慢。在X86CPU上，每次引用一个静态TLS变量会生成 三条额外的机器指令。
如果进程创建了另一个线程，那么系统会获知这一情况并自动分配另一块内存来保存新线 程的静态TLS变量。新线程只能访问自己的静态TLS变量，它无法访问属于任何其他线程 的TLS变量。
这基本上就是静态TLS的工作方式。现在让我们来考虑一下有DLL的情况。我们的应用
第21章线程局部存储区
程序可能会用到一些静态TLS变量，而且我们链接的一个DLL也想要使用静态TLS变量。 当系统载入应用程序的时候，会首先确定应用程序的・tls段的大小，并将它与应用程序链接 的所有DLL的.tls段的大小相加。当系统在创建线程的时候，会自动分配一块足够大的内 存来保存应用程序和所有隐式链接的DLL需要的TLS变量。这相当得酷。	―
602窗
但是，让我们来看一看如果应用程序调用LoadLibrary来链接一个DLL,而且该DLL包 含了静态TLS变量，这时会发生什么情况。为了给新DLL提供它需要的额外TLS内存，
系统必须查看进程中所有已有的线程，并扩大它们的TLS内存块。另外，如果应用程序调 用FreeLibrary来释放一个DLL,而且该DLL包含了静态TLS变量，那么与进程中的每 个线程相关联的内存块也应该相应地缩减。好消息是，Windows Vista对此提供了完全的 支持。
第22章 DLL注入和API拦截
本章内容
DLL注入的一个例子］ 使用注册表来注入DLL
22.1
22.2
223 使用Windows挂钩来注入DLL
22.4使用远程线程来注入DLL

22.5使用木马DLL来注入DLL
22.6把DLL作为调试器来注入
22.7使用CreateProcess来注入代码
22.8	API拦截的一个例子
在Microsoft Windows中，每个进程有自己私有的地址空间。当我们用指针来引用内存的时 候，指针的值表示的是进程自己的地址空间中的一个内存地址。进程不能创建一个指针来 引用属于其他进程的内存。因此，如果进程有一个缺陷会覆盖随机地址处的内存，那么这 个缺陷不会影响到其他进程所使用的内存。
独立的地址空间对开发人员和用户都是非常有利的。对开发人员来说，系统更有可能捕获 错误的内存读/写。对用户来说，操作系统变得更加健壮了，因为一个应用程序的错误不会 导致其他应用程序或操作系统崩溃。当然，这样的健壮性也是要付出代价的，因为它使我 们很难编写能够与其他进程通信的应用程序或对其他进程进行操控的应用程序。
应用程序需要跨越进程边界来访问另一个进程的地址空间的情况如下。
•	我们想要从另一个进程创建的窗口派生子类窗口①。
•	我们需要一些手段来辅助调试一一例如，我们需要确定另一个进程正在使用哪些 DLLo
•	我们想要给另一个进程安装挂钩气
本章将展示多种机制，它们可以用来将一个DLL注入到另一个进程的地址空间中。一旦
①	洋注：subclass a window created by another process0 -个subclass是-•个窗口或-•组具有相同窗口类的窗口，发往这个或这 些窗曰的消息在被送到窗LJ类的窗口过程处理之前，会先被另一个窗LI过程截取并处理。这是对窗口的行为进行扩展和定 制的种方法，它类似「•面向对象编程中从一个基类派生子类，但不同之处在F这种方法并没有创建一个新的窗口类。为 了与面向对象编程中的概念和方法相区分，本”中subclass统•译为子类窗口。
②	译注：hook other processes*
第22章DLL注入和API拦截
DLL代码进入另一个地址空间，那么我们就可以在那个进程中随心所欲，肆意妄为了。这 应该够吓人的了，因此在真的打算这样做之前，请务必慎重考虑。
22.1	DLL注入的一个例子
假设我们想要从另一个进程创建的窗口实例来派生一个子类窗口。读者可能还记得派生子 类窗口可以改变窗口的行为。为了达到这个目的，我们可以调用SetWindowLongPtr来让 该窗口在内存块中的窗口过程地址指向新的(我们自己的)WndProc。Platform SDK文档说 应用程序不能从另一个进程创建的窗口派生子类窗口，这并不完全正确。从另一个进程的 窗口派生子类窗口的问题在于无法跨越进程地址空间的边界。
如果用下面的代码调用SetWindowLongPtr来从一个窗口派生子类窗口，那等于是告诉系 统：所有发到①或发往②hWnd窗口的消息，应该由MySubclassProc来处理，而不是由该窗 口的标准窗口过程来处理。
SetWindowLongPtr(hWnd, GWLP_WNDPROC, MySubclassProc)；
换句话说，当系统需要向指定窗口的WndProc派送消息的时候,会先查看窗口过程的地址, 然后通过该地址来调用WndProCo在前面的例子中，由于系统发现与该窗口相关联的窗口 过程的地址是MySubclassProc,因此会直接调用MySubclassProco
从另一个进程创建的窗口派生子类窗口的问题在于，子类窗口的窗口过程在另一个地址空 间中。图22.1是一个经过简化的视图，显示了窗口过程如何处理收到的消息。进程A正在 运行，它已经创建了一个窗口。User32.dll被映射到进程A的地址空间中，负责对发到和 发往进程A的任何窗口◎的消息进行接收和派送。当User32.dll检测到一个消息的时候，会 先确定该窗口的WndProc的地址，然后调用它并在参数中传入窗口句柄、消息、以及 wParam和IParam。当WndProc处理完消息之后，User32.dll会进入下一轮循环并等待对 下一条窗口消息进行处理。	一_^
现在假设我们的进程是进程B,我们想要从进程A创建的一个窗口派生子类窗口。首先， 我们在进程B中的代码必须得到一个窗口句柄，来确定要从哪个窗口派生子类窗口。这可 以通过多种方式来得到。图22.1中的例子通过调用FindWindow来得到想要的窗口。接着, 进程B调用了 SetWindowLongPtr,试图改变该窗口的WndProc的地址。注意这里是“试 图”，因为这个调用什么也没有做，而是直接返回NULLO SetWindowLongPtr中的代码 会检查一个进程试图修改的WndProc的地址是否属于另一个进程创建的窗口，如果是这种 情况的话，函数会直接忽略该调用。
①	译注：send,同步消息传递方式，保证消息会被处理。
②	译注：post,异步消息传递方式，不保证消息会被处理。
③	译注：进程A的窗II就是由进程A的线程所创建的窗II。
WS核心编程（第5版）
进程A
进程B
EXE file
EXE file
LRESULT WndProc (HW4D hWnd, UINT uMsg, ...) (
void SoweFunc (void)(
HWND hWnd = FindWindow(TEXT("Class-A”)， NULL);
SetWindowLongPtr(hWnd, GWLP.MNDPROC, MySubclassProc);
LRESULT My Subcl assProc(HWJD	UINT Msg,...){
USER32.DLL file
USER32.DLL file
LONG DIspatchMessage (CONST MSG *msg) { LONG 1 Result;
WNOPROC IpfnWndProc - (WNDPROC) GetWindowLongPtr(msg.hwrd, GWLP_WNDPROC);
IResult = 1 pf nWnd Proc (msg. hwid, msg. mess age, msg.wParam, msg.1 Param);
return。Result);
图22-1进程B的一个线程试图从进程A创建的一个窗口派生子类窗口
如果SetWindowLongPtr函数能够修改该窗口的 WndProc,那又将如何呢？系统会将 MySubclassProc的地址与指定的窗口关联起来。然后当该窗口接收到一条消息的时候，进 程A中的User32代码会取回消息，得到MySubclassProc的地址，并试图调用这个地址。
这时我们的麻烦就大了： MySubclassProc应该在进程B的地址空间中，但进程A是活动 进程。显然，如果User32代码调用这个地址，那么它调用的是进程A的地址空间中的一个 地址，这很可能会导致内存访问违规。
为了避免这个问题，我们想让系统知道MySubclassProc在进程B的地址空间中，并在调 用子类窗口的窗口过程时切换上下文。出于下列原因，Microsoft并没有实现这个功能。
•	应用程序很少需要从其他进程的窗口派生子类窗口。大多数应用程序只从它们自己 创建的窗口派生子类窗口，Windows的内存体系结构并没有妨碍这种做法。
•	切换活动进程会耗费非常多的CPU时间。
•	进程B中的一个线程必须执行MySubclassProc的代码，系统应该尝试使用哪个线 程？应该使用一个已有的线程，还是创建一个新的线程？
•	User32.dll怎样才能知道与该窗口相关联的窗口过程的地址是在另一个进程中还是 在当前的进程中？
由于这些问题都没有非常好的解决办法，因此Microsoft决定不允许SetWindowLongPtr 对另一个进程创建的窗口的窗口过程进行修改。
但是，我们仍然能够从其他进程创建的窗口派生子类窗口——只不过要采用另一种不同的 方法。这个问题实际上与派生子类窗口无关，而是与进程地址空间的边界有关。如果能够 通过某种方式让我们的子类窗口的窗口过程进入到进程A的地址空间中，就能够轻易地调
第22章DLL注入和API拦截
用SetWindowLongPtr,并把MySubclassProc在进程A中的地址传给它。我称这项技术为 将DLL “注入”到进程的地址空间中。有多种方法可以实现这一技术，我们将依次对它们 进行讨论。
.
说明 如果打算从同一个进程中的窗口派生子类窗口，那么应该利用SetWindowSubclass, GetWindowSubclass , RemoveWindowSubclass 以及 DefSubclassProc。 http://msdn2.microsoft.com/en-us/library/ms649784.aspx 处的"Subclassing Controls” 介绍了这些函数。
22.2使用注册表来注入DLL
如果用过Windows,那么对注册表应该不会感到陌生。整个系统的配置都保存在注册表中， 我们可以通过调整其中的设置来改变系统的行为。我们将要讨论的条目在下面这个注册表 项中：
HKEY_LOCAL_MACHINE\Software\Microsoft
\Windows NT\CurrentVersion\Windows\
下图所示的窗口是用Registry Editor（注册表编辑器）查看该注册表项得到的，它显示了该注 册表项中的条目。


	D ▲ Superfetch	*	I Neme	Type	Data
	Svchojt	奶(Default	REG.SZ	mnmsrvc
	o ▲ SyjtemRestore » & Time Zones > ・占 Tricing 上 Usennstallable.drivers		R£G_SZ	C:\Mylib.dll
		1 J^DdeSendTimeout	REG_DWORD	0x00000000 (0)
1 1	X		■蹒 DesktopHeapLogging	REG.DWORD	0x00000001(1)
: •	1	WbemPerf 卜山 Windows D》Winlogon b 山 Wmsat 山 WinSATAPl	*•»] Devic eNotSclectedTimeout	REG.SZ	15
! j 1 -		^GDIProcessHandleQuota	REG.DWORD	0x00002710 (10000)
		1 *^IconSeiviceLib	REG.SZ	IconCodecService.dll
, .			REG.DWORD	0x00000001 (1)
		^ShutdownWamingDulogTimeout	REG.DWORD	Oxffffffff (4294967295)
	wow	^Spooler	REG.SZ	y”
	A ▲ WUDF	*^Tran$mi5sionRetryTimeout	REG.SZ	90
	▲ Windows Photo Gallery	.晚 USERPortMessageLimit	REG.DWORD	0x00002710 (10000)
	k Windowj Portable Devices	4^]USERProce$$HandleQuota	REG.DWORD	0x00002710 (10000)
ComputerV^JOCAl.,MACHINE\SOnWAR£V<1icrojaft\WindowjN7\CurrentVenion\Windowj
AppInit_Dlls键的值可能会包含一个DLL的文件名或一组DLL的文件名（通过空格或逗号 分隔）。由于空格是用来分隔文件名的，因此我们必须避免在文件名中包含空格。第一个 DLL的文件名可以包含路径，但其他DLL包含的路径则将被忽略。出于这个原因，我们最 好是将自己的DLL放到Windows的系统目录中，这样就不必指定路径了。在图22.2所示 的窗口中，我将这个注册表键值设为一个DLL路径名C:\MyLib.dll。为了能够让系统使用 这个注册表项，我们还必须创建一个名为LoadAppInit_Dlls,类型为DWORD的注册表项, 并将它的值设为1。
lows核心编程（第5版）
当User32.dll被映射到一个新的进程时，会收到DLL_PROCESS_ATTACH通知。当 User32.dll对它进行处理的时候，会取得上述注册表键的值，并调用LoadLibrary来载入这 个字符串中指定的每个DLL。当系统载入每个DLL的时候，会调用它们的DllMain函数 并将参数fdwReason的值设为DLL_PROCESS_ATTACH,这样每个DLL就能够对自己 进行初始化。由于被注入的DLL是在进程生命期的早期被载入的，因此我们在调用函数的 时候应该慎重。调用Kemel32.dll中的函数应该没有问题，但是调用其他DLL中的函数可 能会导致问题，甚至可能会导致蓝屏。User32.dll不会检查每个DLL的载入或初始化是否 成功。
在用来注入DLL的所有方法中，这是最方便的一种。我们所要做的只不过是在注册表项中 添加两个值。但这种方法也有一些缺点，具体如下所示。
•	我们的DLL只会被映射到那些使用了 User32.dll的进程中。所有基于GUI的应用 程序都使用了 User32.dll,但大多数基于CUI的应用程序都不会使用它。因此，如 果想要将DLL注入到编译器或链接器，那么这种方法就不可行。
•	我们的DLL会被映射到每个基于GUI的应用程序中，但我们可能只想把DLL注入 到一个或少数几个应用程序中。我们的DLL被映射到越多的进程中，它导致“容 器”进程崩溃的可能性也就越大。毕竟，这些进程中的线程都在运行我们的代码。 如果我们的代码进入了无限循环或错误地访问了内存，那将会影响到“容器”进程 的行为和健壮性。因此，最好是只把我们的DLL映射到尽可能少的进程中。
•	我们的DLL会被映射到每个基于GUI的应用程序中，在应用程序终止之前，它将 一直存在于进程的地址空间中。这与刚才的问题相似。理想情况下，我们应该把 DLL映射到需要的进程中去，并让映射的时间越短越好。假设我们想要在用户启动 我们的应用程序时，从WordPad的主窗口派生一个子类窗口。在用户启动我们的 应用程序之前，我们没有必要将DLL映射到WordPad的地址空间中。如果用户后 来终止应用程序，那么我们应该要将派生自WordPad的主窗口的子类窗口撤销。 在这种情况下，我们的DLL没有必要再继续存在于WordPad的地址空间中。最好 是只在需要的时候才注入我们的DLLo
22.3使用Windows挂钩来注入DLL
我们可以用挂钩来将一个DLL注入到进程的地址空间中。为了能让挂钩的工作方式与它们 在16位Windows中的工作方式相同，Microsoft被迫设计出一种机制，这种机制可以让我 们将一个DLL注入到另一个进程的地址空间中。
让我们来看一个例子。进程A（一个类似于Microsoft Spy++的工具）为了查看系统中各窗口 处理了哪些消息，安装了一个WH_GETMESSAGE挂钩。这个挂钩是通过调用 SetWindowsHookEx来安装的，如下所示：
HHOOK hHook = SetWindowsHookEx（WH_GETMESSAGE, GetMsgProc,
hlnstDll, 0）；
第22章 DLL注入和API拦截
第1个参数WH_GETMESSAGE表示要安装的挂钩的类型。第2个参数GetMsgProc是 一个函数的地址(在我们的地址空间中)，在窗口即将处理一条消息的时候，系统应该调用 这个函数。第3个参数hlnstDll标识一个DLL,这个DLL中包含了 GetMsgProc函数。在 Windows中，hlnstDll的值是进程地址空间中DLL被映射到的虚拟内存地址。最后一个参 数0表示要给哪个线程安装挂钩。一个线程可能会调用SetWindowsHookEx并传入系统中 另一个线程的线程标识符。通过给这个参数传0,我们告诉系统要给系统中的所有GUI线 程安装挂钩。
现在让我们来看一看接下来会发生什么。
(1)	进程B中的一个线程准备向一个窗口派送一条消息。
(2)	系统检查该线程是否已经安装了 WH_GETMESSAGE挂钩。
⑶ 系统检S GetMsgProc所在的DLL是否己经被映射到进程B的地址空间中。
(4)	如果DLL尚未被映射，那么系统会强制将该DLL映射到进程B的地址空间中，并将 进程B中该DLL的锁计数器(lock count)递增。
(5)	由于DLL的hlnstDU是在进程B中映射的，因此系统会对它进行检查，看它与该DLL 在进程A中的位置是否相同。
如果hlnstDll相同，那么在两个进程的地址空间中,GetMsgProc函数位于相同的位置。 在这种情况下，系统可以直接在进程A的地址空间中调用GetMsgProCo
如果hlnstDll不同，那么系统必须确定GetMsgProc函数在进程B的地址空间中的虚 拟内存地址。这个地址通过下面的公式得出：•
GetMsgProc B = hlnstDll B + (GetMsgProc A — hlnstDll A)
通过把GetMsgProc A减去hlnstDll A,我们可以得到GetMsgProc函数的偏移量，以 字节为单位。把这个偏移量与hlnstDll B相加就得到了 GetMsgProc函数在进程B的 地址空间中的位置。
(6)	系统在进程B中递增该DLL的锁计数器。
(7)	系统在进程B的地址空间中调用GetMsgProc函数。
(8)	当GetMsgProc返回的时候，系统递减该DLL在进程B中的锁计数器。
注意，当系统把挂钩过滤函数(hook filter function)所在的DLL注入或映射到地址空间中时， 会映射整个DLL,而不仅仅只是挂钩过滤函数。这意味着该DLL内的所有函数存在于进程 B中，能够为进程B中的任何线程调用。
因此，为了从另一个进程的窗口来创建一个子类窗口，我们可以先给创建窗口的线程设置 一个WH.GETMESSAGE挂钩，然后当GetMsgProc函数被调用的时候，我们就可以调 用SetWindowLongPtr来派生子类窗口。当然，子类窗口的窗口过程必须和GetMsgProc 函数在同一个DLL中。
和用注册表来注入DLL的方法相比，这种方法允许我们在不需要该DLL的时候从进程的 地址空间中撤销对它的映射，只需调用下面的函数就可以达到这一目的：
BOOL UnhookWindowsHookEx(HHOOK hHook);
indows核心编程（第5版）•	.
当一个线程调用UnhookWindowsHookEx的时候，系统会遍历自己内部的一个己经注入过 该DLL的进程列表，并将该DLL的锁计数器递减。当锁计数器减到0的时候，系统会自 动从进程的地址空间中撤销对该DLL的映射。我们应该还记得，系统在调用GetMsgProc 函数之前，会递增该DLL的锁计数器。（参见前面的第6步。）这可以防止内存访问违规。
如果这个锁计数器没有递增，那么当进程B中的线程试图执行GetMsgProc的时候，系统 中的另一个线程可能会调用UnhookWindowsHookEx函数，从而引起内存访问违规。
所有这些意味着我们不能在派生完子类窗口之后马上就把挂钩清除。在子类窗口的整个生 命期内，这个挂钩必须一直有效。
Desktop Item Position Saver(DIPS)工具
DIPS.exe应用程序使用了窗口挂钩来将一个DLL注入到Explorer.exe的地址空间中。应用 程序和DLL的源文件和资源文件在本书配套网页的22-DIPS和22-DIPSLib目录中。
我通常使用自己的笔记本电脑来办公，而且最喜欢使用1400x1050的分辨率。但是，我有 时必须通过投影仪来做演示，而大多数投影仪只支持较低的分辨率。因此在准备用笔记本 来进行投影之前，我会到控制面板的显示属性中，将分辨率改为投影仪所要求的分辨率。 在结束投影之后，我会回到显示属性，将分辨率改回1400xl050o
能够动态地更改显示分辨率是Windows提供的一项很棒而且很受欢迎的特性。但是，在更 改显示分辨率的时候有一件事情让我非常不喜欢：桌面上的图标记不住原来的位置。我的' 桌面上有许多图标，能让我快速地启动应用程序或打开我常用的文件。我在桌面把这些图 标摆放得井井有条。但一旦更改显示分辨率，不仅桌面窗口的大小会改变，而且我的图标 也会被重新排列，使我完全找不到我要找的东西。然后，当我把显示分辨率更改回来之后， 我的图标又会被重新排列成一种新的顺序。为了恢复图标原来的位置，我必须手动地把桌 面上所有的图标放回原处一一太烦人了 ！
我痛恨手动重排这些图标，为此我创建了 Desktop Item Position Saver 即DIPS。DIPS 包括一个很小的可执行文件和一个很小的DLL。当应用程序启动的时候，会显示下图所示 的消息框。
这个消息框显示了如何使用该工具。当我们传给DIPS的命令行参数是S的时候，它会创 建下面的注册表项，并为桌面上的每个图标都添加一个注册表项：
第22章DLL注入和API拦截
HKEY_CURRENT_USER\Software\Wintellect\Desktop Item Position Saver
DIPS会为每个图标保存一个位置。比如我们因为要玩游戏而需要更改屏幕的分辨率，我们 就可以在更改分辨率之前运行DIPSS,然后当打完游戏之后，我们先把屏幕恢复到原来的 分辨率，然后运行DIPS Ro这使得DIPS会打开注册表项，找到那些保存过位置的图标， 并将它们的位置恢复到运行DIPS S时它们所在的位置。
读者一开始可能会觉得DIPS应该相当容易实现。毕竟，我们只要取得桌面的ListView控 件的窗口句柄，向它发送消息来枚举其中的元素，得到它们的位置，并把这些信息保存到 注册表中。但是，如果亲手尝试一下，你就会发现实际上并没有那么简单。问题在于大多 数公共控件的窗口消息，比如LVM_GETITEM和LVM^GETITEMPOSITION,是不能 跨越进程边界的。
之所以有这样的限制，是因为LVM.GETITEM消息要求我们在它的LPARAM参数中传 入一个LVJTEM数据结构。由于这个内存地址只对发送消息的进程有意义，因此接收消 息的进程是无法使用它的。为了让DIPS能够按照前面描述的方式工作，我们必须将代码 注入到 Explorer.exe ,因为只有它才能成功地将 LVM_GETITEM 和 LVM_GETITEMPOSITION消息发送到桌面的ListView控件。
说明 在使用Windows内建的控件(如按钮、编辑框、静态框、组合框等)时，我们可以跨 越进程的边界向它们发送消息并与它们进行交互，但我们不能对新的公共控件(如 ListView控件)这样做。举个例子，我们可以向另一个进程创建的列表框控件发送一 条LB_GETTEXT消息，其中LPARAM参数指向的字符串缓存在发送消息的进程 中。这之所以能够工作，是因为 Microsoft专门做了检查，如果发送的是 LB_GETTEXT消息，那么操作系统会在内部创建一个内存映射文件并在进程间复 制字符串数据。
为什么Microsoft决定对内建控件进行这样的处理，而对新的公共控件却不进行这样 的处理呢？答案是为了兼容性的缘故。在16位Windows中，所有应用程序都在同 一个地址空间中，一个应用程序可以向另一个应用程序创建的窗口发送 LB_GETTEXT ＞肖息。为了便于将这些16位应用程序移植到Win32, Microsoft投 入了额外的精力来确保这种方式仍然能够工作。但是，在创建那些在16位Windows 中尚未出现的新公共控件时，并不存在移植性的问题，因此Microsoft决定不再为这 些公共控件投入额外的精力。
当DIPS.exe运行的时候，它首先会取得桌面的ListView控件的窗口句柄：
// The Desktop Listview window is the
// grandchild of the ProgMan window.
hWndLV = GetFirstChild(
GetFirstChiId(FindWindow(TEXT(■ProgMan"), NULL)))；
这段代码先查找一个类别(class)为ProgMan的窗口。即使程序管理器(Program Manager)应 用程序没有运行，Windows外壳仍然会创建一个类别为ProgMan的窗口，其目的是为了向
dows核心编程（第5版）
后兼容那些为老版本Windows设计的应用程序。这个ProgMan窗口有且只有一个类别为 SHELLDLL_DefView的子窗口。这个子窗口同样有且只有一个子窗口，子窗口的类别为 SysListView32o这个SysListView32窗口就是桌面的ListView控件窗口。（顺便说一句， 我是通过Spy++来获得所有这些信息的。）
一旦有了 ListView的窗口句柄，就可以通过调用GetWindowThreadProcessId来确定创建 该窗口的线程的标识符。然后把线程标识符传给SetDIPSHook函数（在DIPSLib.cpp内实 现）。SetDIPSHook会给这个线程安装一个WH_GETMESSAGE挂钩，并调用下面的函数 来强制唤醒Windows资源管理器线程。
PostThreadMessage（dwThreadld, WM_NULL, 0, 0）;
由于我们己经在这个线程中安装了一个WH_GETMESSAGE挂钩，因此操作系统会自动 地将DIPSLib.dll注入到Windows资源管理器的地址空间中并调用我们的GetMsgPmc函 数。这个函数首先会检查它是否第一次被调用，如果是第一次被调用，那么它会创建一个 标题为“WintellectDIPS.”的隐藏窗口。记住，这个隐藏窗口是由Windows资源管理器的 线程创建的。在这个过程中，DIPS.exe线程已经从SetDIPSHook调用中返回并接着调用下 面的函数：
GetMessage（&msg, NULL, 0, 0）;
o 这个调用将线程切换到睡眠状态，直到它的消息队列中出现消息为止。即便DIPS.exe没有 创建任何属于自己的窗口，它仍然有一个消息队列，我们能且只能通过调用 PostThreadMessage来将消息放到这个队列中。如果看一下DIPSLib.cpp中GetMsgProc函 数的代码，那么会看到它在调用CreateDialog之后立即调用了 PostThreadMessage,后者 使得DIPS.exe线程再次被唤醒。由于SetDIPSHook己经把线程标识符保存在了一个共享 变量中，因此PostThreadMessage可以直接使用它。
注意，我们使用了线程的消息队列来进行线程同步。这样做绝对不会有什么问题，而且和 使用其他内核对象（互斥量、信号量、事件等）来进行线程同步相比，通过这种方式来进行 线程同步有时还更容易。Windows提供了丰富的API,我们应该加以充分利用。
当DIPS可执行文件中的线程被唤醒的时候，它知道服务器对话框己经创建完成，于是就 调用FindWindow来得到该窗口的句柄。我们现在就可以通过窗口消息在客户（DIPS应用 程序）和服务器（隐藏的对话框）之间进行通信了。由于创建对话框的线程是在Windows资源 管理器的进程内运行的，因此这对我们能执行什么操作多少有些限制。
为了告诉我们的对话框去保存或恢复桌面图标的位置，我们只需发送一条消息：
// Tell the DIPS window which Listview window to manipulate
// and whether the items should be saved or restored.
SendMessage（hWndDIPS, WM_APP, （WPARAM） hWndLV, bSave）;
对话框的对话框过程对WM_APP消息进行了处理。当它接收到这条消息的时候， WPARAM参数是一个窗口句柄，表示要操作的ListView控件，LPARAM是一个布尔值，
第22章 DLL注入和API拦截
表示应该将图标的当前位置保存到注册表中，还是应该根据保存在注册表中的信息恢复图 标的位置。
由于使用的是SendMessage,而不是PostMessage,因此只有当操作完成后函数才会返回。 如果需要，我们可以在对话框的对话框过程中增加更多的消息处理，这样我们就可以让自 己的程序对Windows资源管理器有更多的控制。当与对话框的通信完成后，为了让服务器 终止（可以这么说），我们向对话框发送了一条WM_CLOSE消息，让它销毁自己。
最后，在DIPS应用程序终止之前，它再次调用了 SetDIPSHook,但这些传入的线程标识 符是0。0是一个标记，用来告诉函数把已经安装的WH_GETMESSAGE挂钩清除。当挂 钩被清除后，操作系统会自动地从Windows资源管理器的地址空间中卸载DIPSLib.dll,这 也意味着对话框的对话框过程在Windows资源管理器的地址空间已经不复存在了。非常重 要的一点是，必须先销毁对话框，再清除挂钩，否则对话框收到的下一条消息会导致 Windows资源管理器的线程引发访问违规。如果发生这种情况，那么操作系统将终止 Windows资源管理器。这也提醒我们在使用DLL注入时必须非常谨慎！
* Dips. Cpp
/************************************************* ***************************** Notices： Copyright (c) 2008 Jeffrey Richter & Christophe Nasarre
#include ■..\CommonFiles\CmnHdr.h*	/* See Appendix A. */
♦include <WindowsX.h>
#include <tchar.h>
#include "Resource.h"
tinclude ・..\22-DIPSLib\DIPSLib.hB
///////////////////////////////////////////////////////////////////////////////
BOOL Dlg_OnInitDialog(HWND hWnd, HWND hWndFocusr LPARAM 1Param) (
chSETDLGICONS(hWnd, IDI_DIPS);
return(TRUE)；
}.
///////////////////////////////////////////////////////////////////////////////
void Dlg_OnC(xnmand (HWND hWnd, int id, HWND hWidCtl, UIh«T	(
switch (id) ( case IDC_SAVE:	
case IDC_RESTORE:	■- ••	, , • • /- • •	•	J	Q ■■一 . I C~'一.	-•—，々•	|	* I
case IDCANCEL:	•	苞冬军
EndDialog(hWnd, id); break；	‘m阳vy•:火;黑-宇志习£佗'	-■
} )	'您W *邀心
/////////〃/////////////////////////////////////////////,^|^^^^^^^^//
Endows核心编程（第5版）
BOOL WINAPI Dlg_Proc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM 1Param) ( switch (uMsg) (
chHANDLE_DLGMSG(hWnd, WM_INITDIALOG, Dlg_OnInitDialog); chHANDLE_DLGMSG (hWnd, WM__COMMAND,	DI g_0nCommand);
)
return(FALSE)；
}
//////////////////////////////////////////////////////////////〃///////////////
int WINAPI _tWinMain(HINSTANCE hlnstExe, HINSTANCE, PTSTR pszCmdLine, int) (
// Convert command-line character to uppercase.
CharUpperBuff(pszCmdLine, 1);
TCHAR cWhatToDo = pszCmdLine[0];
if ((cWhatToDo != TEXT('S')) && (cWhatToDo != TEXT(*R•))) (
// An invalid command-line argument； prompt the user. cWhatToDo = 0;
}
if (cWhatToDo == 0) {
//No command-line argument was used to tell us what to
// do； show usage dialog box and prompt the user.
switch (DialogBox(hInstExer MAKEINTRESOURCE(IDD_DIPS), NULL, Dlg_Proc)) ( case IDC_SAVE：
cWhatToDo = TEXT('S*)；
break；
case IDC_RESTORE:
cWhatToDo = TEXT('R1)； break；
}
}
if (cWhatToDo == 0) (
// The user doesn't want to do anything. return(0);
}
// The Desktop Listview window is the grandchild of the ProgMan window. HWND hWndLV = GetFirstChild(GetFirstChild(
FindWindow(TEXT(■ProgMan"), NULL)))；
chASSERT(IsWindow(hWndLV));
// Set hook that injects our DLL into the Explorer's address space. After // setting the hook, the DIPS hidden modeless dialog box is created. We // send messages to this window to tell it what we want it to do. chVERIFY(SetDIPSHook(GetWindowThreadProcessId(hWndLV, NULL)))y
// Wait for the DIPS server window to be created.
MSG msg；
GetMessage(&msg, NULL, 0, 0)；
// Find the handle of the hidden dialog box window.
HWND hWndDIPS = FindWindow(NULL, TEXT("Wintellect DIPS"));
// Make sure that the window was created. chASSERT(IsWindow(hWndDIPS));
// Tell the DIPS window which Listview window to manipulate
// and whether the items should be saved or restored.
BOOL bSave = (cWhatToDo == TEXT('S*));
第22章DLL注入和API拦截
SendMessage(hWndDIPS, W«_APP, (WPARAM) hWndLV, bSave);
// Tell the DIPS window to destroy itself. Use SendMessage
// instead of PostMessage so that we know the window is
// destroyed before the hook is removed.
SendMessage(hWndDIPS, WMLCLOSE, 0, 0);
// Make sure that the window was destroyed. chASSERT(!IsWindow(hWndDIPS));
// Unhook the DLL, removing the DIPS dialog box procedure
// from the Explorer * s address space.
SetDIPSHook(O);
return(0);
}
//////////////////////////////// End of File //////////////////////////////////
DIPSLib・ cpp
/************★***★****************•***★**********•***★**************•***★****** Module： DIPSLib.cpp
Notices： Copyright (c) 2008 Jeffrey Richter & Christophe Nasarre
*********************•*******★*********★***********★*********★****************/
#include •..\CommonFiles\CmnHdr.hB	/* See Appendix A. */
#include <WindowsX.h>
#include <CommCtrl.h>
#define DIPSLIBAPI _declspec(dllexport)
#include "DIPSLib.h-
#include "Resource.h*
///////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
// This function forces the debugger to be invoked
void ForceDebugBreak() {
_try { DebugBreak()； }
_except(UnhandledExceptionFilter(GetExceptionlnformation())) ( }
}
#else
#define ForceDebugBreak()
#endif
///////////////////////////////////////////////////////////////////////////////
// Forward references
LRESULT WINAPI GetMsgProc (int nCode, WPARAM wParan/	j .
INT_PTR WINAPI Dlg_Proc(HWND hWnd, UINT uMsg, WPARAM wParam,, I^PARAM iParam);
///////////////////////////////////////////////////////////////////////////////
// Instruct the compiler to put the g_hHook data variable in
// its own data section called Shared. We then instruct the
// linker that we want to share the data in this section
// with all instances of this application.
#pragma data_seg("Shared")
HHOOK g_JiHook = NULL;
DWORD g_dwThreadIdDIPS = 0;
indows核心编程（第5版）
#pragma data_seg()
// Instruct the linker to make the Shared section // readable, writable, and shared.
♦pragma comment(linker, ■/sect ion:Shared , rws■)
///////////////////////////////////////////////////////////////////////////////
// Nonshared variables HINSTANCE g_hInstDll = NULL;
////////////////////////////////////〃///〃////////////////////////〃/////〃///
BOOL WINAPI DllMain(HINSTANCE hlnstDll, DWORD fdwReason, PVOID fln^Load) ( switch (fdwReason) (
case DLL_PROCESS_ATTACH:
// DLL is attaching to the address space of the current process. g_hlnstDll = hlnstDll； break；
case DLL_THREAD_ATTACH:
// A new thread is being created in the current process, break；
case DLL_THREAD_DETACH:
// A thread is exiting cleanly.
break;
case DLL_PROCESS_DETACH:
// The calling process is detaching the DLL from its address space. break；
)
return(TRUE);
///////////////////////////////////////////////////////////////////////////////
BOOL WINAPI SetDIPSHook(DWORD dwThreadld) (
BOOL bOk = FALSE;
if (dwThreadld != 0) (
// Make sure that the hook is not already installed. chASSERT(g_hHook == NULL);
// Save our thread ID in a shared variable bo that our GetMsgProc // function can post a message back to the thread when the server // window has been created.	・	*
g_dwThreadIdDIPS = GetCurrentThreadld()；
// Install the hook on the specified thread
g_JiHook = SetWindowsHookEx(WH_GETMESSAGE, GetMsgProc, dwThreadld)；
bOk = (g_hHook != NULL);
if (bOk)(
// The hook was installed successfully； force a	messag6}'''C0??.
// the thread's queue so that the hook function gets called. bOk = PostThreadMessage(dwThreadld, WM_NULL, 0, 0)；
) * *
} else {
第22章DLL注入和API拦截
// Make sure that a hook has been installed. chASSERT(g_hHook != NULL);
bOk = UnhookWindowsHookEx(g_hHook)； g_hHook = NULL;
}
return(bOk)；
}
///////////////////////////////////////////////////////////////////////////////
LRESULT WINAPI GetMsgProc(int nCode, WPARAM wParam, LPARAM 1Param) ( static BOOL bFirstTime = TRUE;
if (bFirstTime) (
// The DLL just got injected. bFirstTime = FALSE;
// Uncomment the line below to invoke the debugger
//on the process that just got the injected DLL.
// ForceDebugBreak()；
// Create the DIPS Server window to handle the client request. CreateDialog(g__hInstDllz MAKEINTRESOURCE(IDD_DIPS), NULL, Dlg_Proc);
// Tell the DIPS application that the server is up
// and ready to handle requests.
PostThreadMessage(g_dwThreadldDIPS, WM_NULLr 0, 0);
return(CallNextHookEx(g_hHook/ nCode, wParam, iParam))；
}
//////////〃〃/////////////////////////////////////////////////////////////////
void Dlg_OnClose(HWND hWnd) (
DestroyWindow(hWnd);
}
///////////////////////////////////////////////////////////////////////////////
static const TCHAR g_szRegSubKey[]=
TEXT("SoftwareWWintellectWDesktop Item Position Saver")；
///////////////////////////////////////////////////////////////////////////////
void SaveListViewItemPositions(HWND hWndLV) (
int nMaxItems = ListView_GetItemCount(hWndLV)；
// When saving new positions, delete the old position
// information that is currently in the registry.
LONG 1 = RegDeleteKey(HKEY_CURRENT_USER, g_szRegSubKey);
// Create the registry key to hold the info	、
HKEY hkey;
1 = RegCreateKeyEx(HKEY_CURRENT_USER, g_szRegSubKey/ 0, NULL,
dows核心编程（第5版）
REG_OPTION_NON_VOLATILEr KEY_SET_VALUE, NULL, &hkey, NULL); ChASSERT(1 == ERROR_SUCCESS);
for (int nltem = 0； nltem < nMaxItems； nltem++) (
// Get the name and position of a Listview item.
TCHAR szName[MAX^PATH]；
ListView_GetItemText(hWndLV, nltem, 0, szName, _countof(szName))；
POINT pt;
ListView_GetItemPosition(hWndLV, nltem, &pt);
// Save the name and position in the registry.
1 = RegSetValueEx(hkey, szName, 0, REG_BINARY, (PBYTE) &pt, sizeof(pt));
ChASSERT(1 == ERROR_SUCCESS);
}
RegCloseKey(hkey);
}
///////////////////////////////////////////////////////////////////////////////
void RestoreListViewItemPositions(HWND hWndLV) (
HKEY hkey；
LONG 1 = RegOpenKeyEx(HKEY_CURRENT_USER r g_szRegSubKey,
0, KEY_QUERY_VALUE, &hkey); if {1 == ERROR_SUCCESS) (
// If the Listview has AutoArrange on, temporarily turn it off. DWORD dwStyle = GetWindowstyle(hWndLV)； if (dwStyle & LVS_J^UTOARRANGE)
SetWindowLong(hWndLV, GWL_STYLE, dwStyle & -LVS_AUTOARRANGE);
1 = NO_ERROR;
for (int nlndex =0; 1 != ERROR_NO_MORE_ITEMS; nlndex++) ( TCHAR szName[MAX_PATH];
DWORD cbValueName = _countof(szName);
POINT pt;
DWORD cbData = sizeof(pt), nltem;
// Read a value name and position from the registry. DWORD dwType；
1 = RegEnumValue(hkey, nlndex, szName, &cbValueName, NULL, &dwType, (PBYTE) &pt, &cbData);
if (1 == ERROR__NO_MORE_ITEMS) continue；
if ((dwType == REG_BINARY) && (cbData == sizeof(pt))) ( // The value is something that we recognize; try to find // an item in the Listview control that matches the name.' LV_FINDINFO Ivfi;
Ivfi.flags = LVFI_STRING;
Ivfi.psz = szName； nltem = ListView_FindItem(hWndLV, -1,	;
if (nltem != -1) (
//We found a match； change the item's position. ListView_SetItemPosition(hWndLV, nltem, pt.x, pt.y);
}
}
}
// Turn AutoArrange back on if it was originally on. SetWindowLong(hWndLV, GWL_STYLEZ dwStyle);
RegCloseKey(hkey)；
第22章DLL注入和API拦截
}
///////////////////////////////////////////////////////////////////////////////
INT_PTR WINAPI Dlg_Proc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM 1Param) ( switch (uMsg) (
chHANDLE_DLGMSG(hWnd, WM_CLOSE, Dlg_OnClose);
case WhCAPP:
// Uncomment the line below to invoke the debugger
//on the process that just got the injected DLL.
// ForceDebugBreak()；
if (iParam)
SaveListViewItemPositions((HWND) wParam)；
else
RestoreListViewItemPositions((HWND) wParam);
break；
}
return(FALSE);
}
//////////////////////////////// End of File //////////////////////////////////
614-621
22.4使用远程线程来注入DLL
注入DLL的第三种方法是使用远程线程(remote thread),它提供了最高的灵活性。这种方法 要求我们理解Windows的许多特性：进程、线程、线程同步、虚拟内存管理、DLL以及 Unicode。(如果不熟悉上述特性中的任何一项，请参阅本书中对应的章节。)大多数Windows 函数只允许一个进程对它自己进行操作。这样的限制是好事，因为它可以防止一个进程破 坏另一个进程。但是，Windows也提供了一些函数来让一个进程对另一个进程进行操作。 虽然这些函数中的大多数一开始都是为调试器或其他工具设计的，但是任何应用程序都可 以调用这些函数。
从根本上说，DLL注入技术要求目标进程中的~个线程调用LoadLibrary来载入我们想要 的DLL。由于我们不能轻易地控制别人进程中的线程，因此这种方法要求我们在目标进程 中创建一个新的线程。由于这个线程是我们自己创建的，因此我们可以对它执行的代码加 以控制。幸运的是，Windows提供了如下所示的CreateRemoteThread函数，它使得在另 一个进程中创建线程变得非常容易：
HANDLE CreateRemoteThread(
HANDLE hProcess,
PSECURITY_ATTRIBUTES psa,
DWORD dwStackSize,
PTHREAD_START_ROUT1NE pfnStartAddr,
PVOID pvParam,
DWORD fdwCreate,
PDWORD pdwThreadld);
除了 CreateRemoteThread 一个额外的参数hProcess之外，它与CreateThread完全相
OWS核心编程(第5版)
同。这个参数用来表示新创建的线程归哪个进程所有。参数pfnStartAddr是线程函数的内 存地址。当然，这个内存地址应该在远程进程(remote process)的地址空间中，因为线程函 数的代码不能在我们自己进程的地址空间中。
621-622
好了，现在我们已经知道了如何在另一个进程中创建一个线程，但怎样才能让那个线程载 入我们的DLL呢？答案很简单：我们需要让该线程调用LoadLibrary函数：
HMODULE LoadLibrary(PCTSTR pszLibFile);
如果在WinBase.h头文件中查看LoadLibrary»会发现下面的定义：
HMODULE WINAPI LoadLibraryA(LPCSTR IpLibFileName)；
HMODULE WINAPI LoadLibraryW(LPCWSTR IpLibFileName);
#ifdef UNICODE
#define LoadLibrary LoadLibraryW
#else
#define LoadLibrary LoadLibraryA
#endif // !UNICODE
实际上有两个LoadLibrary函数：LoadLibraryA和LoadLibraryW。它们之间的唯一区别 在于传给函数的参数类型。如果DLL文件名是以ANSI字符串的形式保存的，那么我们必 须调用LoadLibraryAo (A代表ANSL )如果文件名是以Unicode字符串的形式保存的， 那么我们必须调用LoadLibraryWo (W代表wide character,即宽字符。)LoadLibrary函 数根本不存在——只有LoadLibraryA和LoadLibraryW0对今天的大多数应用程序来说, LoadLibrary 宏被扩展为 LoadLibraryW。
幸运的是，LoadLibrary函数的函数原型和线程函数的函数原型基本相同。下面是线程函 数的函数原型：
DWORD WINAPI ThreadFunc(PVOID pvParam)；
好了，这两个函数原型并非完全相同，但它们已经足够接近了。这两个函数都接收一个参 数，而且都返回一个值。另外，这两个函数都使用相同的调用约定WINAPIo我们的运气 确实很好，因为我们要做的事情就是创建一个线程，并把线程函数的地址设为 LoadLibraryA或LoadLibraryW函数的地址。我们基本上只要执行一行代码，就像下面 的代码那样：
HANDLE hThread = CreateRemoteThread(hProcessRemote, NULL, 0,
LoadLibraryW, L"C: WMyLib.dll", 0, NULL);
如果我们想要使用ANSI版本，那么代码会像下面那样：
HANDLE hThread = CreateRemoteThread(hProcessRemote, NULL, 0,
LoadLibraryA, "C: WMyLib.dll" z 0, NULL);
当新线程在远程进程中被创建的时候，会立.即调用LoadLibraryW(或LoadLibraryA)函数， 并传入DLL路径名的地址。这很容易，但还存在其他两个问题。
第一个问题在于我们不能像刚才的代码那样，直接把LoadLibraryW或LoadLibraryA作 为第4个参数传给CreateRemoteThreado其原因不是那么明显。在编译和链接一个程序的 时候，生成的二进制文件中会包含一个导入段(在第19章中介绍)。这个段由一系列转换函
第22章DLL注入和API拦截
数(thunk)构成，这些转换函数用来跳转到导入的函数。因此，在代码调用诸如 LoadLibraryW之类的函数时，链接器会生成一个调用，来调用我们模块的导入段中的一 个转换函数，这个转换函数然后会跳转到实际的函数。
通 622-623
如果在调用CreateRemoteThread的时候直接引用LoadLibraryW,该引用会被解析为我 们模块的导入段中的LoadLibraryW转换函数的地址。如果把这个转换函数的地址作为远 程线程的起始地址传入，那么天知道远程线程会执行什么代码，其结果很可能是访问违规。 为了强制代码略过转换函数并直接调用LoadLibraryW函数，我们必须通过调用 GetProcAddress 来得到 LoadLibraryW 的确切地址。
对CreateRemoteThread的调用假定在本地进程(local process)和远程进程中，Kemel32.dll 被映射到地址空间中的同一内存地址。每个应用程序都需要Kemel32.dll,而且根据笔者的 经验，系统在每个进程中都会将Kemel32.dll映射到同一个地址。即使这个地址在系统重启 之后可能会改变,就像第14章的地址空间布局随机化(Address Space Layout Randomization, ASLR)一节中看到的那样，这个假定仍然成立。因此，必须像下面这样来调用 C reateRemoteTh read:
// Get the real address of LoadLibraryW in Kernel32.dll.
PTHREAD_START_ROUTINE pfnThreadRtn = (PTHREAD_START_ROUTINE)
GetProcAddress(GetModuleHandle(TEXT("Kernel32")), "LoadLibraryW")；
HANDLE hThread = CreateRemoteThread(hProcessRemote, NULL, 0, pfnThreadRtn, L"C： WMyLib.dll", 0, NULL)；
如果想要使用ANSI版本，那么代码应该像下面这样：
// Get the real address of LoadLibraryA in Kernel32.dll.
PTHREAD_START_ROUTINE pfnThreadRtn = (PTHREAD_START_ROUTINE)
GetProcAddress(GetModuleHandle(TEXT("Kernel32")), "LoadLibraryA")；
HANDLE hThread = CreateRemoteThread(hProcessRemote, NULL, 0, pfnThreadRtn, 'C: WMyLib.dll" # 0, NULL)；
很好，这解决了一个问题，但我们说过一共有两个问题。第二个问题与DLL路径字符串有 关。字符串“C:\XMyLib.dll”位于调用进程的地址空间中。我们把这个地址传给新创建的 远程线程，远程线程再把它传给LoadLibraryW。但当LoadLibraryW去访问这个内存地 址的时候，DLL的路径字符串并不在那里，远程进程的线程很可能会引发访问违规，系统 会向用户显示一条未处理的异常消息框，然后终止远程进程。没错，被终止的是远程进程, 而不是我们的进程。我们将成功地把另一个进程搞崩溃，而自己的进程会继续正常地执行! 为了解决这个问题，我们需要把DLL的路径字符串存放到远程进程的地址空间中去。然后， 在调用CreateRemoteThread的时候，我们需要传入(在远程进程的地址空间中)存放字符串 的地址。幸运的是，Windows为我们提供了 VirtualAllocEx函数，它可以让一个进程在另 一个进程的地址空间中分配一块内存：
PVOID VirtualAllocEx(
HANDLE hProcess,
PVOID pvAddress,
SIZE_T dwSize,
DWORD f1AllocationType,
「indows核心编程(第5版)
DWORD f1Protect);
623
另一个函数可以让我们释放这块内存：
BOOL VirtualFreeEx(
HANDLE hProcess,
PVOID pvAddress,
SIZE_T dwSize,
DWORD dwFreeType);
这两个函数与它们的非Ex版本相似(在第15章中介绍)，唯一的区别在于这两个函数要求 一个进程句柄作为它们的第一个参数。这个句柄表示应该在哪个进程中执行该操作。
一旦为字符串分配了一块内存，我们还需要一种方法来把字符串从进程的地址空间中复制 到远程进程的地址空间中去。Windows提供了一些函数，可以让一个进程对另一个进程的 地址空间进行读写：
BOOL ReadProcessMemory(
HANDLE hProcess,
LPCVOID pvAddressRemote,
PVOID pvBufferLocal,
SIZE_T dwSize,
SIZE_T* pdwNumBytesRead);
BOOL WriteProcessMemory(
HANDLE hProcess,
PVOID pvAddres s Remot e,
LPCVOID pvBufferLocal,
SIZE_T dwSize,
SIZE_T* pdwNumBytesWritten)；
远程进程由hProcess参数来标识。参数pvAddressRemote表示远程进程中的地址， pvBufferLocal是本地进程中的内存地址，dwSize是要传输的字节数，pdwNumBytesRead 和pdwNumBytesWritten分别表示实际传输的字节数，我们可以在函数返回后查看这两个 参数的值。
现在我们已经理解了我们要做什么，让我们来总结一下必须采取的步骤。
(1)	用VirtualAllocEx函数在远程进程的地址空间中分配一块内存。
(2)	用WriteProcessMemory函数把DLL的路径名复制到第1步分配的内存中。
(3)	用 GetProcAddress 函数来得到 LoadLibraryW 或 LoadLibraryA 函数(在 Kemel32.dll 中)的实际地址。
(4)	用CreateRemoteThread函数在远程进程中创建一个线程，让新线程调用正确的 LoadLibrary函数并在参数中传入第1步分配的内存地址。这时，DLL已经被注入到 远程进程的地址空间中，DLL的DUMain函数会收到DLL_PROCESS_ATTACH通 知并且可以执行我们想要执行的代码。当DUMain返商的时候，阮程线程会从 LoadLibraryW/A 调用返回到BaseThreadStart函数(在第6章中介绍)。 BaseThreadStart然后调用ExitThread,使远程线程终止。
现在远程进程中有一块内存，它是我们在第1步分配的，DLL也还在远程进程的地址 空间中。为了对它们进行清理，我们需要在远程线程退出之后执行后续步骤。
(5)	用VirtualFreeEx来释放第1步分配的内存。
第22章DLL注入和API拦截
(6)用 GetProcAddress 来得到 FreeLibrary 函数(在 Kemel32.dll 中)的实际地址。
⑺ 用CreateRemoteThread函数在远程进程中创建一个线程，让该线程调用FreeLibrary 函数并在参数中传入远程DLL的HMODULEo
基本上就是这样。
22.4.1	Inject Library 示例程序
22-InjLib.exe应用程序使用了 CreateRemoteThread函数来注入DLL。应用程序和DLL的 源代码和资源文件在本书配套网页的22-InjLib和22.ImgWalk目录中。程序通过下图所示 的对话框来让用户输入一个正在运行的进程的进程标识符。
Process Id (decimal): |
1^1
我们可以通过Windows自带的任务管理器来得到进程标识符。为了试图打开这个正在运行 的进程的句柄，程序会用这个标识符来调用OpenProcess,并请求合适的访问权限： hProcess = OpenProcess(
PROCESS_CREATE_THREAD I	//	For	CreateRemoteThread
PROCESS_VM_OPERATION I	//	For	VirtualAllocEx/VirtualFreeEx
PROCESS_VM_WRITEZ	//	For	WriteProcessMemory
FALSE, dwProcessId);
如果OpenProcess返回NULL,那说明应用程序所在的安全上下文(security context)不允许 它打开目标进程的句柄。一些进程是用本地系统帐号运行的，如WinLogon, SvcHost和 Csrss,登录的用户是无法对这些进程进行修改的。如果我们己经获得调试安全特权(debug security privilege)的授权，并且也启用了调试安全特权，那么我们也许能够打开这些进程的 句柄。第4章的Processinfo示例展示了应该怎么做。
如果OpenProcess调用成功，那么它会先用待注入DLL的完整路径来初始化一个缓存，然 后调用InjectLib,并传入远程进程的句柄以及要待注入DLL的路径名。最后，当InjectLib 返回的时候，程序会先显示一个消息框，表示DLL是否已经被成功地载入到了远程进程中， 然后关闭进程句柄。这就是整个过程。
读者可能会注意到，代码还特意检查了传入的进程标识符是否为0。如果为0,代码将调用 GetCurrentProcessId把进程标识符设为InjLib.exe自己的进程标识符。这样，当调用 InjectLib的时候，该DLL会被注入到进程自己的地址空间中。这样做是为了便于调试。 可以想象，当缺陷发生的时候，有时我们很难判断是本地进程有缺陷还是远程进程有缺陷。 一开始，我用两个调试器来调试代码，一个调试器用来监视InjLib,另一个调试器用来监 视远程进程。实践证明，这实在是太不方便了。后来我才发现InjLib也可以将一个DLL注 入到它本身，即注入到的地址空间与调用者所在的地址空间是同一个地址空间。这使代码

加dows核心编程（第5版）
的调试变得容易很多。
我们可以看到，在源代码的顶部，InjectLib实际上是一个宏。根据我们编译源代码的方式, 这个宏会被展开为InjectLibA或InjectLibW。InjectLibW函数是示例程序的关键。由于 注释已经非常清晰，因此这里也没有什么需要补充的。但是，我们会发现InjectLibA函数 比较短。这是因为它只不过是先把ANSI格式的DLL路径名转换为Unicode格式，然后再 调用InjectLibW来完成实际的工作。这种方式恰恰是第2章“字符和字符串处理”中推荐 的方式。这也意味着我只要编写和调试一份注入代码就够了一一省了我不少时间。
InjectLib InjectLibW EjectLib EjectLibW
■..\CommonFiles\CmnHdr.h" <windowsx.h> <stdio.h> <tchar.h> <malloc.h> <TlHelp32.h> ■Resource.h* <StrSafe.h>
// Calculate the number of bytes needed for the DLL's pathname
InjLib.cpp
Module： InjLib.cpp
Notices: Copyright (c) 2008 Jeffrey Richter & Christophe Nasarre
#include #include #include #include ♦include #include #include #include
///////////////////////////////////////////////////////////////////////////////
#ifdef UNICODE #define #define
#else ♦define #define
#endif
InjectLib InjectLibA EjectLib EjectLibA // !UNICODE
///////////////////////////////////////////////////////////////////////////////
BOOL WINAPI InjectLibW(DWORD dwProcessId, PCWSTR pszLibFile) (
BOOL bOk = FALSE; // Assume that the function fails HANDLE hProcess = NULL, hThread =
PWSTR pszLibFileRemote
=NULL, hThread = NULL; =NULL;
—try (
// Get a handle for the target hProcess = OpenProcess(
PROCESS_QUERY_INFORMATION | PROCESS_CREATE_THREAD	I
PROCESS_VK^OPERATION	|
PROCESS_VK.WRITE,
FALSE, dwProcessId)；
if (hProcess == NULL) _leave；
第22章DLL注入和API拦截
int cch = 1 + IstrlenW(pszLibFile)；
int cb = cch * sizeof(wchar_t);
// Allocate space in the remote process for the pathname pszLibFileRemote = (PWSTR)
VirtualAllocEx(hProcess, NULL, cb, MEbCCOMMIT, PAGE_READWRITE); if (pszLibFileRemote == NULL) _leave;
// Copy the DLL's pathname to the remote process' address space
if (JWriteProcessMemory(hProcess, pszLibFileRemote, (PVOID) pszLibFile, cb, NULL)) _leave;
// Get the real address of LoadLibraryW in Kernel32.dll
PTHREAD_START_ROUTINE pfnThreadRtn = (PTHREAD_START_ROUTINE)
GetProcAddress (GetModu 1 eHandle (TEXT ("Kemel32")), ■ LoadLibraryW")； if (pfnThreadRtn == NULL) _leave;
// Create a remote thread that calls LoadLibraryW(DLLPathname) hThread = CreateRemoteThread(hProcess, NULL, 0,
pfnThreadRtn, pszLibFileRemote, 0, NULL);
if (hThread == NULL) _leave；
// Wait for the remote thread to terminate
WaitForSingleObject(hThread, INFINITE);
bOk = TRUE; // Everything executed successfully
}
_finally { // Now, we can clean everything up
// Free the remote memory that contained the DLL's pathname if (pszLibFileRemote != NULL)
VirtualFreeEx(hProcess, pszLibFileRemote, 0, MEM_RELEASE)；
if (hThread != NULL) CloseHandle(hThread);
if (hProcess != NULL) CloseHandle(hProcess);
return(bOk);
///////////////////////////////////////////////////////////////////////////////
BOOL WINAPI InjectLibA(DWORD dwProcessId, PCSTR pszLibFile) (
// Allocate a (stack) buffer for the Unicode version of the pathname
SIZE_T cchSize = IstrlenA(pszLibFile) + 1； PWSTR pszLibFileW = (PWSTR)
^.alloca (cchSize ♦ sizeof (wchar_t))；
// Convert the ANSI pathname to its Unicode equivalent, StringCchPrintfW(pszLibFileW, cchSize, L"%S", pszLibFile);
// Call the Unicode version of the function to actually do the work. retumdnjectLibWtdwProcessId, pszLibFileW))；
}
//////////////////////////////////////////////////////////////////////Z7//”"/
BOOL WINAPI EjectLibW(DWORD dwProcessId, PCWSTR pszLibFile) ( 二项:招，.*品
BOOL bOk = FALSE； // Assume that the function fails
lows核心编程（第5版）
HANDLE hthSnapshot = NULL;
HANDLE hProcess = NULL, hThread = NULL;
—try (
// Grab a new snapshot of the process hthSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPM0DULEr dwProcessId)； if (hthSnapshot == INVALID_HANDLE_VALUE) _leave;
// Get the HMODULE of the desired library
MODULEENTRY32W me = ( sizeof(me) };
BOOL bFound = FALSE;
BOOL bMoreMods Module32FirstW(hthSnapshot,,&me)； for (； bMoreMods; bMoreMods = Module32NextW(hthSnapshotr &me)) ( bFound = (_wcsicmp(me.szModule, pszLibFile) == 0) I I (_wcsicmp(me.szExePath, pszLibFile) == 0)；
if (bFound) break;
}
if (!bFound) _leave；
// Get a handle for the target process. hProcess = OpenProcess(
PROCESS_QUERY_INFORMATION I PROCESS__CREATE_THREAD I PROCESS—VWLOPERATION, // For CreateRemoteThread FALSE, dwProcessId);
if (hProcess == NULL) _leave；
// Get the real address of FreeLibrary in Kernel32.dll PTHREAD_START_ROUTINE pfnThreadRtn = (PTHREAD_START_ROUTINE)
GetProcAddress(GetModu1eHandle(TEXT("Kernel32")), "FreeLibrary *)；
if (pfnThreadRtn == NULL) _leave；
// Create a remote thread that calls FreeLibrary() hThread = CreateRemoteThread(hProcess, NULL, 0, pfnThreadRtn, me.modBaseAddr, 0, NULL)；
if (hThread == NULL) _leave；
// Wait for the remote thread to terminate
WaitForSingleObject(hThread, INFINITE)；
bOk = TRUE； // Everything executed successfully
}
_finally { // Now we can clean everything up
if (hthSnapshot != NULL) CloseHandle(hthSnapshot)；
if (hThread != NULL) CloseHemdle(hThread)；
if (hProcess != NULL) CloseHandle(hProcess);
return(bOk)； }
///////////////////////////////////////////////////////////////////////////////
BOOL WINAPI EjectLibA(DWORD dwProcessId, PCSTR pszLibFile) (
// Allocate a (stack) buffer for the Unicode version of the pathname
SIZE_T cchSize = 1strlenA(pszLibFile) + 1；
PWSTR pszLibFileW = (PWSTR)
第22章 DLL注入和API拦截
_alloca(cchSize * sizeof(wchar_t));
// Convert the ANSI pathname to its Unicode equivalent StringCchPrintfWfpszLibFileW, cchSize, L"%S", pszLibFile);
// Call the Unicode version of the function to actually do the work, return(EjectLibW(dwProcessIdr pszLibFileW))；
}
///////////////////////////////////////////////////////////////////////////////
BOOL Dlg_OnInitDialog(HWND hWnd, HWND hWndFocus, LPARAM 1Param) { chSETDLGICONS(hWnd, IDI_INJLIB);
return(TRUE);
///////////////////////////////////////////////////////////////////////////////
void Dlg_OnCommand(HWND hWnd, int id, HWND hWndCtl, UINT codeNotify)(
switch (id) (
case IDCANCEL:
EndDialog(hWnd, id);
break；
case IDC_INJECT:
DWORD dwProcessId = GetDlgltemlnt(hWnd, IDC^PROCESSID, NULL, FALSE); if (dwProcessId == 0)(
// A process ID of 0 causes everything to take place in the // local process； this makes things easier for debugging. dwProcessId = GetCurrentProcessId()；
}
TCHAR szLibFile[MAX_PATH];
GetModuleFileName(NULL, szLibFile, _countof(szLibFile));
PTSTR pFilename = _tcsrchr(szLibFile, TEXT('\\')) + 1;
_tcscpy__s(pFilenamer _countof(szLibFile) - (szLibFile - szLibFile), TEXT(-22-ImgWalk.DLL"));
if (InjectLib(dwProcessId, szLibFile)) {
chVERIFY(EjectLib(dwProcessId, szLibFile))； chMB(■DLL Injection/Ejection successful.*);
} else (
chMB("DLL Injection/Ejection failed.■);
}
break；
}
}
//////////////////////////////////////////////////////////////////////////////I
INT_PTR WINAPI Dlg_Proc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM 1 Param) (,'
switch (uMsg) (	“人;
chHANDLE_DLGMSG(hWnd, WM_INITDIALOG, Dlg_OnInitDialog) ;	" —* "
chHANDLE__DLGMSG (hWnd, WM_COMMANDr Dlg_OnCommand);	「技,•代，；二
} ,• return (FALSE) ；	p . "备飘九斜
///////////////////////////////////////////////////////////////////////相方〃无熊
:indows核心编程（第5版）
int WINAPI _tWinMain(HINSTANCE hlnstExe, HINSTANCE, PTSTR pszCmdLine, int) ( DialogBox(hlnstExe, MAKEINTRESOURCE(IDD_INJLIB)r NULL, Dlg__Proc);
return(0)；
}
//////////////////////////////// End of File //////////////////////////////////
626-630
22.4.2	Image Walk DLL
22-ImgWalk.dll是这样一个DLL：它一旦被注入到进程的地址空间中，就可以报告该进程 正在使用的所有DLL。（该DLL的源文件和资源文件在本书配套网页的22-ImgWalk目录中。） 例如，如果我们先运行记事本程序，然后再运行22-InjLib并传入记事本程序的进程标识符， 那么InjLib会将22-ImgWalk.dll注入到记事本程序的地址空间中。一旦22JmgWalk.dll被 注入到进程中，它会检查记事本程序正在使用哪些文件映像（可执行文件和DLL）,并把结 果显示在下图所示的消息框中。
为了遍历一个进程的地址空间并查找已映射的文件映像，22.ImgWalk会反复调用 VirtualQuery来得到一个MEMORY_BASIC_INFORMATION结构。在每次迭代的时候, 22-ImgWalk会把文件的路径名与一个字符串连接起来，并将得到的字符串显示在消息框 中。下面是DllMain的入口函数的代码。
ImgWalk.cpp	」
/***************************★*****★********************************★*菽稣斜成£*膏'r Module: ImgWalk.cpp
第22章DLL注入和API拦截
Notices： Copyright (c) 2008 Jeffrey Richter & Christophe Nasarre
*★★★*★**★***★*****★***********************************************************/
#include ■..\CommonFiles\CnuiHdr.h"	/* See Appendix A. */
#include <tchar.h>
///////////////////////////////////////////////////////////////////////////////
BOOL WINAPI DllMain(HINSTANCE hlnstDll, DWORD fdwReason, PVOID flmpLoad) {
if (fdwReason == DLL_PROCESS_ATTACH) {
char szBuf[MAX_PATH * 100] = { 0 };	:订
PBYTE pb = NULL;
MEMORY_BAS IC_INFORMATION mbi;
while (VirtualQuery(pb, &mbi, sizeof(mbi)) == sizeof(mbi)) {
int nLen；
char szModName[MAX_PATH];
if (mbi.State == MEM_FREE)
mbi.AllocationBase = mbi.BaseAddress；
if ((mbi.AllocationBase == hlnstDll) I I
(mbi.AllocationBase != mbi.BaseAddress) I I
(mbi.AllocationBase == NULL)) (
// Do not add the module name to the list
// if any of the following is true：
// 1. If this region contains this DLL
// 2. If this block is NOT the beginning of a region
// 3・ If the address is NULL nLen = 0;
} else (
nLen = GetModuleFileNameA((HINSTANCE) mbi.AllocationBase, szModName, _countof(szModName))；
}
if (nLen > 0) (
wsprintfA(strchr(szBuf, 0), •\n%p-%s*, mbi.AllocationBase, szModName)；
}
pb += mbi.RegionSize;
}
// NOTE： Normally, you should not display a message box in DllMain // due to the loader lock described in Chapter 20. However, to keep // this san^jle application simple# I am violating this mle. .■-chMB(&szBuf[1]);
}
return(TRUE);
}
//////////////////////////////// End of File //////////////////////*////////////
首先，代码会检查区域的基地址与被注入的DLL的基地址是否匹配。如果匹配，代码便将 nLen设为0,这样被注入的DLL就不会出现在消息框中。如果不匹配，代码将试图得到 被载入到区域中这个基地址处的模块的文件名。如果nLen变量大于0,系统将识别出这个
bws核心编程（第5版）
地址标识的是一个已经载入的模块，它会在szModName缓存中填入该模块的完整路径。 代码然后将模块的HINSTANCE（基地址）与它的路径名连接起来，保存在szBuf字符串中， 这个字符串最终会显示在消息框中。循环结束的时候，DLL会用最终的字符串作为消息框 的内容来显示一个消息框。
22.5使用木马DLL来注入DLL
注入DLL的另一种方式是，把我们知道的进程必然会载入的一个DLL替换掉。举个例子, 如果我们知道进程会载入Xyz.dll,则可以创建自己的DLL并给它起同样的文件名。当然, 必须将原来的Xyz.dll改成别的名称。
在我们的Xyz.dll的内部，我们导出原来的Xyz.dll导出的所有符号。这用（第20章介绍的） 函数转发器很容易实现，这样一来，给某些函数安装挂钩只不过是小事一桩。但是，由于 这种方法不能自动适应版本变化，因此我们应该避免使用它。比如，如果替换的是一个系 统DLL,而Microsoft后来又在该DLL中添加了新的函数，那么我们的DLL中将不会有这 些新函数的转发器。引用了这些新函数的应用程序将无法被载入和执行。
如果只想把这种方法用在一个应用程序中，则可以给我们的DLL起一个独一无二的名称， 并修改应用程序的.exe模块的导入段。说得更具体一点，导入段包含了一个模块所需的所 有DLL的名称。我们可以在文件的导入段中找到那个要被替换的DLL的名称，对它进行 修改，这样载入程序就会载入我们自己的DLL。这种方法也不差，但前提是我们必须相当 熟悉.exe和DLL的文件格式。
22.6把DLL作为调试器来注入
调试器可以在被调试进程中执行许多特殊的操作。系统载入一个被调试程序（debuggee）的时 候，会在被调试程序的地址空间准备完毕之后，但被调试程序的主线程尚未开始执行任何 代码之前，自动通知调试器。这时，调试器可以强制将一些代码注入到被调试程序的地址 空间中（比如使用WriteProcessMemory）,然后让被调试程序的主线程去执行这些代码。
这种方法要求我们对被调试线程的CONTEXT结构进程操作，这也意味着我们必须编写与 CPU相关的代码。为了让这种方法能在不同的CPU平台上正常工作，我们必须对源代码进 行修改。此外，我们可能还必须手工编写一些我们想让被调试程序执行的机器语言指令。 在默认的情况下，如果调试器终止，那么Windows会自动终止被调试程序。但是，调试器 可以通过调用DebugSetProcessKillOnExit并传入FALSE来改变默认的行为。在不终止一 个进程的前提卜停止调试该进程也是有可能的，这要归功于DebugActiveProcessStop函数。
飕63^
第22章 DLL注入和API拦截
XI/ \7
12 3 4 fk z(x
22.7	使用CreateProcess来注入代码
如果要注入代码的进程是由我们的进程生成(spawn)的，那么事情就比较好办了。举个例子, 我们的进程(父进程)可以在创建新进程的时候将它挂起。这种方法允许我们改变子进程的 状态，同时又不影响它的执行，因为它根本还没有开始执行。但是，父进程也会得到子进 程的主线程的句柄。通过这个句柄，可以对线程执行的代码进行修改。由于我们可以设置 线程的指令指针，让它执行内存映射文件中的代码，因此我们可以解决前一节提到的问题。 下面是让进程对它的子进程的主线程执行的代码进行控制的一种方法。
让进程生成一个被挂起的子进程。
从.exe模块的文件头中取得主线程的起始内存地址。
将位于该内存地址处的机器指令保存起来。
强制将一些手工编写的机器指令写入到该内存地址处。这些指令应该调用 LoadLibrary 来载入一个 DLL。
(5)	让子进程的主线程恢复运行，从而让这些指令得到执行。
(6)	把保存起来的原始指令恢复到起始地址处。
(7)	让进程从起始地址继续执行，就好像什么都没有发生过一样。
要正确地实现第6步和第7步是比较棘手的，因为必须修改正在执行的代码。但这并非没 有可能，我就曾见过这样的实现。
这种方法有很多好处。首先，它在应用程序开始执行之前得到地址空间。其次，由于我们 的应用程序不是调试器，因此我们可以非常容易地对应用程序和注入的DLL进行调试。最 后，这种方法同时适用于控制台应用程序和GUI应用程序。
当然，这种方法也有一些缺点。只有当我们的代码在父进程中的时候，我们才能用这种 方法来注入DLL。当然，这种方法还与CPU相关，我们必须为不同的CPU平台做相应的 修改。
22.8	API拦截的一个例子
将一个DLL注入到进程的地址空间中是一种很好的方法，可以让我们了解进程内部的各种 信息。但是，简单地注入DLL并不能为我们提供足够的宿息。我们常常想要知道某个进程 中的线程具体是怎么调用各种函数的,我们可能还想对一个Windows函数的行为进行修改。 例如，我知道一家公司开发了一个DLL。这个DLL会被数据库产品载入，它的工作是对该 数据库产品的功能进行增强和扩展。当该数据库产品终止的时候，这个DLL会收到一个 DLL_PROCESS_DETACH通知，当且仅当这个时候，它会执行所有的清理代码。这个 DLL会调用其他DLL中的一些函数来关闭套接字、文件以及其他资源，但当它收到 DLL_PROCESS_DETACH通知的时候,位于进程地址空间中的其他DLL也已经收到了它
indows核心编程（第5版）
们的DLL_PROCESS_DETACH通知。因此，当该公司的这个DLL试图进行清理的时候, 由于其他DLL已经清理完毕，因此它调用的许多函数将会失败。
该公司聘请我来帮助他们解决这个问题，我建议他们对ExitProcess函数进行拦截。正如我 们所知，调用ExitProcess会使系统用DLL_PROCESS_DETACH来通知所有的DLL。通 过对ExitProcess函数进行拦截，我们可以确保当ExitProcess被调用的时候，该公司的DLL 能够立刻得到通知。由于这个通知发生在任何其他DLL得到DLL_PROCESS_DETACH 通知之前，因此进程中的所有DLL都还是经过初始化的，能够正常工作。这时，该公司的 DLL得知进程即将终止，它可以成功地完成所有的清理。然后操作系统的ExitProcess函 数会被调用，这使得所有的DLL都收到自己的DLL_PROCESS_DETACH通知并进行清 理。当该公司的DLL收到这个通知的时候，不需要进行什么特殊清理，因为该清理的已经 清理过了。	一
在这个例子中，我们不需要为注入DLL费心：数据库应用程序的设计允许我们这样做，它 会载入该公司的DLL。当该公司的DLL被载入的时候，必须遍历所有已经载入的可执行文 件和DLL模块来找到对ExitProcess的所有调用。当该DLL找到所有对ExitProcess的调 用之后，它必须对各模块进行修改，使它们调用该公司的DLL中的一个函数，而不是调用 操作系统的ExitProcess函数。（这个过程比听起来还要简单得多。）一旦该公司用来替代 ExitProcess的函数（更通常的叫法是拦截函JR,即hook function）^行完它的清理代码，就 会调用操作系统的ExitProcess函数（在Kemel32.dll中）。
这个例子展示了 API拦截的一个典型用法，它用非常少的代码解决了一个非常实际的问题。
22.8.1通过覆盖代码来拦截API
API拦截并不是什么新发明——开发人员使用API拦截已经有许多年了。当我们用它来解 决刚才描述的问题时，每个人想到的第一个“解决方案”就是通过覆盖代码来进行拦截。 下面是这种方法的工作方式。
⑴ 在内存中对要拦截的函数（假设是Kemel32.dll中的ExitProcess）进行定位，从而得到它 的内存地址。
（2）	把这个函数起始的几个字节保存到我们自己的内存中。
（3）	用CPU的一条JUMP指令来覆盖这个函数起始的几个字节，这条JUMP指令用来跳 转到我们的替代函数的内存地址。当然，我们的替代函数的函数签名必须与要拦截的 函数的函数签名完全相同：所有的参数必须相同，返回值必须相同，调用约定也必须 相同。
⑷现在，当线程调用被拦截函数（hooked function）的时候，跳转指令实际上会跳转到我们 的替代函数。这时，我们就可以执行自己想要执行的任何代码。
（5）为了撤销对函数的拦截，我们必须把（在第2步中）保存下来的字节放回被拦截函数起 始的几个字节中。
第22章 DLL注入和API拦截
(6)	我们调用被拦截函数(现在已经不再对它进行拦截了)，让该函数执行它的正常处理。
(7)	当原来的函数返回时，我们再次执行第2步和第3步，这样我们的替代函数将来还会 被调用到。
16位Windows下的程序员大量使用了这种方法，它在那个环境下工作得很好。今天，这种 方法存在一些严重的不足，我强烈建议不要使用它。首先，它对CPU有依赖性：x86, x64, IA.64以及其他CPU的JUMP指令各不相同，为了让这种方法能够工作，我们必须手工编 写机器指令。其次，这种方法在抢占式、多线程环境下根本不能工作。一个线程覆盖另一 个函数起始位置的代码是需要时间的，在这个过程中，另一个线程可能试图调用同二个函 数，其结果将是灾难性的！因此，只有当我们知道在任一时刻只可能有一个函数会试图调 用这个函数时，这种方法才可以工作。
22.8.2通过修改模块的导入段来拦截API
事实证明，另一种拦截API的方法可以解决刚才提到的两个问题。这种方法不仅容易实现, 而且也相当健壮。但为了理解这种方法，我们必须理解动态链接的工作方式。特别是，我 们必须理解模块的导入段中包含什么信息。虽然第19章并没有深入讨论相关的数据结构， 但是我们也确实花了不少篇幅来解释导入段是如何生成的，以及其中包含什么信息。在阅 读后面的内容时，读者可以回过头去参考第19章。
正如我们所知，一个模块的导入段包含一组DLL,为了让模块能够运行，这些DLL是必需 的。此外，导入段还包含一个符号表，其中列出了该模块从各DLL中导入的符号。当该模 块调用一个导入函数的时候，线程实际上会先从模块的导入表中得到相应的导入函数的地 址，然后再跳转到那个地址。
因此，为了拦截一个特定的函数，我们所需要做的就是修改它在模块的导入段中的地址。 就这么简单，完全不存在对CPU的依赖性。而且，由于我们并没有修改函数的代码，因 此也就不必担心线程同步的问题。
下面的函数用来执行这个“神奇的”操作。它在一个模块的导入段中查找对一个符号的引 用，如果存在这样的引用，它便会修改该符号的地址。
void CAPIHook::ReplacelATEntxylnOneMod(PCSTR pszCalleeModName,
PROC pfnCurrent, PROC pfnNew, HMODULE hmodCaller) (
- * ■ " •
// Get the address of the module's import section
ULONG ulSize；
//An exception was triggered by Explorer (when browsing the content of // a folder) into imagehipdl1. It looks like one module was unloaded... // Maybe some threading problem： the list of modules from Tool he Ip might // not be accurate if FreeLibrary is called during the enumeration. PIMAGE_IMPORT_DESCRIPTOR plinportDesc = NULL;
—try <
plmportDesc = (PIMAGE_IMPORT_DESCRIPTOR) ImageDirectoryEntryToData(
hmodCaller, TRUE, IMAOE_J>IRECTORY_ENTRY_IMPORT, &ulSize);
indows核心编程(第5版)
--------------------•
_except (InvalidReadExceptionFilter(GetExceptionlnformation())) (
// Nothing to do in here« thread continues to run normally // with NULL for plmportDesc
)
if (plmportDesc == NULL) return； // This module has no import section or is no longer loaded
// Find the import descriptor containing references to callee's functions for (； pImportDesc->Naine； pImportDesc++) (
PSTR pszModName = (PSTR) ((PBYTE) hmodCaller + plmportDesc->Name); if (1strcmpiA(pszModName, pszCalleeModName) == 0) {
, // Get caller's import address table (IAT) for the callee's functions PIMAGE_THUNK_DATA pThunk = (PIMAGE_THUNK_DATA)
((PBYTE) hmodCaller + pImportDesc->FirstThunk);
// Replace current function address with new function address for (； pThunk->ul.Function； pThunk++)(
// Get the address of the function address
PROC* ppfn = (PROC*) &pThunk->ul.Function；
// Is this the function we1 re looking for? BOOL bFound = (*ppfn == pfnCurrent); if (bFound) (
if (1WriteProcessMemory(GetCurrentProcess(), ppfn, &pfnNewz sizeof(pfnNew), NULL) && (ERROICNOACCESS == GetLastError())) ( DWORD dwOldProtect;
if (VirtualProtect(ppfn, sizeof(pfnNew)r PAGE__WRITECOPY, &dw01dProtect)) (
WriteProcessMemory(GetCurrentProcess()r ppfn, &pfnNew, sizeof(pfnNew), NULL);
VirtualProtect(ppfn, sizeof(pfnNew)r dwOldProtect, &dw01dProtect>;
}
) return； // We did it, get out }
}
} // Each import section is parsed until the right entry is found and patched )
}
为了帮助读者理解应该如何调用这个函数，让我们先设想一个可能的情形。假设我们有一 个名为Database.exe的模块，这个模块的代码调用了 Kemel32.dll中的ExitProcess函数， 但我们想让它调用我们的DbExtend.dll模块中的MyExitProcess函数。为了达到这一目的， 我们应该像F面这样调用ReplacelATEntrylnOneMod函数：
PROC pfnOrig = GetProcAddress(GetModuleHandle("Kernel32"),
"ExitProcess")；
HMODULE hmodCaller = GetModuleHandle("Database.exe")；
ReplacelATEntrylnOneMod(
"Kernel32.dll", // pfnOrig, // MyExitProcess, // hmodCaller) ； //
Module containing the function (ANSI)
Address of function in callee
Address of new function to be called
Handle of module that should call the new function
ReplacelATEntrylnOneMod 所做的第一件事就是调用 ImageDirectoryEntryToData 并传
第22章 DLL注入和API拦截
入 IMAGE_DIRECTORY_ENTRY_IMPORT,其目的是为了对 hmodCaller 的导入段进行 定位。如果ImageDirectoryEntryToData函数返回NULL,那么说明DataBase.exe模块没 有导入段，不需要执行任何操作。ImageDirectoryEntryToData函数由ImageHlp.dll提供， 为了捕获从这个函数中抛出的任何意想不到的异常，我们用_try/_except代码块（第24章 对此进行了详细介绍）把这个函数调用保护起来。由于这种情况有可能发生，因此这样的保 护是必需的。如果在调用ReplacelATEntrylnOneMod时，在最后一个参数中传入的是一 个无效的模块句柄，就会触发0xC0000005异常。举个例子，这种情况可能发生在Windows 资源管理器的环境中，Windows资源管理器会在另一个线程中快速地动态载入和卸载DLL, 从而导致ReplacelATEntrylnOneMod所在线程所引用的模块句柄变成无效的。
637T38
如果Database.exe有一个导入段，那么ImageDirectoryEntryToData会返回导入段的地址， 实际上这是一个PIMAGE_IMPORT_DESCRIPTOR类型的指针。我们现在必须在模块的 导入段中查找我们想要修改的导入函数所在的DLL。在这个例子中，我们要查找的符号是 从"Kemel32.dll"（即传给ReplacelATEntrylnOneMod函数的第一个参数）中导入的。for 循环对DLL模块的名称进行搜寻。注意，模块的导入段中的所有字符串都是以ANSI格式 （绝对不会是Unicode）保存的。这也是代码为什么要显式地调用IstrcmpiA函数，而不使用 Istrcmpi宏的原因。
如果直到循环结束都未能找到对“Kemel32.dll”中任何符号的引用，函数便会返回，不执 行任何操作。如果模块的导入段确实引用了 “Kemel32.dll”中的符号，那么我们会得到一 个地址，这个地址指向一个由IMAGE_THUNK_DATA结构组成的数组，其中包含与导入 符号有关的信息。注意，有些编译器（比如Borland Delphi）,会在同一个模块中生成多个导 入段，这也是为什么我们在找到第一个符合要求的导入段时不停止循环的原因。然后，对 每个符合要求的导入段，我们会遍历所有从“Kemel32.dll”中导入的符号，来查找一个与 符号当前地址相匹配的地址。在本例中，查找的是一个与ExitProcess函数的地址相匹配的 地址。
如果没有地址与我们要找的地址相匹配，那么这个模块肯定没有导入我们要找的符号，因 此 ReplacelATEntrylnOneMod 直接返回。如果找到了地址，ReplacelATEntrylnOneMod 就会调用WriteProcessMemory来将地址修改为替代函数的地址。如果有错误发生，那么 ReplacelATEntrylnOneMod还会尝试用VirtualProtect来修改页面保护属性，然后再修改 函数指针，最后用VirtualProtect来恢复页面保护属性。
从现在开始，当任何线程执行Datobase.exe模块中调用了 ExitProcess的代码时，会调用我 们的替代函数。在这个替代函数中，如果想要正常的ExitProcess处理，我们可以轻易地得 到位于Kemel32.dll中真正的ExitProcess函数的地址并调用它。
注意，ReplacelATEntrylnOneMod函数修改的函数调用都来自同一个模块。但是，地址空 间中的另一个DLL也可能会调用ExitProcesSo如果Database.exe之外的一个模块试图调用 ExitProcess»那么它会成功地调用到位于Kemel32.dll中的ExitProcess函数。
indows核心编程(第5版)
如果想要捕获所有模块对ExitProcess的所有调用，必须对载入到地址空间中的每个模块都 调用 ReplacelATEntrylnOneModo 为此，我编写了 另一个名为 ReplacelATEntrylnAllMods 的函数。这个函数只不过是用ToolHelp函数来枚举载入到进程地址空间中的所有模块，然 后再以每个模块的句柄为最后一个参数来调用ReplacelATEntrylnOneModo
有一些地方口J能会出现问题。举个例子，如果一个线程在我们调用了 ReplacelATEntrylnAllMods之后调用LoadLibrary来载入一个新的DLL,那会怎么样？ 在这种情况下，新载入的DLL可能会调用ExitProcess,而我们还没有拦截这些调用。为 了解决这个问题，我们必须拦截LoadLibraryA, LoadLibraryW, LoadLibraryExA以及 LoadLibraryExW函数，这样我们就能够捕获这些调用，并为新载入的模块调用 ReplacelATEntrylnOneModo但是，仅仅这样还是不够的。设想新载入的模块对其他DLL 有链接时的依赖性，而这些DLL也可能会调用ExitProcess<>当LoadLibrary*函数被调用 的时候，Windows会首先载入这些静态链接的DLL,而不给我们以机会去更新它们的导入 地址表(Import Address Table, IAT)中与ExitProcess有关的部分。解决的办法很简单，我们 不应该只为显式载入的DLL调用 ReplacelATEntrylnOneMod ,而应该调用 ReplacelATEntrylnAllMods,这样新的隐式载入的模块也能得到更新。
63&639
最后一个问题与GetProcAddress有关。假设一个线程执行下面的代码：
typedef int (WINAPI *PFNEXITPROCESS)(UINT uExitCode);
PFNEXITPROCESS pfnExitProcess = (PFNEXITPROCESS) GetProcAddress( GetModuleHandle("Kernel32"), "ExitProcess");
pfnExitProcess(0);
这段代码告诉系统先取得Kemel32.dll中ExitProcess的实际地址，然后再调用该地址。如 果一个线程执行这段代码，那么我们的替代函数也不会被调用。为了解决这个问题，我们 还必须拦截GetProcAddress函数。如果这个函数被调用，而且要返回的一个被拦截函数的 地址，则必须返回相应的替代函数的地址。
下一节介绍的示例程序不仅展示了如何拦截API,而且解决了所有与LoadLibrary和 GetProcAddress相关的问题。
说明 MSDN 杂志上一篇名为 wDetect and Plug GDI Leaks in Your Code with Two Powerful Tools fbr Windows XPW的文章解释了如何用一个专门的线程和内存映射文件，在侦 听程序和被拦截进程之间构建一种更加复杂的双向通信协议。文章可以通过以下链 接访 问：http://msdn.microsoft.eom/msdnmag/issues/03/01 /GDILeaks/o
22.8.3	Last MessageBox Info 示例程序
Last MessageBox Infb 应用程序(22-LastMsgBoxInfd.exe)展示了如何拦截 API。它拦截了所有 对MessageBox函数(位于User32.dll中)的调用。为了在所有进程中拦截这个函数，应用程 序使用了 Windows挂钩技术来完成DLL注入。应用程序的源文件和资源文件在本书配套
第22章 DLL注入和API拦截
网页的 22-LastMsgBoxInfb 和 22-LastMsgBoxInfbLib 目录中。
应用程序启动后，会显示下图所示的对话框。
这时，应用程序处于等待状态。现在让我们运行任何一个应用程序并让该应用程序显示一 个消息框。出于测试的目的，让我们使用第20章构建的20-DelayLoadApp.exeo当执行不 同的延迟载入的情形时，这个C++应用程序会弹出类似下图所示的消息框。
639
二“J \	4 [ ft if • <
* * ' * •
Module "20-DelayLoadLibM is loaded.
OK
关闭这个对话框之后，Last MessageBox Info对话框看起来下图所示。
lessageBdxInfo
Proce$$: (1140) C:\Apps\20-D dajtoad^pp.exe Caption: C:\Apps\20-D da^iLoadAipp.exe Message: Module >2ODelayLoadLb>l is loaded Result Ok
正如我们所见,LastMsgBoxInfo应用程序可以确切地知道其他进程是如何调用MessageBox 函数的。但是，读者可能会注意到LastMsgBoxInfo并没有检测到第一个消息框。原因很简 单：用来注入我们的监控代码的Windows挂钩是在第一个消息框弹出之后，由它收到消息 所触发的——而这时已经太晚了……
用来显示和管理Last MessageBox Infb对话框的代码相当简单。拦截API是难点所在。为 了让拦截API更加容易，我创建了一个名为CAPIHook的C++类。这个类在APIHook.h中 定义，在APIHookxpp中实现。这个类非常容易使用，因为它只有少数几个公有成员函数： 一个构造函数、一个析构函数以及一个函数用来返回被拦截函数原来的地址。
为了拦截一个函数，我们只要像下面这样创建一个CAPIHook类的实例：
CAPIHook g_MessageBoxA("User32.dll", "MessageBoxA",
(PROC) Hook_MessageBoxA, TRUE)；
CAPIHook g_MessageBoxW("User32.dll", "MessageBoxW",
(PROC) Hook_MessageBoxW, TRUE);
lows核心编程(第5版)
注意，必须拦截两个函数：MessageBoxA和MessageBoxWo这两个函数都包含在User32.dll 中。当MessageBoxA被调用的时候，我们希望被调用的是Hook__MessageBoxA；当 MessageBoxW被调用的时候，我们希望被调用的是Hook_MessageBoxWo
CAPIHook类的构造函数只不过是先把我们想要拦截哪个API记下来，然后再调用 ReplacelATEntrylnAllMods 来进行拦截。
下一个公有成员函数是析构函数。当CAPIHook对象超出作用域的时候，它的析构函数会 调用ReplacelATEntrylnAllMods来把每个模块中该符号的地址重置为原来的地址，这样 就撤销了对这个函数的拦截。
第三个公有成员用来返回函数原来的地址。通常替代函数为了调用原来的函数，会在内部 调用这个成员函数。下面就是Hook_MessageBoxA函数中的代码：
int WINAPI Hook_MessageBoxA(HWND hWnd, PCSTR pszText,
PCSTR pszCaption, UINT uType) (
inc nResult = ((PFNMESSAGEBOXA)(PROC) g_MessageBoxA)
(hWnd, pszText, pszCaption, uType)；
SendLastMsgBoxInfo(FALSE, (PVOID) pszCaption, (PVOID) pszText, nResult); return(nResult);
)
这段代码用到了类型为CAPIHook的全局变量g_MessageBoxAo将这个对象转型为PROC 数据类型使得第3个成员函数返回MessageBoxA函数在User32.dll中原来的地址。
如果使用这个C++类，那么拦截导入函数和撤销拦截就是这么简单。如果我们查看 CAPIHook.cpp底部的代码，会发现CAPIHook类自动创建了一些实例来捕获对 LoadLibraryA^ LoadLibraryW, LoadLibraryExA, LoadLibraryExW 和 GetProcAddress 的调用。通过这种方式，CAPIHook类自动地处理了前面提到的问题。
注意，当CAPIHook的构造函数运行的时候，我们想要拦截的导入函数所在的模块必须已 经被载入，否则CAPIHook的构造函数将不可能得到函数原来的地址：GetModuIeHandleA 会返回NULL, GetProcAddress会失败。延退载入模块所提供的优化就是直到延迟载入的 导出函数真正地被调用时，才载入对应的模块。正因为如此，CAPIHook无法处理延迟载 入模块的情况，这是它的一个主要局限。
一种可能的解决方案是用被拦截的LoadLibrary*函数，来检测何时一个模块的一个导出函 数应该拦截但尚未拦截，然后执行下面的操作。
(1)	再次对已经载入的模块的导入表进行拦截，因为现在可以调用GetProcAddress并得到 被拦截函数原来的地址。注意，我们需要在构造函数中将函数名作为类的一个成员保 存起来。
(2)	像ReplaceEATEntrylnOneMod函数中显示的那样，直接对模块的导出地址表中的被 拦截函数进行更新。这样，所有调用了被拦截函数的新模块都会调用我们的替代函数。
但是，如果导出被拦截函数的模块由于FreeLibrary调用而已经被卸载了，那会发生什么
第22章DLL注入和API拦截
情况？如果该模块后来又重新被载入，又会发生什么情况？可以想象，一个完整的实现己 经超出了本章讨论的范畴，但我们现在已经掌握了所有的基本要素，应该完全有能力将上 述解决方案加以改编，以解决我们的实际问题。
WW~Microsoft研究院 已经发表了一个名为 Detours的拦截 API,详情请访问 http://research.microsoft.com/sn/detours/并可在此下载。
/* See Appendix A. */
#include #include #include #include #include
LastMsgBoxIn£o・ epp
Notices： Copyright (c) 2008 Jeffrey Richter & Christophe Nasarre
******************************************************************************
"..\CommonFiles\CmnHdr.h• <windowsx.h> <tchar.h> •Resource.hB
...\22-LastMsgBoxInfoLib\LastMsgBoxInfoLib.hB
// Some hooked process sent us some message b8x info, display it SetDlgItemTextW(hWnd/ IDC_INF0, (PCWSTR) pcds->lpData}； return(TRUE);
switch (id) ( case IDCANCEL:
EndDialog(hWnd/§^®f.^
break；
chSETDLGICONS(hWnd, IDI_LASTMSGBOXINFO); SetDlgltemText(hWnd, IDC_INF。，
TEXT("Waiting for a Message Box be dismissed-))； return(TRUE)；
}
///////////////////////////////////////////////////////////////////////////////
BOOL Dlg_OnInitDialog(HWND hWnd, HWND hWndFocus, LPARAM IParam) (
///////////////////////////////////////////////////////////////////////////////
void Dlg_OnSize(HWND hWnd, HINT state, int ex, int cy) (
SetWindowPos(GetDlgltem(hWnd, IDC_INFO), NULL, . 0, 0, ex, cy, SWP NOZORDER):
///////////////////////////////////////////////////////////////////////////////
void Dlg_0nCommand(HWND hWnd, int id, HWND hWndCtl, UINT codeNotify) (
〃〃///////////////////////////////////I///////////////////////////////////////
r *. -	, t , . < * 4 -	i • . :, , .,，! X， •	：,•	AC,» • V ,
BOOL Dlg_OnCopyData(HWND hWnd, HWND hWndFrom, PCOPYDATASTRUCT peds) (
///////////////////////////////////////////////////////////////////////////////
INT_PTR WINAPI Dlg_Proc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM 1 Param) (
WtLINITDIALOG, WM_SIZE# WM_COMMAND, WK_COPYDATA,
///////////////////////////////////////////////////////////////////////////////
switch (uMsg) ( chHANDLE_DLGMSG(hWnd, chHANDLE_DLGMSG(hWnd, chHANDLE_DLGMSG(hWnd, chHANDLE^DLGMSG(hWnd, } return(FALSE);
}
Dlg_OnInitDialog); Dlg_OnSize);
Dlg_0nCommand); Dlg^OnCopyData)；
int WINAPI _tWinMain(HINSTANCE hlnstExe, HINSTANCE, PTSTR pszCmdLine, int) (
DWORD dwThreadld = 0;
LastMsgBoxInfo_HookAllApps(TRUE, dwThreadld);
DialogBox(hlnstExe, MAKEINTRESOURCE(IDD_LASTMSGBOXINFO)# NULL, Dlg_Proc); LastMsgBoxInfo_HookAllApps(FALSE, 0);
return(0);
}
//////////////////////////////// End of File //////////////////////////////////
#include #include #include ♦include #include
LastMsgBoxInfoLib・ cpp /******•*********••***************••****•***•••**•****•***•******•***********•* Module： LastMsgBoxInfoLib.cpp
Notices: Copyright (c) 2008 Jeffrey Richter & Christophe Nasarre
************★**************************★***********************•****★★********/
///////////////////////////////////////////////////////////////////////////////
■..\CommonFiies\CmnHdr.hB <WindowsX.h> <tchar.h> <stdio.h>
"APIHook.h"
#define LASTMSGBOXINFOLIBAPI extern "C" ___declspec(dllexport)
#include "LastMsgBoxInfoLib.h' #include <StrSafe.h>
// Prototypes for the hooked functions typedef
PCSTR
int (WINAPI pszCaption,
typedef
int (WINAPI
*PFNMESSAGEBOXA)(HWND hWnd, PCSTR pszText, UINT uType);
*PFNMESSAGEBOXW)(HWND hWnd, PCWSTR pszText, PCWSTR pszCaption, UINT uType);
//We need to reference these variables before we create them, extern CAPIHook g_MessageBoxA; extern CAPIHook g_MessageBoxW；
///////////////////////////////////////////////////////////////////////////////
// This function sends the MessageBox info to our main dialog box
第22章DLL注入和API拦截
L"(Unknown)•;
the main dialog
_countof(sz), %s\r\nCaption： %s\r\nCaption：
void SendLastMsgBoxInfo(BOOL bUnicode,
PVOID pvCaption, PVOID pvText, int nResult) (
// Get the pathname of the process displaying the message box wchar_t szProcessPathname (MAX__PATH]； GetModuleFileNameW(NULLr szProcessPathname, MAX_PATH)；
// Convert the return value into a human-readable string PCWSTR pszResult =
switch	(nResult) {				
case	IDOK:	pszResult	=	L-Ok";	break;
case	IDCANCEL:	pszResult		L"Cancel";	break；
case	IDABORT:	pszResult	—	L-Abort-;	break；
case	IDRETRY:	pszResult	=	L"Retry";	break；
case	IDIGNORE:	pszResult	=	L"Ignore"；	break；
case	IDYES:.	pszResult	=	L-Yes";	break；
case	IDNO:	pszResult		L"No";	break；
case	IDCLOSE:	pszResult	z	L*CloseB；	break；
case	IDHELP:	pszResult	=	L-Help";	break；
case	IDTRYAGAIN:	pszResult	2	LBTry Again";	break；
case	IDCONTINUE:	pszResult	=	L"Continue";	break；
}
// Construct the string to send to wchar_t sz[2048];
StringCchPrintfW(sz,
? L"Process: (%d)
:L"Process： (%d)
GetCurrentProcessId(), szProcessPathname, pvCaption, pvText, pszResult);
bUnicode %s\r\nMessage： %S\r\nMessage:
%s\r\nResult： %s" %S\r\nResult: %s",
// Send the string to the main dialog box COPYDATASTRUCT cds = { 0, ((DWORD)wcslen(sz) + 1)
* sizeof(wchar_t), FORWARD_WM__COPYDATA(FindWindow(NULL, TEXT("Last MessageBox Info・)), NULL, &cds, SendMessage);
}
///////////////////////////////////////////////////////////////////////////////
// This is the MessageBoxW replacement function
int WINAPI Hook_MessageBoxW(HWND hWnd, PCWSTR pszText, LPCWSTR pszCaption, UINT uType) (
// Call the original MessageBoxW function int nResult = ((PFNMESSAGEBOXW)(PROC) g_MessageBoxW)
(hWnd, pszText, pszCaption, uType)；
// Send the information to the main dialog box SendLastMsgBoxInfo(TRUE, (PVOID) pszCaption, (PVOID) pszText, nResult);
// Return the result back to th« waller return(nResult)；
}
/////////////////////〃///〃〃/〃〃〃///〃〃〃〃〃/////////////////////////////
// This is the MessageBoxA replacement fUjact;ion；
int WINAPI Hook_MessageBoxA(HWND hWrtd, PCSTR pszText, PCSTR pszCaption, UINT uType) (
// Call the original MessageBoxA function
int nResult = ( (PFNMESSAGEBOXA) (PROC|\ gJMessagreBoxA) (hWnd, pszText, pszCaption,
lows核心编程（第5版）
// Send the information to the main dialog box
SendLastMsgBoxInfo(FALSE, (PVOID) pszCaption, (PVOID) pszText, nResult);
// Return the result back to the caller return(nResult)；
///////////////////////////////////////////////////////////////////////////////
// Hook the MessageBoxA and MessageBoxW ftmctions CAPIHook gJMessageBoxA(■User32.dl1•, ■MessageBoxA", (PROC) Hook^MessageBoxA);
CAPIHook g_MessageBoxW("User32.dll■/ "MessageBoxW*, (PROC) HookJMessageBoxW)；
HHOOK gjhhook = NULL;
///////////////////////////////////////////////////////////////////////////////
static LRESULT WINAPI GetMsgProc(int code, WPARAM wParam, LPARAM iParam) { return(CallNextHookEx(g_hhookr code, wParam, IParam))；
///////////////////////////////////////////////////////////////////////////////
// Returns the HMODULE that contains the specified memory address static HMODULE ModuleFromAddress(PVOID pv) (
MEMORY_BASIC_INFORMATION mbi;
return((VirtualQuery(pv,	sizeof(mbi)) != 0)
? (HMODULE) mbi.AllocationBase : NULL)；
///////////////////////////////////////////////////////////////////////////////
BOOL WINAPI LastMsgBoxInfo_HookAllApps(BOOL blnstall, DWORD dwThreadld) (
BOOL bOk;
if (blnstall) {
chASSERT(g_hhook == NULL)； // Illegal to install twice in a row
// Install the hhook = i
bOk = (g_hhook != } else (
■辱濒浮丁牛
ChASSERT (g_hhook != NULE«WC Can• t uninstall if bOk = UnhookWi ndowsHookEii^™»^fe| g_Jlh8k = NULL;
:not installed
return(bOk)；
J
//////////////////////////////// End of Pile //////////////////////////////////
第22章DLL注入和API拦截
LastMsgBoxInfoLib.h
Module: LastMsgBoxInfoLib.h
Notices： Copyright (c) 2008 Jeffrey Richter & Christophe Nasarre
I********************** I****************************************************/
#ifndef LASTMSGBOXINFOLIBAPI
#define LASTMSGBOXINFOLIBAPI extern	_declspec(dllimport)
#endif
///////////////////////////////////////////////////////////////////////////////
LASTMSGBOXINFOLIBAPI BOOL WINAPI LastMsgBoxInfo_HookAllApps(BOOL blnstall, DWORD dwThreadld);
///////〃//////////〃/////////// End of File //////////////////////////////////
APIHook.cpp
/*********************•********************■************************★*********** Module: APIHook.cpp
Notices： Copyright (c) 2008 Jeffrey Richter & Christophe Nasarre it*****************************************************************************/
#include *..\CommonFiles\CmnHdr.h・
#include <ImageHlp.h>
#pragma comment(lib, ■ImageHlp•)
#include "APIHook.h"
#include ■..\CommonFiles\Toolhelp.h" #include <StrSafe.h>
/////////////////////////////////////////////////////////////////////////////////
// The head of the linked-list of CAPIHook objects CAPIHook* CAPIHook::snupHead = NULL;
// By default, the module containing the CAPIHook() is not hooked BOOL CAPIHook::ExcludeAPIHookMod = TRUE;
///////////////////////////////////////////////////////////////////////////////
CAPIHook::CAPIHook(PSTR pszCalleeModName, PSTR pszFuncName, PROC pfnHook) {
// Note: the function can be hooked only if the exporting module
// is already loaded. A solution douid be to store the function
// name as a member； then, in' the hooked LoadLibrary* handlers, parse //	the list of CAPIHook instancesr check if pszCa11eeModName
//	is the name of the loaded ttiodule to its export table, and
// re-hook the import tables of all- loaded modules.
nupNext = sm_pHead； // The next node was at head sm_pHead = this；	// This node is now at the head
// Save information about this hooked function *」： m__pszCalleeModName = pszCa 11 eeModName;	二
m__pszFuncName	= pszFuncName；	,-
nupfnHook	= pfnHook;	:
ncpfnOrig	=	七
GetProcAddressRaw(GetModuleHandleA(pszCalleeModName), m_pszFuncName)；
Windows核心编程（第5版）
// If function does not exit,... bye bye
// This happens when the module is not already loaded
if (m_pfnOrig == NULL)
(
wchar_t szPathname[MAX_PATH];
GetModuleFi1eNameW(NULL, szPathname, _countof(szPathname)); wchar_t sz[1024];
StringCchPrintfW(sz, _countof(sz),
TEXT(■[%4u - %s] impossible to find %S\r\n*), GetCurrentProcessIdf) , szPathname, pszFuncNcime); OutputDebugString(sz);
return；
}
#ifdef _DEBUG
// This section was used for debugging sessions when Explorer died as
II a folder content was requested
//
//static BOOL s_bFirstTime = TRUE;
//if (s_bFirstTime)
//{
// s_bFirstTime = FALSE;
// wchar_t szPathname[MAX_PATH];
// GetModuleFileNameW(NULL, szPathname, _countof(szPathname));
// wchar_t* pszExeFile = wcsrchr(szPathname, L'\\') + 1；
// OutputDebugStringW(L-Injected in ")；
// OutputDebugStringW(pszExeFile);
// if (_wcsicn^p (pszExeFile, L"Explorer .EXE") == 0)
// {
// DebugBreak()；
// }
// OutputDebugStringW(L"\n --> ■)；
// StringCchPrintfW(szPathname, _countof(szPathname), L"%S", pszFuncName);
// OutputDebugStringW(szPathname);
// OutputDebugStringW(Lw\n");
//)
#endif
// Hook this function in all currently loaded modules ReplacelATEntrylnAllMods (n\_pszCalleeModNamer in_pfnOrig, m_pfnHook);
}
///////////////////////////////////////////////////////////////////////////////
CAPIHook::-CAPIHook() (
// Unhook this function from all modules
ReplacelATEntryInAlIMods(nupszCalleeModName, ncpfnHook, nupfnOrig)；
// Remove this object from the linked list
CAPIHook* p = sm_J>Head；	,
if (p == this) ( // Removing the head node 3 sn\_pHead = p->m_pNext ;；	二	.\ ■'
} else {
BOOL bFound = FALSE;	( , •，-	- j；. ： *
// Walk list from head and fix pointers- >
for (; !bFound && (p->m__pNext != NUL0 r p « p-xrupNext) {
if (p->m__pNext == this) (	, 3
// Make the node that points to us point to our next node p->m_pNext = p->nL-PNext->nvjpNext;
bFound = TRUE；	, :	<： E
} :二二、"
第22章DLL注入和API拦截
}
///////////////////////////////////////////////////////////////////////////////
// NOTE: This function must NOT be inlined
FARPROC CAPIHook::GetProcAddressRaw(HMODULE hmod, PCSTR pszProcName) (
return(::GetProcAddress(hmod, pszProcName))；
}
///////////////////////////////////////////////////////////////////////////////
// Returns the HMODULE that contains the specified memory address static HMODULE ModuleFromAddress(PVOID pv) (
MEMORY.BASIC__INFORMATION mbi;
return((VirtualQuery(pv, &mbi, sizeof(mbi)) != 0)
? (HMODULE) mbi.AllocationBase : NULL);
///////////////////////////////////////////////////////////////////////////////
void CAPIHook::ReplacelATEntrylnAllMods(PCSTR pszCalleeModName,
PROC pfnCurrent , PROC pfnNew) (
HMODULE hmodThisMod = ExcludeAPIHookMod
? ModuleFromAddress(ReplacelATEntrylnAllMods) : NULL;
// Get the list of modules in this process
CToolhelp th(TH32CS_SNAPMODULE, GetCurrentProcessId());
MODULEENTRY32 me = { sizeof(me) };
for (BOOL bOk = th.ModuleFirst(&me)； bOk; bOk = th.ModuleNext(&me)) (
// NOTE： We don't hook functions in our own module
if (me.hModule != hmodThisMod) (
// Hook this function in this module
ReplacelATEntrylnOneMod(
pszCalleeModName, pfnCurrent, pfnNew, me.hModule);
}
}
} .
///////////////////////////////////////////////////////////////////////////////
// Handle unexpected exceptions if the module is unloaded
LONG WINAPI InvalidReadExceptionFi1ter(PEXCEPTION__POINTERS pep) (
// handle all unexpected exceptions because we simply don't update // any module in that case
LONG IDisposition = EXCEPTION_EXECUTE_HANDLER;
// Note: pep->ExceptionRecord->ExceptionCode has 0xc0000005 as a value
return(IDisposition)；
}
void CAPIHook::ReplacelATEntrylnOneMod(PCSTR pszCalleeModName,
jndows核心编程（第5版）
PROC pfnCurrent, PROC pfnNew, HMODULE hmodCaller) (
// Get the address of the module*s import section ULONG ulSize;
// An exception was triggered by Explorer (when browsing the content of // a folder) into imagehlp.dll. It looks like one module was unloaded... // Maybe some threading problem： the list of modules from Toolhelp might // not be accurate if FreeLibrary is called during the enumeration. PIMAGE_IMPORT_DESCRIPTOR pgorXDesc = NULL;
—try (
plmportDesc = (PIMAGE_IMPORT_DESCRIPTOR) ImageDirectoryEntryToData( hmodCaller, TRUE, IMAGE_DIRECTORY_ENTRY_IMPORT, &ulSize);
_except (invalidReadExceptionFilter(GetExceptionlnformationO))( // Nothing to do in here, thread continues to run normally // with NULL for plmportDesc
)
if (plmportDesc == NULL)	*
return； // This module has no import section or is no longer loaded
// Find the insert descriptor containing references to callee's functions for (; pIn^ortDesc->Name; pImportDesc++) (
PSTR pszModName = (PSTR) ((PBYTE) hmodCaller + plmportDesc->Name); if (IstrcmpiA(pszModName, pszCal1eeModName) == 0) (
// Get caller's import address table (IAT) for the callee's fxinctions PIMAGE_THUNK_DATA pThunk = (PIMAGE__THUNK_DATA)
((PBYTE) hmodCaller + pImportDesc->FirstThunk)；
// Replace current function address with new function address for (； pThunk->ul.Function; pThunk++) (
// Get the address of the function address PROC* ppfn = (PROC*) &pThunk->ul.Function；
// Is this the function we're looking for? BOOL bFound = (*ppfn == pfnCurrent); if (bFound) (
if (!WriteProcessMemory(GetCurrentProcess()/ ppfn, &pfnNew, sizeof(pfnNew), NULL) && (ERROR.NOACCESS == GetLastError())) ( DWORD dwOldProtect; if (VirtualProtect(ppfn, sizeof(pfnNew), PAGE_WRITECOPY, &dwOldPrctect)) (
WriteProcessMemory(GetCurrentProcess(), ppfn, &pfnNew, sizeof(pfnNew), NULL);
VirtualProtect(ppfnr sizeof(pfnNew), dwOldProtect, &dwOldProtect)；
return； //We did it, get out	与；瓶们领
}	.散
}	藉
} // Each import section is parsed until the
////////////////////////////////////////////////〃/〃///祸〃〃〃/////〃/〃////
void CAPIHook::ReplaceEATEntryInOneMod(HMODULE hmod, PCSTR pszFunctionName, PROC pfnNew) (
第22章DLL注入和API拦截
// Get the address of the module's export section
ULONG ulSize；
PIMAGE_EXPORT_J)IRECTORY pExportDir = NULL;
—try (
pExportDir = (PIMAGE_EXPORT_DIRECTORY) ImageDirectoryEntryToData( hmod, TRUE, IMAGE_DIRECTORY_ENTRY_EXPORT, &ulSize);
}
_except (InvalidReadExceptionFilter(GetExceptionlnformationO)) (
// Nothing to do in here, thread continues to run normally
// with NULL for pExportDir
}
if (pExportDir == NULL)
return； // This module has no export section or is unloaded
PDWORD pdwNamesRvas = (PDWORD) ((PBYTE) hmod + pExportDir->AddressOfNames); PWORD pdwNameOrdinals = (PWORD)
((PBYTE) hmod + pExportDir->AddressOfNameOrdinals);
PDWORD pdwFunctionAddresses = (PDWORD)
((PBYTE) hmod + pExportDir->AddressOfFunctions);
// Walk the array of this module's function names for (DWORD n = 0; n < pExportDir->NumberOfNames； n++) {
// Get the function name
PSTR pszFuncName = (PSTR) ((PBYTE) hmod + pdwNamesRvas[n]);
// If not the specified function, try the next function
if (1strcmpiA(pszFuncName, pszFunctionName) != 0) continue;
//We found the specified function
// --> Get this function's ordinal value
WORD ordinal = pdwNameOrdinals[n];
// Get the address of this function's address
PROC* ppfn = (PROC*) &pdwFunctionAddresses[ordinal];
// Turn the new address into an RVA
pfnNew = (PROC) ((PBYTE) pfnNew - (PBYTE) hmod);
// Replace current function address with new function address
if (!WriteProcessMemory(GetCurrentProcess(), ppfn, &pfnNewr sizeof(pfnNew), NULL) && (ERROR_NOACCESS == GetLastError())) ( DWORD dwOldProtect;
if (VirtualProtect(ppfn, sizeof(pfnNew), PAGE_WRITECOPY, &dwOldProtect)) (
WriteProcessMemory(GetCurrentProcess(), ppfn, &pfnNew, sizeof(pfnNew), NULL);
VirtualProtect(ppfn, sizeof(pfnNew), dwOldProtect r &dw01dProtect); }
}
break； // We did it, get out.
}
///////////////////////////////////////////////////////////////////////////////
// Hook LoadLibrary functions and GetProcAddress so that nooked fuadtlons // are handled correctly if these functions are called.	广；&
CAPIHook
(PROC)
CAPIHook (PROC)
CAPIHook::sirt-LoadLibraryA ("Kernel32.dll', ■ LoadLibnSiryX*, CAPIHook::LoadLibraryA)；
CAPIHook::sm—LoadLibraryW ("Kernel32.dll", ■LoadLibraryW*, CAPIHook::LoadLibraryW);
lows核心编程（第5版）
CAPIHook CAPIHook：:snt-LoadLibraryExA("Kernel32.dll", "LoadLibraryExA", (PROC) CAPIHook::LoadLibraryExA);
CAPIHook CAPIHook: : sm_LoadLibraryExW (■ Kemel32 .dll", "LoadLibraryExW* , (PROC) CAPIHook::LoadLibraryExW);
CAPIHook CAPIHook：:sirc.GetProcAddress (•Kernel32.dll'. "GetProcAddress*, (PROC) CAPIHook::GetProcAddress);	；?.
///////////////////////////////////////////////////////////////////////////////
void CAPIHook::FixupNewlyLoadedModule(HMODULE hmod, DWORD dwFlags)(
// If a new module is loaded, hook the hooked functions if ((hmod != NULL) && // Do not hook our own module
(hmod != ModuleFromAddress(FixupNewlyLoadedModule)) &&
((dwFlags & LOAD_LIBRARY__AS_DATAFILE) == 0) &&
((dwFlags & LOAD-.LIBRARY_AS_DATAFILE_EXCLUSIVE) == 0) &&
((dwFlags & LOAD-LIBRARY-AS_IMAGE_RESOURCE) == 0)
for (CAPIHook* q. = snupHead； p != NULL； p = p->nupNext) ( if (p->n<jpfnOrig != NULL) {
ReplacelATEntrylnAllMods (p- >nups zCa 11 eeModName r p->n\_pf nOrig, p->m_pfnHook)；
} else (
#ifdef JDEBUG
//We should never end up here
wchar_t szPathname[MAX_PATH]；
GetModuleFileNameW(NULL, szPathname, _countof(szPathname))； wchar__t sz[1024];
StringCchPrintfW(sz, _countof (sz),
TEXT(*[%4u - %s] impossible to find %S\r\n"), GetCurrentProcessId(), szPathname, p->nupszCalleeModNaxne)； OutputDebugString(sz)；
#endif
}
}
}
}
///////////////////////////////////////////////////////////////////////////////
HMODULE WINAPI CAPIHook::LoadLibraryA(PCSTR pszModulePath) (
HMODULE hmod = ::LoadLibraryA(pszModulePath);	；
FixupNewlyLoadedModule(hmod, 0);
return(hmod)； }	庭
///////////////////////////////////////////////////////////////////////////////
HMODULE WINAPI CAPIHook：:LoadLibraryW(PCWSTR pszModulePath) (
HMODULE hmod = ::LoadLibraryW(pszModulePath);
PixupNewlyLoadedModu1e(hmod, 0)；
return(hmod)；
)
'•匚廿八挥尊澄项:礴云爵愈渗萍鼠感馨恣班?淳
//////〃////////////////////////////////////////////////////////////〃///〃////
第22章DLL注入和API拦截
HMODULE WINAPI CAPIHook::LoadLibraryExA(PCSTR pszModulePath, HANDLE hFile, DWORD dwPlags) (
HMODULE hmod = ::LoadLibraryExA(pszModulePath, hFile, dwFlags); FixupNewlyLoadedModule(hmod, dwFlags);
return(hmod);
///////////////////////////////////////////////////////////////////////////////
HMODULE WINAPI CAPIHook::LoadLibraryExW(PCWSTR pszModulePath, HANDLE hFile, DWORD dwFlags) {
HMODULE hmod = ::LoadLibraryExWfpszModulePath, hFile, dwFlags)； FixupNewlyLoadedModule(hmod, dwFlags);
return(hmod)；
}
///////////////////////////////////////////////////////////////////////////////
FARPROC WINAPI CAPIHook::GetProcAddress(HMODULE hmod, PCSTR pszProcName) (
// Get the true address of the function
FARPROC pfn = GetProcAddressRaw(hmod, pszProcName);
// Is it one of the functions that we want hooked? CAPIHook* p = sntjpHead;
for (; (pfn != NULL) && (p != NULL) ; p = p->in_jpNext) (
if (pfn == p->m_pfnOrig) {
// The address to return matches an address we want to hook
// Return the hook function address instead
pfn = p->nupfnHook；
break；
}
}
return(pfn);
} . //////////////////////////////// End of File //////////////////////////////////
APIHook<h
Module: APIHook.h
Notices： Copyright (c) 2008 Jeffrey Richter & Christophe Nasarre
#pragma once	犯5祈寻淑境%导金与警：梆必
盘耕秒：•"择*、嫦浇蔑 〃/////〃//////////////////〃/〃〃/////////////////〃/////〃〃〃/////糕凝〃///
［吸沔'《ME",乙"'邱土土" 3：
class CAPIHook {
public：
// Hook a function in all modules
CAPIHook(PSTR pszCalleeModName, PSTR pszFuncName, PROC pfnHook);
:indows核心编程（第5版）
// Unhook a function from all modules -CAPIHook();
// Returns the original address of the hooked function operator PROCO { return(nupfnOrig) ； }
// Hook module w/CAPIHook implementation?
// I have to make it static because I need to use it // in ReplacelATEntx^rlnAllMods
static BOOL Exc1udeAPIHookMod;
public：
// Calls the real GetProcAddress static
FARPROC WINAPI GetProcAddressRaw(HMODULE hmod, PCSTR pszProcName);
private: static static
PVOID sntjpvMaxAppAddr; CAPIHook* snupHead;
//
Maximum private memory address Address of first object
CAPIHook* n\_pNext;
Address of next object
PCSTR m_ps zCal 1 eeModNeime;
PCSTR m_pszFuncName;
PROC m__pfnOrig；
PROC nk_pfnHook;
Module containing the function (ANSI) Function name in callee (ANSI) Original function address in callee Hook function address
in a module's import section
private:
// Replaces a symbol * s address
static void WINAPI ReplacelATEntrylnAllMods(PCSTR pszCa11eeModName/ PROC pfnOrig, PROC pfnHook);
// Replaces a symbol * s address in all modules' import sections static void WINAPI ReplacelATEntrylnOneMod(PCSTR pszCa11eeModName, PROC pfnOrig, PROC pfnHook, HMODULE hmodCaller);
// Replaces a symbol's address in a module's export sections
static void ReplaceEATEntrylnOneMod(HMODULE hmod, PCSTR pszFunctionName, PROC pfnNew);
private：
// Used when a DLL is newly loaded after hooking a function
static void WINAPI FixupNewlyLoadec3Module(HMODULE hmod, DWORD dwFlags);
// Used to trap when DLLs are newly loaded
static HMODULE WINAPI LoadLibraryA(PCSTR pszModulePath); static HMODULE WINAPI LoadLibraryW(PCWSTR pszModulePath); static HMODULE WINAPI LoadLibraryExA(PCSTR pszModulePath, HANDLE hFile, DWORD dwFlags);
static HMODULE WINAPI LoadLibraryExW(PCWSTR pszModulePath, HANDLE hFile, DWORD dwFlags);
// Returns address of replacement function if hooked function is requested static FARPROC WINAPI GetProcAddress(HMODULE hmod, PCSTR pszProcName);
private:
// Instantiates static static static static static
};
CAPIHook CAPIHook CAPIHook CAPIHook CAPIHook
hooks on these functions snuLoadLibraryA; sm_LoadLibraryW; sn\_LoadLibraryExA; sm_LoadLibraryExW;
sm_Get ProcAddre s s；
//////////////////////////////// End of File //////////////////////////////////
642-656
*第23章 ►第24章
►第25章
终止处理程序 异常处理程序与软件异常 未处理异常、向量化异常 处理与C++异*
错哪告与嬲蜒复
►第26章
亲或顼如牌•灸恕庭籍£ 立..，i . •»,•••	,
T Eg泌点诲盘

M故释碱禅ww	，
g 鬲事情。代码蒋会因此而容易编写，容易阅读，号宜最易理解。再也不需要为代码里随处
可见的if语句和goto语句而烦恼——对每个函数，我们都只需要从头到尾把代码写完。
如果这种直接的编程方法对你来说是一个美梦的话，那么你一定会喜欢上结构化异常处理 (structured exception handling, SEH)。SEH带来的好处是我们在写代码时，可以先集中精力 完成软件的正常工作流程。如果在运行的时候出现了什么问题，系统会捕获这个问题，并 且通知我们。
使用SEH,并不意味着可以完全忽略代码中可能出现的错误，但是我们可以将软件主要功 能编写和软件异常情况处理这两个任务分离开。这样，就可以先集中注意力完成手头上的 工作，稍后再去处理软件可能会遇到的各种错误情况。
促使Microsoft将SEH加入Windows系统的因素之一是它可以简化操作系统本身的开发工 作。操作系统的开发人员使用SEH来让系统更加健壮，而我们也可以使用SEH来让应用 程序更为健壮。
为了让SEH运作起来，编译器的工作量要大于操作系统。在进入和离开异常处理代码块时, 编译器必须生成一些特殊的代码，以及产生一些关于支持SEH的数据结构表，还必须提供 回调函数给操作系统调用，以便系统遍历异常代码块。编译器还负责准备进程的栈框架 (stack frame)和其他一些内部信息，这些信息都是操作系统需要使用或者引用的。让编译器 支持SEH不是一个简单的任务，就算不同的编译器厂商以不同的方式来实现它，也不是什 么奇怪的事情。幸运的是，我们可以直接利用编译器对SEH的支持，而不需要理会编译器 如何支持它的细节。
但是，不同编译器针对SEH的实现不尽相同，这给我们用具体的方法和具体的例子来讨论 SEH的优点带来了困难。所幸的是，大部分的编译厂商都遵循了 Microsoft建议的语法。本 书例子中使用的语法或者关键字可能与其他公司的编译器所采用的并不一致，但是SEH的 基本概念是一样的。本章采用Microsoft Visual C++编译器规定的语法。
659
A^idows核心编程(第5版)
说明不要混淆结构化异常处理与C++异常处理。C++异常处理在形式上表现为使用关键 字catch和throw,这和结构化异常处理的形式不同。Microsoft Visual C++支持异常 处理，它在内部实现上其实就是利用了编译器和Windows操作系统的结构化异常处 理功能。
SEH实际上包含两方面的功能：终止处理(termination handling)和异常处理(exception handling)o这一章讨论终止处理，下一章才讨论异常处理。
终止处理程序确保不管一个代码块(被保护代码(the guarded body))是如何退出的，另一个代 码块(终止处理程序)总能被调用和执行。终止处理的语法(当使用Microsoft Visual C++编译 器时)如下所示：
—try {
// Guarded body
)
__finally (
// Termination handler
_try和_finally关键字标记了终止处理程序的两个部分(被保护代码和终止处理程序)。在 前面这段代码中，操作系统和编译器的协同工作保证了不管被保护代码部分是如何退出的 无论我们在被保护代码中使用了 return,还是goto,又或者longjump语句(除非调用 ExitProcess, ExitThread, TerminateProcess, TerminateThread 来终止进程或线程)-
终止处理程序都会被调用，即_finally代码块都能执行。我将通过几个例子来说明这一点。
通过实例理解终止处理程序
当我们使用SEH时，代码执行与操作系统和编译器紧密相关。因此我认为阐述SEH如何 工作的最佳途径是分析实例的源代码，并讨论例子中代码的执行顺序。
下面几个小节将分别展示一些不同的代码，并解释编译器和操作系统如何调整代码的执行 顺序。
1.	Funcensteinl 函数
在分析终止处理程序的各种不同情况之前，让我们首先看一个更具体的例子：
DWORD Funcensteinl() (
DWORD dwTemp;
II 1. Do any processing here.
• • ・
_try (
// 2. Request permission to access
// protected data, and then use it.
WaitForSingleObject(g_hSem, INFINITE)；
g_dwProtectedData = 5;
dwTemp = g_dwProtectedData;

第23章终止处理程序
)
_finally (
// 3. Allow others to use protected data. Releasesemaphore(g_hSem, 1, NULL);
}
// 4. Continue processing, return(dwTemp)；
)

代码注释里的数字表示相关代码的执行顺序。在函数Funcensteinl使用try-finaUy代码块 并没有为我们带来什么好处。这段代码等待一个信号量，修改一个受保护变量的值，然后 将这个值保存在一个局部变量dwTemp里，接着释放信号量资源，最后返回改变后的值。
2.	Funcenstein2 函数
现在，让我们稍微改动一下这个函数,
看看会发生什么:
DWORD Funcenstein2() (
DWORD dwTemp；
// 1. Do any processing here.
一try (
// 2. Request permission to // protected data, and then WaitForSingleObject(g_hSem,
access use it. INFINITE);
g_dwProtectedData = 5; dwTemp = g_dwProtectedData；
// Return the new value. return(dwTemp)；
}
_finally (
// 3. Allow others to use protected data. Releasesemaphore(g_hSem, 1, NULL);
)
// Continue processing--this code
// will never execute in this version.
dwTemp = 9;
return(dwTemp)；
}
禽661
Funcensteinl中的try代码块结尾有一个return语句。这个return语句等于告诉编译器， 在这里要退出当前函数并返回dwTemp变量的值，现在它的值是5。如果没有使用终止处 理，因为return语句在信号量释放语句的前面，return语句被执行，线程便没有机会释放 信号量资源，其他线程当然也不会再得到对这个信号量的控制权。不难想象，在等待同一 个信号量的其他线程因此再也没有机会运行，这样的执行顺序带来了很严重的问题。
幸运的是，通过使用终止处理程序可以防止过早地执行return语句。当return语句试图退 出try块的时候，编译器会让finally代码块在它之前执行。即编译器保证finally代码块在 try块中的函数退出语句return之前执行。在Funcensteinl中，将ReleaseSemaphore置于 终止处理程序中可以保证信号量会被释放。这样，一个线程便不会在无意中一直占有一个
idows核心编程（第5版）
信号量，也就意味着其他等待着同一个信号量的线程不会因此而始终处于等待状态。
finally代码块执行完以后，函数就可以返回了。因为try语句块中包含一个return语句， 所以finally块之后的代码都没有机会执行，因此这个函数的返回值是5,而不是9。
读者可能想知道，编译器如何保证finally块可以在try代码块退出前被执行。原来当编译 器检查程序代码时，会发现在try代码块里有一个return语句。于是，编译器就会生成一 些代码先将返回值（在我们的例子中，这个值为5）保存在一个由它创建的临时变量里，然后 再执行finally代码块，这个过程被称之为局部展开（local unwind）o更确切地说，当系统因 为try代码块中的代码提前退出而执行finally代码块时，就会发生局部展开。一旦finally 代码块执行完毕，编译器所创建的临时变量的值就会返回给函数的调用者。
由此可见，为了让整个机制运行起来，编译器必须生成一些额外代码，而系统也必须执行 一些额外工作。在不同的CPU体系结构上，让终止处理工作起来的步骤也不同。需要注意 的是，应该避免在try代码块中使用return语句，因为这对应用程序性能是有害的。我们 将在本章稍后部分讨论_leave关键字，它可以帮助我们发现那些有局部展开开销的代码。
异常处理是用来捕获那些本不应该经常发生的异常（在我们的例子中，即try代码块中提前 调用的return语句）。如果是常见的问题，应该显式地检查这些问题以提高运行效率，而不 是依赖于操作系统和编译器的SEH机制来捕捉这些问题。
如果代码控制流正常地离开try代码块进入finally代码块（如我们在Funcensteinl中演示的 那样），那么进入finally代码块的额外开销就是最小的。若是使用Microsoft的编译器，而 应用程序又运行在x86体系结构的CPU上，离开try代码块进入finally代码块只需要执行 一条机器指令一一我怀疑你甚至觉察不到这种开销。当编译器需要生成额外代码，系统也 必须做一些额外工作时，开销才会更加明显。
3.	Funcenstein3
现在，让我们再修改一下这个函数，看看会发生什么:
DWORD Funcenstein3() {
DWORD dwTemp;
// 1. Do any processing here.
一try {
// 2. Request permission to access
// protected data, and then use it.
WaitForSingleObject. (g_hSem, INFINITE);
g_dwProtectedData = 5;
dwTemp = g_dwProtectedData；
// Try to jump over the finally block, goto Returnvalue；
}
—finally (
// 3. Allow others to use protected data.
第23章终止处理程序
Releasesemaphore(g_hSem, 1, NULL)；
)
dwTemp = 9;
// 4. Continue processing.
Returnvalue:
return(dwTemp);
)
当编译器看到函数Funcenstein3中try块的goto语句时，就会产生局部展开以执行finally 代码块。这一次，当Hnally代码块执行完毕后，因为try和finally代码块中都没有函数返 回语句，所以RetumValue标签后的代码也会被执行。因此这个函数的返回值为5。但是 因为破坏了代码从try块到finally块的正常执行流程，可能有比较大的性能损失，其程度 取决于运行程序的CPU体系结构。
4.	Funcfurterl
现在让我们再观察一个例子，在这个例子中，终止处理将真正证明它的价值。首先看一下 这个函数：
DWORD Funcfurterl() (
DWORD dwTemp;
// 1. Do any processing here.
_try (
// 2. Request permission to access // protected data, and then use it. WaitForSingleObject(g_hSem, INFINITE); dwTemp = Funcinator(g_dwProtectedData)； ) _finally (
// 3. Allow others Co use protected data. Releas'eSemaphore(g^Sem, 1, NULL);
)
// 4. Contzinue processing.
return(dwTemp);
} 一 _ 663*664
假设try代码块中的Funcinator函数存在一个缺陷会导致程序访问非法的内存。如果没有 SEH,这种情况下最终导致Windows错误报告(Windows Error Reporting,后面简称为WER) 弹出一个对话框："Application has stopped working”。这个对话框在Windows上经常可以 见到。我们将在第25章详细讨论它。一旦用户取消这个对话框，进程就会终止(因为非法 的内存访问)，但信号量将依然被占用并再也得不到释放。其他进程中的线程就会因为无休 止地等待这个信号量而得不到CPU时间片。如果把释放信号量的语句置于finally块中， 即使try中调用的函数发生了内存访问违规这样的异常，这个信号量也可以被释放。但是 请注意，从Windows Vista系统开始，须显式地保护try/finally框架，以确保在异常抛出时, finally代码块会执行。读者可以在后面“SEH终止示例程序”一节中找到相关解释。我们 在下一章还会深入探讨使用try/except保护代码的细节。
然而，就算在早期的Windows系统里，在异常发生时，finally块也不能保证绝对能得到执
j^^idows核心编程(第5版) _
行。例如，在windows XP系统里，如果一个“栈耗尽异常”(stack exhaustion exception)发 生在try代码块里，finally块就很有可能得不到运行机会，因为运行在出错进程里的WER 代码都可能没有足够的栈空间去报告错误。所以在这种情况下，进程往往是不加任何提示 地被终止。还有，如果异常导致SEH链的中断，终止处理程序也不会得到执行。最后，如 果异常发生在异常过滤程序里，终止处理程序也不会被执行。一条经验法则是尽量限制在 catch或者finally块中代码所做的工作，否则进程很有可能会在finally块执行前突然终止。 这也就是为什么在Windows Vista系统上，错误报告过程(WER)运行在另一个独立的进程里 (详见第25章)。
如果终止处理程序强大到能捕获非法的内存访问引起的进程终止，我们没有理由怀疑它也 能捕获setjump和longjump的结合，当然更不用说类似于break, continue这样的简单 语句。
5.突击测验：FuncaDoodleDoo
现在不妨做一个测验，判断一下这个函数的返回值:
DWORD FuncaDoodleDoo()(
DWORD dwTemp = 0;
while (dwTemp < 10) (
_try {
if (dwTemp == 2)
continue；
if (dwTemp == 3)
break；
}
_finally (
dwTemp++；
}
dwTemp++；
dwTemp += 10;
return(dwTemp)；
}
让我们逐步分析这个函数的执行过程：一开始将dwTemp赋值为0,然后try块中的代码 开始执行，但是两个if语句的表达式计算结果都不是TRUEo于是程序正常进入到finally 代码块，在这里给dwTemp的值加上1,而finally块后面的代码又将dwTemp的值加U
下一个循环迭代开始时，dwTemp的值为2,所以第一个if块内的continue语句会执行。 如果没有终止处理程序强制finally块在try块退出前被执行，程序控制会跳回到while循 环的测试表达式，但dwTemp的值不会被改变，这将会是一个无限循环。但是现在我们有 终止处理程序，系统注意到continue语句将会导致控制流提前跳出try块，于是强制执行 finally代码块。在finally代码块中，dwTemp的值被增加到3。这一次finally代码块之后 的代码没有机会执行，因为finally块运行结束后，程序控制流将跳到continue语句的执行 处，然后再回到循环的顶部。
第23章终止处理程序
现在，我们开始分析循环的第三次迭代，这次第一个if判断表达式的值为FALSE,第二个 if判断为TRUE0系统再一次侦测到程序流想要提前跳出try块，于是调用finally代码块, 在这里dwTemp的值增加到4。因为break语句的执行，程序控制流从while循环后开始 继续。因Ifi], finally块之后循环以内的代码就不会被执行了。而循环之后的代码将dwTemp 的值设为14——这个程序的最终返回结果。不用我指明，读者也不会写出FuncalDoodleDoo 函数中的代码。我将continue和break语句放在函数代码中间，仅仅为了演示终止处理程 序是如何工作的。
尽管绝大部分情况下，try块中的提前退出都会被终止处理程序所捕获，但是在进程或者线 程被提前终止的情况下，系统没法保证finally代码块的执行。调用ExitThread或者 ExitProcess可以马上终止线程或者进程，而不会引发finally代码块执行。同样，如果当前 线程或者进程因为另一个程序调用TerminateThread或者TerminateProcess而不得不结 束，finally代码块也不会被执行。有一些C运行期函数(比如abort)因为在其内部最终调用 的是ExitProcess,也会导致finally块不能执行。我们没法阻止别的线程“杀死”我们的线 程或者进程，但是可以在百己的代码中尽量避免对ExitThread或者ExitProcess的草率调用。
6.	Funcenstein4 函数
我们再来讨论一种终止处理程序的情形：
DWORD Funcenstein4() (
DWORD dwTemp；
// 1. Do any processing here.
_try (
// 2. Request permission to access
// protected data, and then use it.
WaitForSingleObject(g_hSem, INFINITE);
g_dwProtectedData = 5； dwTemp = g_dwPro t ec t edDa t a；
// Return the new value.
return(dwTemp)；
)
_finally {
// 3. Allow others to use protected data.
Releasesemaphore(g_hSem, 1, NULL)； return(103);
)
// Continue processing--this code will never execute.
dwTemp = 9;
return(dwTemp)；
)
在Funcenstein4中，try代码块在执行时试图退出函数，返回dwTemp(5)给函数的调用者。 正如我们前面通过Funcensteinl提到的那样，试图在try块中提前退出函数会导致编译器 生成一些额外代码，将函数返回结果保存在一个临时变量里，然后执行finally代码块。注 意,这个函数和前面的函数FiincensteinZ TT所不同：finally块中多了一个return语句。那 么现在函数Funcenstein4的返回结果是5还是103呢？答案是103,因为finally块中的 return语句导致103被写入到编译器生成的临时变量里，从而覆盖了原先的值5。当finally
^dows核心编程(第5版)
代码块执行完毕，函数Funcensteiii4退出并将临时变量(值为103)返回给其调用者。
我们已经看到为了防止因try代码块提前退出而带来严重后果，终止处理程序做了积极有 效的工作。但是我们也看到终止处理程序因为阻止了 try块的提前退出，又可能带来预料 之外的结果。一条好的经验法则是，不要在终止处理程序里包含让try块提前退出的语句, 这意味着从try块和finally块中移除return, continue, break, goto等语句，即把这些语 句放在终止处理程序之外。这样做的好处是不需要去捕捉那些在try块中的提前退出，从 而使编译器生成的代码量更小，同时，因为需要执行局部展开的代码更少，从而程序运行 更快。此外，代码的可读性和可维护性也更好。
7.	Funcaramal 函数
我们巳经讨论了终止处理程序的基本语法和语义，现在来看看如何利用终止处理程序来简 化一个本应复杂的编程问题。首先观察下面这个没有使用终止处理程序的函数：
BOOL Funcaramal() (
HANDLE hFile = INVALID_HANDLE_VALUE;
PVOID pvBuf = NULL;
DWORD dwNumBytesRead；
BOOL bOk;
hFile = CreateFile(TEXT("SOMEDATA.DAT"), GENERIC_READ,
FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
if (hFile == INVALID_HANDLE_VALUE) (
return(FALSE);
}
pvBuf = VirtualAlloc(NULL, 1024, MEM_COMMIT, PAGE_READWRITE);
if (pvBuf == NULL) (
CloseHandle(hFile);
return(FALSE);
)
bOk = ReadFile(hFile, pvBuf, 1024, &dwNumBytesRead, NULL);
if (JbOk I I (dwNumBytesRead == 0)) {
VirtualFree(pvBuf, MEM_RELEASE I MEM_DECOMMIT);
CloseHandle(hFile);
return(FALSE)；
}
// Do some calculation on the data.
• ♦ •
// Clean up all the resources.
VirtualFree(pvBuf, MEM_RELEASE I MEM^DECOMMIT);
CloseHandle(hFile)；
return(TRUE)；
)
Funcaramal中的所有错误检查代码让这个函数变得难以阅读，进而造成该函数难以理解、 修改和维护。
8.	Funcarama2 函数
当然，可以用另一种方式重写这个函数让它更简洁、更容易理解：
BOOL Funcarama2() (
HANDLE hFile = INVALID_HANDLE_VALUE;
第23章终止处理程序
PVOID pvBuf = NULL;
DWORD dwNumBytesRead;
BOOL bOk, bSuccess = FALSE;
hFile = createFile (TEXT( "SOMEDATA.DAT" ) , GENERIJREAD, F1LE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
if (hFile != INVALID_HANDLE_VALUE) (
pvBuf = VirtualAlloc(NULL, 1024, MEM_COMMIT, PAGE_READWRITE);
if (pvBuf != NULL) (
bOk = ReadFile(
hFile, pvBuf, 1024, &dwNumBytesRead, NULL)；
if (bOk && (dwNumBytesRead != 0)) { //Do some calculation on the data.
• ♦ •
bSuccess = TRUE；
} VirtualFree(pvBuf, MEM_RELEASE I MEM_DECOMMIT);
)
CloseHandle(hFile)；
}
return(bSuccess)；
}
尽管比Funcaramal更容易理解，FuncaramaZ仍然难以修改和维护。还有，因为很多条件 语句的嵌套，致使代码的缩进到了极限。我们很快就会发现要从屏幕的很右边的地方开始 写代码，以至于不得不将一个语句写成多行——每行5个字符。
9.	Funcarama3 函数
现在我们使用SEH的终止处理程序来重写函数Funcaramalo
DWORD Funcarama3() (
// IMPORTANT: Initialize all variables to assume failure.
HANDLE hFile = INVALID_HANDLE_VALUE;
PVOID pvBuf = NULL;
_try {
DWORD dwNumBytesRead；
BOOL bOk;
hFile = CreateFile(TEXT("SOMEDATA.DAT"), GENERIC_READ,
FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
if (hFile == INVALID_HANDLE_VALUE) ( return(FALSE);
}
pvBuf = VirtualAlloc(NULL, 1024, MEM_COMMIT, PAGE_READWRITE);
if (pvBuf == NULL) ( return(FALSE);
}
bOk = ReadFile(hFile, pvBuf, 1024, &dwNumBytesRead, NULL)；
if (JbOk I I (dwNumBytesRead != 1024)) (
return(FALSE);
// Do some calculation on the data.
_finally {
// Clean up all the resources.
if (pvBuf != NULL)
VirtualFree(pvBuf, MEM_RELEASE | MEM_DECOMMIT);
WS核心编程(第5版)
if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);
}
// Continue processing.
return(TRUE);
} ____ 668|66 龄
Funcarama3的精髓在于所有的清理工作都被放在并且只放在一个地方:finally块。如果以 后我们还需要往这个函数添加更多代码，可以简单地只在finaUy块里加一行清理代码——不 需要在每个可能出错的地方都加一行清理代码。
10.	Funcarama4：终结版
Funcarama3的问题是额外开销比较大。就像我们在讨论函数Funcenstein4所提到的那样, 应该尽量避免将类似return语句这样的语句放入try块。
为了帮助我们尽可能避免写出让try块提前退出的代码，Microsoft为它的C/C++编译器加 入了一个关键字：_leaveo下面这个函数Funcarama4便使用了关键字_leave：
DWORD Funcarama4() (
// IMPORTANT: Initialize all variables to assume failure.
HANDLE hFile = INVALID_HANDLE_VALUE;
PVOID pvBuf = NULL;
// Assume that the function will not execute successfully.
BOOL bFunctionOk = FALSE;
_try (
DWORD dwNumBytesRead；
BOOL bOk;
hFile = CreateFi1e(TEXT(-SOMEDATA.DAT-), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN.EXISTING, 0, NULL);
if (hFile == INVALID_HANDLE_VALUE) (
_leave；
}
pvBuf = VirtualAlloc(NULL, 1024, MEM_COMMIT, PAGE_READWRITE);.
if (pvBuf == NULL) (
_leave；
}
bOk = ReadFile(hFile, pvBuf, 1024, &dwNumBytesRead, NULL)；
if (JbOk I I (dwNumBytesRead == 0)) {
_leave；
)
// Do some calculation on Che data.
// Indicate that the entire function executed successfully. bFunctionOk = TRUE；
}
_finally (
// Clean up all the resources.
if (pvBuf != NULL)
VirtualFree(pvBuf, MEM_RELEASE I MEM_DECOMMIT);
if (hFile != INVALID_HANDLE_VALUE)
CloseHandle(hFile)；
)
// Continue processing.
return(bFunctionOk);

第23章终止处理程序
关键字_leave会导致代码执行控制流跳转到try块的结尾——也可以认为是跳转到了闭花 括号处。因为在这种情况下，代码执行将正常地从try块进入finally块，所以不会产生任 何额外开销。但是，我们不得不定义一个布尔变量bFuncttonOK,来表明函数的运行结果 是成功还是失败。相对来说，这个开销很小。
以这种方式在函数里使用终止处理程序时，最好在进入try块之前，将所有的资源句柄都 初始化为无效值。这样就可以在finally代码块里检查哪些资源得到了成功分配，从而得知 哪些资源需要释放。另外一个检查哪些资源需要释放的常见做法是，为成功分配的资源设 置标志，然后在finally块里检查这些标志以决定资源是否需要释放。
11.	finally块注意事项
到目前为止，我们己经明确区分并讨论了以下两种会引起finally块执行的情形。
• 从try块到finally的正常代码控制流。
•局部展开：从 try 块中的提前退出（由 goto, longjump, continue, break, return 等语句引起）将程序控制流强制转入finally块。
第三种情形——全局展开——在本章的函数Funcfurtherl中发生过，但没有明确的标识告 诉我们它的发生。函数Funcfurtherl在其try代码块中调用函数Funcinatoro在Windows Vista以前的系统上，如果函数Funcinator引起内存访问违规，那么全局展开将触发函数 Funcfuerl的finally块执行。但对Windows Vista来说，全局展开在默认情况下是不会被触 发的，所以finally块不会被执行。后文的“SEH终止处理示例程序”小节会让读者大致了 解一下什么样的情况会触发全局展开，然后我们在后面两章中将详细讨论全局展开。
finally块的执,亍总是由以上这三种情况之一引起的。要确定是三种情况中的哪一种，可以 调用内在函数 AbnormalTermination：
BOOL AbnormalTermination（）；
说明 内在函数是由编译器所识别并处理的特殊函数。编译器会为这个函数生成内联代码， 而不是生成代码来调用这个函数。比如，memcpy是内在函数（如果打开编译开关/Oi）。 当编译器见到对memcpy的调用，它会直接将memcpy的代码放置在调用memcpy 的函数里，而不是生成调用memcpy的代码。这样做通常让程序运行更快，但体积 更大。
内在函数AbnormalTermination和memcpy的区别在于它只会以内置这一种形式存 在。任何C/C++动态运行库都没有这个函数。
我们只能在finally块里调用这个内在函数，它将返回一个布尔值来表明一个与当前finally 块相关的try块是否已经提前退出。换句话说，如果代码执行从try块正常流入finally块, 函数的返回结果就是FALSEo如果控制流从try块中异常退出——通常情况下，这是因为
①译注：即 intrinsic functiono
■^^■dows核心编程(第5版)
try块中的goto，break, return或者continue语句导致了局部展开，或者因为try块中的 代码抛出了访问内存访问违规或其他异常引起全局展开 那么AbnormalTermination的 返回值为TRUEO但是进一步区分到底是局部展开还是全局展开引起finally块的执行是不 可能的。当然，这不应该是一个问题，因为总是应该尽量避免写出会导致局部展开的代码。
12.	Funcfurter2 函数
下面的函数Funcfurter2演示了如何使用函数AbnormalTerminationo
DWORD Funcfurter2()(
DWORD dwTemp;
// 1. Do any processing here.
一try {
// 2. Request permission Co access
// protected data, and then use it.
WaitForSingleObject (g^Sem, INFINITE)； dwTemp = Funcinator(g_dwProtectedData)；
}
_finally (
// 3. Allow others to use protected data.
Releasesemaphore(g_hSemr 1, NULL)；
if (!AbnormalTermination()) {
// No errors occurred in the try block, and
// control flowed naturally from try into finally.
} else {
// Something caused an exception, and
// because there is no code in the try block
// that would cause a premature exit, we must
//be executing in the finally block
// because of a global unwind.
// If there were a goto in the try block,
//we wouldn't know how we got here.
)
// 4. Continue processing.
return(dwTemp);
}
现在我们巳经了解了如何编写终止处理程序。当我们在下一章中开始学习异常过滤与异常 处理时，将会看到终止处理程序能发挥更加重要的作用。但首先还是回顾一下使用终止处 理程序的理由。
•	因为清理工作集中在一个地方执行，并且保证能得到执行，从而简化了错误处理。
•	提高了代码的可读性。
•	让代码更容易维护。
•	如果正确使用，它们对程序性能和体积的影响是微小的。
13.	SEH终止处理示例程序
程序SEHTerm(23-SEHTerm.exe),演示了终止处理是如何工作的。其源代码和资源文件可
第23章终止处理程序
在与本书配套的网页下载，它们在23-SEHTerm目录中。
当运行这个程序时，主线程进入try代码块，弹出消息框，如下图所示。
Perform invalid memory access?
这个消息框询问是否要访问内存中一个非法的字节。（很多程序可不这么体贴，它们直接就 访问非法的内存了）。尝试一下单击按钮No,看看会发生什么情况。在这个例子中，线程 控制流会从正常地从try代码块进入到finally代码块，弹出一个对话框，如下图所示。
注意，这个消息框表明控制流从try块正常退出。关闭这个消息框后，线程离开finally块, 并弹出另一个对话框，如下图所示。
在程序主线程退出前，最后一个消息框被弹出，告诉我们并没有未处理异常发生，如下 图所示。
当这个消息框被关闭后，进程因为_tWinMain返回而正常退出。
楚673
好吧，现在让我们再一次运行这个程序。这一次，我们单击Yes按钮，故意让程序访问非 法的内存。单击Yes按钮后，线程试图将值5写入到地址为NULL的内存。写入地址NULL 总是会引起内存访问违规异常，当线程抛出的内存访问违规异常没有被处理时，在Windows XP中，系统就会显示一个如图23.1所示的对话框。
lows核心编程(第5版)
图23・1 Windows XP中，出现未处理异常时所显示的消息框
在Windows Vista ±,默认情况下，首先弹出如图23・2所示的对话框。
图23・2在Windows Vista	当未处理异常发生时弹出的第一个消息框
如果单击Cancel按钮来关闭消息框，程序进程就会不加任何提示地结束。如果不去单击
Cancel按钮，另一个对话框在一段时间后会被弹出，取代第一个，如图23.3所示。
23-SEHTerm.exe has stopped working
A problem caused the program to stop working correctly. Windows will ck>$e the program and notify you if 8 solution ts ivitldble.
「program
图23・3在Windows Vista ±,当未处理异常发生时弹出的第二个消息框
如果单击Debug按钮，系统将触发一个工作流(workflow),详见第25章。
/ 如果这时候单击的是 Close Program 按钮(在 Windows Vista 上)或者 Send Error Report/Don,t Send按钮(在Windows XP ±),进程将会被终止。然而，代码中存在一个finally代码块， 它会在进程结束前被执行。于是，如果在XP系统上，会显示如下图所示的消息框。
SEHTerm: In finally block X |
Abrtormel termlnatfon
第23章终止处理程序
finally块的执行是由于对应try块的异常退出。当这个消息框被关闭后，进程当然也就结 束了。然而这句话只在Windows Vista以前的Winodws版本上成立，在那些平台上,finally 块的执行仅仅因为全局展开。如我们在第6章所提到那样，一个线程入口点（entry point）被 try/except块所保护。为了触发全局展开，_except块的异常过滤程序理应返回 EXCEPTION_EXECUTE_HANDLER。然而，Windows Vista ±为了提高错误记录和报告 的可靠性，从架构上对未处理异常的处理过程做了一个重大的改动（详见第25章）。一个明 显的缺点是用来作为保护的异常过滤程序返回的是EXCEPTION_CONTINUE_SEARCH, 进程将会马上被终止，从而导致finally块没有机会执行。
4
程序SEHTerm.exe会检查当前运行平台是不是Windows Vista,如果是，将弹出一个消息框 让我们选择是否使用try/except来保护错误函数，如下图所示。
Protect with try/except?
Yes | No
如果单击Yes按钮,try/finally结构将会被一个异常过滤程序所保护起来，并且这个过滤器 总是返回EXCEPTION_EXECUTE_HANDLER。它的作用是保证当异常被抛出时，全局 展开会被触发，让finally块代码可以被执行，从而弹出下图所示的消息框。
675
在退出应用程序的主线程并返回错误代码T之前，except块中的代码会执行并显示下图这 个消息框。
如果单击的是No按钮，当异常发生时（不要求启动即时调试），应用程序就会在执行finally 块之前立即终止。
SBHTern.cpp	■j-
/************************★*•*****★*****★*** ********、***.*1*,*独以***************
Module: SEHTerm.cpp
lows核心编程（第5版）
Notices: Copyright (c) 2008 Jeffrey Richter & Christophe Nasarre ****m*****m******** ************************** ********** ************* /
#include <windows.h>
#include <tchar.h>
///////////////////////////////////////////////////////////////////////////////
BOOL IsWindowsVista() {
// Code from Chapter 4
// Prepare the OSVERSIONINFOEX structure to indicate Windows Vista. OSVERSIONINFOEX osver = { 0 };
osver.dwOSVersionlnfoSize = sizeof(osver)；
osver.dwMaj orVers ion = 6;
osver.dwMinorVersion = 0；
osver.dwPlatformld = VER^PLATFORICWINa 2 JNT;
// Prepare the condition mask.
DWORDLONG dwlConditionMask = 0; // You MUST initialize this to 0. VEK_SET_CONDITION(dwlConditionMask, VER_MAJORVERSION, VER_EQUAL); VER_SET_CONDITION(dwlConditionMask, VER_MINORVERSION, VER_EQUAL); VER_SET_CONDITION(dwlCondi t ionMask , VER_PLATFORMID, VERJEQUAL);
// Perform the version test.
if (VerifyVersioninfo(&osverr VER.J4AJORVERSION I VERJdlNORVERSION | VER_PLATFORMID, dwlConditionMask)) (
// The host system is Windows Vista exactly.
return(TRUE)；
} else {
// The host system is NOT Windows Vista, return(FALSE);
}
}
void TriggerException() (
一try {
int n = MessageBox(NULL, TEXT(■Perform invalid memory access?"), TEXT( "SEHTerm： In try block"), MB__YESNO);
if (n == IDYES) (
,	* (PBYTE) NULL = 5； // This causes an access violation
}
}
一finally (
PCTSTR psz = AbnormalTermination()
? TEXT("Abnormal termination") : TEXT("Normal termination*)； MessageBox(NULL, psz, TEXT(•SEHTerm: In finally block"MB_OK);
}
MessageBox (NULL, TEXT ("Normal function	„
TEXT("SEHTerm： After finally block")r MB_OKi;
}
int WINAPI _tWinMain(HINSTANCEr HINSTANCE, PTSTR, int) 侦
// In Windows Vista, a global unwind occurs if an except filter
// returns EXCEPTION_EXECUTE_HANDLERif an unhandl^b exception
// occurs, the process is simply termihated and the finally Slocks
// are not exectuted.
if (IsWindowsVista()) (
DWORD n = MessageBox(NULL, TEXT(■Protect:with try/except?*), TEXT (■SEHTerm： workflow-), MB_YESNO) ; •保、，’丁 ，提.
if (n == IDYES) {
第23章终止处理程序
with
return(0);
process termination ie main thread"), MB
MessageBox(NULL, TEXT(-Normal TEXT(•SEHTerm: before leaving t
.except (EXCEPTION_EXECUTE_HANDLER) {
// But the system dialog will // So, popup a message box.
MessageBox(NULL/ TEXT("Abnormal process terminati TEXT("Process entry point try/except handler
else (
TriggerExcept ion()
//////////////////////////////// End of File /////////////////////////////////

676T78
第24章 异常处理程序与软件异常
本章内容
24.1通过实例理解异常过滤程序和异常处理程序
24.2	EXCEPTION_EXECUTE__HANDLER 约
24.3	EXCEPTION CONTINUE EXECUTION
24.4	EXCEPTION_CONTINUE_SEARCH
24.5	GetExceptionCode
24.6	GetExceptionlnfbrmation
24.7软件异常
软件异常是我们都不愿意看到的。在良好编码的应用程序里，我们不会想到诸如试图访问 非法的内存地址或者用0除一个数。然而，这样的错误还是时有发生。CPU负责捕获类似 非法内存访问和以0作为除数这样的问题，一旦侦测到这些错误行为，它会抛出相应的异 常。由CPU抛出的异常都是硬件异常。而在这一章的后半部分，我们可以看到操作系统和 应用程序也可以抛出异常，这些异常通常被称为软件异常。
当一个硬件或者软件异常被抛出时，操作系统会给我们的应用程序一个查看异常类型的机 会，并允许应用程序自己处理这个异常。下面的代码演示了异常处理程序的语法结构：
一try (
// Guarded body
}
_except (exception filter) (
// Exception handler
}
请注意_except关键字，任何时候创建一个try块，后面必须跟一*个finally代码块或except 代码块。但是try块后不能同时有finally块和except块，也不能同时有多个finally块或 except块。不过却可以将try-finally块嵌套于try・except块中，反过来也可以。
679
24.1通过实例理解异常过滤程序和异常处理程序
与终止处理程序(我们在前一章已经讨论过)不同，异常过滤程序(exception句ter)与异常处理 程序(exception handler)主要由操作系统来负责执行——在异常过滤程序表达式计算和异常 处理程序执行方面，编译器所做的工作十分有限。下面几个小节将说明try-except块在一
第24章异常处理程序与软件异常
般情况下的执行流程，解释操作系统如何计算异常过滤程序和为什么这么做，并演示了操 作系统在什么情况下会执行异常处理程序中的代码。
24.1.1	Funcmeisterl 函数
一个关于try-except块使用的具体实例：
DWORD Funcmeisterl() (
DWORD dwTemp；
// 1. Do any processing here.
—try (
// 2. Perform some operation.
dwTemp = 0;
}
_except (EXCEPTION_EXECUTE_HANDLER) (
// Handle an exception； this never executes.
• • •
}
// 3. Continue processing.
return(dwTemp)；
)
在函数Funcmeisterl的try块中，我们只做一个简单的操作，那就是将0赋值给变量 dwTempo这个操作肯定不会导致异常，所以except块中的代码不会执行，请注意这里和 try-finaUy块的不同之处。dwTemp被设置为0后，下一条要执行的指令就是return语句。
尽管我强烈建议读者不要在终止处理程序的try块中使用return, goto, continue和break 语句，但是在异常处理程序的try块中，这些语句不会导致程序性能损失或者增加代码量。 换句话说，把这些语句置于try块中不会带来局部展开这样的额外开销。
880
24.1.2	Funcmeister2 函数
现在我们修改一下前面这个函数，看看会发生什么情况。
DWORD Funcmeister2() (
DWORD dwTemp = 0;
// 1. Do any processing here.
• • •
_try (
// 2. Perforin some operation (s).
dwTemp = 5 / dwTemp； // Generates an exception dwTemp += 10; // Never executes
}
_except ( /* 3. Evaluate filter. */ EXCEPTION_EXECUTE_HANDLER){ // 4. Handle an exception.
MessageBeep(0)；
• • ♦
}
// 5. Continue processing.
return(dwTemp)；
}
Windows核心编程（第5版）
函数FuncmeisterZ的try块中有一个指令试图用5除以0。CPU会捕获到这个事件，并抛 出一个硬件异常。当这个异常被抛出时，系统定位到except块的开始处，并对异常过滤程 序的表达式求值，这个表达式的值必定为以下三个标识符之一（如表24-1所示），这些标识
符在Microsoft Windows的Excpt.h文件中定义。	
表24.1异常过滤程序的返回值	
标识	值
EXCEPTION EXECUTE HANDLER	1
EXCEPTION EXECUTE SEARCH	0
EXCEPTION CONTINUE EXECUTION	-1
接下来的几个小节将具体讨论每个标识符将怎样影响线程的执行。读者在阅读这些内容的 时候，可以参考图24-1,该图总结了系统处理异常的步骤。


图24-1系统处理异常的过程
噱682鹳
第24章 异常处理程序与软件异常
24.2	EXCEPTION_EXECUTE_HANDLER
函数Funcmeisterl中的异常过滤程序的值为EXCEPTION_EXECUTE_HANDLER,这个 值基本上等于告诉系统，“我知道这个异常，并预计这个异常在某种情况下会发生，同时 已经写了一些代码来处理它，让这些代码现在就执行吧。”于是，系统执行全局展开（即global unwind,详见本章后文讨论），让程序执行跳转到except代码块处（即异常处理程序代码）。 当except代码块运行结束后，系统就会认为异常已经得到了处理，于是允许应用程序继续 执行。这个机制允许Windows应用程序捕获错误，处理它们，并继续运行，用户甚至不知 道曾经发生过错误。
问题是except块执行完毕后，程序执行从哪里开始继续呢？稍微开动一下脑筋，我们就可 以想到几种可能。
第一种可能是从导致异常的那条CPU指令之后的第一条指令开始执行。具体到函数 FuncmeisterZ,就是从给dwTemp加10的那条语句开始继续。这看起来合情合理，但是实 际上，对大部分的应用程序来说，一旦一条指令运行失败，之后也就难以正确运行了。
虽然函数Funcmeister2的代码能正常往下继续执行，但是它不能代表普遍情况。大部分情 况下，CPU指令只有在它们之前那条导致异常的指令返回一个合法值才能成功运行。比如， 我们可能在某个函数里先调用内存分配指令，然后之后一系列的运算都是在操控那块内存。 显然，一旦内存分配失败，所有后继指令都会失败，程序也会不停地抛出异常。
再举一个例子说明为什么不能从失败指令之后继续执行。假设我们将函数FuncmeisterZ中 那条产生异常的C语言代码替换成下面这个语句：
malloc（5 / dwTemp）；
编译器会为上面这句代码生成相应CPU指令来执行除法运算，并将除法运算的结果置于栈 上，最后调用函数malloc。如果除法运算失败，代码显然不能往下继续正确地执行。系统 必须在栈顶放置一些数据，否则，栈就被破坏了。
幸运的是，如果一个语句抛出异常，Microsoft并没有提供一种从那条语句之后开始执行的 可能。这个决定让我们远离了前面所讨论的这些麻烦。
第二种可能是从产生异常的那句指令本身开始继续执行。这是一个有趣的可能性。想象一 下如果我们在except块中加入下面这个语句：
dwTemp = 2;
如果except块包含这个语句，应用程序的执行就可以从产生异常的那行代码继续。因 为这一次我们将用来除5的值是2,所以这个语句会执行成功，而不会有异常发生。 也就是说，我们可以改动一下先决条件，让先前抛出异常的指令再次执行。但是，需 要小心的是这种方法可能导致一些令人费解的行为。我们将在后面的
dows核心编程(第5版)
“ EXCEPTION_CONTINUE_EXECUTION ”小节中详细讨论它。
<683*684
第三种也是最后一种可能就是从except块后开始继续执行。这也正是异常处理程序被指定 为EXCEPTION_EXECUTE_HANDLER时系统所做的。即当except块中的代码执行完毕 后，代码执行从except块后的第一句代码继续。
24.2.1	一些有用的例子
假定我们要实现一个很健壮的程序，这个程序需要24小时不间断运行。鉴于现在的软件相 当复杂，并且有很多的变数和因素会影响到应用程序的表现，在我看来，若不借助于结构 化异常处^(structured exception handling,后面简称为SEH),要实现一个很健壮的应用程 序是不可能的。我们先讨论一个简单的例子，即不安全的C/C++运行库函数strcpyo char* strcpy(
char* strDestination,
const char* strSource);
这是一个很简单的函数，不是吗？这个旧式strcpy怎么可能导致进程终止呢？然而，如果 调用者传入NULL(或者其他非法地址)给两个参数的任意一个,strcpy都会引发一个访问违 规，然后，整个进程就会被系统终止。
使用SEH,我们便可以写出更健壮的strcpy函数：
char* RobustStrCpy(char* strDestination, const char* strSource) (
_try (
strcpy(strDestination, strSource);
}
—except (EXCEPTION_EXECUTE_HANDLER) (
// Nothing to do here
}
return(strDestination)；
}
这个函数所做的事情仅仅是将对strcpy的调用置于结构化异常处理的保护之内。如果 strcpy执行顺利，函数正常返回。如果strcpy引发访问违规，异常过滤程序返回 EXCEPTION_EXECUTE_HANDLER,于是线程开始执行异常处理程序的代码。而在这 个函数中，异常处理程序实际上什么也不做。所以，RobustStrcpy函数此时就会返回给它 的调用者。但是，RobustStrcpy不会引起进程终止！然而，尽管这个函数的实现让我们感 觉更安全，但是它很可能隐藏了更多的问题。
由于不知道strcpy是如何实现的，我们根本不知道在它执行过程中会有什么类型的异常会 被抛出。前面只提到参数为NULL或者其他非法地址的情况。如果地址是合法的，但是对 应的目标内存没有足够的空间可以容下strSource又会怎样？另外指针strDestinatioii指 向的内存块可能是一大块内存的一部分，那么这块内存就很可能被strcpy破坏。又或者这 块内存不足够大，于是我们也将得到一个访问违规的异常。然而，因为我们捕获了异常， 并且不让它继续抛出，进程还将执行——但是执行在一个受损坏状态上，导致程序一会儿
第24章异常处理程序与软件异常
就会崩溃，而其原因将很难查明；又或者引起一个可能会被利用的安全漏洞。其实这里的 原则很简单：只处理那些我们知道怎么处理的异常，并且也不要忘记其他的保护措施，以 防止程序状态混乱或者安全漏洞。(关于如何系统地使用安全的String函数，请参考第2章。)
欲684瑚5
让我们再来看一个例子。下面这个函数返回一个字符串中以空格作为分隔符的符号(token) 个数：
int RobustHowManyToken(const char* str) {
int nHowManyTokens = -1； // -1 indicates failure
char* strTemp = NULL; // Assume failure
_try (
// Allocate a temporary buffer
strTemp = (char*) malloc(strlen(str) + 1);
// Copy the original string to the temporary buffer strcpy(strTemp, str)；
// Get the first token
char* pszToken = strcok(strTemp,"")；
// Iterate through all the tokens
for (； pszToken != NULL; pszToken = strtok(NULL, " ■)) nHowManyTokens + +;
nHowManyTokens++; // Add 1 since we started at -1
}
_except (EXCEPTION_EXECUTE_HANDLER)(
// Nothing to do here
// Free the temporary buffer (guaranteed)
free(strTemp)；
return(nHowManyTokens)；
}
这个函数先将字符串复制到一块临时分配的缓冲区内。然后，使用C/C++库函数strtok 来得到字符串中的符号。分配临时缓冲区是有必要的，因为strtok在查找符号时会改写字 符串。
由于有了 SEH,这个看似简单的函数处理了各种可能性。我们来观察一下这个函数在各种 不同情形下的执行情况。
首先，假设调用者传入NULL(或者任何其他非法内存地址)；nHowManyTokens被初始化 为-1。之后，在try块中对strlen的调用引发一个访问违规。异常过滤程序得到控制权， 并将它传给except代码块，在这里异常处理程序什么也不做o except代码块执行结束以后， 我们用free函数来释放临时分配的内存块，并且给free函数传入的参数值为NULL。根据 ANSIC的规定，这是对free函数的一种合法调用。在这种情况下，free函数实际上什么也 不做——所以这里不会有什么问题。最后，函数返回-1,表明函数运行失败。请注意，进 程并没有终止。	___
第二种可能是，调用者传入了一个合法地址，但是对malloc的调用(在try块中)可能会失
Endows核心编程(第5版)
败并返回NULLo这将导致对strcpy的调用引发访问违规。这次，系统也会调用异常过滤 程序，并执行except代码块(什么也不做)，之后代码以NULL为参数调用free函数(什么 也不做)。于是函数返回T，表示这个函数运行失败。请注意，进程还是不会终止。
最后让我们假定，调用者传入了一个合法地址并且对malloc的调用也会成功。在这种情况 下，函数的其他代码的执行也不会有问题，符号个数的计算结果会存储在变量 nHowManyTokens里。直到try块结束，系统也不会调用异常过滤程序，因此except代码 块没有执行机会。最终临时内存将会被释放，函数结果nHowManyTokens将会被返回给 其调用者。
使用SEH是一件很酷的事情。RobustHowManyToken函数演示了如何保证在不使用 try-finally结构的情况下清理资源。并且在异常处理程序之后的代码也保证被执行(假定函 数没有在try块中返回一一这是开发者应该避免的做法)。
我们再来看最后一个也是非常有用的SEH示例。下面是一个实现内存复制功能的函数：
PBYTE RobustMemDup(PBYTE pbSrc, size_t cb) (
PBYTE pbDup = NULL； // Assume failure
一cry {
// Allocate a buffer for the duplicate memory block pbDup = (PBYTE) malloc(cb);
memcpy(pbDup, pbSrc, cb);
}
—except (EXCEPTION_EXECUTE_HANDLER) {
free(pbDup)；
pbDup = NULL;
)
return(pbDup)；
}
这个函数首先分配一块内存缓冲区作为目标内存块，然后从原内存块复制字节到目标内存 块。然后，函数返回日标内存地址给其调用者(如果函数失败，返回NULL)。如果调用者 需要负责释放函数所分配的内存。这是我们第一个在except块包含代码的例子，我们来看 看它在不同情形下的执行情况。
•	如果调用者给pbSrc参数传入非法地址或者调用malloc函数失败(返回NULL),会 导致memcpy抛出访问违规异常，导致异常过滤程序执行，过滤程序又将程序控制 流将交给except块。在except块里，我们释放内存缓冲区并设置puDup为NULL, 从而让函数调用者知道这个函数运行失败。注意ANSI C允许给free函数传入 NULLo
•	如果调用者给函数传入一个合法地址并且对malloc函数的调用成功返回，新分配 的内存块地址将返回给调用者。
第24章 异常处理程序与软件异常
24.2.2全局展开
当异常过滤程序的计算结果为EXCEPTION_EXECUTE_HANDLER时，系统必须执行全 局展开。全局展开导致所有巳经开始执行但尚未完成的try.finally块得以继续执行，在调 用栈中，这些try-finally块位于对异常进行了处理的try-except块的下方〉图24.2描绘了 系统执行全局展开的流程。读者在学习后面的实例时可以不时回顾这张图。
开始进 行全局 展开
记住那个对过滤程序求 值得到的结果是EXCEPTION, EXECUTE_HANDLER 的try代再块的位置
系统确定景里面 一层的try代码块
图24-2系统如何执行全局展开
687
void FuncOStimpyl()
// 1. Do any processing here.
①译注：此处我们定义调用栈的顶部（上方）是懿先被调用的函数，调用栈的底部（下方）是最后被调用的函数。这也是通常的定 义，但它和我们在调试器的调用栈窗口中所看到的恰好相反。本散后面的提到的方向（向上或向下）与此处的定义一致。
Endows核心编程（第5版）
—try {
// 2. Call another function.
FuncORenl()；
// Code here never executes.
)
_except ( /* 6. Evaluate filter. */EXCEPTION_EXECUTE_HANDLER) (
// 8. After the unwind, the exception handler executes.
MessageBox(...)；
}
// 9. Exception handled--continue execution.
• ♦ •
}
void FuncORenl() (
DWORD dwTemp = 0;
// 3. Do any processing here.
_try (
// 4. Request permission to access protected data.
WaitForSingleObject(g_hSem, INFINITE)；
// 5. Modify the data.
// An exception is generated here.
g_dwProtectedData = 5 / dwTemp；
}
_finally {
// 7. Global unwind occurs because filter evaluated
//to EXCEPT工ON_EXECUTE_HANDLER.
// Allow others to use protected data.
Releasesemaphore(g_hSem, 1, NULL)；
} >
// Continue processing--never executes.
}
我们将结合FunOStimpyl和FuncORenl来阐述SEH最让人费解的一部分。注释前面的数 字代表了执行的顺序，我们先来看一下函数的大致执行情况。
函数FuncOStimpyl执行从进入try块并调用FuncORenl开始。函数FuncORenl从try 块开始，并在进入try块后就等待一个信号量。一旦得到该信号，FuncORenl试图改变全 局变量g_dwProtectData的值。但是，以0作为除数的运算导致一个异常产生。于是系统 夺回控制权，它会搜索与try块匹配的except块。因为与FuncORenl中的try块匹配的是 finally块，于是系统在调用栈中向上搜索到另一个try块，这时，它会看到函数 FuncOStimpyl 中的 try 块与 except 块匹配。
于是系统开始执行与函数FuncOStimpyl中的except块相关联的异常过滤程序，并等待其 返回结果。当系统看到返回结果是EXCEPTION_EXECUTE_HANDLER时，马上在 FuncORenl的finally块中开始全局展开。请注意，全局展开发生在FuncOStimpyl中except 块执行之前。在进行全局展开时，系统会从调用栈的底部开始向上搜索所有己经开始执行 但尚未完成的try块，寻找所有带finally块的try块。这个例子中系统会找到函数
第24章异常处理程序与软件异常
FuncORenl 中的 finally 块。
当系统执行FuncORenl的finally代码块时，我们可以清楚地看到SEH所起到的作用： FuncORenl的finally块释放了信号量，使得另一个等待这个信号量的线程得以继续运行。 如果我们不在finally块中包含调用ReleaseSemaphore的语句，信号量就永远不会被释放。
当这个finally块中的代码执行完毕后，系统继续在调用栈中向上查找需要被执行的finally 块。这个例子己经没有需要执行的finally块了，于是系统在找到能够对异常进行处理的 try/except块时，停止查找，至此全局展开结束，系统执行except代码块。
这就是结构化异常的工作机制。我们代码的执行与系统的控制有很大关联，使得SEH很难 理解。代码执行控制流不再是从头到尾，系统根据自己的意图决定代码每一部分的执行顺 序。系统的执行顺序虽然复杂，但仍然是可推断的。而且在图24-1和图24-2这两个流程 图的帮助下，我们应该有信心理解和使用SEH。
为了更好地理解执行的顺序，让我们从另一个稍微不同的角度来看看发生了什么。当异常 过滤程序返回EXCEPTION_EXECUTE_HANDLER时，等于在告诉操作系统，当前线程 指令指针应该指向except块中的指令。然而，实际上当前指令指针指向的是try块中的指 令。在第23章，我们知道当一个线程离开try-finally结构的try块部分，系统需要确保finally 块中的代码得到执行。当异常发生时，系统用来确保这条规则成立的机制就是全局展开。
说明 从Windows Vista开始，如果一个异常发生在try/finally块中，并在其上层又没有 try/except块（同时过滤程序返回EXEPTION_EXCUTE_HANDLER）,进程就会 立刻终止。即全局展开并不会发生，finally块也不会执行。但是在早期版本的 Windows中，全局展开会在进程终止前发生，从而finally块也有机会得到执行。在 下一章，我们将对未处理异常的运作流程展开更为详细的讨论。
24.2.3停止全局展开
我们可以通过将return语句置于finally块中以阻止系统完成全局展开。首先看看下面这段 代码：
void FuncMonkey() {
—try {
FuncFish()；
)
_except (EXCEPTION_EXECUTE_HANDLER) (
MessageBeep(O)；
}
MessageBox(...)；
)
void FuncFish() (
FuncPheasant()；
MessageBox(...)；
}
void FuncPheasant() (
l^^idows核心编程(第5版)
—try {
Strcpy(NULL, NULL);
}
_finally {
return；
}
)
当FuncPheasant的try块调用strcpy函数时，一个访问内存违规异常被抛出。于是系统开 始检查是否存在异常过滤程序可以处理这个异常。这次，系统发现FuncMonkey中的异常 过滤程序可以处理它，于是系统初始化一个全局展开。
全局展开从执行FuncPheasant中的finally代码块开始,然而这个代码块中包含一个return 语句，它导致系统停止展开，实际上FuncPheasant也将停止执行，控制流返回到FuncFish 函数。后者继续执行并在屏幕上显示一个消息框，然后返回到FuncMonkeyo FuncMonkey 中调用消息框的代码执行。
请注意FuncMonkey的exception代码块没有机会执行对 MessageBeep的调用。
FuncPheasant中finally代码块的return语句导致系统停止之后所有的全局展开步骤，并 让系统正常执行，就好像没有异常发生过一样。
Microsoft将SEH设计成以这样的方式工作是经过慎重考虑的。在某些情况下，我们有可能 需要停止展开并允许在异常发生时程序正常执行。这种方式提供了这样做的机会，尽管在 通常情况下这应当不是我们想要做的事前。一条原则是，尽量避免将return语句置于Hnally 块中。C++通过产生C4532编译警告来帮助我们找到这些不好的返回语句：
'return' : jump out of _finally block has undefined behavior during termination handling.
24.3	EXCEPTION_CONTINUE_EXECUTION
现在让我们更详细地讨论异常过滤程序，看看我们怎么在其中返回三个异常标识符中的一 个，它们在Excpt.h中定义。在前面的“Funcmeister2”中，为了简单起见，我们在异常过 滤程序中指定常量EXCEPTION_EXECUTION_HANDLERo实际上，可以让异常过滤程 序调用一个函数，来决定返回三个标识符中的哪一个。下面就是一个例子：
TCHAR g_szBuffer[100]；
void FunclinRooseveltl() (
int x = 0；
TCHAR *pchBuffer = NULL;
_try (
*pchBuffer = TEXT('J')；
x = 5 / x；
_except (OilFilterl(&pchBuffer)) (
MessageBox(NULL, TEXT("An exception occurred"), NULL, MB_OK)；
}
第24章异常处理程序与软件异常
MessageBox(NULL, TEXT("Function completed"), NULL, MB_OK)；
}
LONG OilFilterl(TCHAR **ppchBuffer) (
if (*ppchBuffer == NULL) (
*ppchBuffer = g_szBuf fer；
return(EXCEPTION_CONTINUE_EXECUTION);
}
return(EXCEPTION_EXECUTE_HANDLER);
}
当函数将字符置于pchBuffer所指向的内存缓冲区内时，遇到了第一个问题：很不幸, 我们没有初始化pchBuffer,让它指向全局内存缓冲区g_szBufffer0因此，pchBufTer的值 为NULLo CPU会抛出一个异常，并对发生异常的try块所对应的except块的异常过滤程 序进行求值。后者则以变量pchButter作为参数值调用OilFilterl。
当OilFilterl开始执行，它首先检S*ppchBufTer的值是不是NULL。如果是，设置*ppBuffer 的值，让其指向全局内存缓冲g_szBuffero于是，这次异常过滤程序的返回结果为 EXCEPTION_CONTINUE_EXECUTION。系统在看到过滤程序返回值为 EXCEPTION_CONTINUE_EXECUTION后，将程序控制流跳转到导致异常的那条指令， 并尝试重新执行这条指令。这次，指令将执行成功，'J'被置于LszBuffer所指向缓冲区 的第一个字节。
代码继续执行，将会遇到以0作为除数的异常。系统再一次计算异常过滤程序表达式。这 —次，OilFilter 检查至lJ*ppchBufTer 的值不是 NULL,于是返回 EXCEPTION_EXECUTE_ HANDLER,让系统执行except代码块。于是一个消息框被弹出，指明一个异常发生。
691
可以看出，我们可以在异常过滤程序里添加很多代码。当然，过滤程序必须返回三个异常 标识符中的其中一个。但是它也可以执行其他我们想要它执行的任务。不管怎样，请记住 在一个异常被抛出后，进程很可能已经变得不稳定。所以，最好还是让异常过滤程序中的 代码相对简单。比如，在堆被破坏的情况下，在过滤程序里运行很多的代码可能导致进程 被挂起或者不加任何提示地终止。
谨慎使用 EXCEPTION_CONTINUE_EXECUTION
尝试纠正导致异常发生的错误有时候可以成功，但并不是每次都这么幸运，我们将通过函 数FuncinRooseveltl证明——它成功与否取决于程序的目标CPU,和我们的编译器如何为 C/C++语句产生具体机器指令和编译选项。
编译器可能为下面这条C/CI■语句生成两条机器指令：
*pchBuffer = TEXT(* J');
编译器为其生成的机器指令如下：
MOV EAX, DWORD PTR[pchBuffer] // Move the address into a register
MOV WORD PTR[EAX], 'J' // Move 'J' into the address
「indows核心编程(第5版)
抛出异常的是第二条指令。异常过滤程序可以捕获这个异常，修正变量pchBuffer的值， 并让系统重新执行第二条CPU指令。问题是寄存器不可能自动更新以反映变量pchBuffer 的更新，于是重新执行这条CPU指令又会产生另一个异常。程序将陷入了死循环当中！
继续执行可能因为编译器优化了代码而成功，也可能因为编译器没有优化代码而失败。这 可能会导致一个非常难以解决的软件缺陷，因为需要检查汇编级别的代码才能发现问题到 底发生在哪里。这个例子给我们的教训是，在异常过滤程序中返回 EXCEPTION_CONTINUE_EXECUTION 是需要非常谨慎的。
有一种情况，返回EXCEPTION_CONTINUE_EXECUTION将保证继续执行始终都能成 功：当我们为已预订的内存区域稀疏地调拨存储器时。在第15章，我们讨论了如何预订大 块的地址空间和如何为地址空间稀疏地调拨存储器。VMAIloc示例程序对此做了演示。更 好的办法是让VMAIloc通过使用SEH机制来按需调拨存储器，而不是每次都调用 VirtualAlIoCo
在第16章，我们讨论了线程栈。我们专门讨论了系统如何为线程栈预订1 MB的内存和系 统如何在线程需要的时候自动地为线程栈调拨新的存储器。系统会在其内部建立一个SEH 框(SEH frame)o当我们的线程试图访问栈中尚未调拨存储器的区域时，会引发一个异常。 系统内部的异常过滤程序将捕获到这个因为线程试图访问已预订的栈地址空间而引发的异 常。于是，它在其内部调用VirtualAUoc来为线程栈调拨更多的存储，并且返回 EXCEPTION_CONTINUE_EXECUTIONo于是，原先抛出异常的指令再次执行将会成功 并且线程也能在此继续运行下去。
如果能很好地结合虚拟内存技术和结构化异常处理，我们就能写出运行速度极快和高效的 应用程序。在第25章，我们将通过电子表格(spreadsheet)的例子展示如何通过SEH有效地 实现内存分配与管理，那段代码是为高性能运行而设计的。
692Y93
24.4	EXCEPTION_CONTINUE_SEARCH
到目前为止讨论的例子都比较平淡，现在我们将增加一个函数调用使前面这个例子更有趣。
TCHAR g_szBuffer[100]；
void FunclinRoosevelt2() (
TCHAR *pchBuffer = NULL;
_cry (
FuncAtude2(pchBuffer);
}
_except (OilFilter2(&pchBuffer)) {	,
MessageBox(...)；
)
void FuncAtude2(TCHAR *sz) ( *sz = TEXT(1\0*)；
第24章异常处理程序与软件异常
}
LONG OilFilter2 (TCHAR **ppchBuffer) (
if (*ppchBuffer == NULL) (
*ppchBuffer = g_szBuffer;
return(EXCEPTION_CONTINUE_EXECUTION);
)
return(EXCEPTION_EXECUTE_HANDLER);
}
当FunclinRooserveltl开始执行时，调用FuncAtudel,并以NULL作为参数值。因此当 FuncAtudel执行时，将抛出异常。和前面所讨论的一样，系统计算与最近执行的try块匹 配的异常过滤程序。在这个例子中，FunclinRooseveIt2中的try块是最近执行的，于是系 统调用OilFilterZ来计算异常过滤程序——尽管异常发生在函数FuncAtudel里。
下面加入另一个try-except块使这个例子有趣：
TCHAR g_szBuffer[100];
void Fund inRoosevelt 3 () {
TCHAR *pchBuffer = NULL;-
_try {
FuncAtude3(pchBuffer)；
}
_except (OilFilter3(&pchBuffer)) (
MessageBox(...)；
)
void FuncAtude3(TCHAR *sz) (
_try (
*sz = TEXT('\0');
)
_except (EXCEPTION_CONTINUE_SEARCH) ( // This never executes.
LONG OilFilter3(TCHAR **ppchBuffer) ( if (*ppchBuffer == NULL) (
*ppchBuffer = g_szBuffer； return(EXCEPTION_CONTINUE_EXECUTION); ) return(EXCEPTION_EXECUTE_HANDLER);
当FuncAtude3试图将HO'写入地址NULL时，CPU抛出异常，但这一次系统计算的是 FuncAtude3中的异常过滤程序。这个异常过滤程序很简单，就是返回常量，即 EXCEPTION_CONTINUE_SEARCH。这个标识符让系统在调用栈中向上查找前一个带 except块的try代码块，并调用这个try块对应的异常过滤程序。
因为FuncAtude3的异常过滤程序返回EXCEPTION_CONTINUE_SEARCH,系统寻找到 在它上层的前一个try块(在FunclinRoosevelt3中)并调用对应异常过滤程序中的函数 OilFiIter3o OilFilter3看到pchBuffer的值为NULL,于是设置pchBuffer指向全局缓存，
如lows核心编程（第5版）
并让系统重新执行之前抛出异常的那句指令。这会让FuricAtude3中的try块继续执行，但 是不幸的是，FuncAtude3的局部sz变量并没有发生改变，从原先失败的那条指令开始执 行只会使同一个异常再发生一遍。但这一次函数OilFilter3看到pchBuffer不是NULL,于 是将返回EXCEPTION_EXCUTE_HANDLER,这会让系统执行从except代码块开始。即 执行Fu n ciin Roose velt3中的except块中的代码。
注意，我所说的系统在调用栈中向上寻找最近的与except块匹配的try块并计算其对应的 异常过滤程序。这意味着如果一个try块与finally块成对出现，而不是与except块，那么 系统在查找的过程中会忽略它。原因很简单：finally块没有异常过滤程序，从而系统也没 有什么需要进行求值。如果最后一个例子的FuncAtude3包含的是一个finally块而不是 except块，系统首先会计算FunclinRooseveB中的异常过滤程序，调用函数OilFilter3o
我们将在第25章将详细讨论EXCEPTION CONTINUE SEARCHo
24.5	GetExceptionCode
决定在异常过滤程序中返回什么标识符前，我们必须具体情况具体分析。比如，应用程序 可能知道怎么处理以0作为除数引发的异常，但是却不知道怎么处理一个非法访问内存异 常。异常过滤程序应根据具体的情况返回合适的值。
这段代码展示了调用一个函数来识别刚刚发生的异常的类型。
_try {
x = 0;
y = 4 / x; // y is used later so this statement is not optimized away
}
_except ((GetExceptionCode() == EXCEPTION_INT_DIVIDE_BY_ZERO) ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) ( // Handle divide by zero exception.
}
GetExceptionCode是内在函数，它的返回值表明刚刚发生的异常的类型。
DWORD GetExceptionCode（）;
下面列出了预定义的异常标识符和它们的具体含义，它们来自于Platform SDK的文档。我 们可以WinBase.h文件中找到它们。我对它们进行了归类。
与内存相关的异常如下。
•	EXCEPTION_ACCESS_VIOLATION 线程试图读写一个虚拟内存地址，但在这 个地址它并不具备相应权限。这是最常见的异常。
•	EXCEPTION_DATATYPE_MISALIGNMENT 线程试图从没有提供自动对齐机|
制的硬件里读入没有对齐的数据。例如，16位数据必须与2字节边界对齐，32位 数据必须与4字节边界对齐，诸如此类。	;
•	EXCEPTION_ARRAY_BOUNDS_EXCEEDED 线程在支持边界检查（bounds
第24章异常处理程序与软件异常
checking)的硬件上访问越界的数组元素。
•	EXCEPTION_IN_PAGE_ERROR 因文件系统或设备驱动返回读取错误而引起 不能满足要求的页错误。
•	EXCEPTION_GUARD_PAGE 线程试图访问具备PAGE_GUARD属性的内存 页。该内存页是可访问的，但同时EXCUPTION_GUARD_PAGE异常被抛出。
•	EXCEPTION_ST ACK_O VERFLO W 线程用光了系统分配给它的栈空间。
•	EXCEPTIONJLLEGALJNSTRUCTION 线程执行了一条非法指令。这个异常 由具体的CPU架构所定义，在不同的CPU上执行一条非法指令可能会导致陷阱错 误(trap error) o
•	EXCEPTION_PRIV_INSTRUCTION线程试图执行在当前机器模式下并不允许 的操作。
与异常本身相关的异常如下。
•	EXCEPTION_INVALID_DISPOSrnON 异常过滤程序返回 EXCEPTION_EXECUTE_ HANDLER, EXCEPTION_CONTINUE_SEARCH,或者 EXCEPTION_CONTINUE_ EXECUTION以外的值。
•	EXCEPTION_NONCONTINUABLE_EXCEPTION 异常过滤程序返回 EXCEPTION_CONTINUE_EXECUTION,但实际上当这个类型的异常发生以后， 系统并不能允许程序继续执行。
与调试相关的异常如下。
•	EXCEPTION_BREAKPOINT 执行到一个断点。
•	EXCEPTION_SINGLE_STEP 由跟踪中断或者其他单步执行机制发出的一条指 令巳经执行完由］信号。
•	EXCEPTION_INVALID_HANDLE 传入无效句柄给一个函数。
与整型相关的异常如下。
•	EXCEPTION_INT_DIVIDE_BY_ZERO 线程试图在整数除法运算中以0作为除数。
•	EXCEPTION JNT_OVERFLOW 整型运算的结果超过了该类型规定的范围。
浮点类型相关的异常如下。
•	EXCEPTION_FLT_DENORM AL_OPERAND 浮点运算的其中一个运算数是非 法值。非法值即这个值太小以致不能作为一个标准的浮点数。
•	EXCEPTION_FLT_DIVIDE_BY_ZERO 线程试图在浮点除法运算中以浮点数0 作为除数。
•	EXCEPTION_FLT_INEX ACT_RESULT 浮点运算的结果不能精确地表示为十 进制小数。
•	EXCEPTION_FLT_INVALID_OPERATION 表示任何没有在此列出的其他浮点 数异常。
•	EXCEPTION_FLT_OVERFLOW 浮点运算结果的指数部分超过了该类型允许的 .最大值。
indows核心编程（第5版）
•	EXCEPTION_FLT_STACK[CHECK 浮点运算造成栈向上溢出或向下溢出。
•	EXCEPTION_FLT_UNDERFLO W 浮点运算结果的指数部分小于该类型允许的 最小值。
内在函数GetExceptionCode只能在异常过滤程序里(B|J_except之后的括号里)或者异常 处理程序的代码里调用。因此下面的代码是合法的：
_try (
y = o；
x = 4 / y;
)
_except (
((GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION) I I
(GetExceptionCode() == EXCEPTION_INT_DIVIDE_BY_ZERO)) ?
EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) (
switch (GetExceptionCode()) ( case EXCEPTION_ACCESS_VIOLATION: // Handle the access violation.
break'；
case EXCEPTION_INT_DIVIDE_BY_ZERO:
// Handle the integer divide by 0.
break;
}
} ____________________________________________________________________
696-697
但是我们不能在异常过滤程序的函数里调用GetExceptionCode,所以编译器在编译以下代 码时会产生一个编译错误。
—try (
y = 0;
x = 4 / y；
)
_except (CoffeeFilter()) (
// Handle the exception.
• • •
}
LONG CoffeeFilter (void) (
// Compilation error： illegal call to GetExceptionCode. return((GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION) ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH);
} _
当然，我们可以像下面这样重写这段代码以达到预期效果。
_try (
y = 0;
x = 4 / y；
}
_except (CoffeeFilter(GetExceptionCode())) (
// Handle the exception.
)
LONG CoffeeFilter (DWORD dwExceptionCode) {
return((dwExceptionCode == EXCEPTION_ACCESS_VIOLATION) ?
EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)；
}
第24章 异常处理程序与软件异常
异常代码遵循在WinError.h文件中定义的有关错误代码的规则。每个DWORD值被划分为 几个部分（详见第1章），如表24-2所示。
表24-2错误代码的各个组成部分
位	31-30	29	28	27-16	15-0
内容	严重性	Microsoft/ Customer	保留位	设备代码	异常代码
含义	0=Success l=lnfbrmational 2=Waming 3=error	0=Microsoft 所定 义的代码 I =Customer 所定 义的代码	一直为0	前256个值为 Microsoft 所保留 （见表24-3）	由 Microsoft/ Customer 所定义的代码
表24-3是到目前为止Microsoft所定义的设备代码。
表24・3设备代码
设备代码	值	设备代码	值
FACILITY NULL	0	FACILITY WINDOWS CE	24
FACILITY RPC	1	FACILITY HTTP	25
FACILITY DISPATCH	2	FACILITY USERMODE COMMONLOG	26
FACILITYSTORAGE	3	FACIL【TY USERMODE FILTER MANAGER	31
FACILITYJTF	4	FACILITY BACKGROUNDCOPY	32
FACILITY WIN32	7	FACILITY CONFIGURATION	33
FACILITY WINDOWS	8	FACIL1TY STATE MANAGEMENT	34
FACILITY SECURITY	9	FACILITY METADIRECTORY	35
FACILITY CONTROL	10	FACILITY WINDOWSUPDATE	36
FACILITY CERT	11	FACILITY DIRECTORYSERVICE	37
FAC1LITY INTERNET	12	FACILITY GRAPHICS	38
FACILITY MEDIASERVER	13	FACILITY SHELL	39
FACILITY MSMQ	14	FACILITY TPM SERVICES	40
FACILITY SETUPAPI	15	FACILITY TPM SOFTWARE	41
FACILITY SCARD	16	FACILITY PLA	48
FACILITY COMPLUS	17	FACILITY FVE	49
FACILITY AAF	18	FACIL1TY FWP	50
FACILITY URT	19	FACILITY WINRM	51
FAC1LITY ACS	20	FACILITY NDIS	52
indows核心编程（第5版）
—.---- ----- ------ ♦
续表
设备代码	值	设备代码	值
FACILITY DPLAY	21	FACILITY USERMODE HYPERVISOR	53
FACILITY UMI	22	FACILITY CMI	54
FACILITY SXS	23	FACILITY WINDOWS DEFENDER	80
不妨将EXCEPTION_ACCESS_ VIOLATION拆开，看看每个位分别代表什么。在 WinBase.h 中找至lj EXCEPTION_ACCESS_VIOLATION ,可以看到它被定义成 STATUS__ACCESS_VIOLATION0 而后者在 WinNT.h 定义，其值为 020000005,即：
C0000005	（16 进制）
1100 0000 0000 0000 0000 0000 0000 0101 （2 进制）
第30位和第31位都被设成1,表示这是一个严重错误（线程在这种情况不能继续往下执行）。 第29位为0,表示Microsoft已经定义了这个代码。第28位是0,为今后扩展而保留。从 16到27位都是0,表示FACILITY_NULL（即违规访问异常可以在系统任何设备出现，并 不是只发生在一些特定的设备上）。第0到15位包含的值为5,仅仅表示Microsoft将访问 违规异常代码定义为5,并无其他特殊含义。
24.6	GetExceptionInformation
当一个异常发生时，操作系统将向发生异常的线程的栈中压入三个结构：
EXCEPTION_RECORD, CONTEXT 和 EXCEPTION_POINTERS。
EXCEPTION_RECORD结构包含关于抛出异常的信息，这些信息的内容与具体的CPU没 有关系。CONTEXT结构则包含关于异常但与CPU也有关的信息。
EXCEPTION_POINTERS结构仅包含两个数据成员，它们分别为指向被压入栈中的 EXCEPTION_RECORD结构的指针和指向CONTEXT结构的指针。
typedef struct _EXCEPTION_POINTERS （
PEXCEPTION_RECORD ExceptionRecord;
PCONTEXT ContextRecord；
} EXCEPTION_POINTERS, * PEXCEPTION_POINTERS;
如果想要得到这些信息，并在应用程序中使用它们，可以如下调用函数
GetExceptionlnformation:
PEXCEPTION_POINTERS GetExceptionlnformation（）；
这个内在函数返回一个指向EXCEPTION__POINTERS结构的指针。
这里有一个关于GetExceptionlnformation的重要提示：这个函数只能在异常过滤程序中调 用，这是因为 CONTEXT, EXCEPTION_RECORD,以及 EXCEPTION_POINTERS 数 据结构只有在系统计算异常过滤程序时才是有效的。一旦程序控制流被转移到异常处理程 序或者别的地方，这些栈上的数据结构就被销毁了。
第24章 异常处理程序与软件异常
如果需要在异常处理程序里访问异常信息(尽管实际上，这种情况应该是很少见的)，必须 将 EXCEPTION_POINTERS 的成员指向的 EXCEPTION_RECORD 结构和 / 或 CONTEXT结构保存在我们建立的一个或多个变量里。以下代码演示了如何保存 EXCEPTION_RECORD 和 CONTEXT 结构。
void FuncSkunk() (
// Declare variables that we can use to save the exception
// record and the context if an exception should occur.
EXCEPTION_RECORD SavedExceptRec;
CONTEXT SavedContext；
• • •
—try (
• • ・
)
_except (
SavedExceptRec =
*(GetExceptionlnformation())->ExceptionRecordz
SavedContext =
*(GetExceptionlnformation())->ContextRecord,
EXCEPTION_EXECUTE_HANDLER) (
//We can use the SavedExceptRec and SavedContext
// variables inside the handler code block.
switch (SavedExceptRec.ExceptionCode) (
}
}
请注意异常处理程序中对C/C++语言的逗号操作符（，）的使用。许多程序员可能并不习惯 于见到这个操作符。它告诉编译器从左到右执行逗号所分隔的表达式。当所有表达式都求 值完毕时，返回最后一个表达式的值。
在FuncSkiyik中，最左边的表达式将线程栈上的EXCEPTION_RECORD结构保存到局 部变量SavedExceptReco这个表达式的计算结果就是变量SavedExceptRec的值。然而， 这个结果实际上会被丢弃，然后其右边的表达式开始执行。它将栈上的CONTEXT结构存 储在局部变量SavedContext里，表达式结果即为变量SavedContext的值。同样，第二个 表达式结果也会被丢弃。最后一个表达式很简单，即为常量 EXCEPTION_EXECUTE_HANDLER。这个常量就是最后一个表达式也是整个逗号所分 隔的表达式组的计算结果。
因为异常过滤程序返回EXCEPTION_EXECUTE_HANDLER,所以系统将会执行except 代码块。此时因为SavedExceptRec和SavedContext变量此时已被初始化，所以我们可以 在except块中使用它们。但是，请记住在try块以外声明SavedExceptRec和SavedContext 变量。	>
读者可能已经猜到，EXCEPTION_POINTERS结构中的Exception Record成员指向的是 EXCEPTION_RECORD 结构。
typedef struct _EXCEPTION_RECORD （
DWORD ExceptionCode;
DWORD ExceptionFlags;
Windows核心编程（第5版）
struct _EXC E PTION_RECORD * Except i onRecord;
PVOID ExceptionAddress;
DWORD Numberparameters;
ULONG_PTR ExceptionInformaCion[EXCEPTION_MAXIMUM_PARAMETERS];
} EXCEPTION_RECORD;
EXCEPTION_RECORD结构包含了关于刚发生的异常的详细信息（这些信息与具体的 CPU无关），如下所示。
•	ExceptionCode表明异常代码，这个代码就是内在函数GetExceptionCode所返回 的代码。
•	ExceptionFlags包含一些跟异常相关的标志。目前只有两个值，分别是0（表示可以 继续的异常）和EXCEPTION_NONCONTINUABLE（表示不能继续的异常）。如果程 序试图在一个不能继续的异常发生之后继续执行，就会引发 EXCEPTION_NONCONTINUABLE_EXCEPTION 异常。
•	ExceptionRecord指向另一个未处理异常的EXCEPTION_RECORD结构。在处理 一个异常的时候，有可能会发生另一个异常。比如，异常过滤程序中的代码可能试 图以0去除一个数。如果在异常过滤程序执行时又发生了一个异常，那么就会生成 嵌套异常。当嵌套异常发生时，异常记录可以链接起来，以便提供更多的信息。在 Windows Vista之前的系统上，当嵌套异常发生时，进程就会被终止。如果没有未 处理的异常，ExceptionRecord的值为NULL。
•	ExceptionAddress表明导致异常的CPU指令的地址。
•	NumberParameters 表明与异常相美参数的个数（0 到 15）。即 Exceptionlnformation 数组里的元素个数。对绝大部分的异常来说，这个值为0。
•	Exceptionlnformation表示用来进一步描述异常的附加参数数组。对绝大部分异常 来说，这些数组元素都未定义。
700-701
EXCEPTION_RECORD 结构的最后两个成员（NumberParameters 和 Exceptioninformation）为异常过滤程序提供了关于异常的附加信息。目前只有 EXCEPTION_ACCESS_VIOLATION异常提供附加信息，而其他所有异常的 NumberParameters值为0。我们nJ以检查Exceptioninformation来查看关于异常的附加 信息。
对于一个 EXCEPTION_ACCESS_VIOLATION 异常，Exceptionlnformation[0]包含一个 标志，指出引发这个非犊访问的异常类型。。表示线程试图读取不能访问的数据；1表示线 程试图写入不能访问的数据。当数据执行保护（Data Execution Prevention,简称DEP）侦测到 线程执行不具备访问权限的内存页中的代码时，这个异常也会抛出，同时 ExceptionInformation[0|值被设置为 8（在 IA-64 平台为 2）。
通过使用这些信息，我们的异常过滤程序可以提供很多关于进程的重要信息。比如，可以 编写一个这样的异常过滤程序：
_try {
_except (ExpFltr (Get Except ionlnformat.ion () ) ) (
第24章异常处理程序与软件异常
LONG ExpFltr (LPEXCEPTION_POINTERS pep) (
TCHAR szBuf[300], *p；
PEXCEPTION_RECORD pER = pep->ExceptionRecord; DWORD dwExceptionCode = pER->Except ionCode;
StringCchPrintf(szBuf, _countof(szBuf), TEXT("Code = %x. Address = %p"), dwExceptionCode, pER->ExceptionAddress)；
// Find the end of the string. p = _tcschr(szBuf7 TEXT('01));
// I used a switch statement in case Microsoft adds
// information for other exception codes in the future. switch (dwExceptionCode) (
case EXCEPTION_ACCESS_VIOLATION:
StringCchPrintf(p, _countof(szBuf), TEXT(M\n--> Attempt to %s data at address %pM)z pER->ExceptionInformation[0] ?
TEXT(-write") : TEXT(-read"), pER->ExceptionInformation(1])； break;
default： break； )
MessageBox(NULL, szBuf, TEXT("Exception"), MB_OK I MB_ICONEXCLAMATION);
return(EXCEPTION_CONTINUE_SEARCH);
)
701-702
EXCEPTION_POINTERS结构中的ContextRecord成员指向一个CONTEXT结构（请参考 第7章），这个结构是与平台相关的——即它在不同的CPU平台上有着不同的内容。
针对CPU上的每个寄存器，这个结构都有对应的成员。当异常被抛出，可以通过查看这个 结构的成员以找到更多的信息。但为了得到这种便利，除了合理地使用CONTEXT结构， 我们也不得不编写与平台相关的代码来识别程序运行的平台当然，最好是在代码中使用 #ifdef指令。Windows支持的各种CPU的CONTEXT结构定义都放在WinNT.h文件中。
24.7软件异常
到目前为止，我们讨论了硬件异常，即由CPU捕获某一个事件并抛出的异常。其实，我们 也可以在应用程序代码里强制抛出一个异常。这是函数将运行失败通知其调用者的另一种 方式。传统上，函数通过返回一些错误代码来指明运行失败。函数的调用者应该检查这些 错误代码并采取相应的措施。这会导致调用者需要频繁地做清理工作并返回给它自己的调 用者i个失败代码。错误代码的逐层传播导致代码很难编写和维护。
另一种方法是我们可以让函数在失败时抛出异常，而不是返回错误代码。这种方式下，代 码更容易编写和维护。并旦，因为省略了很多的错误检测代码，程序运行效率更高。实际
jl^dows核心编程(第5版)
上，当且仅在函数失败时也就是发生异常时才有必要执行错误检测代码。
不幸的是，大部分的开发者并不习惯通过异常机制来进行错误处理。这有两方面的原因。 第一个原因是很多开发者并不熟悉SEHo就算有其中一个开发者熟练掌握了它，其他开发 者却未必。在这种情况下，如果一个开发者编写一个会抛出异常的函数，但是其他开发者 却并不懂得编写SEH框来捕获并处理这个异常，进程就会被操作系统终止。
第二个原因是对SEH机制的使用不容易被移植到其他的操作系统平台。SEH是Windows 专有的技术。很多公司的产品想要面向各种操作系统但只想维护一套源代码，这当然是可 以理解的。
不过，如果读者决定通过异常机制来返回函数错误又该如何？我赞成这个决定并且为这些 读者准备了这一节内容。首先，我们来看一下Windows的堆操控函数，比如HeapCreate 和HeapAlloc等。回顾第18章的内容，我们知道这些函数给开发者提供了一种选择。通常 情况下，当堆操控函数失败时，会返回NULL来表示失败。然而，也可以给它们传入 HEAP_GENERATE_EXCEPTIONS标记，要求它们在失败时，不要返回NULL而是抛出 一个STATUS_NO_MEMORY软件异常。于是，程序的其他代码就可以使用SEH框来捕 获这个异常。
如果想利用这个异常，我们可以在编写try块时假定内存分配一定会成功。如果内存分配 实际上失败，我们通过except块处理这个异常或者在Hnally块里做清理工作。瞧，多么 方便！
软件异常的捕获方式与硬件异常完全一样。因此，我们前面讨论的内容对软件异常同样 适用。
本节要重点讨论的是如何让我们的函数强制抛出软件异常，以作为一种指明错误的方法。 当然，也可以像Microsoft实现堆函数那样，让调用者传递一个标记以决定函数以何种方式 指明错误。
抛出一个软件异常再容易不过了，只需要调用RaiseException函数：
VOID RaiseException(
DWORD dwExceptionCode,
DWORD dwExcept ionFlags,
DWORD nNumberOfArguments, CONST ULONG_PTR *pArguments);
第一个参数dwExceptionCode是所要抛出异常的标识符。HeapAlloc函数对这个参数的设 定为STATUS_NO_MEMORY。如果我们要定义自己的异常标识符，应该遵循Windows 错误代码定义的标准格式，它们在WinErronh文件中定义。一个DWORD值要被分成几个 部分，具体请参阅表24-1 o
如果要自定义异常代码，需要填充DWORD值的以下五个部分。
• 第31位和第30位包含严重性系数。

第24章 异常处理程序与软件异常
•	第29位是1（0表示 Microsoft定义的异常，如函数HeapAIIoc抛出的
STATUS_NO_MEMORY）o
•	第28位是0。
•	第27位到16位是Microsoft预定义的设备代码。
•	第15到结束可以是任意值，用来标识符引发异常的程序段。
RaiseException 的第二个参数 dwExceptionFlags 必须设置成 0 或者 EXCEPTION_ NONCONTINUABLEo 一般来说，这个标记用来指出异常过滤程序在处理这个异常时能否 返回 EXCEPTION_CONTINUE_EXECUTION。如果不给 RaiseException 传递 EXCEPTION_NONCONTINUABLE 标记，过滤程序就可以返回 EXCEPTION_CONTINUE_ EXECUTIONo正常情况下这会导致线程重新执行产生软件异常的那条CPU指令。但是， Microsoft在这里做了一些“手脚”来让程序从RaiseException函数调用的后面继续执行。
如果给RaiseException传递EXCEPTION_NONCONTINUABLE,等于告诉系统一旦发生 这种类型的异常，程序便不能继续。这个标志在操作系统内部被用来传递极为严重（不可恢 复）的错误信息。比如，当HeapAIIoc抛出STATUS_NO_MEMORY软件异常时，它使用 EXCEPTION_NONCONTINUABLE标志来告诉系统，发生这个异常后，程序不能再继续 执行下去。这是正确的，因为系统没有办法强制分配内存并让程序继续运行。
如果过滤程序忽略 EXCEPTION NONCONTINUABLE 并返回 EXCEPTION CONTINUE EXECUTION ,系统就会抛出一个新的异常：EXCEPTION_NONCONTINUABLE_ EXCEPTION o
当系统在处理一个异常时，很可能再抛出另一个异常，这也是有意义的。比如在finally块， 在异常过滤程序或者异常处理程序中都有可能发生非法内存访问。这种情况发生时，系统 会将异常叠加起来。还记得 GetExceptionlnformation函数吗？这个函数返回 EXCEPTION_POINTERS 结构的地址，结构的 Exception Record 成员指向 EXCEPTION_RECORD结构，而这个结构又包含一个Exception Record成员。这个成员 是另一个EXCEPTION_RECORD结构的指针，它包含了之前发生的异常的信息。
通常系统一次只需处理一个异常，所以ExceptionRecord成员的值是NULL。然而，如果 在处理一个异常时，又发生一个异常，第一个EXCEPTION_RECORD结构包含的是最近 发生的异常的信息并且它的ExceptionRecord成员指向之前发生的异常的 EXCEPTION_RECORD结构。如果附加异常没有全部得到处理，可以搜索这个 EXCEPTION_RECORD结构的链表以决定如何处理异常。
RaiseException的第三个与第四个参数（nNumberOfArguments和pArguments）用来传递有关 抛出异常的附加信息。一般情况下是不需要附加参数的，我们可以简单地给pArguments参 数传入NULL,于是RaiseException就会忽略nNumberOfArguments参数。如果确实有必要 传递附加参数，nNumberOfArguments必须指明pArguments参数指向的ULONG_PTR数组
Endows核心编程（第5版）
的元素个数。但是这个参数的值不能超过EXCEPTION_MAXIMUM_PARAMETERS（在 WinNT.h中定义为15）。
在异常的处理过程中，我们口J以让异常过滤程序查看EXCEPTION_RECORD结构的 NumberParameters 和 Exceptionlnfbrmation 成员，来获得 nNumberOfArguments 和 pArguments 参数所包含的信息。
有很多理由致使我们应该在应用程序中自定义软件异常。比如，我们可能想给系统的事件 日志发送通知消息。一旦程序中某个函数发生了某个问题，我们可以调用RaiseException 并让位于调用树上层的异常处理程序捕获某些特定的异常，异常处理程序可以将异常信息 写入到事件日志，或者弹出一个消息框。我们也可能需要创建软件异常来传递应用程序内 部的严重错误信息。
704耳
本章内容
25A UnhandledExceptionFilter 函数详解
25.2即时调试
25.3电子表格示例程序
25.4向量化异常和继续处理程序
25.5	C++异常与结构化异常的比较
25.6异常与调试器
前一章讨论了异常过滤程序返回EXCEPTION_CONTINUE_SEARCH时所发生的情况： 系统继续在调用树中的上层寻找异常过滤每一序。可是如集每个异常过滤程序都返回 EXCEPTION_CONTINUE_SEARCH,又会发生什么呢？在这种情况下，我们会遇到所谓 的未处理异常。
Microsoft Windows 提供了函数 SetUnhandledExceptionFilter» 它给了我们处理异常的最 后机会，否则Windows就会正式认为这个异常没有得到处理。
PTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFiIter( PTOP_LEVEL_EXCEPTION_FILTERpTopLevelExceptionFilter);
我们通常应在进程初始化阶段调用这个函数。一旦这个调用了这个函数，进程中任意线程 抛出未处理异常都会导致我们指定(通过SetUnhandledExceptionFilter的参数)的最上层异 常过滤函数执行。这个异常过滤函数原型必须与下面类似：
LONG WINAPI TopLevelUnhandledExceptionFilter(PEXCEPTION_POINTERS pExceptionlnfo);
在异常过滤程序里，只要返回如表25・1所列的三个EXCEPTION,*标识符之一，就可以做 任何我们想要做的处理。注意，进程可能因为栈溢出而未释放同函信号，或者没有释放在 堆上分配的内存，而已经处于被破坏的状态。所以，我们应该尽量减少异常过滤函数的处 理工作，并且不要再申请动态内存，因为堆可能己经被破坏。
表25-1由最上层异常过滤程序所返回的值
标识符	对应的结果
EXCEPTION_EXECUTE_HANDLER	进程在不给用户任何通知的情况下悄然终止。注意全局展 开会被引发，所以finally代码块会执行
Endows核心编程(第5版)
	续表
标识符	对应的结果
EXCEPTION_CONTINUE_EXECUTION	从抛出异常的指令继续执行，我们可以修改由 PEXCEPTION_POINTERS参数指向的异常信息。如果 我们不修正导致异常的错误，同样的异常还会再一次被抛 出，于是进程将进入异常不断被抛出的无限循环
EXCEPTION_CONTINUE_SEARCH	异常不会得到任何处理。随后的"UnhandledExceptionFilter 函数详解”小节描述了接下来所发生的事情
当我们设置新的未处理异常过滤程序时，SetUnhandledExceptionFilter返回上次安装的异 常过滤程序的地址。注意，如果程序使用的是C/C++运行库，在进程入口点函数开始执行 前，C/C++运行函数就会安装一个默认的全局异常过滤程序，即 _CxxUnhandledExceptionFiltero这个函数所做的工作很简单，首先检查异常是不是属于 C++异常(关于它的详细讨论，请参阅本章稍后的“C++异常与结构化异常的比较”小节)。 如果是，则在结束时执行abort函数，后者将调用Kemel32.dll中的 UnhandledExceptionFilter函数。在早期版本的C/C-H-运行库中，进程到此就终止了。 _set_abort.behavior函数可以用来配置由abort函数执行的错误报告。如果 _CxxUnhandledExceptionFilter认为当前异常不是一个C++异常，就会返回 EXCEPTION_CONTINUE_SEARCH,来让Windows来处理这个未处理异常。
705*706
所以，如果调用SetUnhandledExceptionFilter来安装我们自己的全局异常过滤程序，其返 回的地址即为函数_CxxUnhandledExceptionFilter的地址。当我们在 Microsoft Visual Studio中调试代码时，可以通过智能感知(IntelliSense)看到这个函数。否则默认过滤程序为 函数 UnhandledExceptionFilter<>
注意 我们可以以NULL作为参数调用SetUnhandledExceptionFilter来将全局未处理异 常过滤程序设回 UnhandledExceptionFilter0
如果过滤程序即将返回EXCEPTION_CONTINUE_SEARCH,读者很可能想在此之前调 用之前的全局异常过滤程序，它的地址可以通过SetUnhandledExceptionFilter的返回值得 到。然而，我并不建议这么做。因为我们根本不知道程序使用的某个第三方组件是否安装 了什么异常过滤程序，甚至如果第三方组件是一个动态装载的模块，此时它可能已经被卸 载了。关于要避免这么做的另一个原因，请参阅后面的“步骤3：通知我们设置的全局异 常过滤函数”小节。
回顾第6章，我们知道每个线程的执行都是从NTDLL.dll中的函数BaseThreadStart开始的: VOID BaseThreadStart(PTHREAD_START_ROUTINE pfnSCartAddrr PVOID pvParam) (
_try (
ExitThread((pfnStartAddr)(pvParam))；
}
_except (UnhandledExcepcionFiIter(GetExceptioninformation())) (
ExitProcess(GetExceptionCode())；
第25章 未处理异常、向量化异常处理与C++异常
}
// NOTE： We never get here
}
这个函数包含一个结构化异常处理框(structured exception handling frame, SHE代码 框)：它首先进入try代码块，然后在try块中调用线程/程序的入口点函数。所以， 如果我们的线程抛出一个异常，并且所有安装的异常过滤程序都返回 EXCEPTION_CONTINUE_SEARCH ,系统提供的一个特殊函数将被自动调用，即 UnhandledExceptionFiltero
LONG UnhandledExceptionFilter(PEXCEPTION_POINTERS pExceptioninfo)
和普通异常过滤程序一样，这个函数返回三个EXCEPTION,*异常标识符中的一个，表25.2 分别描述各个异常标识符返回时所发生的情况。
表25-2 UnhandledExceptionFilter返回值所对应的系统操作
标识符	对应的系统操作
EXCEPTION_EXECUTE_HANDLER	发生一个全局展开，所有挂起的finally块执行。针对未处 理异常，BaseThreadStart的异常处理程序将调用 ExitProcess,于是进程会悄然终止。注意：进程退出时将 返回异常代码
EXCEPTION_CONTINUE_EXECUT1ON	执行从抛出异常的指令继续。25.1节 uUnhandledExceptionFilter函数详解”中描述的步骤1 将执行
EXCEPTION_CONTINUE_SEARCH	要么出错进程已经在调试器的控制之下，要么默认调试器 将被附着到出错进程。系统会将该异常通知调试器，所以 程序会正好停在发生异常的地方。后面的“即时调试”小 节将会详细解释调试器的处理步骤。如果没有调试器可以 附着，Windows就会知道在用户模式发生了未处理异常
说明在发生嵌套异常(即在异常过滤程序里又抛出一个异常)的情况下，UnhandledExceptionFUter 将返回 EXCEPTION_NESTED_CALL ° 但在 Windows Vista 之前的平台， UnhandledExceptionFilter并不返回，进程不加任何提示地结束。
在返回这些异常标识符之前，UnhandledExceptionFilter还会执行大量的代码。现在我们来 分析一下这个函数内部的执行步骤。
25.1	UnhandledExceptionFilter 函数详解
UnhandledExceptionFilter函数在处理异常时会按顺序执行5个步骤。我们将依次讨论每个 步骤。在执行完这些步骤后，UnhandledExceptionFilter将执行控制交给Windows错误报
j^^!dows核心编程（第5版）
告（Windows Error Reporting,后面简称为WER）,详见“未处理异常与WER的交互”小节。
一
1 .步骤1：允许对资源进行写入操作并继续执行
如果因为线程的写操作而引起非法访问异常,UnhandledEXceptionFilter会查看这个线程是 不是正在修改.exe或DLL模块中的资源。这些资源默认（并且应该）为只读的，试图去修改 它们会引发访问违规。然而，16位Windows却允许修改这些资源，出于向后兼容的考虑， 32位和64位Windows也应该这样做。为了保证兼容性，UnhandledExceptionFilter调用 VirtualProtect将资源页的保护属性设为 PAGE_READWRITE ,并返回 EXCEPTION_CONTINUE__EXECUTION,以允许失败的指令再次执行。
2.	步骤2：将未处理异常报告给调试器
UnhandledExceptionFilter首先检查当前应用程序是不是在调试器的控制在之下，如果是, 它将返回EXCEPTION_CONTINUE_SEARCH。此时，因为当前异常未处理，所以Windows 通知附着在当前进程的调试器。调试器将会收到当前异常EXCEPTION_RECORD结构的 Exceptionlnformation成员，它通过这些信息来定位到代码里抛出异常的那条指令，并通 知我们什么样的异常被抛出。请注意，我们可以在代码里调用IsDebuggerPresent来检测 当前进程是不是处于调试器的控制之下。
3.	步骤3：通知我们设置的全局异常过滤函数
如果应用程序已经调用SetUnhandledExceptionFilter来指定全局异常过滤程序， UnhandledExceptionFilter将调用这个异常过滤函数。如果异常过滤函数返回值为 EXCEPTION_EXECUTE_HANDLER 或者 EXCEPTION_CONTINUE_EXECUTION, UnhandledExceptionFilter将直接 返回这 个值给 靠统。如一果 返 回的是 EXCEPTION_CONTINUE_SEARCH,将转到步骤4。但是等一下！我刚才已经解释过 C/C-H-全局未处理过滤程序 _CxxUnhandledExceptionFilter显式地调用 UnhandledExceptionFilter。因此，这里有一个一个无穷递归调用，很快就会导致栈溢出异 常，将真正的异常隐藏起来。这也是我们不要去调用之前安装的全局过滤程序的另一个原 因。为了 防止这种无穷递归，_CxxUnhandledExceptionFilter 在调用 UnhandledExceptionFilter 之前会调用 SetUnhandledExceptionFilter（NULL）o
当程序使用C/C~h■运行库（run time）的时候，运行库会用try/except结构保护线程入口点函 数，对应的异常过滤程序会调用C/C++运行库的_XcpFilter函数。而_XcpFilter函数内部 则调用UnhandledExceptionFilter,后者又会调雨全局异常过滤程序（如果有）。所以，当 _XcpFilter发现一个未处理异常时，我们安装的全局过滤程序就会被调用。而如果我们的 过滤程序返回EXCEPTION_CONTINUE_SEARCH,（真正的）未处理异常就会到达 BaseThreadStart的异常过滤程序，于是UnhandledExceptionFilter又会执行，结果，我们 的全局过滤程序也会再一次执行。
4.	步骤4：将未处理异常报告给调试器（再次）
在步骤3,全局未处理异常过滤函数会调用调试器并让调试器附着到抛出异常的进程。如
第25章 未处理异常、向量化异常处理与C++异常
果这个时候未处理异常过滤程序返回EXCEPTION_CONTINUE_SEARCH,调试器将再 一次被调用（如同步骤2）o
708
5.步骤5：终止进程
如果进程中的某个线程曾调用SetErrorMode设置标志SEM_NOGPFAULTERRORBOX,那么 UnhandledExceptionFilter 会返回 EXCEPTION_EXECUTE_HANDLERo 在未处理异常的情形 下，返回这个值将会引发全局展开，后者在进程悄然终止前让未执行的finally块执行。类似 地，如果进程处于作业里（请参考第5章），并且作业的限制信息（limit information）设置了标志 JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION,那么 UnhandledExceptionFilter 也将返回 EXCEPTION_EXECUTE_HANDLERo
在这些步骤里，UnhandledExceptionFilter 1作于后台，试图解决引发异常的问题，通知调 试器（如果有），或者在必要情况下简单地终止程序运行。如果不能处理异常，就会返回 EXCEPTION_CONTINUE_SEARCH,于是系统内核得到程序控制，将程序运行错误通知 用户。在讨论当UnhandledExceptionFilter返回时Windows内核所做的工作之前，我将先 详细演示对应的用户界面，并阐述异常将在系统中所经过的路径。（详见后面的“未处理异 常与WER的交互”小节。）
图25-1演示了在Windows XP上，在异常到达UnhandledExceptionFilter之前所发生的 动作。
图25-1当未处理异常发生时，Windows XP弹出的消息框
在Windows Vista系统上，两个对话框（如图25-2和图25-3所示）依次弹出。
' Windows is checking for a solution to the problem...
图25-2当未处理异常发生时，Windows Vista弹出的第一个消息框
709
ndows核心编程(第5版)
A problem caused the program to stop working conectiy. Wmdow$ wil close the pcognm .nd notify you if a solubon t$ tvaiUble
图25・3当未处理异常发生时，Windows Vista弹出的第二个消息框
读者现在应该对异常到达UnhandledExceptionFilter的工作流和它们在界面上的具体呈现 有了一个大概的了解吧。
6. UnhandledExceptionFilter 与 WER 的交互
图 25-4 演示了 Windows 如何使用 Windows 错误报告机制(Windows Error Reporting in&astructure)来处理未处理异常。我们己经在之前的小节中讨论了步骤1和步骤2。
出错进程
VOID BaseThreadSurt(..{ —try {
// An exception 1s unhandled // by your code _
_except(UnhandledExcept^onFllrer(...)) ( Ex1tProcess(..
LONG UnhandledExcept1onF1lter(...) (
// Try to fix when possible
②仃(...)(
r«turn(EXCEPTION_CONnNUE_EXEaJTION);
}
// Other steps
// nothing else can be done return(Da：EEDN_CONTIMJE_SEARCH);。
kernel detects。 unhandled exception
blocking ALPC call
9 to Wer Service
z
r Wer Service (WerSvc) -i *	4
TermlnateProcess(...)
(§)CreareProcess(...);、 ./
Wa1t*(hProcess..J
WerFaultexe
正常退出・
^Reporting ♦
25 -HandleUnhandled^xe has stopped working
Wait^ChSynchEvent...);
J
—JfT-Debugger
Ser Evenr(hSynchEvenr);

A pcoblem caused the program to stop wcxbng correctly Wcdowj cloie the program and notify you d , soSoo ■
图25-4 Winodws如何使用错误报告机制来处理未处理异常
第25章 未处理异常、向量化异常处理与C++异常
从Windows Vista开始，UnhandledExceptionFilter函数不再发送错误报告到Microsoft的 服务器。作为替代，完成25.1节"UnhandledExceptionFilter函数详解”所描述的步骤后， 返回EXCEPTION_CONTINUE_SEARCH（图25-4中的第3步）。于是，系统内核知道一 个异常在用户态线程没有得到处理（第4步）。然后，关于异常的通知被发送给WerSvc专用 服务。
这个通知是由一个叫做"高级本地过程调用（Advanced Local Procedure Call,后面简称为 ALPC）的机制发出的，ALPC机制并没有对外公开。ALPC会先阻塞线程，直到WerSvc完 成它的处理（第5步）。后者通过调用CreateProcess来启动WerFault.exe（第6步），并等待 新进程的结束。报告的创建和发送（第7步）由WerFault.exe完成。在WerFault程序中，会 弹出一个对话框来允许用户选择关闭应用程序或者附着一个调试器（第8步）。如果用户选 择关闭程序，WerFault.exe会调用TerminateProcess来不加提示地完全结束应用程序（第9 步）。由此可见，大量处理会在发生错误的进程之外执行来保证错误报告行为的稳定。
我们可以通过注册表配置在这个过程中呈现给用户的界面，相关信息可以参考 http://msdn2.microsoft.com/en-us/library/bb513638.aspx。当 HKEY_CURRENT_USER\Software\ Microsoft\Windows\Windows Error Reporting 子项之下的 DontShowUI 值设置为 1 时，就不 会有任何对话框弹出，报告会在后台生成并发送给Microsoft的服务器。如果想在问题发生 时让用户选择发送或者不发送错误报告给Microsoft,我们可以改变DefaultConsent的值， 值类型为DWORD,位于Consent子项下。但是，更值得推荐的做法是在Control Panel（控 制面板）中的Problem Reports And Solutions（问题报告与解决方案）来打开WER控制台，并 单击设置来访问这些选项，如图25.5所示。
710
图25-5允许用户选择是否发送错误报告给Microsoft
切
如果选择Ask Me To Check If A Problem Occurs选项，WER将弹出一个新对话框，如 图25-6（而不是图25-2和图25-3所示的那两个通常的对话框），这个对话框提供了三种选择。
■f膏版）

23-SEHTerm.exe has stopped working
Windows can check online for a solution to th« problem the next time you go online.
» Check online for a solution later and close the program
今 Close the program
今 Debug the program	.
(j?) View problem details
图25・6用户可以选择不要自动发送错误报告给Microsoft
虽然不推荐在最终使用产品的计算机上选择这个选项，因为我们不想因此错过任何问题， 但是当调试程序时，它可以节省很多时间，因为不需要等待报告生成和发送。当计算机没 有联网时，节省这些时间就更加重要了，因为在WerSvc弹出选择对话框之前的发送超时 这段时间是没有必要花费的。
如果正在运行自动测试案例，我们肯定不想让WER对话框来破坏或终止自动测试。如果 将Reporting注册表子项的ForceQueue设置为1, WER将在后台生成错误报告。一旦自动 测试运行完毕，可以使用WER控制台来列出发生过的问题并得到它们的详细信息，请参 考第26章的图26-2与图26-3o
现在我们来讨论一下当未处理异常发生时，WER提供的最后一个功能：即时调试，它让程 序员的梦想成为现实。如果用户选择调试出错的进程（第10步），WerFault.exe程序就会创 建一个事件，将手动重置设置为True,同时置为未触发状态，并且设置blnheritHandles 参数为Trueo从而允许WerFault.exe的子进程（比如调试器），可以继承这个事件句柄。然 后WER找到并启动默认调试器，让它附着到出错的进程上（详见25.2节“即时调试”）。通 过将调试器附着到进程，我们得以查看全局、局部和静态变量的值；设置断点；检查函数 调用树；重启进程以及做其他任何我们在调试一个进程时可以做的事情。
说明 本书只讨论用户态程序开发。读者可能会好奇运行在内核态的线程抛出未处理异常 会发生什么事情。从内核抛出的未处理异常往往意味着操作系统或者设备驱动（大部 分情况）存在严重的缺陷，并不是应用程序的问题。
在这种情况下，内核内存空间很可能已经被破坏，再让系统继续运行是不安全的。 在出现所谓的“蓝屏死机”前，系统让相关设备驱动调用CrashDmp.sys来在页文件 中建立Crash Dump,然后停止计算机的所有操作。因此，我们不得不重启计算机， 任何没有保存的工作也会丢失。如果系统是在崩溃或者挂起之后重启，它在启动时 会检查页文件是不是包含一个Crash Dumpo如果有，则表示相关内容得到了保存， 系统会让WerFault.exe运行来产生错误报告并发送给Microsoft的服务器（如果允许）。 这让我们可以在WER控制台得到Windows错误列表。
第25章 未处理异常、向量化异常处理与C++异常
25.2即时调试
即时调试的真正好处是可以在程界发生问题时马上处理它。在很多其他操作系统平台，我 们必须通过调试器来重启程序并调试。如果异常发生在其他操作系统平台的进程里，必须 先结束进程，接着启动调试器，然后再通过调试器启动程序。问题是在解决问题之前，我 们还得先重现这个问题。可是谁又能还原各个变量在发生这个问题的时间点上的值呢？这 使得解决一个缺陷变得更加困难。「U以动态附着调试器到进程是Windows最好的功能之一。
我们来看一下它是怎么工作的。首先注册表包含下面这个相关子项：
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AeDebug
在这个子项之下，有一个名为Debugger的值，在Visual Studio安装过程中被设置如下： "C:\Windows\system32\vsjitdebugger.exe" -p %ld -e %ld
O
系统可以通过这个值找到调试器。但vsjitdebugger.exe本身并不是调试器，它实际上是一个 允许我们通过下图所示的对话框来选择调试器的应用程序。
当然，我们也可以改变这个注册表项的值，让它直接指向一个调试器。WerFault.exe会给 调试器传入两个参数。第一个参数是要调试的进程的ID。第二个参数是继承过来的事件句 柄，它指向由WerSvc服务创建的处于未触发状态的手动重置事件（第6步）。注意，问题进 程也在等待WerSvc返回的ALPC通知。第三方厂商实现的调试器也必须能够识别.p和y 这两个开关，它们分别代表进程ID和事件句柄。
WerFault.exe先将进程ID和步件句柄合并到-•个字符串里，然后通过CreateProcess启动
Endows核心编程（第5版）
调试器，并将blnhentHandles参数设成TRUE,允许调试器进程可以继承事件对象的句柄。 此时，调试器进程启动并查看命令行参数，如果・p开关存在，调试器拿到进程ID并通过 DebugActiveProcess将自己附着到对应进程上：
BOOL DebugActiveProcess（DWORD dwProcessID）;
操作系统对调试器完成附着操作以后，会将被调试程序的状态报告给调试器。比如，系统 会告诉调试器被调试程序有多少个线程以及被调试程序载入了多少个DLLo调试器需要花 一些时间处理这些数据来准备调试进程。在这些准备工作进行时，发生问题的进程只能等 待。检测到未处理异常的那段代码（第4步）也在等待从WerSvc返回的ALPC通知（第5步）。 而ALPC本身因为以WerFault.exe进程句柄为参数调用WaitForSingleObjectEx被阻塞， 直到 WER完成它的工作。注意，在这里使用的是 WaitForSingleObjectEx,而非 WaitForSingleObject,因此线程可以在可通知状态下等待。这意味着在队列里的异步过程 调用（asynchronous procedure call,简称 APC）都能得到处理。
请注意，在Windows Vista之前的操作系统上，问题进程里的其他线程并不会暂停，所以 它们会在已经损坏的上下文中运行并有可能抛出更多的未处理异常，因此系统很可能会突 然终止进程，这将使问题更加复杂。就算没有其他线程崩溃，在产生dump文件时，程序 运行状态可能已经改变。这将使得查找导致异常的根本原因变得更加困难。而在Windows Vista上，如果该应用程序不是一个服务，问题进程的所有线程都会被挂起，不会再占用 CPU,直到WER让它们继续执行，以便将未处理异常通知调试器。
调试器完成初始化工作后，开始检查・e开关。如果这个开关存在，调试器得到事件句柄并 调用SetEvento因为由WerFault创建并传递给调试器（作为子进程的调试器进程可以继承 句柄，包括同步事件句柄）的事件是一个可继承事件，所以调试器可以直接使用这个事件的 句柄。
设置事件（第11步）是为了通知WerFault.exe调试器已经附着到了问题进程，可以接收并处 理异常了。于是，WerFault.exe进程将正常退出，而WerSvc服务也将发现其子进程己经退 出，于是让ALPC返回（第12步）。这将导致被调试程序的线程被唤醒，它会通知内核一个 调试器已经附着到当前线程，并准备好接收未处理异常的通知（第13步）。这和25.1节
UnhandledExceptionFilter函数详解”中的步骤3效果相同。紧接着，调试器将收到关于 未处理异常的通知，它将载入正确的源代码文件，并定位到抛出异常的那条指令（第14步）。 这很酷，不是吗！
顺便提一下，我们不需要等到发生异常才能去调试一个进程。任何时候都可以通过运行 vsjitdebugger.exe -p PID来让调试器附着到任意进程，PID表示要调试的进程的ID。事 实上，Windows任务管理器使得调试进程更加容易，我们可以打开“进程”属性页,选择 一个进程，并单击鼠标右键，然后选择“Debug” o这会让任务管理器查询我们之前提到 的注册表子项，调用CreateProcess来启动调试器，传入我们选择的进程ID。在这里，Task Managed任务管理器）给事件句柄参数传入的值为0。
第25章 未处理异常、向量化异常处理与C++异常
技巧提示 HKEY_LOCAL_MACHINE\SOFrWARE\Microsoft\Windows NT\CumentVmion\AeDebug 注册表子项还包含一个名为Auto的数值，类型为REG_SZ。这个值表示是否 让WER询问用户调试还是关闭问题进程。如果Auto值为1, WER不询问用 户，直接启动调试器。这应该是我们想要的默认行为，而不是让WER弹出两 个消息框一一因为当未处理异常发生时，我们总是迫切希望调试问题进程。 有时，我们并不希望调试一些容器进程，比如svchost.exe的某个服务崩溃。在 这种情况下，可以在AeDebug子项下再添加一个子项AutoExclusionList＞并在 它下面创建一个DWORD数值，将其名字设为我们不想调试的程序，值设为L 如果需要进一步细分哪个程序需要自动即时调试，我们可以设置Auto为1,但 是在 HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\Windows Error Reporting之下添加一个子项DebugApplications.在这个子项下，创建一个 DWORD数值，将其名称设为我们想要在未处理异常发生时自动调试的程序， 值设为L
25.3电子表格示例程序
现在让我们通过一个实例来看一看怎样用SEH来处理预料中的异常，从而避免未处理异常 所造成的惨痛后果。电子表格示例程序(25-Spreadsheet.exe)演示如何利用结构化异常处理机 制向己预订的地址空间区域稀疏地调拨存储器。这个应用程序的源代码和资源文件可以在 与本书配套网页下载，它在25-Spreadsheet目录中。当我们执行示例程序时，会弹出下图 所示的对话框。
程序内部为二维表格预订了一块区域。表格的大小为256行*1024列，每个单元格占用1024 个字节。如果想要给进程调拨整个表格的物理内存，需要268 435 456字节(即256 MB)大 小的存储空间。为了节省宝贵的物理存储空间，程序只预订了 256 MB大小的地址空间， 并没有真正地调拨存储空间。
WS核心编程（第5版）
假设用户想要向第100行第100列的单元格写入数值12345（如同上面这个对话框所演示的 那样）。当用户单击Write Cell按钮，程序试图去写表格中的这个位置。显然，这个写操作 会导致访问违规。好在我们的程序中使用了 SEH,异常过滤程序将侦测到这个写操作，于 是在对话框底部显示一个消息：“Violation: Attempting to Write”，同时为这个单元格调拨 物理存储器，并让抛出异常的指令重新执行。如下图所示。这一次，因为存储器己调拨， 值12345将被成功写入单元格。
Cell size: 1024 bytes Rows:	256
Cdumm: 1024
Total »ze: 256 MB (268.435,456 bytes)
Rflw(0-255^ I®
Column (0-1023):谕
12345


Value:
Execution E：
Violation: Attempting to Write
我们再做一个试验，即从第5行第20列读取单元格的值。当我们试图读这个单元格时，程 序再次抛出访问违规异常。对读操作，异常过滤程序不会去申请存储空间，但是还是会在 对话框里显示一个消息：“Violation: Attempting to Read”。程序从失败的读操作恢复过来 的表现是将对话框Value字段的数字擦掉，如下图所示。
第三个实验试图去读取第100行第100列的单元格的数值。因为这个单元格的存储器已经 得到调拨，因此不会再发生访问违规，而异常过滤程序也不会执行（性能会更好）。对应的 对话框如下图所示。
第25章 未处理异常、向量化异常处理与C++异常
Cell size: 1024 bjrtes
Rows:	256
Columns: 1024
Total size: 256 MB (268,435,456 bytes)
Rfiw (0-255):	m
Column (0-1023): 100	眦W]
Value:	[云 45	顷 le^eT]
Execution log
No violation raised
第四个也是最后一个试验，试图将值54321写入第100行第101列的单元格。因为这个单 元格和(100, 100)在同一个存储页上，这个操作不会引起任何访问违规。我们可以看到对 话框底部显示的消息为：“No violation raised” ,如下图所示。
7”
我个人经常在项目里使用虚拟内存和SEH技术。于是，我创建了一个C++模板类 CVMArray来封装所有复杂的工作。这个C++类的源代码可以在VMArray.h里找到(它也 是电子表格示例程序的一部分)。有两种方式来使用CVMArray类。第一种是我们可以创 建这个类的实例，并传递数组元素的上限给构造函数。这个类会自动为整个进程建立一个 未处理异常过滤程序，因此，一旦任意线程里的任意代码访问虚拟内存数组中的内存地址, 未处理异常过滤程序就会调用VirtualAlloc来为新的元素调拨物理存储器，然后返回 EXCEPTION_CONTINUE_EXECUTION。以这种方式使用CVMArray类让我们可以只 用很少的代码就能实现稀疏内存管理，并且不需要在源代码里到处使用SHE代码框。这 种方式的唯一坏处是，一旦需要的内存因为某种原因不能成功调拨，进程便不能很好地恢 复过来。
"dows核心编程（第5版） 
第二种方式是让我们的类继承自CVMArrayo使用继承类，我们可以得到基类带来的好处, 同时还可以添加自定义的功能。比如，现在我们可以通过重载虚拟函数OnAccessViolation
将内存不够的问题处理得更合理。电子表格示例程序演示了如何在CVMArray的子类中加
入这些功能。

Spreadsheet•cpp
Module: Spreadsheet.cpp
Notices: Copyright (c) 2008 Jeffrey Richter & Christophe Nasarre ***************************************★**•******★***************/
#include #include #include #include #include #include
■..\CommonFiles\CmnHdr.h" /* See Appendix A. */ <windowsx.h>
<tchar.h>
■Resource.h"
■VMArray.h"
<StrSafe.h>
//////////////////////////////////////////////////////////////////
HWND g_hWnd； // Global window handle used for SEH reporting
const int g_nNumRows = 256;
const int g_nNumCols = 1024；
// Declare the contents of a single cell in the spreadsheet typedef struct (
DWORD dwValue;
BYTE bDummy(1020];
) CELL, *PCELL;
// Declare the data type for an entire spreadsheet typedef CELL SPREADSHEET[g_nNumRows][g_nNumCols]; typedef SPREADSHEET *PSPREADSHEET;
//////////////////////////////////////////////////////////////////
//A spreadsheet is a 2-dimensional array of CELLS class CVMSpreadsheet : public CVMArray<CELL> ( public:
CVMSpreadsheet() : CVMArray<CELL>(g_nNumRows * g_nNumCols) {}
private：
LONG OnAccessViolation(PVOID pvAddrTouched, BOOL bA11emptedRead, PEXCEPTION_POINTERS pep, BOOL bRetryUntilSuccessful);
}；
long CVMSpreadsheet:：OnAccessViolation(PVOID pvAddrTouched, BOOL bAttemptedRead, PEXCEPTION^POINTERS pep, BOOL bRetryUntilSixCCessful) {
TCHAR sz[200];
StringCchPrintf(sz# _countof(sz), TEXT("Violation: Attempting to %s"), bAttemptedRead ? TEXT("Read") : TEXT("Write*))f
SetDlgltemText(g_hWnd, IDC_LQG, 〈
LONG iDisposition = EXCEPTION_EXECUTE_HAND^ER; Ji 上
if (!bAttemptedRead) {
// Return whatever the base class says to do
IDisposition = CVMArray<CELL>:：OnAccessViolation(pvAddrTouched,
第25章 未处理异常、向量化异常处理与C++异常
bAtt^mptedRead, pep, bRetryUntilSuccessful);
}
return(iDisposition);
//////////////////////////////////////////////////////////////////
// This is the global CVMSpreadsheet object static CVMSpreadsheet g_ssObject；
// Create a global pointer that points to the entire spreadsheet region SPREADSHEETS g_ss = * (PSPREADSHEET) (PCELL) g_ssObject;
//////////////////////////////////////////////////////////////////
BOOL Dlg_OnInitDialog(HWND hWnd, HWND hWndFocus, LPARAM 1Param) (
chSETDLGICONS(hWnd, IDI_SPREADSHEET);
g_hWnd = hWnd; // Save for SEH reporting
// Put default values in the dialog box controls Edit^LimitText(GetDlgItem(hWndf IDC^ROW), 3)； Edit_LimitText(GetDlgItem(hWnd/ IDC_COLUMN), 4); Edit_LimitText(GetDlgItem(hWnd, IDC_VALUE), 7); SetDlgltemlnt (hWnd# IDC__ROW, 100, FALSE); SetDlgltemlnt (hWnd, IDC^COLUMN, 100, FALSE); SetDlgltemlnt(hWnd, IDC.VALUE, 12345, FALSE); return(TRUE)；
}
//////////////////////////////////////////////////////////////////
void DIg_OnCommand(HWND hWnd/ int id, HWND hWndCtl, UINT codeNotify) (
int nRow, nCol;
switch (id) {
case IDCANCEL:
EndDialog(hWnd# id)；
break；
case IDC_ROW:
// User modified the row, update the UI nRow = GetDlgltemlnt(hWnd, IDC_ROW, NULL, FALSE)； EnableWindow(GetDlgItem(hWndr IDC..READCELL), chINRANGE (0, nRow, g_pNuinRow8 - 1))； EnableWindow(GetDlgItem(hWnd, IDC_WRITECELL)z chINRANGE(0, nRow, g_nNumRows - 1))； break；
case IDC_COLUMN： ；
// User	column, update the UI
nCol = GetDlgltemlnt(hWnd, IDC_COLUMN, NULL, FALSE); EnableWindow	(hWnd, IDC顼瞬«
chINRANGE(0/ iCol, gJtt^Cols -1));
EnableWindowIDC^WRITECELL), ChINRANGE(0, nfepi, gjnHumCols	?
break;	轩•淳就	.顼、#	•化,、？； ,r.	
			
case IDC_READCELL:
// Try to read a value from the us1 ected cell SetDlgltemText(g.hWnd, IDC_LOGr TEXT("No violation raised-))； nRow = GetDlgltemlnt(hWnd, IDC^ROW, NULL, FALSE)； nCol = GetDlgltemlnt (hWnd, TDC^COLUMN陷阖扯 FALSE);
—try {
WS核心编程（第5版）
SetDlgltemlnt(hWnd, IDC_VALUE, g_ss[nRow][nCol].dwValue, FALSE)； ,}
_except ( g_ssObject.ExceptionFiIter(GetExceptionlnformation(), FALSE)) (
// The cell is not backed by storage, the cell contains nothing. SetDlgltemText(hWnd,工DC_VALUE, TEXT("■));
}
break；
case IDC_WRITECELL:
// Try to write a value to the user's selected cell SetDlgltemText(g__hWnd, IDC_LOG, TEXT("No violation raised")); nRow = GetDlgltemlnt(hWnd, IDC_ROW, NULL, FALSE);
nCol = GetDlgltemlnt(hWnd, IDC_COLUMN, NULL, FALSE);
// If the cell is not backed by storage, an access violation is
// raised causing storage to automatically be committed. g_ss[nRow][nCol].dwValue =
GetDlgltemlnt(hWnd, IDC_VALUE, NULL, FALSE); break；
}
}
//////////////////////////////////////////////////////////////////////////////
INT_PTR WINAPI Dlg_Proc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM iParam) (
switch (uMsg) ( chHANDLE_DLGMSG(hWnd, WM^INITDIALOG, Dlg_OnInitDialog); chHANDLE.DLGMSG(hWnd, WM_COMMAND, Dlg_OnCommand);
} return(FALSE);
}
//////////////////////////////////////////////////////////////////
int WINAPI _tWinMain(HINSTANCE hlnstExe, HINSTANCE, PTSTR, int) {
DialogBox(hlnstExe, MAKEINTRESOURCE(IDD..SPREADSHEET), NULL, Dlg_Proc); return(0)；
}
//////////////////////////////// End of File /////////////////////
VMUrray.h
/**********************************************************★******
Module: VMArray.h Notices： Copyright (c) 2008 Jeffrey Richter & Christophe Nasarre *********?**************★*****★★******************★**************/
#pragma once
//////////////////////////////////////////////////////////////////
// NOTE： This C++ class is not thread safe. You cannot have multiple threads // creating and destroying objects of this class at the same time.
// However, once created, multiple threads can access different CVMArray
// objects simultaneously and you can have multiple threads accessing a single // CVMArray object if you manually synchronize access to the object yourself.
//////////////////////////////////////////////////////////////////
template <class TYPE>
class CVMArrdy (
第25章 未处理异常、向量化异常处理与C++异常
public：
// Reserves sparse array of elements CVMArray(DWORD dwReserveElements);
// Frees sparse array of elements virtual -CVMArray();
// Allows accessing an element in the array operator TYPE*() { return(m_pArray); } operator const TYPE* () const ( return (m__pArray) ； }
// Can be called for fine-tuned handling if commit fails LONG ExceptionFilter(PEXCEPTION^POINTERS pep,
BOOL bRetryUntilSuccessful = FALSE)；
protected:
// Override this to fine-tune handling of access violation virtual LONG OnAccessViolation(PVOID pvAddrTouched, BOOL bAttemptedRead, PEXCEPTION_POINTERS pep, BOOL bRetryUntilSuccessful);
Address of first object of next object
TYPE* m_pArray; // Pointer to DWORD nt_cbReserve; // Size of
reserved region array
reserved region array (in bytes)
private:
// Address of previous unhandled exception filter static
PTOP_LEVEL_EXCEPTION_FILTER sm_pfnUnhandledExceptionFi11erPrev;
// Our static )；
global unhandled except ion filter for instances of this class LONG WINAPI UnhandledExceptionFilter(PEXCEPTION_POINTERS pep);
//////////////////////////////////////////////////////////////////
// The head of the linked-list o£ objects template <class TYPE>
CVMArray<TYPE>* CVMArray<TYPE>: : sm__pHead = NULL;
// Address of previous unhandled exception filter template <class TYPE>
PTOP_LEVEL_EXCEPTION_FILTER CVMArray<TYPE>：:sn\_pfnUnhand1edExcept ionFi11erPrev；
//////////////////////////////////////////////////////////////////
template <class TYPE> CVMArray<TYPE>::CVMArray(DWORD
dwReserveElements) (
if (sncpHead == NULL) (
// Install our global
// creating the first
sm__pfnUnhandledExcept ionFi 1 terPrev .=
SetUnhandledExceptionFilter(UnhandledExceptionFilter)；
unhandled exception filter when instance of the class. '
nupNext = sm__pHead; // The next node was at the head sn\_pHead = this; // This node is now at the head
m_cbReserve = sizeof(TYPE) * dwReserveElements；
// Reserve a region for the entire array :
nt_pArray = (TYPE*) VirtualAlloc(NULL, ni_CbReserve, MEM_RESERVE I MEH_TOP_DOWN, PAGE_READWRITE)； chASSERT (n\_pArray != NULL);
}
indows核心编程（第5版）
}
//////////////////////////////////////////////////////////////////
template <class TYPE>
CVMArray<TYPE>::-CVMArray() (
// Free the array's region (decommitting all storage within it) VirtualFree(in__pArray, 0, MEM__RELEASE);
// Remove this object from the linked list CVMArray* p = sm__pHead;
if (p == this) ( // Removing the head node
sm_pHead = p->nL_pNext ；
} else (
BOOL bFound = FALSE；
// Walk list from head and fix pointers
for (; !bFound && (p->nupNext != NULL) ; p = p->m__pNext) ( if (p~>m_pNext == this) {
// Make the node that points to us point to the next node p->nt_pNext = p->m_pNext->rn_pNext;
break；
}
}
chASSERT(bFound);
}
}
//////////////////////////////////////////////////////////////////
// Default handling of access violations attempts to commit storage template <class TYPE>
LONG CVMArray<TYPE>::OnAccessViolation(PVOID pvAddrTouched,
BOOL bAttemptedRead, PEXCEPTION^POINTERS pep, BOOL bRetryUntilSuccessful) (
BOOL bCommittedStorage = FALSE； // Assume committing storage fails
do (
// Attempt to commit storage bCommittedStorage = (NULL != VirtualAlloc(pvAddrTouched, sizeof(TYPE), MEM_COMMIT, PAGE.READWRITE));
// If storage could not be committed and we're supposed to keep trying // until we succeed, prompt user to free storage if (!bCommittedStorage && bRetryUntilSuccessful) (
MessageBox(NULL,
TEXT("Please close some other applications and Press OK."), TEXT("Insufficient Memory Available*), MB_ICONWARNING I MB_OK)； }
} while (IbCornmittedStorage && bRetxyUntilSucceasful);
// If storage committed, try again. If not； execute the handler return(bCommittedStorage	、壬，	二.：
? EXCEPTION_CONTINUE_EXECUTIONt : EXCEPTION_EXECUTE_HANDLER);
}
//////////////////////〃////////////〃〃〃//〃/〃/〃/〃〃/〃〃////
// The filter associated with a single CVMArray object template <class TYPE>
LONG CVMArray<TYPE>::ExceptionFilter(PEXCE^PION_PdlNTBRS pep, BOOL bRetryUntilSuccessful) (	s
// Default to trying another filter (safe临却ing 比 do) LONG iDisposition = EXCEPTION_CONTINUE_SEARCH;
第25章 未处理异常、向量化异常处理与C++异常
// We only fix access violations
if (pep->ExceptionRecord->ExceptionCode !=
EXCEPTION__ACCESS_VIOLATION)
return(iDi spos i t ion);
// Get address of attempted access and get attempted read or write PVOID pvAddrTouched = (PVOID) pep->Except ionRecord->Exceptionlnformation[1]； BOOL bAttemptedRead = (pep->ExceptionRecord->ExceptionInformation[0] == 0)；
// Is attested access within this VMArray's reserved region? if ( (m__pArray <= pvAddrTouched) &&
(pvAddrTouched < ((PBYTE) m_pArray + cbReserve))) (
// Access is in this array； try to fix the problem iDisposition = OnAccessViolation(pvAddrTouched, bAttemptedRead,pep, bRetryUntilSuccessful)；
}
return(IDisposition)；
}
//////////////////////////////////////////////////////////////////
// The filter associated with all CVMArray objects template <class TYPE>
LONG WINAPI CVMArray<TYPE>::UnhandledExceptionFilter(PEXCEPTION_POINTERS pep) {
// Default to trying another filter (safest thing to do)
LONG IDisposition = EXCEPTION_CONTINUE_SEARCH;
// We only fix access violations
if (pep->ExceptionRecord->ExceptionCode == EXCEPTION_ACCESS_VIOLATION) (
// Walk all the nodes in the linked-list
for (CVMArray* p = sm_pHead; p != NULL; p = p->m__pNext) (
*	// Ask this node if it can fix the problem.
// NOTE： The problem MUST be fixed or the process will be terminated! IDisposition = p->ExceptionFilter(pep, TRUE)；
// If we found the node and it fixed the problem, stop the loop if (IDisposition != EXCEPTION_CONTINUE_SEARCH) break；
}
}
// If no node fixed the problem, try the previous exception filter if (IDisposition == EXCEPTION_CONTINUE_SEARCH)
IDisposition = sm__pfnUnhandledExceptionFiIterPrev(pep);
return(IDisposition)；
}
//////////////////////////////// End of File /////////////////////
25.4向量化异常和继续处理程序
第23章和第24章所介绍的SEH机制是一种基于代码框的(Bame.based)机制，即每次当线 程进入一个try块(或代码框)时，系统会在链表里加入一个节点。如果发生异常，系统依次
indows核心编程(第5版)
访问链表中的每个代码框——从最晚进入的try块一直到最早进入的try块——并寻找每个 try块的catch处理程序。一旦找到一个catch处理程序，系统再次访问链表，执行finally 块。当展开结束后(或者try块由于没有发生异常而正常退出)，系统从链表中移除所有的代 码框。
Windows也提供了向最化异常处理(vectored exception handing,后面简称为VEH)机制，它 与SEH协同工作。程序可以注册一个函数，而不需要依赖与语言有关的关键字。每当异常 发生或者一个未处理异常脱离标准SEH的控制时，这个函数就会被调用。
AddVectoredExceptionHandler函数负责异常处理程序的注册，注册的异常处理程序会被 添加到函数列表里，当进程中任意线程发生异常时，这些函数都会被调用。
PVOID AddVectoredExceptionHandler (
ULONG bFirstlnTheList, PVECTORED_EXCEPTION_HANDLER pfnHandler);
pfnHandler是指向向量化异常处理程序的指针。这些函数必须具有以下签名：
LONG WINAPI ExceptionHandler(struct _EXCEPTION_POINTERS* pExceptionlnfo)；
如果给bFirstlnTheList参数传递的值为0,那么通过pfnHandler传递的异常处理 函数就会添加到列表的尾端。如果传递给bFisrtlnTheList的值非0,函数就会被置 于内部列表的头部。当异常发生时，系统在执行SEH过滤程序之前，将按列表顺序 逐个调用这些函数。一旦某个函数能够纠正发生的问题，应该马上返回 EXCEPTION_CONTINUE_EXECUTION,以让抛出异常的指令再次执行。只要某个向量 化处理程序返回EXCEPTION_CONTINUE_EXECUTION, SEH过滤程序便不会有处理 异常的机会。如果异常处理函数不能纠正问题，应该返回 EXCEPTION_CONTINUE_SEARCH,让列表中的其他处理函数有机会去处理异常。如果 所有的处理函数都返回EXCEPTION_CONTINUE_SEARCH, SEH过滤程序就会执行。 需要注意的是，VEH过滤函数不能返回EXCEPTION__EXECUTE_HANDLERo
我们可以通过下面这个函数来删除之前安装的VEH异常处理函数：
ULONG RemoveVectoredExceptionHandler (PVOID pHandler);
pHandler参数即之前安装的函数句柄。这个句柄从AddVectoredExceptionHandler的返回值 得到。
Matt Pietrek 在他的 MSDN 文章 “Under the Hood: New Vectored Exception Handling in Windows XP” ( http://msdn.microsoft.eom/msdnmag/issues/01 /09/hood/)描述了如何使用向量 化异常处理函数来实现基于断点的进程内API hooking,提供了另一种技巧(有别于第22章 所介绍的技巧)。
除了能在SEH之前处理异常，VEH还让我们能在未处理异常发生时得到通知。要得到这 个通知的详细信息，我们需要通过调用下面这个函数注册一个继续处理程序(continue handler)：
第25章 未处理异常、向量化异常处理与C++异常
PVOID AddVectoredContinueHandler (
ULONG bFirstlnTheList,
PVECTORED_EXCEPTION_HANDLER pfnHandler);
同样，如果给bFirstlnTheList参数传递0,那么通过pfnHandler传入的函数会添加到继续 处理程序列表的尾部。如果bFisrtlnTheList是一个非0值，函数会被置于继续处理程序列 表的头部。当未处理异常发生时，系统会按照列表次序逐个执行继续处理程序函数。需要 特别说明的是，这些处理程序的执行是在SetUnhandledExceptionFilter所安装的全局异常 处理程序返回EXCEPTION_CONTINUE_SEARCH之后才开始的。一个继续处理程序可 以返回EXCEPTION_CONTINUE_EXECUTION来停止在它后面的继续处理程序的执行, 并让系统再次执行失败指令。或者返回EXCEPTION_CONTINUE_SEARCH让系统执行 在它后面的处理程序。
我们可以通过下面这个函数来从列表里删除之前安装的继续处理程序：
ULONG RemoveVectoredContinueHandler (PVOID pHandler)；
pHandler参数表示之前安装的处理程序函数的句柄。这个句柄可以从 AddVectoredContinueHandler 的返回值得到。
由此可以想象，继续处理程序一般用来实现诊断与跟踪。
25.5	C++异常与结构化异常的比较
很多开发者经常问我在开发应用程序时应该使用结构化异常还是C++异常。我将在这里解 答这个问题。
首先，我想说的是SEH是操作系统所提供的便利，它在任何语言中都可以使用。而CI•异 常处理只有在编写C++代码时才可以使用。如果读者在开发C++应用程序，那就应该使用 C++异常，而不是结构化异常。理由是C++异常是语言的一部分，编译器知道什么是一个 C++对象。这也就意味着编译器会自动生成代码来调用C++对象的析构函数，保证对象的 释放。
我们应该了解Microsoft的Visual C++编译器使用操作系统的结构化异常机制来实现C++ 异常处理机制。所以，在创建一个C++ try块时，编译器会为我们生成一个SEH _try 块。C++的catch语句对应SEH异常过滤程序，catch块中的代码则对应SEH _except块 中的代码。而编译器也会为C++ throw语句生成对Windows RaiseException函数的调用。 throw语句所使用的变量则成为RaiseException的附加参数。
下面这段代码有助于更清楚地了解整个过程。左边的函数使用Ci•异常处理，而右边的函 数则演示了 C++编译器生成的对应的结构化异常处理代码。
void ChunkyFunky() (	void ChunkyFunky() (
try {	_try (
// Try body	// Try body
Windows核心编程莒史圈
throw 5;
)
catch (int x) {
// Catch body
RaiseException(Code=0xE06D7363,
F1ag=EXCEPTION_NONCONTINUABLE, Args=5);
}
_except ((ArgType == Integer) ?
EXCEPTION_EXECUTE_HANDLER :
EXCEPTION_CONTINUE_SEARCH) (
// Catchbody
} }
读者可能注意到前面这段代码中一些有趣的细节。首先，传给RaiseException的异常代码 为0xE06D7363。这是Visual C++开发组选择用来抛出一个C++异常的软件异常代码。如果 读者查看ASCII码，可以看到6D 73 63代表“msc”。
读者可能还注意到每次抛出一个C++异常都会使用EXCEPTION_NONCONTINUABLE 标记。C++异常意味着不能再次执行错误代码，异常过滤程序处理C++异常时返回 EXCEPTION_CONTINUE_EXECUTION是错误的。事实上，如果我们查看右边函数里的 _except中的过滤程序，可以看到它只会返回EXCEPTION_EXECUTE_HANDLER或者 EXCEPTION_CONTINUE_SEARCHo
RaiseException余卜的参数被用作把指定变量抛出的机制。被抛出变量的信息到底是怎么 传递给RaiseException的？虽然这一点并没有文档讪载，但是我们也不难想象编译器开发 组可能会采用哪些方式来实现它。
最后所提的与_except过滤程序有关。这个过滤程序的作用是比较throw变量的数据类型 和C++ catch语句中所用到变量的数据类型。如果数据类型是一样的，过滤程序返回 EXCEPTION_EXECUTE_HANDLER,让 catch 块(_except 块)中的语句执行。如果不同， 则返回EXCEPTION_CONTINUE_SEARCH,对处于调用树上层的catch过滤程序进行 求值。
嫡 728*729
说明C++异常在其内部实际上是通过结构化异常来实现的，这使得我们可以在一个应用 程序中同时使用这两种机制。比如，我喜欢使用虚拟内存技术，在发生访问违规时 调拨存储器。但C++语言根本就不支持这种可恢复异常处理(resumptive exception handling)。好在如果我想要这个功能，便可以在部分代码里使用结构化异常处理。 在这部分代码里，我可以编写自己的_except过滤程序，让它返回 EXCEPTION_CONTINUE_EXECUTION.对于代码中其他不需要可恢复异常处理 的部分，则坚涂使用C++异常处理。
25.6异常与调试器
Microsoft Visual Studio的调试器为异常调试提供了出色的支持。当进程中的某个线程抛出 异常，操作系统会马上通知调试器(如果调试器已经附着)。这个通知被称为“首次机会通 知”(命st.chance notification)。调试器将响应这个通知，促使线程寻找异常过滤程序。如果
第25章 未处理异常.向量化异常处理与C++异常
所有的异常过滤程序都返回EXCEPTION_CONTINUE_SEARCH,操作系统会给调试器 一个“最后机会通知” （last-chance notification）o这两个通知的存在使得软件开发人员能更 好地控制异常调试的过程。
针对每个解决方案"，我们可以通过调试器的Exceptions对话框（如下图所示）决定调试器如 何响应首次机会异常通知。
U$er-unhandled
Name
(U C++ Exceptions
GO Common Language Runtime Exceptions ffl M^n^ged Debugging Assistants
IS Native Run-Time Checks
S Win32 Exceptions
40010005 Control-C
40010008 Control-Break
80000002 Datatype misalignment.
Break when an exception i$:
Caned
C0000005 Accejj violation
c0000006 In page error
c0000008 An invalid handle was specified
c0000017 Not Enough Quota
cOOOOOld Illegal Instruction
rnnnnn?®!	rannnt rnntimi* from thi< •vr^nfinr*
[2i®pl@E00Lzl0 剧 Er/lslQ mElEEQ0@@口ffiEl@srlrl
Find...
Find Next
Add...
Delete
可以看出，对话框对所有异常进行了归类。我们可以找到Win32异常，在这里列出了所有 系统定义的异常。对话框显示了每个异常的32位代码，描述信息，以及当首次机会通知 （Thrown复选框）和最后机会通知（User.Unhandled复选框）发生时调试器的反应。清注意后 者仅对CLR异常适用。在这个对话框中，我选中了访问违规异常并改变了它的设定，让调 试器在这个异常发生时马上停止在异常发生处。于是每次当被调试线程引发访问违规时， 调试器都会收到首次机会通知，并显示类似如下图所示的消息框。
这个时候，线程还没TT得到机会来/找异常过滤程序。但我们可以在代码里设置一个断点, 检查变量的值或查看线程的函数调用栈。此时，异常刚刚发生，尚未执行任何异常过滤程 序。如果使用调试器来单步调试代码，我们会遇到下图所示的消息框。
① 译注:这里指的是Visual Studio的解决方案.即.sin文件。
^^^ndows核心编程（第5版）
选择No会让被调试线程重新执行失败指令。对大部分的异常来说，重新执行没有什么用 处，只会再次引发异常。但是，对一个通过RaiseException函数来抛出的异常，这个选项 让线程当作异常没有发生，继续往下执行。以这种方式继续对调试一个C++异常相当管 用，因为它看起来就好像C++的throw语句从未执行一样。我们在前一节中讨论过C++异 常处理。
选择Yes允许被调试线程寻找异常过滤程序。如果找到的某个异常过滤程序返回 EXCEPTION EXECUTE HANDLER 或者 EXCEPTION CONTINUE EXECUTION, 那么线程将继续执行。如果所有的过滤程序都返回EXCEPTION_CONTINUE_SEARCH, 调试器将收到最后机会通知并显示类似如下图所示的消息框。
73。
这种情况下，我们只能调试这个程序，或者终止它。
我已经演示了通过Thrown夏选框设置当异常发生时让调试器马上停止线程所产生的效果。 但在默认情况下，对大部分的异常，这个夏选框是没有选中的。于是，如果一个线程抛出 异常，调试器会收到首次机会通知，但调试器只会在输出窗口中显示一行文字表示它收到 了通知，如下图所示。
Cd U4 Ch U4
・'凶 hmod NULL) &&
尊胃始添❶金________
♦ x♦: OxCOOCOOGS: Acc«9>	**r locMCion OxOOOCDOGO
caption at 0«0G411b>

第25章 未处理异常、向量化异常处理与C++异常
如果没有为访问违规异常选中Thrown对话框，调试器允许线程寻找异常过滤程序。如果 异常没有得到处理，调试器会弹出下图所示的消息框。
说明 关于首次机会通知，需要记住它并不表示应用程序有问题或者缺陷。事实上，这个 通知只有在程序调试的时候才会出现。调试器只是将正发生的异常简单报告给程序 员，但是如果调试器没有显示消息框，应用程序的异常过滤程序会处理这个异常， 并且程序也会运行良好。最后机会通知则表示我们的代码有问题或者缺陷需要解决。
本章最后，我对调试器的异常对话框还需要做一些说明：这个对话框完全支持我们自己定 义的软件异常。我们只需要单击Add按钮，在随后弹出的New Exception对话框中，选择 异常类型为Win32异常，输入异常名称和异常代码（不能与已有的重复），然后单击0K按 钮来添加自定义异常到列表。下图演示了我是如何让调试器知道自定义软件异常的存在的。
理731~732 ・

第26早 错误报告与应用程序恢复
本章内容
26.1	Windows错误报告控制台	八丁
26.2	可编程的Windows错误报告	£ ¥
26.3对进程中所有的问题报告进行定制
26.4问题报告的创建与定制嬲麴*顼*
26.5应用程序的自动重启与恢复
第25章讨论了未处理异常与Windows错误报告(Error Reporting,后面简称为WER)机制如 何协同工作，以保证程序失败能被记录下来。在这一章，我们将更详细地介绍问题报告， 并阐述如何在应用程序中使用WER的应用程序编程接口(API)。使用WER API可以帮助我 们了解程序运行失败的深层原因，从而更好地发现和解决缺陷，改善用户体验。
26.1	Windows错误报告控制台
当一个进程因为未处理异常而终止时，WER会创建关于未处理异常及其执行上下文 (execution context)的错误报告(error reporting)o
如果得到用户的许成，这个报告就会通过安全信道发送给Microsoft的服务器，在那里它会 和数据库里的2知问题做比较。如果数据库里已经有这个问题的解决方案，服务器会将它 发送给用户，这样用户就可以采取相应少骤来继续完成自己的工作。
硬件与软件厂商可以利用这个技术来访问与其注册产品相关的报告。这个过程也适用于内核 模式设备驱动程序的崩溃或者挂起，因此可能的解决方案将是多种多样的。(关于错误报告 技术和它的相关好处，读者可以访问 http:// www.microsoft.com/whdc/maintain/StartWER.mspx 以及 Windows Quality Online Services Web 网站 https://winqual.microsoft.com)o
就算用户不愿发送报告给Microsoft的服务器，生成的报告也会保存在用户的机器上。通过 WER控制合，用户可以在本地机器上浏览这些曾经发生的问题并查看相应的报告。
图 26-1 演示了 Problem Reports And Solutions 控制面板程序(%SystemRoot%\ system32\wercon.exe)
第26章错误报告与应用程序恢复
Tasks
'■* Check for ne-.v solutions

See problems to check
Solve problems on your computer
Check online for solutions or see more information about problems on your computer. If solutions to install are available, install them before taking other steps to solve problems.
View problem history
Change settings
Clear solution and problem history
Solutions to install
No solutions found
Seeako
Read our privacy statement onfine	..
, Customer Experience Improvement Settings
Information about other problems
刖 Contact Microsoft Corporation for support
同 Download and install the driver for Reattek AC'97 Audio/nForce4 for AMD
Fl Download and install the driver for Microsoft Fingerprint Reader
@ Problem caused by computer hardware
IP Problem caused by NVIDIA Graphics Driver
Sj] Problem caused by Windows Search Protocol Host

图26-1从控制面板可以访问WER控制台程序
如果单击左边的View Problem History link, WER控制台会列出所有曾经发生的进程崩溃或 挂起记录。如图26.2所示。其他问题（诸如找不到硬件驱动或系统崩溃）也在此列。


堪 Problem Reports and Solutions
Problems Windows has identified
Product
Problem
Date
Status
& 23-SEHTerm.exe (10)
23-SEHTenn.exe
23-SEHTenn.exe
Not Reported Not Reported
Stopped woridng Stopped woridng
8/10/2007 6:33 PM
8/5/2007 9:52 PM
	smierni.c		07 9:40 PM	Not Reported 1
	23-SEHTerm.exe	Check fora solution	711:44 AM	Report Sent
	23-SEHTerm.ex<	Delete	711:43 AM	Report Sent
	23-SEHTerm.exe	View solution	711:43 AM	Report Sent
	23-SEHTerm.ex<	View problem details	711:42 AM	Report Sent
	23-SEHTerm.ex<	Group by	►	711:41 AM	Report Sent
	23-SEHTerm.ex<	- 	, 	, ■	11:40 AM	Report Sent
23-SEHTerm.exe
Stopped working
8/5/2007 10:50 AM
Report Sent
1匕心麟跟
—c.




图26-2 WER控制台列出了发生在每个程序上的崩溃记录（按照产品名称进行归类）
注意，状态栏指出哪些问题已经被发送给Microsoft,并以黑体字表示哪些问题还在等待提 交。右键单击问题，我们可以查看解决方案，删除问题报告，或者查看问题详细信息。如 果选择View Problem Details（或者双击问题），我们可以看到如图26-3所示的报告。
734
睡dows核心编程（第5版）	.
图26-3通过WER控制台查看错误报告
这个摘要提供了关于错误的信息，这些信息大部分可以从EXCEPTION_RECORD结构的 Exceptionlnfbrmation 成员得到，EXCEPTION RECORD 结构是函数 UnhandledExceptionFilter 的参数。比如异常代码（图26.3中为C0000005,表示访问违规异常）。对一般用户，这些信 息是难以理解的，但是对开发人员就很有•意义了。然而，它还是不足以帮助我们找出问题 的根源。不要紧，我们|寸以单击链接"View A Temporary Copy Of These Files”来得到表26-1 所列出的4个文件，当UnhandledExceptionFilter被调用时，WER会生成这些文件。默认 情况下，只有在报告还没有发送给Microsoft Ht，这些文件才会保留。稍后，我们将看到如 何强制WER总是保留这些文件。
Memory.hdmp文件是报告中最有趣的部分，它使得我们可以用熟悉的调试器来启动一个事 后调试会话（postmortem debug session）0从而让调试器为我们定位到抛出异常的那条指令。
说明 在以后版本的Windows中，dump文件的名字可能会改变.以后的版本将会包含错 误程序的名字，但是后缀名.hdmp/.mdmp保持不变。比如，MyApp.exe.hdmp和 MyApp.exe.mdmp 会被用来代替 Memory.hdmp 和 MiniDump.mdmp,关于 minidumps, 读者如果还想了解更多，可以参考John Robbins的Debugging Applications for Microsoft .NETand Microsoft Windows。
第26章错误报告与应用程序恢复
表26-1由WER生成的4个文件的详细信息
文件名	描述
AppCompat.txt	失败进程导入的模块列表(XML格式)
Memory.hdmp	失败进程的用户模式转储(dump),包含栈、堆和句柄表格。下面是用来生成 这个转储文件的标记： MiniDumpWithDataSegs | MiniDumpWithProcessThreadData | MiniDumpWithHandleData | MiniDumpWithPrivateReadWriteMemory | MiniDumpWithUnloadedModules | MiniDumpWithFullMemorylnfo
MiniDump.mdmp	失败进程的用户模式小型转储(minidump)。下面是用来生成这个小型转储文 件的标记： MiniDumpWithDataSegs | MiniDumpWithUnloadedModules | MiniDumpWithProcessThreadData
Version.txt	包含Microsoft Windows当前安装版本的信息： Windows NT Version 6.0 Build: 6000 Product (0x6): Windows Vista (TM) Business Edition: Business BuildString: 6000.16386.x86fre.vista_rtm.061101-2205 Flavor: Multiprocessor Free Architecture: X86 LCID: 1033
26.2可编程的Windows错误报告
下面的函数可以让我们为进程改变一些设置。这个函数存在于kemel32.dll并在werapi.h 定义：
HRESULT WerSetFlags(DWORD dwFlags);
表26・2列出了 4个渐增选项。
表26・2 对WerSetFlags参数的描述
WER FAULT REPORTING* 选项	描述
FLAG NOHEAP = 1	生成的报告将不包括堆信息，这有助于减小报告的大小
FLAG_DISABLE_THREAD_SUSPENSION =4	默认情况下，当程序出错时，为了防止其他线程破坏当 前线程数据，WER会暂停交互式进程里所用线程的执 行。这个标志让WER不要去停止其他线程，使用这个 标志是有一定风险的
indows核心编程（第5版）
	续表
WER FAULT REPORTING* 选项	描述
FLAG_QUEUE = 2	如果发生一个严重错误并旦打开了报告开关，这个报告会 添加到木地机器上的队列里，但不会发送给Microsoft
FLAG_QUEUE_UPLOAD = 8	如果发生一个严重错误并旦打开了报告开美，这个报告会 加到本地机器的队列里并发送给Microsoft
736
最后两个标志（WER_FAULT_REPORTING_FLAG_QUEUE 和 WER_FAULT_REPORTING_ FLAG_QUEUE_UPLOAD）的实际效果取决于当前的同意设置（consent setting）（如图25-5所 示）。如果同意设置不是默认值，即查找解决寺案，WER对这两个标志都会生成报告。但 是，如果设置 WER_FAULT_REPORTING_FLAG_QUEUE_UPLOAD, WER 会在发送报 告前弹出确认对话框，而设置 WER_FAULT_REPORTING_FLAG_QUEUE则不会发送 报告。应用程序不能在没有经过用尸（或管理员）同意的情况下强行上传报告，因为同意设 置始终可以驳回那些能够通过WER函数设置的选项。
说明 报告生成后会被加入到本地机器上的队列里。如果有用户许可，报告会被上传到 Microsoft的服务器，同时保留一个记录，所以它也会出现在WER控制台里。如果 许可选项设置成不要发送报告和检查解决方案，WER会弹出一个对话框让用户决定 需要做什么。即使报告没有被上传，它也会保留在本地队列里，并可以通过WER 控制台查看。
如果想知道某个进程的当前设置，可以调用下面这个函数：
HRESULT WerGetFlags（HANDLE hProcess, PDWORD pdwFlags）;
第一个参数hProcess是我们想要查询的进程的句柄。这个句柄必须具备 PROCESS_VM_READ访问属性。调用GetCurrentProcess可以得到我们当前进程的句柄。
注意 如果在调用WerGetFlags之前，没有调用过WerSetFlags,那么WerGetFlags会返 回 WER E NOT FOUND°
禁用报告生成与发送
应用程序可以选择在失败时不让WER发送报告。如果应用程序还处于部署和发布前的开 发和测试阶段，那么这个选项对我们很有用处。可以调用下面这个函数来禁用报告生成与 发送：
HRESULT WerAddExcludedApplicat ion（PCWSTR pwzExeName, BOOL bAllUsers）;
参数pwzExeName指出.exe文件的文件名（包括后缀）或者完整路径名（可选）。
参数bAHUser用来指明禁用报告对所有登录用户还是仅对当前用户生效。如果给这个参数 传递的值为TRUE,程序必须运行在管理员权限下，否则这个函数的返回结果为
第26章错误报告与应用程序恢复
E_ACCESSDENIED。(请参考4.5节“管理员以标准用户权限运行时")
当未处理异常发生在己被WER排除的程序中时，WER不会为它生成报告，但是WerFault 仍然会启动，让用户选择调试还是关闭这个程序，如图26.4所示。
[737
MitrosoftWindows	G>

23-SEHTerrp.exe has stopped working
A problem caused the program to stop working correctly. Please clos« the program.
\ 今 Close the program
今 Debug the program
图26V 被WER排除的程序只剩下两个选择
如果要启用错误报告，可以调用函数WerRemoveExcludedApplication：
HRESULT WerRemoveExcludedApplication(PCWSTR pwzExeName, BOOL bAllUsers)；
说明 这两个函数都存在于wer.dll中，并在werapi.h中声明。
26.3对进程中所有的问题报告进行定制
有时，我们可能想让应用程序通过调用一系列的WER函数定制错误报告。下面是我们可 能需要定制错误报告的三种情况。
•	我们在编写自己的未处理异常过滤程序。
•	我们想要应用程序在未处理异常没有发生的情况下也生成报告。
•	我们想往错误报告里添加更多信息。
定制问题报告的一种简单方式是指出哪些数据块或者文件需要添加到为进程生成的每个问 题报告里。要添加任意数据块，我们可以调用：
HRESULT WerRegisterMemoryBlock(PVOID pvAddress, DWORD dwSize)；
我们通过参数pvAddress来传入内存块地址，通过参数dwSize来指明需要保存的数据有多 少字节。调用这个函数后，每当一个问题发生时，这个范围内的字节就会保存在小型转储 中，我们可以通过事后调试器(postmortem debugger)来查看这些字节。请注意我们可以通过 多次调用WerRegisterMemoryBlock来将多个数据块保存在小型转储文件中。
要添加任意文件到问题报告中，我们只需调用：
HRESULT WerRegisterFile(
PCWSTR pwzFilename,
WER_REGISTER_FILE_TYPE regFileType,
DWORD dwFlags);
738
Endows核心编程(第5版)
我们通过参数pwzFilename来传入目标文件的路径名。如果不提供完整路径名，WER会在 当前工作目录寻找文件。可以给参数regFileType传入以下两个值中的其中一个，如表26.3 所示。
表26-3要添加到错误报告中的文件类型
参数regFileType的值	描述
WerRegFileTypeUserDocument = 1	这是一个文档文件，有可能包含与用户相关的数据。默认情况下， 这个文档不会发送给Microsoft的服务器。但是，Microsoft计划将 来允许开发人员通过Windows Quality网站访问这些文件
WerRegFileTypeOther = 2	任何其他文件
参数dwFlags的值可以是下面两个值的按位组合，如表26-4所示。
表26V添加文件的附加标志
dwFlags 标志的 WER FILE* 值	描述
DELETE WHEN DONE = 1	提交报告后就删除文件
ANONYMOUS_DATA = 2	这个文件并不包含可以用来识别用户的私人信息。如果这个标志 没有设置，Microsoft第一次访问这个文件时，会弹出对话框让用 方决定是否发送这个文件。如果用户选择上传，注册表里的同意 设置的位就会设置为3。一旦这个值为3,标记为匿名的文件将直 接发送给Microsoft,并不需要用户的进-步确认
现在，每当一个问题报告生成，	上面这个函数注册的文件都会保存在报告里。值得一提的
是，我们可■以通过多次调用WerRegisterFile来在报告里保存多个文件。
说明 我们通过WerRegisterMemoryBlock或者WerRegisterFile的注册的条目个数不能超过 WER_MAX_REGISTERED_ENTRJES (目前定义为 512)。如果超过，HRESULT 将返回一个Win32错误代码，我们可以通过下面这个操作来检验：
if (HRESULT CODE(hr) == ERROR INSUFFICIENT BUFFER)
厂三
还应该指出的是，下面这两个函数中可以分别用来移除已经注册的数据块或文件：
HRESULT WerUnregisterMemoryBlock(PVOID pvAddress)；	.
HRESULT WerUnregisterFile(PCWSTR pwzFilePath)；
26.4问题报告的创建与定制
下面将讨论如何在应用程序中定制错误报告。读者口J■以在错误(包含那些和异常处理没有什 么关系的问题)出现时，使用这里描述的函数。应用程序在创建报告后不需要马上终止。我
第26章 错误报告与应用程序恢复
们应该尽量使用Windows错误报告，而不是将一些含义模糊的信息写入到Windows事件 日志。但是，WER框架通过一些注册表数值限制了报告的大小和数目，如表25.5所示。 我们口 J 以在 HKEY_CURRENT_USER\Software\MicrosoR\ Windows'Windows Error Reporting 子项下找到这些值。
表26・5与WER存储相关的注册表设置
注册表设置	描述
MaxArchiveCount	存档中文件数目上限。为1〜5000 Z间的一个值。默认值为】000
MaxQueueCount	在发送给Microsoft的服务器之前保存在木地机器队列里的报告数日1:限。为 1-500之间的一个值。默认值为50
说明 已发送报告的跟踪信息保存在当前用户的AppData\Local\Microsoft\Windows\ WER'ReportArchive目录。但是，附加文件不在这个目录。未发送报告队列保存在 当前用户的 AppData\Local\Microsoft\Windows\WER\ReportQueue 目录。遗憾的是， WER控制台用来访问这些报告的API并没有公开，所以我们不能枚举应用程序的 问题报告。但愿以后的版本Windows系统能增加这个功能。
问题报告的创建、定制和提交给WER是按以下步骤调用不同的函数来实现的。
(1)	调用WerReportCreate来创建一个新问题报告。
(2)	调用WerReportSetParameter零次或者多次来设置报告参数。
(3)	调用WerReportAddDump来将小型转储放进报告。
(4)	调用WerReportAddFile零次或者多次来将任意文件(比如用户文档)放进报告。
(5)	调用WerReportSetUIOption来修改一些字符串，当调用WerReportSubmit时，这些 字符串可能会在同意对话框中呈现给用户。
⑹ 调用WerReportSubmit来提交一个报告。根据不同的标志，Windows可能会将报告放 进队列，或者提示用户将报告发送给服务器，或者直接发送报告。
(7)调用 WerReportCloseHandle 来关闭报告。
本节余下的内容将详细介绍每个步骤对最终错误报告的影响。在阅读后面的几个段落时， 我们可能需要参考GenerateWerReport函数，读者可以在本章稍后的WER定制示例程序 中找到这个函数。
运行这个程序以后，可以打开WER控制台并选择View Problem History link来得到己发送 错误报告的列表，如图26.5所示。
25-HandleUnhandled.exe的错误报告与23-SEHTerm.exe的错误报告有所不同，在产品这一 栏，前者出现在“Wintellect Applications Suit”之下，后者则出现在与可执行文件同名的产 品之下。同时，前者的“Problem” 一栏还给出了错误报告的详细信息，而不仅仅是字符串 u Stopped working n。
	r	二- .、卜	
fi			it
Problems Windows has identified
Product	Probtem	Date	SUtus
S Microsoft Visual Studw			■ A
Mkrowft Vhwi Studio	Stopped worlds	8/28/2007 11:14 AM	Hof Reported
£3USS Mass Storage De/Ke			A
USB Mass StoraQe Device	CouM not Bud driver software	9/1/2007 l(h25 FM	Not Reported
.Endows							A
■ 	 waMMjw>	Shot down uneMpecte<*y	8/19/2007 10:57 PM	Not Reported
.Windows Explorer (4)			A
Windows Explorer	Stopped responding and was closed	8/31/200710:15 PM	Report Sent
Windows Explorer	Stopped working	8/27/2007 3X)7 PM	Report Sent
Windows Expkxer	Stopped responding and was closed	8/23/2007 11：36AM	Report Sent
Windows Exploret	Stopped responding and was closed	8/22/2007 627 PM	Report Sent
回 Wintelkct Applications Suite			A
Apphstknu Suite	Unexpected Error - 0x12345678	9/27/2007 1:57 PM	Not Reported |
t_________3 _ j

图26-5 WER控制台中的条目是以产品名排序的
当我们双击报告查看它的详细信息时，可以看到这些信息也是定制的。通过图26-6,我给
出了每个Wer*函数对这些信息的影响。我们可以通过与图26-3进行比较来找出不同Wer*
函数如何改变默认的报告信息。
•Ml®：小
Wintellect Applications Suite
ProMew
Unetpected trroc • 0x12.^45678
Druiiptlon
Thu proMr»*> report.. gencted for testing 回，pox
PfoUrta xiqnatufr Problem (vent Fhme: AppixatiCrnNeme： Apphcibon La4 Action:
[■:f Connected >tvtr： 0$Ver»on:
Lgg
9/27/2007
WerReportAddDump
WerReportAddFile/ WerRegisterFile
WerReportCreate
sutm
Not Reported
Unexpected Eno*
26 Cu.tom<z<sMTR.e*e
s.o.o.e	j
Server R»qu<)t <12	r
httt/ u*.*•/**	Bt c t c om	J
6e.6000.Z0 0 25^6
1033
IB<m ftMl >«Hp detertt»e pcobArn
M0reD«t«.M awm
Rtg'^eredDMZ.M
RegirtertdDHiLtd mwI
Vtnioc td
m^rhocy.hdmp —
W«nin^: !f i wu} or other ftcur«ty threat caused the problem, opemg a copy of th,	h»rm your
C^nputer.
j) Qcpy fO clipboard
WerReportSetParameter

图26书 WER控制台里定制的报告描述
摘要列表里的报告标题和错误标签保持不变。我们增加了 “描述”字段来提供对错误的大 致描述，同时错误事件的名称也比默认的字符串APPCRASH更有意义。
第26章 错误报告与应用程序恢复
26.4.1创建一个自定义的问题报告
要创建一个自定义的错误报告，可以调用WerReportCreate,并传入报告的详细信息。
HRESULT WerReportCreate(
PCWSTR pwzEvencType,
WER_RE PORT_TY PE repType,
PWER_REPORT_INFORMATION pReportInformation, HREPORT *phReport);
pwzEventType表示作为问题签名(problem signature)第一个元素的Unicode字符串。注意， 如果我们想要报告能在 Windows Quality Web 网站((http://WinQual.Microsoft.com))上被浏 览，必须先向Microsoft注册该事件类型(请参考MSDN上关于WerReportCreate的相关文 档描述，网址为 http://msdn2.microsoft.com/en-us/library/bb513625.aspx)o
重要提示 所有Wer*函数都只接受Unicode字符串，并且这些函数没有A或者W后缀。
可以给参数repType传入表26-6中的某个值。
表26-6可给参数repType传入的值
repType 的值	描述
WerReportNonCritical = 0	不加任何提示地将报告放入队列并且根据同意设置上传到 Microsoft的服务器
WerReportCritical = 1	将报告放进本地队列并在用户界面上通知用户。同时，如果有必要， 结束程序的运行
WerReportApplicationCrash = 2	与WerReportCritical凡乎一样，除了在用户界面上以应用程序的 友好名称代替可执行文件名
WerReportApplicationHang = 3	与WerReportA叩licationCrash几乎一样，但应该在挂起或者死锁 时使用
参数pReportlnfbrmation指向一个WER_REPORTJNFORMATION结构。这个结构包含如 表26-7所示的几个Unicode字符串。
表 26-7 WER_REPORTJNFORMATION 的字符串成员
成员	描述
wzApplicationName	产品名，可以在WER控制台的历史错误信息和错误详细信息的程序图标 附近见到
wzApplicationPath	在本地机器上看不到，但是Windows Quality Web网站会用到它
wzDescription	可以在问题描述标签下见到
wzFriendlyEventName	报告中问题签名区域的事件名称条目
lows核心编程（第5版）
和所有Wer*函数一样，WerReportCreate的返回值类型为HRESULT。如果执彳丁成功, 这个函数通过参数phReport返回报告句柄。
26.4.2	设置报告参数：WerReportSetParameter
问题签名区域中出现在错误事件名称之后，OS版本和区域ID之前的问题签名区域中的是 一些键/值对，我们可以通过下面这个函数设置它们：
HRESULT WerReportSet Parameter（
HREPORT hReport,
DWORD dwParamID,
PCWSTR pwzName,
PCWSTR pwzValue）;
我们给参数hReport传入之前调用WerReportCreate.所获得的报告句柄。参数dwParamID 指明我们想要设置哪个键/值对。这个函数允许我们设置10个键/值对，werapi.h中的宏 WER_P0（值为0）到宏WER_P9（值为9）所标明了这些键/值对。同时，我们给参数pwzName 和pwzValue传入我们想要传入的Unicode字符串。
4743黔
请注意，如果传入的整数值小于0或者大于9, WerReportSetParameter将返回 EJNVALIDARGo另外，我们不能跳过任何ID,即如果想要设置WER_P2,我们必须也 设置WER_P1和WER_P0。参数的设置顺序无关紧要，但如果跳过某个ID,最后调用 WerReportSubmit 时就会失败，失败的 HRESULT 值为 0x8008FF05。
默认情况下，对一个非定制的报告，由WER设置的参数如表26.8所示。
表26-8问题报告的默认参数
参数ID	描述
1	错误程序的名称
2	错误程序的版本
3	标明程序二进制文件在什么时候构建的时间戳
4	失败模块的名称
5	失败模块的版木
6	标明程序二进制文件在什么时候构建的时间戳
7	异常代码，记载刚发生的异常的类型
8	发生错误的地方相对模块起始位置的偏移景。这个值的计算方法是将崩溃时的扩展指令指 针值（或者非x86平台的对等实体）减去发生异常模块的导入地址值
26.4.3	将小型转储文件放入报告：WerReportAddDump
当生成错误报告时，我们可以通过调用WerReportAddDump放入一个小型转储文件。
第26章错误报告与应用程序恢复
HRESULT WerReportAddDump（
HREPORT hReport,
HANDLE hProcess,
HANDLE hThread,
WER_DUMP_TYPE dumpType,
PWER_EXCEPT10N_INFORMATION pei,
PWER_DUMP_CUSTOM_OPTIONS pDumpCustomOpt ions, DWORD dwFlags）;
参数hReport表示需要放进小型转储文件的报告句柄。参数hProcess表示产生转储文件的 进程句柄。这个句柄必须在创建时赋予STANDARD_RIGHTS_READ和 PROCESS_QUERYJNFORMATION权限。一般来说，我们需要传入的句柄应该从 GetCurrentProcess得到，它返回的句柄具有全部进程权限。
参数hThread表示线程句柄（处于hProcess指向的进程内）。WerReportAddDump使用它 来访问线程的函数调用栈。当使用事后调试时，调试器使用这个函数调用栈来帮我们定位 到导致异常的指令。除了保存函数调用栈，WerReportAddDump还需要知道一些额外异常 信息。我们必须通过参数pExceptionParam来传入它们，如下面的代码所示：
WER_EXCEPTION_INFORMATION wei;
wei.bClientPointers = FALSE; // We are in the process where
wei.pExceptionPointers = pExceptionlnfo； // pExceptioninfo is valid
744-745
前面这段代码的pExceptionlnfo指向由GetExceptionlnfbrmation返回的异常信息，一般情况 下，我们将这些信息传给异常过滤程序。之后，&wei会传给WerReportAddDump的参数 peio转储的类型由参数dumpType和pDumpCustomOptions共同定义（详见对应的MSDN 文档）。
我们可以给dwFlags参数传递0或者WER_DUMP_N0HEAP_0NQUEUEo 一般来说，小型 转储包含了堆数据。但是 WER_DUMP_NOHEAP_ONQUEUE 标志让 WerReportAddDump 忽略堆数据。因为报告中不再包含堆信息，这个标志有助于节省磁盘空间。
26.4.4将任意文件放入报告：WerReportAddFile
hReport表示我们要放入文件的报告句柄，放入的文件名称由pwzFilename指出。同时， 我们可以给参数addFileType传入表26-9所列值中的其中一个。
不要混淆 WerFileTypeMicrodump, WerFileTypeMinidump 和 WerFileTypeHeapdumpo
当报告要上传到Microsoft的服务器时，系统会建立一个比较复杂的通信，本地机器需要响 应服务器关于哪些文件需要发送的请求。在某些情况下，服务器需要转储文件，而本地存 储则依赖这三个标志来考虑在WerReportAddDump函数之外生成的自定义转储。关于上 传错误报告的通信协议，详见Windows Quality网站。参数dwFileFlags和函数 WerRegisterFile的同名参数具有相同的含义。因此表26-4所展示的标志和它们的含义也 适用。
Endows核心编程(第5版)
表26・9系统地放入报告中的文件类型
文件类型	描述
WerFileTypeMicrodump = 1	自定义的微型转储(microdump)
WerFileTypeMinidump = 2	自定义的小型转储
WerFileTypeHeapdump = 3	自定义的堆转储
WerFileTypeUserDocument = 4	这是一个文档文件，有可能包含与用户相关的数据。默认情况下， 这个文档不会发送给Microsoft的服务器。但是，Microsoft计划将来 允许开发人员通过Windows Quality Web网站访问这些文件
WerFileTypeOther = 5	任何其他文件
745
26.4.5	修改对话框文本：WerReportSetU I Option
当报告提交给WER时，会弹出同意对话框。如果我们想定制同意对话框上出现的文本， 可以调用下面这个函数：
HRESULT WerReportSetUIOption(
HREPORT hReport,
WER_REPORT_UI repUITypelD,
PCWSTR pwzValue);
hReport参数表示报告句柄，这个报告就是我们想要修改其用户界面的报告。repUITypelD 参数表示我们想要修改的用户界面元素。pwzValue表示我们想要显示的Unicode字符串 文本。
对想要修改的每个用户界面元素，我们都可以调用一次WerReportSetUIOptiono注意，有 一些标签和按钮是不能修改的。下图所示的快照显示了一些可以修改的文本域。如果想要 了解更多，读者可以参考Platform SDK文档中关于函数WerReportSetUIOption的介绍。
WerUlConsentDIgHeadef
WeftXons«ntD»gBody
今 WerUlOnlineSolutionCheckText
今 WerUICIoseText
今 Debug the program
26.4.6	提交错误报告：WerReportSubmit
我们可以通过下面这个函数来提交错误报告:
第26章 错误报告与应用程序恢复
HRESULT WerReportSubmit(
HREPORT hReport,
WER_CONSENT consent,
DWORD dwFlags, PWER_SUBMIT_RESULT pSubmitResult);
hReport参数表示我们想要提交的报告的句柄。consent参数必须是这三个值中的一个： WerConsentNotAsked, WerConsentApproved 或者 WerConsentDeniedo 正如之前所解释 的那样，是否上传报告取决于注册表里的同意设置。但是，当一个报告提交时，展示给用 户的界面并不一样，它取决于传给参数consent的值。如果传入的值是WerConsentDenied, 那么报告就不会发送。如果是WerConsentApproved,当报告生成和发送给Microsoft的服 务器时，最常用的通知对话框(见图25-2和图25.3)就会呈现给用户。如果是 WerConsentNotAsked并且注册表中的同意设置的值为1(表示在寻找解决方案前总是先征 询用户，如图25.5所示)，会弹出图25-6所示的对话框，让用户决定是否发送报告给Microsoft 并在关闭应用程序前寻找可能的解决方案(作为常见的调试与关闭选项的一个补充)。
参数dwFlags的值是表26-10所列这些值的位掩码。
表26-10定制报告的提交
WER_SUBMIT_*	描述
HONOR_RECOVERY = 1	如果是严重错误，则显示恢复选项。详见26.5节“应用程 序的自动重启与恢复"
HONOR_RESTART = 2	如果是严重错误，显示重启应用程序选项。详见26.5节“应 用程序的自动重启与恢复”
SHOW DEBUG = 8	如果没有设置这个标志，调试选项就不会显示给用户
NO CLOSE UI = 64	不要显示关闭选项给用户
START MINIMIZED = 512	为通知对话框在Windows任务栏显示一个闪烁图标
QUEUE=4	不显示用户界面，直接发送报告到队列。如果同意设置的 值为1,会询问用户的选择，报告仍然不加任何提示地生成 但不会发送到Microsoft的服务器
NO QUEUE = 128	不要将报告放进队列
NO ARCHIVE = 256	在报告上传给Microsoft之后，不在本地存档
OUTOFPROCESS = 32	报告处理过程由另一个进程(wermgr.exe)完成
OUTOFPROCESS_ASYNC = 1024	报告处理过程由另一个进程(wermgr.exe)完成，并旦 WerReportSubmit函数不等这个进程完成处理就立即返1可
ADD_REGISTERED_DATA = 16	将相关注册数据添加进报告。注意如果我们在设置这个选 项的同时使用进程外报告生成(out-of-process report generation),通过WerRegisterFile加入的文件会在问题报告 中被存储两次。这个缺陷会在以后版本的Windows中解决
indows核心编程(第5版)
提交失败或者成功由WerReportSubmit的HRESULT返回值标明。但是，实际的函数结 果通过pSubmitResult参数指向的WER_SUBMIT_RESULT变量传递。关于可能的结果， 请参考相关 MSDN 文档。只有当 dwFlags 包含 WER_SUBMIT_OUTOFPROCESS_ASYNC 标志时，我们才需要用到pSubmitResult,这是因为在这种情形下WerReportSubmit函数 不等报告处理完毕就直接返回了。可以想象，对这个标志需要谨慎使用，而且一定不能在 未处理异常的上下文使用，因为进程绝对有可能在报告收集和上传完成之前就终止了。如 果我们不想等待报告处理这个过程，可以在没有异常发生的情形下使用这个标志。
WER_SUBMIT_OUTOFPROCESS_ASYNC标志是当监控进程侦测到错误发生在另一个 进程中时使用的。比如Windows服务控制管理工具(Windows Service Control Manager,简 称SCM)使用这个标记来报告一个服务挂起错误。
26.4.7	关闭问题报告：WerReportCloseHandle
在报告提交以后，不要忘记调用WerReportCloseHandle,并将报告句柄作为参数值传入。 这样，相关内部数据结构才会得到释放：
HRESULT WerReportCloseHandle(HREPORT hReportHandle)；
26.4.8	Customized WER 示例程序
Customized WER示例程序(26-CustomizedWER.exe)展示了当侦测到未处理异常时，如何定 制一个错误报告。另外，它提供了一种实现，允许finally块总是会被执行。最后，定制的 用户界面将会显示给用户，以允许用户选择关闭程序或者调试程序。而不是使用默认的同 意设置和显示WER对话框。如果读者不想提供默认的调试程序选项或者需要本地化对话 框(使用和程序一样的语言文字，而不是和操作系统一样)，可以在自己的应用程序里修改 相关代码。这个应用程序的源代码和资源文件可以在与本书配套的网页下载，它在 26-CustomizedWER 目录中。
说明 如果程序需要在Windows Vista之前版本的Windows系统上运行，我们需要使用 ReportFault函数。但这个函数提供的选项比前面介绍的Wer*函数少很多。如果目 标运行平台是Windows Vista或者之后的系统，我们应该避免使用ReportFault函数。
当我们执行定制WER示例程序时，会显示下图所示的对话框。
第26章 错误报告与应用程序恢复
当我们单击“Access Violation"按钮，就会调用下面这个函数：
void TriggerException() (
// Trigger an exception wrapped by a finally block
// that is only executed if a global unwind occurs 一try (
TCHAR* p = NULL;
*p = TEXT('a*);
}
_finally {
MessageBoxfNULL, TEXT("Finally block is executed"), NULL, MB_OK)；
}
}
而CustomUnhandledExceptionFilter函数是保护应用程序进入函数的try/except块的异常过 滤程序，所以它会执行。
int APIENTRY _tWinMain(HINSTANCE hlnstExe, HINSTANCE, LPTSTR, int) (
int iReturn = 0;
// Disable the automatic JIT-debugger attachment
// that could have been enabled in CustomUnhandledExceptionFilter
// in a prior execution of the same application
EnableAutomaticJITDebug(FALSE):
// Protect the code with our own exception filter
_try (
DialogBox(hInstExe, MAKEINTRESOURCE(IDD_MAINDLG), NULL, Dlg_Proc);
}
—except(CustomUnhandledExceptionFilter(GetExceptioninformation())) { MessageBoxCNULL, TEXT("Bye bye"), NULL, MB_OK);
ExitProcess(GetExceptionCode())；
}
return(iReturn);
主程序窗口的选项决定了这个过滤程序的行为：
static BOOL s_bFirstTime = TRUE；
LONG WINAPI CustomUnhandledExceptionFilter(
struct _EXCEPTION_POINTERS* pExceptioninfo) {
// When the debugger gets attached and you stop the debugging session, // the execution resumes here...
// So this case is detected and the application exits silently
if (s_bFirstTime)
s_bFirstTime = FALSE；
else
ExitProcess(pExcepc ioninfo->Except ionRecord->ExceptionCode)；
// Check shutdown options
if (!s_bCustom)
// Let Windows treat Che exception
return(UnhandledExceptionFilter(pExceptionlnfo))；
// Allow global unwind by default
LONG IReturn = EXCEPTION_EXECUTE_HANDLER;
// Let the user choose between Debug or Close application
// except if JIT-debugging was disabled in the options int iChoice = IDCANCEL； if (s_bA11owJITDebug) (
indows核心编程(第5版)
iChoice = MessageBox(NULL,
TEXT("Click RETRY if you want to debug\nClick CANCEL to quit"),
TEXT(-The application must stop"), MB_RETRYCANCEL I MB_ICONHAND);
}
if (iChoice == IDRETRY) (
// Force JIT-debugging for this application
EnableAutomaticJITDebug(TRUE);
// Ask Windows to JIT-attach the default debugger iReturn = EXCEPTION_CONTINUE_SEARCH;
} else (
// The application will be terminated
IReturn = EXCEPTION_EXECUTE_HANDLER;
// But check if we need to generate a problem report first
if (s_bGenerateReport)
GenerateWerReport(pExceptioninfo)；
}
return(IReturn);
)
/ 749~750滩
如果选择Default单选框，函数返回UnhandledExceptionFilter(默认Windows异常处理程 序)的输出。在这种情形下，前面详细描述的用户界面和错误报告处理将会出现。
如果选择Custom单选框，另外两个选项将对CustomUnhandledExceptionFiltei*的行为造 成影响。如果选择了 “Allow Debug”，就会弹出下图所示的这个简单对话框。
如果用户单击Retry,那么我们还需要蒙骗一下Windows才能强制让它开始即时调试，这 是因为仅仅返回EXCEPTION_CONTINUE_SEARCH是不够的。这只不过意味着异常未被 处理，于是WER再次向用户显示默认的用户界面，询问用户想做什么。 EnableAutomaticJITDebug的作用就是告诉WER,我们巳经决定了要附加调试器。
void EnableAutomaticJITDebug(BOOL bAutomaticDebug) (
// Create the subkey if necessary
const LPCTSTR szKeyName = TEXT ("SoftwareWMicrosoftWWindowsW" +
TEXT (Windows Error ReporvingWDebugApplications")；
HKEY hKey = NULL;
DWORD dwDisposition = 0；
LSTATUS iResult = ERROR_SUCCESS;
iResult = RegCreateKeyEx(HKEY_CURRENT_USER, szKeyName, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, &dwDisposition); if (IResult != ERROR_SUCCESS) (
MessageBox(NULL, TEXT("RegCreateKeyEx failed"),
TEXT("EnableAutomaticJITDebug"), MB_OK I MB_ICONHAND)；
return；
}
// Give Che right value to the registry entry DWORD dwValue = bAutomaticDebug ? 1 ： 0;
第26章 错误报告与应用程序恢复
TCHAR szFullpathName[MAX_PATH]；
GetModuleFileName(NULL, szFullpathName, _countof(szFullpathName));
LPTSTR pszExeName = _tcsrchr(szFulIpathName, TEXT('\\')};
if (pszExeName != NULL) (
// Skip the '\'
pszExeName++；
// Set the value
iResult = RegSetValueEx(hKey, pszExeName, 0/ REG_DWORD,
(const BYTE*)&dwValue, sizeof(dwValue))；
if (IResult != ERROR_SUCCESS) (
MessageBox(NULL, TEXT("RegSetValueEx failed"),
TEXT(-EnableAutomaCicJITDebug")# MB_OK I MB_ICONHAND);
return；
)
}
)
这段代码很直接，并使用了 25.2节“即时调试”中介绍的注册表设置。注意，当应用程序 启动时，EnableAutomaticJITDebug会被调用，传入参数值为FALSE,它会重新设置相关 注册表值为Oo
如果在主对话框选择了“Allow Debug",我们期望进程直接退出，不要显示任何自定义消 息框。这个效果和单击“Cancel”按钮是一样的：返回EXCEPTION_EXECUTE_ HANDLER ,同时全局except块调用 ExitProcess。然而如果在返回 EXCEPTION_EXECUTE_HANDLER 之前，选择了 “Generate A Report”，一个 WER 问 题报告就会通过下面的GenerateWerReport函数生成，后者使用本章前面提到的 WerReport* 函数。
LONG GenerateWerReport(struct __EXCEPTION_POINTERS* pExceptioninfo) (
// Default return value
LONG IResult = EXCEPTION_CONTINUE_SEARCH;
// Avoid stack problem because wri is a big structure static WER_REPORT_INFORMATION wri = { sizeof(wri) }；
// Set the report details
StringCchCopyW(wri.wzFriendlyEventName, _countof(wri.wzFriendlyEventName),
L"Unexpected Error - 0x12345678");
StringCchCopyW(wri.wzApplicationName, _countof(wri.wzApplicationName), L'Wintellect Applications Suite")；
GetModuleFileNameW(NULL, (WCHAR*)&(wri.wzApplicationPath),
_countof(wri.wzApplicationpath))；
StringCchCopyW(wri.wzDescription, _countof(wri.wzDescription),
L"This problem report is generated for testing purpose*)；
HREPORT hReport = NULL;
// Create a report and set additional information
_try { // instead of the default APPCRASHJEVENT
HRESULT hr = WerReportCreatefL"Unexpected Error",
WerReportApplicationCrash, &wri, fchReport);
if (FAILED(hr)) (
MessageBox(NULL, TEXT("WerReportCreate failed"), TEXT("GenerateWerReport*)r MB_OK I MB_ICONHAND); return(EXCEPTION_CONTINUE_SEARCH);
}
if (hReport == NULL) (
MessageBox(NULL, TEXT("WerReportCreate failed"), TEXT("GenerateWerReport"), MB_OK I MB_ICONHAND)；
■^^dows核心编程（第5版）
return(EXCEPTION_CONTINUE_SEARCH);
)
// Set more details important to help fix the problem
WerReportSetParameter(hReport, WER_P0,
L"Application Name", L"26-CustomizedWER.exe")；
WerReport Set Parameter(hReport, WER_P1,
L"Application Version", L'5.0.0.0");
WerReportSetParameter(hReport, WER_P2,
L"Last Action", L"Server Request #12')；
WerReportSetParameter(hReport, WER_P3,
L"Last Connected Server", LBhttp://www.wintellect.com");
// Add a dump file corresponding to the exception information WER_EXCEPTION_INFORMATION wei;
wei.bClientPointers = FALSE； //We are in the process where
wei.pExceptionPointers = pExceptioninfo； // pExceptioninfo is valid hr = WerReportAddDump(
hReport z GetCurrentProcess(), GetCurrentThread(), WerDumpTypeHeapDump, &wei, NULL, 0)； if (FAILED(hr)) {
MessageBox(NULL, TEXT(*WerReportAddDump failed-),
TEXT(-GenerateWerReport"), MB_OK I MB_ICONHAND); return(EXCEPTION_CONTINUE_SEARCH);
}
// Let memory blocks be visible from a mini-dump
s_moreInfol.dwCode = 0x1； s_morelnfol.dwValue = OxDEADBEEF;
s_jnorelnfo2 .dwCode = 0x2； s__morelnfo2 .dwValue = OxOBADBEEF; hr = WerRegisterMemoryBlock(&s_jnorelnfol, sizeof(s_morelnfol))； if (hr != S_OK) ( // Don't want S_FALSE
MessageBox(NULL, TEXT("First WerRegisterMemoryBlock failed'), TEXT("GenerateWerReport-)/ MB_OK I MB_ICONHAND)； return(EXCEPTION_CONTINUE_SEARCH)；
}
hr = WerRegisterMemoryBlock (&s__morelnfo2, sizeof (s_jnorelnfo2));
if (hr != S_OK) { // Don't want S_FALSE
MessageBox(NULL, TEXT("Second WerRegisterMemoryBlock failed"), TEXT("GenerateWerReport"), MB_OK I MB_ICONHAND)； return(EXCEPTION_CONTINUE_SEARCH);
}
// Add more files to this particular report wchar_t wszFilename[] = L'MoreData.txt";
char textData[] = "Contains more information about the execution \r\n\" + ■context when the problem occurred. The goal is to \r\n\" + "help figure out the root cause of the issue.■；
// Note that error checking is removed for readability
HANDLE hFile = CreateFileW(wszFilename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
DWORD dwByteWritten = 0;
WriteFile(hFile, (BYTE*)textData, sizeof(textData), &dwByteWritten,
NULL);
CloseHandle(hFile)；
hr = WerReportAddFile(hReport, wszFilename, WerFileTypeOtherz WER_FILE_ANONYMOUS_DATA);
if (FAILED(hr)) {
MessageBox(NULL, TEXT(-WerReportAddFile failed"), TEXT(-GenerateWerReport-), MB_OK I MB_ICONHAND)； return(EXCEPTION_CONTINUE_SEARCH);
// It is also possible to use WerRegisterFile char textRegisteredData[]=
■Contains more information about the execution\r\n■+
第26章 错误报告与应用程序恢复
■context when the problem occurred. The goal is to \r\n\* +
"help figure out the root cause of the issue.";
// Note that error checking is removed for readability
hFile = CreateFileW(L"RegisteredDatal.txt", GENERIC_WRITE, Q, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE__NORMAL, NULL);
<JwBy t eWr i 11 en = 0;
WriteFile(hFile, (BYTE*)textRegisteredData, sizeof(textRegisteredData), &dwByteWritten, NULL);
CloseHandle(hFile);
hr = WerRegisterFile(L"RegisteredDatal.txt", WerRegFi1eTypeOther, WER_FILE_ANONYMOUS_DATA);
if (FAILED(hr)) (
MessageBox(NULL, TEXT("First WerRegisterFile failed"),
TEXT(•GenerateWerReport"), MB_OK I MB_ICONHAND)； return(EXCEPTION_CONTINUE_SEARCH)；
}
hFile = CreateFileW(L"RegisteredData2.txt", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE__ATTRIBUTE__NORMAL, NULL);
dwByteWritten = 0;
WriteFile(hFile, (BYTE*)textRegisteredData, sizeof(textRegisteredData), &dwByteWritten, NULL);
CloseHandle(hFile)；
hr = WerRegisterFile(L"RegisteredData2.txt■, WerRegFileTypeOtherr WER_FILE_DELETE_WHEN_DONE)； // File is deleted after WerReportSubmit if (FAILED(hr)) (
MessageBox(NULL# TEXT(•Second WerRegisterFile failed"),
TEXT("GenerateWerReport"), MB_OK I MB.ICONHAND); return(EXCEPTION_CONTINUE_SEARCH);
}
// Submit the report
WER_SUBMIT_RESULT wsr；
DWORD submitOptions =
WER_SUBMIT_QUEUE I WER_SUBMIT_OUTOFPROCESS I WER_SUBMIT_NO_CLOSE_UI; // Don't show any UI
hr = WerReportSubmit(hReport, WerConsentApproved, sukmiitOptions, &wsr)； if (FAILED(hr)) (
MessageBox(NULL, TEXT("WerReportSubmit failed"),
TEXT("GenerateWerReport■), MB_OK I MB.ICONHAND); return (EXCEPTION__CONTINUE_SEARCH);
}
// The submission was successful, but we might need to check the result switch(wsr)
{
case WerReportQueued:
case WerReportUploaded: //To exit the process
iResult = EXCEPTION_EXECUTE_HANDLER;
break；
case WerReportDebug: //To end up in the debugger
IResult = EXCEPTION__CONTINUE_SEARCH;
break；
default： // Let the OS handle the exception
IResult = EXCEPTION_CONTINUE_SEARCH;
break；
// In our case, we always exit the process after the report generation IResult = EXCEPTION_EXECUTE_HANDLER;
_finally (
// Don't forget to close the report hand坨 if (hReport != NULL) (
WerReportCloseHandle(hReport);
Vindows核心编程（第5版）
hReport = NULL;
}
return(iResult); )
75A754静
26.5应用程序的自动重启与恢复
应用程序在运行期发生一个严重的问题时，WER可以在程序终止以后自动重启它。对 Windows Vista系统来说，这是一个衡量程序质量的要求，随同Windows Vista 一起发布的 大部分应用程序（比如Windows Explorer, Internet Explorer, RegEdit以及一些游戏）就支持 自动重启。更有甚者，WER允许应用程序在被终止前恢复任何重要的数据。
26.5.1应用程序的自动重启
应用程序如果想允许自动重启，必须通过下面这个函数在WER中注册自己:
HRESULT RegisterApplicationRestart（
PCWSTR pwzCommandline,
DWORD dwFlags）;
参数pwzCommandLine表示一个Unicode字符串，这个字符串是WER应该用来重启应用 程序的命令行参数。如果应用程序不需要特殊的参数来检测重启，我们应该给这个参数传 入的值为NULLo如果给dwFlags参数的传入值为0,当一个严重错误被WER侦测到时， 应用程序总是会重启o我们可以使用表26-11所列标志的组合来限制在哪些情形下需要重启o
表26-11用来限制程序重启的标志
标志	描述
RESTART NO CRASH = 1	在应用程序崩溃的情况下不要重启应用程序
RESTART NO HANG = 2	在应用程序挂起的情况下不要重启应用程序
RESTART NO PATCH = 4	不要在安装更新后重启应用程序
RESTART NO REBOOT = 8	不要在系统因为系统更新而重启的情况下重启应用程序
最后两个标志在异常处理的上下文中好像有点奇怪，但是应用程序重启特性其实是一 套更为通用的API的一部分，这套API被称为重启管理（Restart Manager）o （关于重启	
管理，读者可以参考 MSDN 文档" Guidelines for Applications ”，网址为 http://msdn2.microsoft.com/en-us/library/aa373651 .aspx。)
如果进程遇到一个由WER处理的严重错误，在调用RegisterApplicationRestart函数以后，、 下面这个对话框（见下图所示）就会在应用程序重启时弹出。
第26章 错误报告与应用程序恢复
为了防止重复地重启出错的应用程序,WER在重启它之前会先检查它是否已经运行了至少 60秒。
说明 如果我们想告诉WER不要重启当前的应用程序，可以调用下面这个函数:
HRESULT UnregisterApplicationRestart()；
755
26.5.2对应用程序恢复的支持
进程可以注册一个回调函数让WER在进程非正常终止时调用。这个回调函数可以保存任 意数据和状态信息。要注册回调函数，可以让进程调用下面这个函数：
HRESULT RegisterApplicationRecoveryCallback(
APPLICATION_RECOVERY_CALLBACK pfnRecoveryCallback,
PVOID pvParamecer,
DWORD dwPinglnterval,
DWORD dwFlags); // Reserved; pass 0
pfnRecoveryCallback参数所指向的函数必须具备这样的签名：
DWORD WINAPI ApplicationRecoveryCalIback(PVOID pvParameter)；
这个回调函数由WER调用，它给pvParameter参数传递的值就是我们在调用 RegisterApplicationRecoveryCallback时所传递的值。当WER调用我们的函数时，将显 示图26.7所示的对话框。
V MicfojoftWindow	EJ回一匹
26-RecoveryAndRestart.exe is trying to recover	
your information^ This might take several minutes.	
I 1—ww	
	士三-		 ||
图26-7当程序在准备恢复时，用户会得到通知
pfnRecoveryCallback函数需要让WER知道它正在工作当中，因此它至少每隔dwPinglnterval 呈秒就调用一次 ApplicationRecoverylnProgresSo 如果 AppIicationRecovery In Progress 没有
indows核心编程（第5版）
被及时地调用，WER就会终止进程。ApplicationRecoverylnProgress函数以一个BOOL指 针作为参数来让我们知道用户是否已经单击了图26-7 ±的“Cancel”按钮。当恢复函数运 行结束，它也应该调用ApplicationRecoveryFinished来让WER知道函数是否成功运行结束。
下而是应用程序恢复回调函数的示例:
DWORD WINAPI ApplicationRecoveryCallback(PVOID pvParameter) {
DWORD dwReturn = 0；
BOOL bCancelled = FALSE; while (IbCancelled) (
// Show progress
ApplicationRecoverylnProgress(&bCancelled)；
// Check for user cancellation
if (bCancelled) {
// The user clicked the Cancel button
// Notify that we have failed to finish the recovery process ApplicationRecoveryFinished(FALSE)；
} else {
//
Save the state required for recovery, chunk by chunk
(MorelnformationToSave()) (
Save a chunk of data in fewer milliseconds than the delay set with the dwPinglnterval parameter you passed to
RegisterApplicationRecoveryCallback
} else { // Nothing more to save
// It is still possible to update the restart command line //by calling RegisterApplicationRestart when the name of // a recovery file is known, for example.
// Notify that we have finished the recovery process ApplicationRecoveryFinished(TRUE)；
// Set bCancelled to TRUE when finished to exit the loop bCancelled = TRUE;
}
}
}
return(dwReturn)；
}
需要记住的是当回调函数运行时，进程可能处在一个被破坏的状态，同时，对异常过滤程 序的限制同样适用于这种类型的回调函数。
756-757^
0




►附录A ►附录B
构建环境
消息处理宏、子控件宏 和API宏

2
8
4LT 泓二
'竺Q:q* F 心"v ]	t mW > 二、
附录A构建环境
9
由于并不是所有的设置都能放到头文件里面，因此需要按照下述方式修改每个示例程序的 项目属性。第M解决方案中选中所有的项目，然后显示项目属性对话框，接着在 Configuration Properties页面中做以下改动。
• 在General属性页，改变“输出目录”，让所有项目生成的.exe或者.dll文件都能输
为了构建本书提供的所有示例程序，我们必须修改编译器与链接器的一些默认设置。我尽 量将它们的绝大部分放在-个叫“CmnHdr.h"的头文件里，这样我们蠲些 细节。本书中所有的示例程序和源文件都包含这个头文件。
出到同一个指定目录。
•	在C/C++代码构建属性页，在“运行库” 一栏中选择“多线程版本DLL”。
•	在C/C++属性页，在“侦测64位可移植性” 一栏中选择“Yes(/Wp64)”°
这些就是对项目属性所做的全部修改。对其他的设置，都采用了默认值。请注意，前面提 到的这些改动不仅针对项目的Debug配置，同时也针对Release配置。其他的编译器和链 接器选项是可以放在源文件中的，只要读者使用相应的源文件，这些选项就会生效。
CmnHdr.h头文件
示例程序中的所有源文件都包含CmnHdr.h头文件，并且对这个头文件的包含置于其他头 文件前面。编写CmnHdr.h(这个文件的内容在后面列出)的目的是简化我们的编程工作。该 文件包含宏定义，链接器指示符(linkerdirectives)以及其他一些能在整个程序范围内共享的 代码。这样，在需要做一些实验时，只需改动CmnHdr.h里的相关部分并重新构建所有示 例程序即可。这个文件放在本书配套网页的根目录。
下面我们将分别讨论CmnHdr.h头文件的每一段。我会解释每一段的基本原理并解释在重 新构建所有示例程序前，怎样去修改这些代码，以及为什么要这么做。
Microsoft Windows Version 构建选项
因为有一些示例程序调用了一些Windows Vista中的新函数，所以我在CmnHdr.h文件的这 一部分定义了_WIN32_WINNT和WINVER这两个预处理符号(symbol),如下所示：
// = 0x0600 for VISTA level from sdkddkver.h
OWS核心编程(第5版)
#define _WIN32_WINNT _WIN32_WINNT_LONGHORN
#define WINVER _WIN32_WINNT_LONGHORN
这样做的原因是在Windows.h头文件中，Windows Vista特有的新函数是这样定义的：
#if (_WIN32_WINNT >= 0x0600)
HANDLE
WINAPI
CreateMutexExW(
LPSECURITY_ATTRIBUTES IpMutexAttributes,
LPCWSTR IpName,
DWORD dwFlags,
DWORD dwDesiredAccess
)；
♦ ♦ ♦
#endif /* _WIN32_WINNT >= 0x0600 */
除非在引入Windows.h之前定义符号_WIN32_WINNT,否则这些新函数原型就不会得到 声明。如果试图去调用这些函数，就会引起编译错误。Microsoft通过符号_WIN32_WINNT 将这些函数隔离开，以确保我们开发的程序能在不同的Windows平台上运行。
Unicode构建选项
本书的所有示例程序既可以编译成ANSI版本，也可以编译成Unicode版本。为了能够构 建Unicode版本，头文件CmnHdr.h中定义了符号UNICODE和..UNICODEo(关于Unicode 的详细介绍，请参阅第2章)。
Windows Definitions与编译警告级别4
我在开发软件的时候，总是努力排除所有的编译错误和警告。而且，我喜欢用编译器最高 警告级别来编译代码，这样编译器就能帮我分担大部分的工作，甚至连代码中最细枝末节 的部分都不放过。对Microsoft的C/C++编译器来说，这意味着以警告级别4来构建所有示 例程序。
不幸的是，Microsoft操作系统开发团队对编译器警告级别4的观点和我不同。如果用编译 器警告级别4来编译代码，连Windows头文件中的很多行代码都会有编译警告。幸运的是, 这些警告并不代表代码中有错误。大部分的警告是因为使用了非标准C语言，这些用法依 赖于编译器对语言的扩展。当然，几乎所有与Windows兼容的编译器都实现了这些扩展。
在CmnHdr.h文件的这一段，我首先确保编译警告级别设置为3,然后包含标准Windows.h 头文件。紧接着，马上使用编译警告级别4来编译以下的代码。在这个级别，编译器仍然 会发出很多我认为不是什么问题的“警告”，因此我还通过#pragma warning预处理指令 明确告诉编译器忽略这些没有危险的警告。
762
附录A构建环境
pragma message 车甫助宏
在编写代码时，我的习惯是先让代码可以马上运行起来，然后再去慢慢完善整个程序。为 了提醒自己还有哪些代码需要在以后加以关注，我经常会使用下面这样的预处理指令： #pragma message(*fix this later")
编译器在编译这一行时，会输出一串文字，提醒我在某个地方还有一些工作要做。然而， 这个消息也并非那么有用。因此我想找到一个方法让编译器还可以输出pragma预处理指 令出现在哪一个文件的哪一行。这样，不仅可以知道还有一些工作要做，还能马上定位到 相应的代码区域。
为了达到这种效果，得用一系列的宏定义来“欺骗” pragma message预处理指令，这就 是我们现在可以使用的chMSG宏,如下所示：
#pragm chMSG(Fix this later)
在编译器处理上面代码时会输出一行信息，如下所示：
C：\CD\CommonFiles\CmnHdr.h(82):Fix this later
如果使用的是Microsoft Visual Studio,我们可以在输出窗口双击这一行，让Visual Studio 打开相应文件，并且将光标定位到对应的那一行。
为了方便起见，chMSG宏并不要求给字符串参数加上引号。
chINRANGE 宏
这个宏很有用处，示例程序中频繁地使用了它。chINRANGE宏查看一个值是不是处在另 外两个值之间。
chBEGINTHREADEX 宏
本书中所有的多线程程序都使用Microsoft C/C++运行库提供的_beginthreadex＞而不是由 操作系统提供的函数CreateThread来启动一个新线程。这是因为，这个函数允许用C/C++ 运行库函数来初始化一个新线程，并确保在线程返回时，为每一个线程所分配的C/C++运 行库信息块都能得到销毁。(详见第6章。)不幸的是，^beginthreadex函数的原型如下： unsigned long _cdecl _beginthreadex(
void *,
unsigned,
unsigned (_stdcall *)(void ★),
void *,
unsigned,
unsigned *);
俺.763诉
lows核心编程（第5版）
尽管传给_beginthreadex和CreateThread这两个函数的参数值是完全相同的，但是它们的 类型却并不一样。下面是函数CreateThread的原型：
typedef DWORD (WINAPI *PTHREAD_START_ROUTINE)(PVOID pvParam);
HANDLE CreateThread(
PSECURITY_ATTRIBUTES psa,
SIZE_T cbStackSize,
PTHREAD_START_ROUTINE pfnStartAddr,
PVOID pvParam,
DWORD dwCreateFlags,
PDWORD pdwThreadld)；
Microsoft在声明_beginthreadex函数原型时并没有使用Windows平台特有的数据类型，这 是因为Microsoft的C/C++运行库开发团队并不想对操作系统开发团队有任何依赖。我赞成 这个决定，尽管它使得使用函数_beginthreadex更加困难。
函数^beginthreadex的原型存在两个问题：首先这个函数使用的一些数据类型与函数 CreateThread所使用的原始数据类型并不一致。比如，Windows数据类型DWORD定义 如下：
typedef unsigned long DWORD；
这是函数CreateThread的参数dwCreateFlags的数据类型。问题在于_beginthreadex函数 使用unsigned（更准确的说，unsigned int）作为其参数类型。编译器认为unsigned int与 unsigned long是两个不同的类型，因此如果将两者混用时，它会给出一个编译警告。因为 .beginthreadex函数并不是标准C/C++运行库函数，它只是用来作为调用CreateThread的 一种替代方法，所以我认为Microsoft应该将它声明如下来防止这些编译警告：
unsigned long _cdecl _beginthreadex( void *psa,
unsigned long cbStackSize, unsigned (_stdcall *) (void *pvParam)z void *pvParam,
unsigned long dwCreateFlags, unsigned long *pdwThreadld);
第二个问题和第一个有些雷同。函数_beginthreadex的返回值（即新建线程的句柄）类型为 unsigned longo如果某个程序想用一个类型为HANDLE的变量去存储这个返回值，比如:
HANDLE hThread = _beginthreadex (...)；
这行代码又会导致另一个编译警告。要防止编译器产生这个警告，必须使用显式类型转换 重写上面这行代码，如下：
HANDLE hThread = (HANDLE) _beginthreadex (...);
这当然又造成了不便。为了让事情变得简单一些，文件“CmnHdr.h”中定义了宏 chBEGINTHREADEX来执行转型操作：
typedef unsigned (_stdcall *PTHREAD_START) (void *);
#define chBEGINTHREADEX(psa, cbStackSize, pfnStartAddr, pvParam, dwCreateFlags, pdwThreadld)
((HANDLE)_beginthreadex(
附录A构建环境
(void *) (psa),	\
(unsigned) (cbStackSize),	\
(PTHREAD_START) (pfnStartAddr),	\
(void *) (pvParam),	\
(unsigned) (dwCreateFlags),	\
(unsigned *) (pdwThreadld)))
适用于x86平台的对DebugBreak的改进
有些情况下，即便进程不是通过调试器来启动的，我也希望它能按照我的意愿停在某一个 断点。在Windows平台上，可以在一个线程中调用DebugBreak函数来来实现这个功能。 这个Kemel32.dll中的函数让我们可以附加(attach)一个调试器到进程。一旦调试器被附加到 进程，指令指针就会停在到那条激发断点的CPU指令。因为这条指令是Kemel32.dll中的 DebugBreak函数里的指令，所以为了调试我自己的代码，我不得不使用单步调试 (single-step)来跳出 DebugBreak 函数。
在x86微处理架构上，我们其实可以通过执行一条“int3”CPU指令来产生一个断点。所 以在x86平台上，我通过内嵌这条汇编指令的方式，重新定义了 DebugBreak函数。当执 行我的DebugBreak函数时，系统实际上没有执行Kemel32.dll里的代码，这样每次当程序 执行到断点位置的时候，断点发生在我的代码里，并且指令指针所指向的位置就是要调试 的下一条C/C++指令。这样，事情变得简单多了。
创建软件异常码
在处理软件异常的时候，必须创建自定义32位异常码。而且这些异常码得按照一定 的格式定义(请参阅第24章)。为了便于创建这些异常码，我们可以使用 MAKESOFTWAREEXCEPTION 宏。
chMB 宏
chMB宏的作用是弹出一个消息框。消息框的标题是调用进程对应的可执行文件的完整路 径名称。
chASSERT 宏和 chVERIFY 宏
在开发本书附带的示例程序的时候，为了尽可能找到那些潜伏的软件缺陷，我在代码中的 许多地方使用了 chASSERT宏。这个宏用来测试一个表达式的值是不是TRUE,如果不是, 则弹出一个消息框告诉我失败的那个表达式以及其所在的文件和行号。但是在发布版中， 这个宏将不起作用。chVERIFY宏和chASSERT宏几乎一样，唯一不同的是chVERIFY 宏既能在调试版中使用，也能在发行版中使用。
Ihdows核心编程(第5版)
chHANDLE_DLGMSG 宏
在对话框里使用消息处理宏'的时候，不应该使用Microsoft的WindowsX.h头文件提供的 HANDLE_MSG宏，因为这个宏不会返回TRUE或者FALSE来告诉我们对话框过程有没 有对消息进行处理。而我建立的宏chHANDLE_DLGMSG能对消息的返回值进行，它适 合在对话框过程中调用。
chSETDLGICONS 宏
本书大部分的示例程序都用对话框作为其主窗口，为了在任务栏、任务切换窗口(task switch window)以及程序自身的标题栏上显示合适的程序图标，需要手动修改对话框的默认图标。 我们可以在对话框收到WMJNITDIALOG消息的时候调用chSETDLGICONS来正确地 设置图标。
强制编译器寻找(w)WinMain入口点函数
本书前几版的一些读者曾将原来示例程序中的一些源文件加到自己的Visual Studio项目 里，结果遇到了一个链接错误。这是因为这些读者创建的是一个控制台应用程序项目，这 样链接器会去寻找控制台应用程序入口点函数(w)maino而本书中所有的示例程序都是GUI 程序，对应的程序入口点函数是_tWinMain,这就是链接器为什么会报错的原因。
我给这些读者的标准回答是他们应该在Visual Studio里删除原先的控制台程序项目，重新 建立一个Win32程序项目(请注意词语“控制台”没有出现在项目类型名称里)，然后把我 的源文件重新添加到项目中。这样链接器就会去寻找(w)WinMain入口点函数，而由于我 的源代码己经提供了这个函数，因此项目就可以顺利地构建了。
为了减少关于这个问题的来信，我在CmnHdr.h文件里加了一条pragma指示符它强制链接 器去寻找(w)WinMain入口点函数，哪怕当前的Visual Studio项目是一个Win32控制台程 序项目也不例外。
第4章极为详细地讨论了不同的Visual Studio项目类型怎样影响链接器选择不同的函数作 为入口点函数，以及如何改变链接器的默认设置。
通过pragma预处理指令来支持XP风格的用户界面主题
从Windows XP开始，系统为我们用来创建应用程序用户界面的绝大部分控件提供了许多
① 译注：Message Cracker,在WindowsX.h中定义的用来对Windows消息进行处理的•组宏。
附录A构建环境
眩丽的风格，它们被称为用户界面主题(theme)o然而，默认情况下，应用程序并不支持用 户界面主题。支持用户界面主题的一个简单方法是随应用程序提供一个XML格式的清单, 应用程序需要根据这个清单来绑定到正确版本的ComCtl32.dll,这样ComCtl32.dll就能够 以正确的方式重绘 Windows控件。Microsoft C~H•链接器提供了一个manifestdependency 选项，我已经在CmnHdr.h中通过pragma指示符用合适的参数对这个选项进行了设置。(关 于对用户界面主题的支持，详见“ Using Windows XP Visual Styles ”，网址为 https://msdn2.microsoft.com/en-us/library/ms997646.aspx)
766-767
CmnHdr.h /*************************★****•*****•***★*********************•**•************ Modu1e: CmnHdr.h
Notices： Copyright (c) 2008 Jeffrey Richter & Christophe Nasarre
Purpose: Common header file containing handy macros and definitions
used throughout all the applications in the book.
See Appendix A.
Ik*****************************************************************************/
#pragma once // Include this header file once per compilation unit
//////////////////////// Windows Version Build Option /////////////////////////
// = 0x0600 for VISTA level from sdkddkver.h #define _WIN32_WINNT _WIN32_WINNT_LONGHORN #define WINVER	_WIN32_WINNT_LONGHORN
//////////////////////////// Unicode Build Option /////////////////////////////
// Always compiler using Unicode.
#ifndef 0NICODE
#define UNICODE
#endif
// When using Unicode Windows functions, use Unicode C-Runtime functions too. #ifdef UNICODE	'
#ifndef .UNICODE
#define .UNICODE
#endif
#endif
///////////////////////// Include Windows Definitions ///////////////////////// tpragma warning(push, 3)
#include <Windows.h>
#pragma warning(pop)
tpragma warning(push, 4)
#include <CommCtrl.h>
#include <process.h>	// For .Joeginthreadex
///////////// Verify that the proper header files are being used //////////////
#ifndef FILEL.SKIP_COMPLETION_PORT_ON_SUCCESS
tpragma message("You are not using the latest Platfontt SDK header/library ■)
#pragma message(*files. This may prevent the project from building correctly.")
indows核心编程（第5版）
#endif
////////////// Allow code to compile cleanly at warning level 4 ///////////////•
/* nonstandard extension 'single line comment' was used */
#pragma warning(disable：4001)
// unreferenced formal parameter
#pragma warning(disable：4100)
// Note： Creating precompiled header
#pragma warning(disable：4699)
// function not inlined
#pragma warning(disable:4710)
// unreferenced inline function has been removed	-
#pragma warning(disable：4514)	•
// assignment operator could not be generated
#pragma warning(disable：4512)
// conversion from 'LONGLONG' to *ULONGLONG', signed/unsigned mismatch
#pragma warning(disable:4245)
// 'type cast' : conversion from 'LONG' to 'HINSTANCE' of greater size #pragma warning(disable：4312)
// 'argument' : conversion from *LPARAM' to 'LONG *, possible loss of data
#pragma warning(disable：4244)
// 'wsprintf ,: name was marked as #pragma deprecated
#pragma warning(disable：4995)
// unary minus operator applied to unsigned type, result still unsigned #pragma warning(disable：4146)
// 'argument1 : conversion from 'size_t* to 'int', possible loss of data #pragma warning(disable：4267)
// nonstandard extension used : nameless struct/union
#pragma warning(disable：4201)
///////////////////////// Pragma message helper macro /////////////////////////
/*
When the compiler sees a line like this：
•pragma chMSG(Fix this later)
it outputs a line like this：
c:\CD\CmnHdr.h(82):Fix this later
You can easily jump directly to this line and examine the surrounding code.
*/
#define chSTR2(x) #x
#define chSTR(x) chSTR2(x)
#define chMSG(desc) message(_FILE・(・ chSTR(___LINE__} •) ：" #desc)
..‘	,, v •.： . ：f	志.L.力r**柴;:	.•
////////////////////////////// chINRANGE Macro 〃〃//〃〃/〃〃〃〃/////////////
附录A构建环境
// This macro returns TRUE if a number is between two others
#define chlNRANGEflow, Num, High) (((low) <= (Num)) && ((Num) <= (High)))
///////////////////////////// chSIZEOFSTRING Macro ////////////////////////////
// This macro evaluates to the number of bytes needed by a string. #define chSIZEOFSTRING(psz) ((Istrlen(psz) + 1) * sizeof(TCHAR))
/////////////////// chROUNDDOWN & chROUNDUP inline functions //////////////////
// This inline function rounds a value down to the nearest multiple template <class TV, class TM> inline TV chROUNDDOWN(TV Value, TM Multiple) (
return((Value / Multiple) * Multiple)；
// This inline function rounds a value down to the nearest multiple template <class TV, class TM>
inline TV chROUNDUP(TV Value, TM Multiple) (
return(chROUNDDOWN(Value, Multiple) +
(((Value % Multiple) > 0) ? Multiple : 0));
}
///////////////////////////// chBEGINTHREADEX Macro ///////////////////////////
// This macro function calls the C runtime's _beginthreadex function.
// The C runtime library doesn•t want to have any reliance on Windows' data // types such as HANDLE. This means that a Windows programmer needs to cast // values when using _beginthreadex. Since this is terribly inconvenient# // I created this macro to perforin the casting.
typedef unsigned (_stdcall *PTHREAD_START) (void *);
#define chBEGINTHREADEX(psa, cbStackSize, pfnStartAddr, \ pvParam, dwCreateFlags, pdwThreadld)	\
((HANDLE)_beginthreadex(	\
(void *)	(psa),	\
(unsigned)	(cbStackSize),	\
(PTHREAD_START) (pfnStartAddr),	\
(void *) (unsigned) (unsigned *)
(pvParam),
(dwCreateFlags), (pdwThreadld)))
////////////////// DebugBreak Improvement for x86 platforms ///////////////////
#ifdef _X86_
#def ine DebugBreak ()	_asm ( int 3 }
#endif
/////////////////////////// Software Exception Macro //////////////////////////
// Useful macro for creating your own software exception codes #define MAKESOFTWAREEXCEPTION(Severity, Facility, Exception) \ ((DWORD) (	\
indows核心编程（第5版）
/* Severity code */ (Severity ) I /* MS(0) or Cust(l) */ (1	« 29) I
/* Reserved(0)	*/ (0	« 28) I
/* Facility code	*/ (Facility « 16) I
/* Exception code */ (Exception « 0)))
/////////////////////////// Quick MessageBox Macro ////////////////////////////
inline void chMB(PCSTR szMsg) (
char szTitle[MAX_PATH];
GetModuleFileNameA(NULL, pzTitle, _countof(szTitle))；
MessageBoxA(GetActiveWindow(), szMsg, szTitle, MB_OK); }
//////////////////////////// Assert/Verify Macros /////////////////////////////
inline void chFAIL(PSTR szMsg) ( chMB(szMsg);
DebugBreak();
// Put up an assertion failure message box.
inline void chASSERTFAIL(LPCSTR file, int line, PCSTR expr) ( char sz[2*MAX_PATH];
wsprintfAfsz, "File %s, line %d : %s", file, line, expr)； chFAIL(sz);
} •
// Put up a message box if an assertion fails in a debug build. #ifdef _DEBUG	•'
#define chASSERT(x) if (! (x)) chASSERTFAIL (_FILE_, _LINE_, #x) #else
#define chASSERT(x)
#endif
// Assert in debug builds, but don't remove the code in retail builds. #ifdef _DEBUG
#define chVERIFY(x) chASSERT(x)
#else
#define chVERIFY(x) (x)
#endif
///////////////////////////
chHANDLE_PLGMSG Macro *々〃///〃/〃〃//〃〃〃〃
// The normal HANDLE_MSG macro in WindowsX.h does not work pfoperly for dialog // boxes because DlgProc returns a BOOL instead of an LRESULT (like // WndProcs). This chHANDLE_DLGMSG macro corrects the problem： #define chHANDLE__DLGMSG(hWnd, message, fn壮盘土 '
case (message) : return (SetDlgMsgResult^O^id, uMsg,"龈
HANDLE__# #message ((hWnd), (wParam), (1 Param)(fn)))魏,土
//////////////////////// Dialog Box Icon Setting Macro ////////////////////////
// Sets the dialog box icons inline void chSETDLGICONS(HWND hWnd, int idi) (
SendMessage(hWnd, WM_SET1CON, ICON_BIGr (LPARAM)
附录A构建环境
Loadicon((HINSTANCE) GetWindowLongPtr(hWnd, GWLP^HINSTANCE), MAKEINTRESOURCE(idi)));
SendMessage(hWnd, WM_SETICON, ICON_SMALL, (LPARAM) Loadicon((HINSTANCE) GetWindowLongPtr(hWnd, GWLP__HINSTANCE), MAKEINTRESOURCE(idi)));
}
/////////////////////////// Common Linker Settings //////////////////////////// 汇虔愉捌鬻凭忑我:糖:翼*洋:&•落!捋}盛，，株携嫌初发笛萨法如展择客谶”,噩挪戒拼，遢如 」"「 .... . • "" " ， - .•
#pragma comment(linker, "/nodefaultlibsoldnames.lib-)
// Needed for supporting XP/Vista styles.
#if defined(_M_IA64)
fpragma	comment(linker,	"/manifestdependency：\*type='Win32'
name='Microsoft.Windows.Common-Controls'	versions'6.0.0.0*
processorArchitectures'IA64' p\iblicKeyToken='6595b64144ccfldf' language^•*'
#endif
#if defined(_M_X64)
#pragma	comment(linker,	"/manifestdependency:\"type='Win32'
name='Microsoft.Windows.Common-Controls'	versions'6.0.6000.0'
processorArchitecture='amd64' publicKeyToken='6595b64144ccfldf• language=•*•) #endif
#if defined(H_IX86)
fpragma	comment(linker,	"/manifestdependency；\w type='Win32'
name='Microsoft.Windows.Common-Controls * versions'6.0.0.O' processorArchitecture='x86' publicKeyToken= *6595b64144ccfIdf' language='*'\w■)
#6ndif
///////////////////////////////// End of File /////////////////////////////////
附录B
消息处理宏*子控件宏和API宏
通过在本书的示例代码中使用消息处理宏，我得以向很多以前可能并不知道这些宏的读者 介绍它们，这些宏虽然并不广为人知，但却很有用处。
消息处理宏在WindowsX.h文件中定义，该文件随Microsoft Visual Stuido 一起提供。我们 通常应该在包含头文件Window.h后，鸟上包含这个文件。WindowsX.h并没有什么特别的 地方，它用了大量的#define指示符，定义了许多宏供我们使用，仅此而已。这些宏又可以 分成三个类别：消息处理宏，子控件宏以及应用程序接口（APD宏。使用它们可以带来以下 好处。
•	它们减少了代码中所需的转型操作的次数，也使必要的转型操作不会产生错误。用 C/C++进行Windows编程的一大问题是经常需要用到转型操作，我们几乎不可能 在不做任何转型的情况下调用一个Windows函数。即便如此，我们仍然应该避免 使用转型操作，因为这削弱了编译器帮我们查找程序中潜在缺陷的能力。一个转型 操作等于告诉编译器：我知道传递了一个错误的数据类型，但是没有关系，我知道 自己在做什么。当我们在进行大量转型操作的时候，很容易犯错误。应该最大限度 地利用编译器来帮助我们找到错误。
•	它们提高了代码的可读性。
•	它们使代码更容易在32位和64位Windows之间进行移植。
•	它们非常易于理解。（毕竟它们只是宏定义。）
•	它们能非常方便地用在己有代码中。我们没有必要用这些宏来更新整个应用程序， 我们可以直接在新的代码中使用它们，而保持原来旧的代码不变。
•	我们町以在C和C++语言中使用它们，尽管在使用C++类库时，使用这些宏并不是 必需的。
•	即使这些宏还不支持我们需要的一些功能，我们也可以很容易地用它们来编写新 的宏。
•	有了这些宏，我们不再需要记住那些晦涩难懂的Windows。例如，很多Windows 函数要求传入一个长整型值，值的高16位代表一种含义，而值的低16位则代表另 一种含义。在调用这样的函数之前，我们必须用两个单独的值来组合成一个长整型 值。我们通常可以使用WinDef.h中定义的MAKELONG宏来完成这个操作。但是 我已经记不清有多少次因为弄反了这两个值而导致给函数传入了错误的参数。头文 件WindowsX.h中的宏可以帮助我们不犯这些错误。
773
附录B消息处理宏、子控件宏和API宏
B.1消息处理宏
消息处理宏可以让窗口过程(Windows Procedure)的编写变得更加简单。典型的窗口过程用 一个巨大的switch语句块实现。我曾经在一个窗口过程函数中见到过一个远远超过500行 代码的switch语句块。尽管我们都知道以这样的方式来实现窗口过程是一种糟糕的做法， 但很多情况下，我们还是这样做。而消息处理宏强制我们将switch语句拆分成多个函数一 一一个窗口消息对应一个处理函数。这会让代码更容易维护。
窗口过程的另一个问题是：每一个消息都有两个参数wParam和IParam,最令人头疼的是 针对不同的消息，它们有不同的含义。在某些情况下，比如WM_COMMAND消息,wParam 还包含两个不同的值，其高16位部分是通知码(notification code),其低16位部分则是控件 的ID。或者正好相反(高16位部分是通知码，低16位部分是控件ID)?我总是会忘记这些 参数的具体含义。如果使用消息处理宏，那我们就不需要再记住或查阅任何这些值的含义。 消息处理宏，顾名思义，它们帮助我们从消息中提取出参数，使得消息处理变得更加容易。 比如处理一个WM_COMMAND消息，我们只要编写一个类似下面的函数：
void C1s_OnCommand(HWND hWnd, int id, HWND hWndCtl,
UINT codeNotify)(
switch(id)(
case ID_SOMELISTBOX:
if (codeNotify != LBN_SELCHANGE)
break;
//Do LBN_SELCHANGE processing.
break;
case ID_SOMEBUTTON;
break；
・ • •
瞧，多么简单！消息处理宏会查看消息的wParam和IParam参数，并将wParam包含的 两个值解析出来，然后调用消息响应函数。
在使用消息处理宏之前，我们必须对窗口过程里的switch语句块做一定的修改。请看下面 这个窗口过程：
LRESULT WndProc (HWND hWnd, UINT uMsg,
WPARAM wParam, LRARAM IParam) (
switch (uMsg) (
HANDLE_MSG(hWnd, WM_COMMAND, Cls_OnCommand);
HANDLE_MSG(hWnd, WM_PAINT, Cls_OnPaint);
HANDLE_MSG(hWnd, WM_DESTROY, Cls_OnDestroy); default:
return(DefWindowProc(hWnd, uMsg, wParam, IParam));
}
)
HANDLE_MSG宏在WindowsX.h中被定义如下：
#define HANDLE_MSG(hwnd, message, fn) \
	r	
		
case (message):
return HANDLE_##message((hwnd),(wParam),(1Param), (fn))	_	_
773*774 除
如果具体消息是WM_COMMAND,预处理指令会展开上面这个宏如下：
case (WM_COMMAND)
return HANDLE_WM_COMMAND((hwnd), (wParam), (1Param),
(Cls_OnCommand));
HANDLE_WM_*①宏也在WindowsX.h中定义，它们就是所谓的消息处理宏。它们会解析 wParam与IParam的内容，执行必要的转型操作，并调用指定的消息处理函数，如前面显 示的 Cls_OnCommand 函数。宏 HANDLE_WM_COMMAND 被定义如下：
#define HANDLE_WM_COMMAND(hwnd, wParam, 1Param, fn) \
((fn) ((hwnd), (int)(LOWORD(wParam)), (HWND)(1Param),
(UINT) HIWORD(wParam)),OL)
预处理器扩展这个宏的结果就是对Cls__OnCommand函数的调用代码，且参数wParam和 IParam被正确地分解和转型。
使用消息处理宏宏来处理一个消息之前，我们最好先打开“WindowsX.h”文件，搜索一下 想要处理的消息。例如，如果搜索WM_COMMAND,将会看到文件的其中一段包含下面 这些代码：
/* void C1 s_OnCominand (HWND hWnd, int id, HWND hWndCtl,
UINT codeNotify); */
#define HANDLE_WM_COMMAND(hwnd, wParam, IParam, fn) \
((fn)((hwnd), (int)(LOWORD(wParam)), (HWND)(IParam), \
(UINT)HIWORD(wParam)), OL)
#define FORWARD_WM_COMMAND(hwnd, id, hwndCtl, codeNotify, fn) \
(void)(fn)((hwnd), WM_COMMANDZ \
MAKEWPARAM((UINT)(id),(UINT)(codeNotify)), \ (LPARAM)(HWND)(hwndCtl))
第一行的注释是一个函数的原型，我们必须编写这样一个函数。下一行是我们巳经讨论过 的HANDLE_WM_*宏，最后一行是消息转发宏。假设在处理WM_COMMAND消息时， 我们想让默认的窗口过程来完成一部分工作。我们可以这样编写Cls_OnCommand函数： void C1s_OnCommand (HWND hWnd, int id, HWND hWndCtl,
UINT codeNotify) (
//Do some normal processing.
// Do default processing.
FORWARD_WM_COMMAND(hWnd, id, hwndCtl, codeNotify, DefWindowProc)；
)
FORWARD_WM_*把分解和转型好的消息参数恢复到原来的wParam和IParam参数，然 后调用我们提供的一个函数。在前面的例子中，我们让这个宏调用DefWindowProc函数， 但我们也可以让它调用SendMessage或者PostMessage函数。事实上，只要我们想向系统
①译注：号表示窗口消息。
附录B消息处理宏、子控件宏和API宏
中任何一个窗口发送消息，就可以使用FORWARD_WM_*来把两个独立的参数组合在 一起。
775
B.2子控件宏
子控件宏简化了发送消息给子控件所需的工作。它们和FORWARD_WM_•宏非常相似。 每一个宏的名称以接收消息控件的类型开始，后面跟一个下划线字符加上待发送消息的名 称。比如，要发送LB_GETCOUNT消息给列表框控件，我们可以使用这个在WindowsX.h 中定义的宏：
#define ListBox_GetCount(hwndCtl) \
((int)(DWORD)SNDMSG((hwndCtl), LB_GETCOUNT, 0, OL))
关于这个宏，有两点需要说明。第一，在MFC中，SNDMSG宏被映射到SendMessage或 者AfxSendMessageo第二，这个宏只有一个参数，即列表框控件的窗口句柄hwndCtlo因 为LB_GETCOUNT消息会忽略wParam和IParam参数，所以我们也可以忽略它们。如 上所示，这个宏在默认情况下使用0作为两个参数的值。还有，当SendMessage函数返回 时，返回值被转型为int,所以也不需要再做转型了。
我不喜欢子控件宏的地方是它们需要控件窗口句柄作为参数。大部分的时候，将要接收消 息的控件是某个对话框的子控件，所以我们最终不得不频繁地调用GetDlgltem函数，如下 所示：
int n = ListBox_GetCount(GetDlgltem(hDlg, ID_LISTBOX));
比起SendDlgltemMessage,代码并不会因此而运行得更慢。但是程序会多出一些额外代码, 这是因为对GetDlgltem的额外调用。如果需要针对同一个控件多次调用GetDlgltem函数, 实际上可以只调用一次GetDlgltem,把子控件窗口的句柄保存下来，然后再用这个句柄来 调用所有宏，如下所示：	,
HWND hwndCtl = GetDlgItem(hDlg, ID_LISTBOX)；
int n = ListBox_GetCount(hwndCtl);
ListBox_AddString(hwndCtl, TEXT("Another string"))；
•••
如果我们以上面的方式来编写代码，那么应用程序会因为不必重复调用GetDlgltem而运行 得更快一些。如果对话框中有许多控件并且要查找的控件的z-order在其他控件之后，那么 GetDlgltem函数可能会比较慢。
B.3 API 宏
API宏简化了一些常用的操作，比如创建一个字体对象，选择一种字体到设备上下文里， 保存原有字体的句柄。这些操作如果不使用API宏，那么代码看起来会像下面这样：
HFON hFontOrig = (HFONT) Selectobject(hDC, (HGDIOBJ) hFontNew)；
g^^dows核心编程(第5版)
这条语句需要两个转型操作来避免编译错误。WindowsX.h头文件中有一个宏正是为了这个 目的而设计的：.
#define SelectFont(hdc, hfont) \
((HFONT) Selectobject( (hdc)# (HGDIOBJ) (HFONT)(hfont)))
如果我们使用这个宏来选择一种字体，代码变得简单许多：
HFONT hFontOrig = SelectFont(hDC, hFontNew)；
这样一来，代码更加易读，而且不容易出错。
"WindowsX.h"文件还有一些其他类似的API宏来帮我们完成一些常见的Windows编程 任务。建议读者花一些时间了解并使用它们。
2上
Symbols
"5or	characters in pszDLLPathName, 557
% (percent signs), 82
\\?\, pathname providing with, 294 n：L：:\ siring, 77
、、、9 0 —
「8
索
Numbers
0 priority, for zero page thread, 190
0 wail, of mutexes, 268
Oxfd value, 24
16-bit applications, porting to Win32 easily. 612
16-bit Windows applications running in, 94 backward compatibility with, 17 first function designed for, 85
32-bit applications, 397, 398
32-bit error code number, translating, 4
32-bit error code set, returning, 4
32-bit processes address space for, 371 running under 64-bil operating sysiem, 94
32-bit Windows kernel, 372
64-bii applications accessing full user-mode partition, 375 running on 64-bit Windows, 398
64-bit processes, address space for, 371
64-bii values, 299
64-bit Windows
8-1B user-mode partition, 375 fully supporiing AWE, 442 getting 2-GB user-mode partition, 374 kernel getting room, 373
64-bii Windows kernel, 372
64-KB boundary, 376
A
abandoned mutexes, 267
AhnormalTermination intrinsic function, 671,672 abort function, 705
ABOVE_NORMAL_PRIOR1TY_C1.ASS, 95, 191 above normal priority class, 189 above normal thread prioriiy, 190, 193 absolute time. 347
abstract layer, 188
AC (alignment check) flag, 391
AcceptEx, 291
access control entry (ACE), 122
access flags, 293
access masks, 62
AccessChk tool, 123
ACE (access control entry), 122
AcquireSRWLockExclusive function, 224, 234
AcquireSRWLockShared function, 225, 236
引

active processes, switching, 607 ActiveProcesses member, 138 ActiveProcessLimil member, 131
AddElement funciion、231 addPileType parameter, 745 address space
determining state of, 408-417 fragmentation, 526 modules in, 539 in a process, 67 regions, 375 regions reserving, 376, 419 reserved for thread s stack, 451 separate for each process, 605 total number of bytes private in, 407
Address Space Layout Randomization (ASLR), 417 address space map
for a process, 383-387
showing regions and blocks, 388-390 address space sandbox, running applications in, 375 address window, 439,440
Address Windowing Extensions. See AWE AddSIDTo Boundary Descriptor function, 59 AddText helper funcuon, 238 AddVectoredConiinueHandler function, 727 AddVectoredExceptionHandler function, 726 administrative tasks, executing, 116 Administrator account
checking if application is running, 117 debugging process、116 users logging on to Windows with, 110
Administrator SID, checking (or. 118
Advanced Local Procedure Call (ALPC) blocked, 714 bkxking thread execution, 710 tracked by WCT, 281
AdvAP132.dll, 537
AeDebug registry subkey, 713,715 affinities, 203-206
of processes. 83 affinity masks, 204 Affinity member, 131 affinity restriction, changing, 130 alertable I/O, 315-320 bad and good of, 318 using, 310 alertable state
calling thread in an. 260 placing thread in, 319 thread entering. 326 thread in, 316 thread waiting in, 714 _aligned_malloc function, 21。
「indows核心编程（第5版）
alignment check, 391 alignment errors, 258 Alignment Fixups/sec counter, 393 allocate declaration, 471 Allocated Ranges edit control, 506 AllocateUserPhysicalPages function, 441 allocation granularity, 376,483 allocation granularity boundary regions beginning on, 375 regions reserved on, 420
AllocationBase member, 409 AllocaiionProtect member, 409 AllocConsole function, 94 ALPC. See Advanced Local Procedure Call (ALPC) /analyze switch, 14 anonymous pipe, 290, 291
ANSI functions, 15-17,520
ANSI strings, 15, 16
ANSI versions
of DLLs, 17
of entry-point functions, 150
of functions, 22
APC (asynchronous procedure call) queue, 315,
316, 318
APC entries, waitable timers queuing, 260-261 APCFunc function, 319
API hooking
example, 634
manipulating module's import section, 636-639 overwriting code, 635
API macros in WindowsX.h, 776
AppCompal.ixt file, 736 Append Method, 270 application code, reading or writing to kernel mode partition, 375
"Application has stopped working" dialog box, 664 Application Instances sample application
(17-Applnst.exe), 472-474 application recovery, support for, 756-757 application restart, flags restricting, 755 ApplicationRecoveryFinished function, 756 Application Recovery I n Progress function, 756 applications
allocating, 439
converting to Unicode-ready, 26 determining version of Windows, 85 developing using Unicode, 17 directory forcing loader io always check, 585 DLLs extending features of, 537 forcing keystrokes into, 278 improving load time, 551
loading DLL and linking to symbol, 553-554 localizing, 11
mapping code and data into, 465 monitoring kernel objects used by, 41 paging file increasing RAM, 378 running, 374, 375, 540, 571 shutting down, 253 subclassing windows created in other processes, 607 theming not suDDorting bv default. 766
tuning, 408
types of, 68,69
users starling, 99
windows locating on screen, 97
writing, 68T04
AppName.local file, 585
a RAM Pages parameter, 442 arbitrary wait, of muiexes, 268 archive file, indicating, 297
_argc variable, 73, 76
_argv variable, 73, 76
ASCII Unicode character set, 13 aslnvoker value, 114
Ask Me To Check If Problem Occurs option, 712 ASLR (Address Space Layout Randomization), 417 assertion dialog boxes, 20 AssignProcessToJobObject function, 136 AssociateDevice member function, 332 AssociateDeviceWithCompletionPort function, 322 asynchronous device I/O, 277
basics of, 305-310
caveats, 307-309	,
asynchronous I/O operations, 304 asynchronous I/O requests
issuing, 327
queuing, 305
system handling, 316 asynchronous procedure call entries. See APC entries asynchronous session, opening, 284
ATL class library, 18 atomic access
of sophisticated data structures, 215
for threads, 208-213
atomic manipulation, 217 atomic test and set operation, 212 atomically-manipulated object set, 238
attribute(s)
associated with sections, 467
changing for sections, 471
passing with IpAttributeList, 99
auribute flags, 297
attribute keys, in STARTUP1NFOEX, 100
attribute list, 100-102
Attribute parameter, 101
Auto value, 715
AutoExclusionList key, 715 automatic application restart, 755-757 auto-reset event(s)
automatically reset lo nonsignaled stale, 249, 253 calling PulseEvent, 251
demonstrating use of, 252
signaling, 247
using instead of manual-reset event, 250 auto-reset timer, signaling, 257
AvaiiPageFile, 407
Avail Phys, 406
AvailVirtual, 407
AWE (Address Windowing Extensions), 439,441 AWE application (15-AWE.exe), 442
索 引
B
background colors, used by child's console window. 97 background process, 195
background processing stale (BPS), 365
Backup/Restore File and Directories privileges, 296 bAlertable flag, 279
bAHUser parameter, 737
base address
for executable file's image, 74 for memory-mapped files, 496-497 of region, 386
returning executable or DLL's file image, 74 /BASE option, 464 base priority level, 194 /BASE:address linker switch, 74 BaseAddress member, 409 _based keyword, 497 based pointers, 497
BaseThreadStart function, 706 basic limit restriction, 129 basic limits, superset of, 132 basic U1 restnctions, 129 batch, detecting end of, 346 Batch application (11-Batch.exe), 342-346 bCancelPendingCallbacks parameter of WaitForThreadpoolloCallbacks function, 355 of WailForThreadpoolWorkCallbacks、342
BCD (boot configuration data), 206 configuring, 374 current value of parameters, 374 programmatic configuration of, 206
BCDEdit.exe, 374
_beginthread function, 168 _beginthreadex function, 151, 160
calling CreaieThread, 162, 168 compared to _beginthread, 168 overriding, 451 problems with. 764 source code for, 161 using, 763
BEl.OW_NORMAL_PRIORITY_Cl.ASS, 95、191 below normal priority class, 189 below normal thread priority, 190, 193 bFirslInTheLisi parameter
of AddVectoredContinueHandler, 727 of AddVectoredExceptionHandler, 726 bGrant parameter, 134 binary (.exe or DLL) file, supporting all languages, 26 Bind.exe utility, 593, 594 BindlmageEx function, 593 binding modules, 592-595 blnheriiHandle member, 44 blnheritl iandle parameter
of DuplicateHandle, 62 of Open* functions, 51 blnheritHandles parameter, 44, 91-92 blnitialOwned parameter, 265
blnitialOwner parameter, 266
bit 29, of error code, 7
bit flags, 133
bitmask, indicating CPUs for threads, 203 bitwise mask, of Label ACE, 124
BlkSize member, 411
block of memory
allocating from heap. 525
allocating properly aligned, 210
guarding, 265
blocks
defining, 387
displaying inside regions, 388 number contained within region, 411 within reserved region, 387
Blue Screen of Death, 713
bManualReset parameter
of CreateEvent, 248
of CreateWaitableTimer, 257
BOOL return type. 3
boot configuration data. See BCD
boundary descriptor
associating SID wnh, 59
creating, 54
protecting namespace name itself, 53
BPS_CONTINUE state, 366
BPS_DONE slate, 366
BPS_STARTOVER state, 366
bReadDonc, 311
breakpoint, forcing, 765 bResume parameter, 259 bRgnisAStack member, 411
.bss section, 467, 470
buffer manipulation functions, 27
buffer overrun errors, 11
buffer overruns, automatically detecting, 27 BUFFSIZE, 331
build environment, for sample applications in this book, 761-767
build number, of current system, 87 Bution_SetEleva(ionRcquiredSiate macro, 118 bWaitAll parameter, 245, 246
c
C/C++ compiler
defining buih-in data type, 13
for IA-64, 393
C/C++ language
comma (,) operator, 700
never calling CreateThread, )51
programs, error checking in, 372
resources not destroyed by ExitThread, 154 C/C++ programming, 19
C/C++ run-time
global variables, 73
library funcuons, 160,168
startup code, 105
垓心编程（第5版）
C/C++ run-time, continued
startup functions, 69, 71
startup routine, 90
C/C+* run time, global variables. 71
C/C++ run-time libraries
Dll Main function. 570
initializing, 69. 570 multithreaded version, 167 not originally designed lor multithreaded applications, 160
present in single address space, 539 shipping with Microsoft Visual Studio, 159 stack-checking funciion, 456-457 startup assistance from, 570 startup code, 146 supplied in DLL, 167 using TLS, 597
C/C++ source code module. 541
C. compiler, mangling C functions, 546
C header file, 14
Cl language, char data type. 13
C run-time function, 17
C. run-time library
invented around 1970, 160
with multithreaded applications, 160 prefixing identifiers with underscores, 18 secure siring functions in, 18-25 string manipulation functions, 19 Unicode and ANSI [unctions in, 17
C run-iitne memory allocation functions, 71
C run-time startup code, 105
C++
heaps with. 528-531
with message crackers, 773
C++ applicalions, using C++ exceptions, 727
C++ classes
avoiding exporting, 542
creating, 443
C++ compilers. See also Microsoft Visual (>+ compiler C4532 warning, 690 equivalent structured exception handling, 728 mangling function and variable names, 544 running from command shell, 93
C++ exception handling
compared to structured exception handling. 660 only when writing C++ code, 727
C++ exceptions, vs. structured exceptions. 727
C++ object address, storing in hEvent, 307
C++ objects, destroying, 104, 106, 154
C++ throw statement, 728
C++ try block, compiler generating SEH _iry block for, 728
C2 security requirements, 332
C4532 warning, 690
CA(：HE_DHSCRIPTOR structure, 214
Cache field, 214
cache (lags、in CreateFile, 295-297
cache lines, 214-215
cache manager, buffering data, 295 CAddrWindow class, 443 CAddrWindowStorage class、443 call tree, 453 callback environmeni, initializing, 357 callback functions
defining, 346
registering io WKR, 756 required by alenable I/O. 318 callback instance, functions applying to, 356 callback method、355 callback routine, 260 callback termination functions, 355 CallbackMayRunl.ong function, 356 calling thread
checking signaled state of kernel objects, 244 as forever blocked. 244 placing in wait state, 221 putting io sleep. 325
transitioning from user mode to kerne) mode, 241 _calhhreadsiariex function, 164, 165 Cancello function. 309
CancelloEx function, 310 CancelSynchronouslo function, 304-305 CancclThreadpoolIo function. 354 CancelWaiiableTimer function, 259 CAP1I lock C++ class. 640 case sensitivity, of reserved keywords, 53 casting, 773 catch C++ keyword, 660 catch han出ers, 726 Cb (count of bytes), 22 cb member, 575 cb parameter, 32 cb value, 97 cbMuhiByte parameter, 28 cbReservedl value, 98 cbSize parameter, 101 cbStackSizc parameter, 151 Cch. in method names, 22 cch 1 parameter (CompareSiring), 25 cch2 parameter (CompareString), 25 cchValue parameter, 81 cchWideChar parameter, 28 ccPath parameter, 560
CD-ROMs, image files copying io RAM, 380 CeilData matrix, 505 CELLDATA structure, 504
committing storage for single, 425 implementing, 424 changed data, preserving, 486 ChangeDisplaySettings function, 133 char data types, 13 character encodings, 12-13 character sets, 12 characters, 26 chBIXiiNTHREADEX macro, 161, 763, 765 .chdir C run-Lime funciion, 85
索 引
Checkinstances function, 54, 59
ChecklbkenMembership function, 118 chHANDLE_DLGMSG macro, 766 child control macros, 776 child process(es), 108-110
current directories, inheriting parent's current, 85 environment variables, inheriting, 81 error mode flags, inheriting, 392
getting copy of parent s environment block, 81 handle table, example, 45
kernel object access, documenting expectation of, 45 kernel object, handle value of, 46 parent console, inheriting, 46
parent termination, continuing to execute, 125 primary thread, controlling code executed by, 634 priority class, changing, 191
process affinity, inheriting, 203
root directory, current directories defaulting to, 85 running detached, 110 spawning, 43-45, 108
chINRANGE macro, 763
chmalloc, 27
chMB macro, 765
chMSG macro. 763
chSETDLGICONS macro, 766
chSize parameter, 82
chVERIFY macro, 765
CIOCP class, 332
ClOReq C++ class, in FileCopy sample application, 307
CK_F1LE completion key, 322
CK_WR11 E completion key, 332
CK_WR1TE I/O completion notifications. 332
class, allocating instance of, 528
cleanup
groups, 358, 360
guaranteed without using try-finally, 686
localizing code in one place, 669
of mutexes vs. critical sections, 268
client machines, communicating with many servers, 261
client session, namespace in Terminal Services、51 client thread(s)
created by Queue, 229
as WriterThread, 232-234
Client Threads list box, 269
clienl/server threads, slopping, 236
Clipboard, preventing processes from reading, 133
CloseHandle function, 39, 103
calling twice, 487
clearing out entry in process' handle table, 40 closing devices, 292, 354 closing job object handle, 128 committed storage, reclaiming, 500 decrementing parent thread object's usage count, 171 destroying all kernel objects, 253
event kernel object is no longer required, 249 forgetting to call, 40
passing handle of completion port, 331
process' statistical data, no longer interested in, 108 protected handle, thread attempting to close, 47 ClosePrivaieNamespace function, 60 closesocket, 292
CloseThreadpool function, 357, 360 CloseThreadpoolCleanupGroup function, 360 CloseThreadpoolCleanupGroupMembers function, 359
CloseThreadpoolIo function, 355 CloseThreadpoolTimer function, 347, 348 CloseThreadpoolWait function, 353 CloseThreadpoolWork, 342 CloseThreadWaitChainSession, 284 CMD.EXE command prompt, 68 CMMFSparse object, 508
Cmnlidr.h header file. 761-767
*cmp string comparisort functions, 25 code
injecting with CreaieProcess, 633 maintaining with termination handlers, 672 running within catch or finally blocks, 664
Code Analysis option, 14
code page
associated with- newly convened string, 28
number associated with multibyte string, 27 code points. See Unicode code points code policies, possible, 124 code section, 466 code-point comparison, 25 coherence, memory-mapped files and, 495 COM
easily integrating with, 26 initialization and calls, 281 interface methods, 17 object DLLs, 585
ComCtl32.dll, 537 ComDig32.dll, 537 comma (,) operator, in exception filter, 700 command console, regaining control of, 305 command line
parsing into separate tokens, 76
of process, 76, 121 command shell, 192 command-line buffer, copying, 76 Commandi.ineToArgvW function, 76, 77 commit argument, with /STACK switch, 151 committed pages, disabling caching of, 382 committing physical storage, 376, 424 communication flags, in CreateFile, 295-298 communication protocol
building complete two-way, 639
related to uploading problem reports, 745 CompareString function, 24 CompareString(Ex) function, 24, 27 CompareStringOrdinal function, 24, 25, 27 comparison, linguistically correct, 24 compatibility rules, reorganized by operating
system, 114
idows核心编程（第5版）
compiler
differences among implementations, 659 guaranteeing finally block execution, 662 vendors following Microsoft's suggested syntax, 659 completion key value set, 141 completion notification, calling thread responding
to, 318
completion port. See I/O completion port(s) completion routine, 315
Completion Key parameter
as CK_READ, 333
of PostQueuedCompletionStatus, 330 CompletionRoutine function, 315 component protection, creating heaps for, 521 components, of a process, 67 computers, supporting suspend and resume, 259 concurrent model, 320
CONDIT!ON_VAR1ABLE_LOCKMODE_SHARED, 227 condition variables, 227-240
in conjunction with lock, 228
signaling, 237 Configuration Properties section, 761 consent dialog box. customizing, 746 consent parameter, 746 Consent setting, 739 console application, forcing full-screen mode, 98 console, use of, 290, 291 console window, 94
buffer identifying, 98
specifying width and height of child's, 97 console-based applications. See CUI-based process constant string, copying to temporary buffer, 90 ConsiructBlklnfoLine, 417 constructors for C++ class objects, 71 ConstructRgnInfoLine, 417 ConsumeElemem function, 234 container applications, 715 content indexing service, 297 contention, 223, 226
CONTROL section, 185
DEBUG.REGISTERS section, 185
EXTENDED_REGISTERS section, 185
FLOATING-POINT section, 185
FULL identifier, 186
INTEGER section, 185
SEGMENTS section, 185
conlext(s)
of thread, 157 types of, 185 CONTEXT CONTEXT CONTEXT CONTEXT CONTEXT CONTEXT CONTEXT.
CONTEXT structure, 183-187,699
changing members in, 186
ContextFlags member, 185
as CPU-specific, 183
defined in WinNT.h header file, 157 pointing to, 702 role in thread scheduling, 183 saving, 699 sections, 185
stack pointer register, 157
for x86 CPU, 183
context structure, of every thread, 173 context switch, 173, 607 ContextFlags member, 185, 18b ContextRecord member, 702 continue handler function
registering, 727
removing from internal list, 727
returning EXCEPT1ON_CONTINUE_EXECUTION,
727
returning EXCEPTION_CONTINUE_SEARCH, 727 ContinueDebugEvent, 176 control window messages, 611 convenience data types, 14
ConvertStringSecurityDescriptorToSecurityDescriptor function, 59
ConvertThreadToFiber function, 362, 365 ConvertThreadToFiberEx function, 362 cookie, storing stack state as, 457 copy-on-write mechanism, 382
of memory management system, 466
pages backing system's paging file, 588
turning off, 468 copy-on-write protection. 382 core components, isolating from malware, 52 core functions, requiring Unicode strings, 15 corruption, of internal heap structure, 524 count of bytes. See Cb
Count of characters. See Cch
Counter application (12-Counter.exe), 365-367 _countof macro
defined in stdlib.h, 19
getting Cch value, 22
_countof (szBuffer), instead of sizeof (szBuffer), 26 counts, functions returning, 3
CPU(s). See also x86 CPUs
aligned data, accessing properly, 391
cache coherency, communicating to maintain. 225
cache line, changing bytes in, 214
cache line, determining size of, 214
exceptions, raising, 679
indicating active, 396
limiting number system will use, 206
load balancing threads over multiple, 68
number in machine, 396
process address spaces for different, 377
registers for each thread, 157
specifying subset of, 131
tasks, giving varied to perform, 146
threads, controlling running on, 203
threads, selecting, 206
CPU architectures, 373
CPU cache lines. See cache lines
CPU lime
accounting information, 130
exceeding allotted, 142
scheduling for threads, 67
索 引
CPU-dependent code, writing, 186
CPU-specific code, writing, 633
CQueue C++ class, 229 constructor, 270 thread-safe, 269
CrashDmp.sys, 713
CREATE_ALWAYS value. 294
CREATE_BREAKAWAY_FROMJOB flag, 95, 136
CREATE_DEFAULT_ERROR_MODE flag, 84, 94
CREATE_EVENT_INIT1AL_SET flag, 248
CREATE_EVENT_MANUAL_RESET flag, 248
CREATE.FORCEDOS flag, 94
CREATE_MUTEX_1NIT1AL_OWNER, 265
CREATE_NEW_CONSOLE flag, 94
CREATE_NEW_PROCESS_GROUP flag, 94
CREATE_NEW value. 294
CREATE_NO_WINDOW flag, 94
CREATE_SEPARATE_WOW_VDM flag, 94
CREATE-Sl IARED_WOW_VDM flag, 94
CREATE_SUSPENDED flag, 174 checking for, 175 correct use of, 153 of CreateProcess fdwCreate, 93 passing to CreateThread, 157, 193 when calling CreateProcess, 136	/
CREATE_UNICODE_ENV1RONMENT (la& 94
Create* functions, 51
CreateBoundaryDescriptor function, 59
CreateConsoleScreenBufTer function, 291
CreateDesklop function, 133
CreateEvent function, 5, 248, 312
CreateEventEx function, 248
CreateFiber function, 362
CreateFiberEx function, 363
CreateFile function, 291-294, 478 cache flags, 295-297 checking return value of, 500 FileReverse calling, 488 not calling methods asynchronously, 304 returning INVALID_HANDLE_VALUE, 39 specifying exclusive access to file, 496
CreateFileMapping function, 479, 488, 500 creating file mapping, 34 passing INVAL1D_HANDLE_VALUE, 499
CreateFileMappingNuma function, 485
CreaieFileW function, 294
Createlcon function, 37
CreateloCompletionPort function, 321, 322
CreateMailslot function, 291
CreateMutex function, 49, 265
CreateNamedPipe function, 291
CreateNewCompletionPort function, 321
CreatePipe function, 291
CreaiePrivateNamespace function, 59,60
CreateProcess function, 44,89-104,136,464 checking for CREATE.SUSPENDED flag, 175 initializing suspend count, 175 invoking debugger process, 714
more control over cursor, 99
spawning WerFauh.exe, 710
CreateProcessWiihLogonW function, 17 CreateRemoteThread function, 621, 623, 625 CreateSemaphore function, 263
CreateSemaphoreEx function, 49
CreateThread function, 150-153, 157
called by _heginthreadex, 162 checking for CREATE_SUSPENDED flag, 175 compared to CreateRemoteThread, 621 creating new thread with normal priority, 193 initializing suspend count, 175 instead of _beginthreadex, 168 never needing to call, 340 prototype for, 764
thread stack storage initially committed, 451 CreateThreadpool function, 356 CreaieThreadpoolCleanupGroup function, 359 CreateThreadpoolIo function, 354 CreateThreadpoolTimer function, 262, 346, 348 CreateThreadpoolWait function, 352 CreateThreadpoolWork function, 341 CreateToolhelp32Snapshot function, 177 CreateWaitableTimer function, 256 CreateWellKnownSid function, 118 CreateWindow function, 97 CreateWindowEx function, 15 CreaieWindowExW function, 16 creation time, returned by GetThreadTimes, 179 critical sections, 217-224, 238
changing spin count for, 223 compared to mutexes, 265, 267 compared to SRWLock, 225
ensuring access to data structures, 218 minimizing time spent inside, 239 reading volatile long value, 226 spinlocks incorporated on. 222 tracked by WCT, 281 using interlocked functions, 219 CRITICAL-SECTION struciure, 218, 220 crilical-error-handler message box, not displaying, 83 CriticalSectionTimeout data value, 221
CRT section, 470
_CrtDumpMemoryLeaks function, 72 crtexe.c file, 71
_CnSetReporiMode, 20
CSparseStream C++ class, 508
CSystemlnfo class, 443
CToolhelp O+ class, 120
Ctrl+Break, 94
Ctrl+C, 94, 304
CUI applications, 68-69
CUI subsystem, selecting, 71
CUl-based process, output to new console window, 93
current drives and directories, of process, 84
current priority level, of thread, 194
current resource count, in semaphore kernel object, 262-263
lindows核心编程（第5版）
Currently Running Fiber field, 365
CurrentVersion\Windows\ key, 608
custom prefix, for named objects, 53 custom problem report, generating, 748 customized report description, in WER console, 742 Customized WER sample applicaticin
(26CusiomizedWER.exe), 748-751
CusiomUnhandledExceptionFuher function, 749, 750 CVMArray templated C++ class, 718
CWCT C++ class, 282
_CxxUnhandledExceptionFilter, 705, 706, 708
D
data
accessing via single CPU, 215
aligning, 391-393
communicating among processes, 463 flushing to devices, 303
passing from one thread to another, 599 protecting from I breads accesses, 230 sharing using memory-mapped files, 109, 498 data blocks, 738, 739 data buffer, not moving or destroying, 309 Data Execution Prevention. See DEP data files
accessing, 463
mapping to address space, 380,476
data misalignmeni exceptions, 392
data section. 467, 470
data structure, example of poorly designed, 214 deadlock(s)
avoiding, 238
dangers faced when synchronizing content, 237 detecting. 281-287
example, 569
issues when stopping threads, 236-238 prevented with WailForMuhipleObjects, 247 typical, 282
DEBUG builds, 72
debug event, 279
Debug menu option, in Task Manager, 715
DEBUG_ONLY_THIS_PROCESS (lag, 93 DEBUG_PROCESS flag, 93 debug section, 470
DebugActiveProcess function, 714
DehugActivePr<x:essStop function, 633 DebugApplications, adding as new subkey, 715 DebugBreak function, 765
debugger
calling SetEvent, 715 connecting co any process, 715 dynamically attaching, 713 exceptions and, 729-732 injecting DLL as, 633 notifying of unhandled exception, 708 positioning at exact location, 735 starting from command shell. 128 debugging
built into Windows operating system, 279
elevated/filtered processes, 116
going across process boundaries, 605
just-in-time, 713-715
monitoring ihread's last error code. 5
one instance of application, 467
unpredictability of first-in/first-out, 247 debugging-related exceptions, 696 DebugSeiProcessKillOnExit function, 633 declaration, of mutexes vs. critical sections, 268 _declspec(align(#)) directive, 214 _declspec(dllexport) modifier, 544
in executable's source code files, 544
in header file, 543
_declspec(dllimpori) keyword. 548
_declspec(thread) prefix, 602 decommitting physical storage, 377, 426 .def file, 547
default debugger, WER locating and launching, 713 default heap, 519, 520
DefaultConsent DWORD value, 710 DefaukSeparate VDM value, 94 #define directives, creating set of macros, 773 DefWindowProc function, 775
Delay Import section, 573
/DELAY linker switch, 572
Delay Loaded DLLs option, setting, 572 delay-load DLLs, 571-582
unloading, 575 delay-ioad hook function, 577 /DELAY1.OAD linker switch, 572, 573 DelayLoadApp application, 576-582 Delay Load DllExceptionFil ter function, 574 _delayLoadHelper2 function, 573, 574 DelayLoadlnfo structure, 574 /Delay:nohind switch, 575 /Delay:unload linker switch, 575 delete operator, 528 delete operator function, 530 DeleteBoundaryDescriptor function, 59,60 DeleteCrilicalSeciion function, 220, 223 DeleteFiber function, 364, 366 DdeteProcThreadAttributeList method, 102 Denial of Service (DoS) attacks, 53 DEP (Data Execution Prevention)
detecting code from a nonexecutable memory page, 701
enabled, 381
dependency loop, 563
DependencyWalker utility, 576 deprecated functions, replacing, 19 desktop(s)
naming io start application, 97
preventing processes from creating or switching, 133 Desktop hem Position Saver utility, 610-616 destination buffer, 23 destination file, size of, 332, 333 DestroyThreadpoolEnvironment, 358, 360 destructors, 72 detached process, 110
索 引
DETACHED_PROCESS (lag, 93
Detours hooking API, 641 device(s), 290
associating with I/O completion ports. 322-324 communicating with asynchronously, 297 flushing data to, 303
opening and closing. 290-298
device driver
executing I/O requests out of order, 308
running in kernel mode, 190 device I/O
canceling queued requests, 309
as slow and unpredictable, 305 device kernel objects, signaling, 310, 311-312 device objects
in nonsignaled state, 277
as synchronizable kernel objects, 277 device-sharing privileges, 293	.
dialog boxes, message crackers with, 766 DialogBox, calling, 252 .didata section, 470. 573 DIPS.exe application, 610-616 directories, 290
obtaining and setting current, 84
opening, 291
tracking Ibr multiple drives, 84 DisableThreadLibraryCalls function, 569, 570 DisassociaieCurrentThreadl'romCallback
funciion, 356
disk defragmeniing software, 147
disk image, 486
disk space, looking like memory, 377 display resolution, 611
DliHook function, 576
DLLs (dynamic-link libraries)
building, 540
calling LoadLibrary to load. 464 containing (unctions called by .exe, 464 as cornerstone of Microsoft, 537 creaied and implicitly linked by applications. 540 creating, 17, 546
delay-loading, 571-582 entry-point function, 562-571 explicitly loaded, 564
exporting variables, functions, or C++ classes, 542 in full 4-TB user-mode partition, 375 functions for specialized tasks, 537 injecting as debugger, 633
injecting using registry. 608-609
injecting using remote threads, 621-633 injecting using Windows hooks, 609-616 injecting with Trojan DLL. 633
in large 2+ GB user-mode partition, 374 loading at preferred base addresses, 464 loading from floppy disk, 380 loading from high-memory addresses, 590 making difficult for hackers to find, 417 mapping into processes using User32.dll, 608 preventing processes from dying, 564
preventing threads from dying, 567
process address space and, 538-539, 564
reasons for using, 537
receiving no notification with TerminateThread, 155
reserving region of address space for, 464
serving special purposes, 538
spreading oui loading, 571
telling to perform per-ihread cleanup, 567 unmapping, 564,610
uploading when callback function returns, 355 usage count, 559
using DllMain functions to initialize, 563
dll extension, 584
DLL functions, 29-30
DLL image file, producing, 541
DLL injection, 605-607
DLL modules
allocating and freeing memory, 539
building, 541-546
explicitly loading, 555
explicitly unloading, 558
loading in user-mode partition, 373
rebasing, 586-592
DLL_PROCESS_AITACH notification, 563, 608
DLL_PROCJ:SS_DETA(：H notification, 564-566
DLL redirection, 585-586
/DLL switch, 538
DLL_THREAD_ATTACH notification. 566
DLL_TI!READ_DETACH notification, 168. 567
DllMain function
calling DLL s, 564
C/C++ run-time library and, 570 implementing. 562 mapping file image without calling, 555 serialized calls to, 567-570
DllMain function name, case sensitivity of, 562
_DllMainCRTStartup function
calling destructors, 570
calling DllMain function. 570
handling DLL_PROCESS_ATTACH notification, 570
inside C/C++ run time's library file, 570
DLLs file image, mapping, 538, 555
dip member, of DelayLoadlnfo, 574
DOMAIN_AL1AS_RID_ADMINS parameter, 59
DONT_RESOLVE_DLL_REFERENCES flag, 555, 556
DomShowUI value, 710
_dospawn, 98
double-byte character sets (DBCSs), 12
drive-letter environment variables, 85
driver, 305
dl command, in WinDbg, 121
due limes, 262
dump files, naming of, 735
DumpBin uiiliiy
running on executable file, 468
using preferred base addresses, 586
viewing DLL's export section, 545
viewing module's import section, 549-550
dumpl\pe parameter, 745
Windows核心编程（第5版）
DUPLICATE_CLOSE_SOURCE flag, 61 DUPL1CATE_SAME_ACCESS flag, 61, 62 DuplicateHandle function, 60,60-63,64, 170 dwLConditionMask parameter, 88 dwActiveProcessorMask member, 396 dwAllocationGranularicy member, 396 dwBlkProtection member, 411 dwBlkStorage member, 411 dwBuildNumber member, 87 dwBytes parameter (HeapAlloc), 525 dwBytes parameter (HeapReAlloc), 527 dwConditionMask parameter, 88 dwCount parameter, 245 dwCreateFlags parameter, 153 dwCreationDisposition parameter, 294 dwData parameter, 319 dwDesiredAccess parameter
accepted by kernel object creation functions, 49 of CreateEventEx, 248
ofCreateFile, 293,478
of CreateMutexEx, 265
of CreateSemaphore, 263
of DuplicateHandle, 61
DuplicateHandle ignoring, 62
of MapViewOfFile, 482
of Open* functions, 50 dwExceptionCode parameter, 703 dwExceptionFlags parameter, 703 dwExitCode parameter
cfExiiThread, 154
of TerminateThread, 155
dwFileFlags parameter, 745 dwFileOffsetHigh parameter, 483 dwFileOffseiLow parameter, 483 dwFillAttribute value, 97
dwFlags in STARTUPINFO, 97,98 dwFlags parameter, 23
of CreateEventEx, 248
of CreateMutexEx, 265
of CreateSemaphore, 263
of GetThreadWaitChain, 285
of LoadLibraryEx, 555
with MuhiByteToWideChar function, 27 in OpenThreadWaitChainSession, 284 of RegisterApplicaiionRestan, 755 as reserved, 101
of SetHandlelnformation, 47
of UpdateProcThread, 101
of WerRegisterFile, 739
of WerReportAddDump, 745
of WerReportSubmit, 747
of WideCharloMultiByte function, 28 dwFlagsAndAttributes parameter, 294 dwldealProcessor parameter, 205 dwlnitialSize parameter. 525 dwl 1 ConditionMask parameter, 87 dwLastError member, 574 dwMajorVersion member, 87
dwMask parameter, 46
dwMaximumSize parameter, 525 dwMaximumSize白igh parameter, 481 dwMaximumSizeLow parameter, 481 dwMilliseconds parameter, 243
of GetQueuedCompletionStaius, 325
of SignalObjectAndWait, 279
of Sleep* functions, 177, 227
of WailForMultipleObjects, 245 dwMinorVersion member, 87 dwMoveMeihod parameter, 301 dwNumberOfBytesToFlush parameter, 486 dwNumberOfBytesToMap parameter, 483 dwNumberO(Processors member, 396 dwNumByles parameter, 330 dwOptions parameter, 61 DWORD, fields of, 703 DWORD return type, 3 dwOSVersionlnfoSize member, 87 dwPageSize member, 396 dwParamID parameter, 743 dwPinglnterval, 756 dwPlatformld member, 87 dwPreferredNumaNode parameter
of CreateFileMappingNuma, 485
of MapViewOfFileExNuma, 485 of VirtualAllocExNuma, 421 dwProcessAffinityMask parameter, 203 dwProcessorType member, 396 dwRgnBlocks member, 411 dwRgnGuardBlks member, 411 dwRgnProtection member, 411 dwRgnStorage member, 411 dwShareMode parameter
of CreateFile, 293, 478 specifying exclusive access, 496
dwSize parameter, 435
of ReadProcessMemory, 624
of WerRegisterMemoryBlock, 738
of WriteProcessMemory, 624
dwSpinCount parameter, 223
of InilializeCriticalSectionAndSpinCount, 222 of SetCriticalSeciionSpinCount, 223 dwStackCommitSize parameter, 363 dwStackReserveSize parameter, 363 dwStackSize parameter, 362 dwThreadAffinilyMask parameter, 204 dwTlsIndex parameter, 599 dwTypeBiiMask parameter, 88 dwTypeMask parameter, 87,88 dwX value, 97 dwXCountChars value, 97 dwXSize value, 97 dwY value, 97 dwYCountChars value, 97 dwYSize value, 97 dynamic boosts, 194 dynamic priority range, 194
索 引
dynamic TLS, 598-602
/dynamicbase linker switch, 417 dynamic-link libraries. See DLLs
E
EJNVAL1DARCJ, 744
edata section, 470
efficiency, for applications with Unicode, 26
EFLAGS register, 391
element, adding on top of stack, 213
ELEMENT structure
of CQueue class, 269
inside CQueue class, 230
elevated account, credentials of, 112
elevated privileges, child process getting, 116 empty stack, 213
emulation layer, (br 32-bit applications, 397
EnableAutomaticJITDebug function, 750 encrypted file, 297 end of file marker, 509 end user. See user(s) endless recursion, 151
_end(hread function, 168
_endthreadex function, 166
compared to _endihread, 169
using, 154
EnterCriticalSection function, 218, 219-220, 223 /ENTRY switch. 570
-entry:command-line option, 69 entry-point function
calling, 71, 146
for every thread, 149
implementing, 562
for Windows application, 69
EnumProcesses function, 119
env parameter, 72, 79
.environ global variable, 73
environment block, 77
containing ANSI strings by default, 94 spaces significant in, 80
environment strings, obtaining from registry keys, 80 environment variables, 77-83
accessing, 72
multiple for process, 84
Environment Variables dialog box. 80
ERANGE, returning, 21
$err,hr, in Watch window, 5,6 errno
C run-time global variable, 160
defining in standard C headers, 166
internal C/C++ run-time library function, 167 macro, 167
setting, 19
errno_i value, 19, 20
error(s)
checking with ReadFile and WriteFile, 308 returning via exceptions, 703 trapping and handling, 683
ERROR_ALREADY_EX1STS, 5
ERROR_CANCELLED, 116
error code(s)
32-bit number with fields, 7 composition of, 697 returned from GetLastError, 308 setting thread's last, 7
Windows functions returning with, 3
ERROR_ELEVATION_REQUIRED, 116 error handling, 659
critical sections and, 223
performed by Windows functions, 3 simplified by termination handlers, 672 using exceptions for, 702
ERROR_INVAL1D_HANDLE, 39, 331
ERRORJNVALID_USER_BUFFER, 308
ERRORJO.PENDING, 308
Error Lookup utility in Visual Studio, 6,9
ERROR_MOD_NOT_FOUND. 557 error mode. 83, 94
ERROR_NOT_ENOUGH_MEMORY, 308 ERROR_NOT_ENOUGH_QUOTA, 308 ERROR_NOT_OWNER, 267
ERROR_OLD_W1N_VERSION, 88 ERROR_OPERATION_ABORTED, 310 error reporting, enabling, 738 ERROR_SUCCESS, 5
ERROR_USER_MAPPED_F1LE, 489
ErrorShow sample application, 6, 7-9
European Latin Unicode character set, 13 events)
allowing threads to synchronize execution, 43 changing to nonsignaled state, 249 changing to signaled state, 249 initializing signaled or nonsignaled, 248 as most primitive of all kernel objects, 247 signaled and immediately nonsignaled, 251 signaling that operation has completed, 247 event handle, creating with reduced access, 248 event kernel objects, 247-253
creating, 248
identifying, 312 signaling, 310,312-313 synchronizing threads, 249 types of, 247
used by critical sections, 223
EVENT_MODIFY_STATE, 248
_except filter, 728
_except keyword, 679 exception(s), 679,695-696
debugger and, 696, 729-732 handling, 684
raised by HeapAiloc, 525
system processing, 682
EXCEPTION JKCCESS_V1OLATION, 695,698, 701 EXCEPTION_ARRAY_BOUNDS_EXCEEDED, 695 EXCEPTION-BREAKPOINT, 696
exception codes, 697, 703
[indows核心编程（第5版）
EXCEPT1ON_CONTINUE_EXECUTION, 681, 691-<>93. 706. 707
»:X(：EPT1ON_CONTINUE_SEARCH. 681. 693-694, 706, 707
filter returning, 574
FilterFunc function returning, 458
EXCEPT1ON_DATATYPE_M1SALIGNMENT. 695 raised by other processors, 258 transforming misalignment fault into, 391
EXCEPTI()N_EXECUTE」1ANDLER. 681, 683-690,
706. 707
FilterFunc function returning, 458
returning. 691
triggering global unwind, 709
exception filters
commilting more storage to thread's stack, 692 debuggee's thread searching for, 730 executed directly by operating system, 680 GetExceptionlnformation calling only in. 699 identifiers, 681
producing, 701
rcmrn values of top-level, 706
thread searching for, 731
understanding by example, 680-682 writing your own unhandled, 738
EXCEPT1()N_FLT-DENORMAL_OPERAND, 696
EXCEPTION J:LT_DIVIDE_BY_ZERO, 696
EXCEPTION EXCEPTION EXCEPTION EXCEPTION EXCEPTION
EXCEPTION
FLT_1NEXACT_RESULT, 696 FLT_INVA1.ID_OPERAT1ON, 696 FLT_OVERFL()W, 696 FLT_STACK_CHECK, 696 FLT_UNDERFLOW, 696
GUARD_PAGE, 695
exception handlers
added into internal list of functions, 726 executed directly by operating system, 680 registering in special table in image file, 381 syntax for, 679
understanding by example, 680-682 exception handling, 662
EXCEPTION JLLEGAUINSTRUCTION, 695
EXCEPTICN」N_PAGE_ERROR, 695
exception information, accessing, 699
EXCI:PT1ON_INT_DIVIDE_BY_ZERO. 696 EXCEPTlON_INT_OVERrLOW, 696
EXCEPTIONJNVA1.1D_D1SPOSITION.695
EXCEPTIONJNVALID.HANDLE, 223,696
EXCEPTION_MAXIMUM_PARAMETERS, 704 EXCEPT【ON_NESTED_CALL, 707 EXCEPTION_NONCONTINUABi.E_EXCEPTION, 695, 704
EXCEPT1ON-NONCONT1NUABLE Hag, 703 always used for C++ exceptions, 728 used by ! ieapAlloc, 704
EXCEPTION_POINTERS structure, 699
EXCEPTION_PRIV_INSTRUCT1ON, 695 EXCEPTION.RECORD structure, 699
pointing to, 700, 704
saving. 699
walking linked list, 704 rXCEPTION_SINGLE_STEP, 696 EXCEPTION_STACK_OVERFL()W, 454, 695 ExceptionAddress member, 701 ExceptionCode member, 700 ExceptionFlags member, 700 Exceptionlnformation member, 701, 704, 708, 735 ExceptionRecord member
of EXCEPTION_PO1NTERS siruciure, 700, 704 of EXCEPTION.RECORD structure, 700 exception-related exceptions, 695 Exceptions dialog box, 729, 731 excluded application, 737, 738 exclusive access
to ensuring queue, 270
opening binary file for, 556
specifying to file. 496
.exe file
building. 540
CreateProcess searching for, 90 execuiing startup code. 465
loading and executing DLL files, 463
loading from floppy disk, 380 locating, 464
multiple mappings, 467
passing instance of, 73
reserving region of address space for. 464 exe module. See executable module executable and DLL modules, rebasing and binding, 551 executable code, storing in heap, 524 executable file. See .exe file executable image file, 541 executable module
building, 541, 547-550
loading in user-mode partition, 373
mapped into new process, address space, 542 running, 550-552
with several DLL modules. 539 executable source code files, 548 EXECUTE attribute. 468 execution
content, containing user-defined value, 364 context, of fiber, 362
picking up with first insiruction following except block, 684
resuming after failed CPU instruction, 683
times of threads, 179-183
exit code, setting, 154
exit function, 72
exit time, relumed by GeiThreadTimes、179 ExitProcess function, 104, 105-106, 155
causing process or thread to die, 105
explicit calls to as common problem. 106 getting address of real, 638
hooking, 634
to terminate process, 564
trapping all calls ic, 638
索 引
ExitThread function, 153, 154, 166. 364, 558 avoiding, 166
causing process or thread to die, 105 explicit calls to as common problem, 106 to kill thread, 567 kills thread, 154
ExitWindowsEx function, 133 ExpandEnvironmentStrings function, 82 explicit data types, 26
explicit DLL module loading and symbol linking, 553-561
explicitly loaded DLLs, 564
Explorer.exe's address space, injecting DLL into. 610 export section, in DLL file, 545-546 exported symbol, explicitly linking, 561
EXPORTS section, 547
-exports switch (DumpBin), 545 expression parameter, 20 extended basic limit resiriction, 129 extended (Ex) version functions, 23
Extended Latin Unicode character set, 13 extended limits, on job, 132
EXTENDED_STARTUP1NFO_PRESENT flag, 95 extended versions of kernel object creation functions. 49
extern 'C modifier
in C++ code. 544
using to mix C and C++ programming, 546 extern keyword, importing symbol, 548 external manifest. 114
/F option, 451
facility codes, 698
Facility field, in error code, 7
failure, indicating for function, 7
Fast User Switching, 52
faulting process, all threads suspended, 715
fdwAllocationType parameter, 420 fdwCreate parameter
of CreateProcess, 93-95, 191 specifying priority class, 95 fdwFlags parameter
of HeapAlloc, 525
of HeapFree, 528
of HeapReAlloc, 527
of HeapSize, 527
fdwOptions parameter, 523
fdwPriority parameter, 191
fdwProtect parameter
of CreateFileMapping, 479
of VinualAlloc, 420
fdwReason parameter. 562
fiber(s), 361-367 FIBER_FLAG_FLOAT_SW1TCH. 362 Fiber Local Storage. See FLS functions FiberFunc function, 366 fields in error code, 7
FIFO algorithm. 247
file(s), 290
aciding io problem reports, 738, 745
contents broken inio sections, 466
copying other media in background, 148 direct access, 331 extremely large, 296
getting size of. 299
locating in Windows Vista, 146
mapping into two address spaces, 499 memory-mapping, 487
opening, 291
pointer, setting beyond end of file's current size, 302 reversing contents of, 488
setting end of, 302
〔ypes added (o problem reports, 745 unmapping data, 485-486 unregistering, 739
F1LE_ATTRIBUTE_ARCH1VU flag, 297
FILE_ATTRIBUTE_ENCRYPTED flag, 297
FlLE_ATrRlBUTE_HIDDLN (lag, 297
FILE_ATTR1BUTE_NORMAL flag, 297
FILE_ATTR1BUTE_NOT_CONTENT_1NDI:XED flag, 297
F1LE_ATTR1BUTE_OFFLINE flag, 297
FILE_ATTRlBUTn_READONLY flag, 297
FILH_ATTRIBUTE_SYSTEM flag, 297
FILE_ATTRIBUTE_TEMPORARY, 296, 297
file attribute flags, 297-298
FILE_BHGIN value, 301
file caching, 477
HILE-CURRENT value, 301
file data, mapping, 482-485
file desired access rights, 478
file devices, 299-302
FltE_END value, 301
FILE_FLAG_BACKUP_SEMANTICS Hag (CreateFilc), 291, 296, 298
ni.E_rLAG_DELETH_ON_CLOSL flag, 296 FILE_FLAG_NO_BUFFERING flag, 295
accessing extremely large files, 296
FileCopy opening using. 331
FILE_FLAG_OPEN_NO_RECAI.L flag, 296
FILEJ-I.AG_OPEN_REPARSE_POINT flag, 296
FI1.E_FLAG_OVERLAPPED fl明(CreaieFile), 297, 305 not specifying, 303
opening device for asynchronous I/O, 311 source file opened with, 331
FILE_FLAG_P()SIX_SEMANTICS flag, 296
F1LE_FLAG_RANDOM_ACCESS (lag, 295
F1LE_H.AG_SEQUENTIAL_SCAN fiag, 295
FILE_FLA(；_WRITE_THROUGH flag, 296, 486
file handle, checking (dr invalid, 298
file image
accessing pages in, 467
locating, 555
used as physical storage, 379
file kernel object, creating or opening, 477,478-479
场心编程（第5版）
FILE_MAP_ALL-ACCESS access right, 483 F1LE_MAP_COPY flag, 483, 486 FILE_MAP_EXECUTE access right, 483 FILE_MAP_READ access right, 483 F1LE_MAP_READ parameter, 36 FILE_MAP_WRITE access right, 483 file objects, closing, 486-487 file pointers, 300-302, 489 file resources, required for processes, 146 File Reverse application (17-FileRev.exe), 487-490 File Save As dialog box, in Notepad. 31 FILE_SHARE_DELETE value, 293
F1LE_SHARE_READ | FILE_SHARE_WRITE value. 293
FILE_SHARE_RBAD value, 293,478 FILE_SHARE_WRITE value, 293,478 FILE_SKIP_COMPLETION_PORT_ON_SUCCESS
Hag. 327 FILE_SK1P_SET_EVENT_ON_HANDLE flag, 313 F1LE_TYPE_CHAR value. 292 FII.E_TYPE_DISK value, 292 FILE_TYPE_PIPE value, 292
FILE_TYPE_UNKNOWN value, 292
FileCopy function, 331, 332
FileC'opy sample application (10-FileCopy.exe), 331 file-mapping kernel object, 477, 479-482 file-mapping objects
backed by a single data file, 495
creating. 488
multiple processes sharing, 499
naming, 482
sharing blocks of data between processes, 43 FileRev, cleaning up, 489 FileReverse function, 488
FILETIME structure. 258
filler value (Oxfd), 21
filtered process, debugging, 116
filtered token, 110
FilterFunc function, 458 flmpLoad parameter (DllMain), 562 finally block(s)
allowing to always execute, 748 ensuring execution, 664 executing code in, 689 forcing to be executed, 671 localizing cleanup code in, 669 not guaranteed to execute for any exception, 664 premaiure exit in try block, 662 putting return statement inside, 690 situations precluding execution of, 665
_finally keyword, 660
FindWindow, 607
first in, first out algorithm, 247 first-chance notification, 729, 731 fixed module, 120
/FIXED switch
of linker, 464
passing io linker, 589
FLAG_DISABLE_THREAD_SUSPENSION,736 flags
for SetErrorMode, 83
stored in process* handle table, 44 used by CompareString, 25
Flags parameter (Sleep functions), 227 flat address space, 465 flNewFrotect, 435
floaiing point-related exceptions, 696 floaiing-poim operations, performed by fiber, 362 flow of control, from try block into finally block, 663 FLS functions, 364
FlsAlloc function, 364
FlsFree function, 364
FlsGetValue function, 364
FlsSetValue function, 364
FlushFileBuffers function, 303
FlushViewOfFile function, 486
ForceClose method, of g_mmf object, 508 ForceQueue value, 712
foreground process, 195 foreign node, using RAM from, 405 FORMAT_MESSAGE_ALLOCATE_BUFFER flag, 9 FORMAT_MESSAGE_FROM_SYSTEM flag, 9 FORMAT_MESSAGE_IGNORE_1NSERTS flag, 9 FormatMessage function, 6,9
FORWARD_WM_* macro, 775 forwarded functions, 583 frame-based mechanism, SEH as, 726 free address space, 375
FREE flag, locating, 599
Free memory region type, 386
free regions, no storage commilted within, 387
FreeEnvironmentSirings function, 79,95 freeing, memory blocks, 527
FreeLibrary function, 558
called by thread, 564
called by _FUnloadDelayLoadedDLL2. 575 decrementing library's per-process usage count, 559 to free DLL containing static TLS variables, 603 from inside DUMain, 563
steps performed when called by thread, 565, 566 thread pool calling, 355
FreeLibraryAndExilThread function, 558, 559, 564 FreeLibrary-WhenCallbackReiurns function, 355 FreeUserPhysicalPages function, 442 fuErrorMode parameter, 83 fuExilCode parameter, 105, 106
full pathname, passed to LoadLibraryEx, 557 full thread stack region, 453
FuncaDoodleDoo example code, 665
Funcarama 1 example code, 667
Funcarama2 example code, 668
Funcarama3 example code, 668
Funcarama4 example code, 669
Funcensteinl example code, 660
Funcensiein2 example code, 661-^62
Funcenstein3 example code, 663
索 弓
Funcenstein4 example code, 666
Funcfurterl example code, 663
Funcfurter2 example code, 672 Funcmeisterl coding example, 680
Funcmeister2 coding example, 681 function forwarders, 583,633 function names, exporting without mangling, 547 functions
allowing one process to manipulate another, 621 for backward compatibility with 16-bit Windows, 17 for C run time to call for invalid parameter, 20 calling asynchronously, 340-346 calling at timed intervals, 346-351
calling when single kernel object becomes signaled, 351-353
creating kernel objects, 37, 38 easily calling nondeprecated, 26 hooking, 640
manipulating kernel objects, 34
for opening devices, 291-292
placing thread in alertable state, 317
with problems in mukiihreaded environments. 160 protecting code against buffer overruns, 11 from psapi.h, 144
reading environment variables, 85 requiring default heap, 520 returning INVALID_HANDLE_VALUE, 39 succeeding for several reasons, 5 used full stack space for, 459 validating parameters, 3
_FUnloadDelayLoadedDLL2 function, 575, 577
G
g_fResourcelnUse spinlock variable, 217 g_fShutdown, 234
g_mmf object, 508
g_x variable, 587
garbage collection (unction, 427, 428 garbage data. 24
GarbageColleci function, 428
GD132.dll, 537
general protection (GP) fault errors, 83
GenerateWerReport function, 741, 751 generic data types, 26
GENER1C_READ access right, 478
GENER1C.READ flag, 303
GENERIC-READ value, 293
GENERIC_WR1TE access right, 293, 478 GENER1C_WRITE flag, 303
GENERIC.WRITE value. 293 GET_MODULE-HANDLE_EX_FLAG_FROM_
ADDRESS parameter, 74
Get*CycleTime functions, 182 GetCommandLine function, 73, 76 GetCompressedFileSize function, 300 GetCPUFrequencylnMHz function, 182 GetCPUUsage function, 330
GetCurrentDirectory function, 84 GetCurrentFiber function, 364, 365
GetCurren[Process function. 63, 169, 744 GetCurrentProcessld function, 104, 170, 625 GetCurrentThread funciion, 169 GetCurrentThreadld function, 104, 170 GeiDiskFreeSpace function, 295 GeiDlgltem function, 776
GetEnvironmentStrings function, 95
retrieving complete environment block, 77 using instead of .environ, 73 CietEnvironmeniVariable function
calling by child process, 46 determining existence and value of, 81 using instead of_wenviron, 73 GetExceptionCode intrinsic function, 695-697 GeiExceptionlnformation intrinsic function, 699-702 GetExitCodeProcess function, 108, 109 CJetExitCodeThread function, 156,458 GeiFiberDaia function, 364 GetFileSizc function, 488 GeiFileSizeEx function, 299 GelFileType function, 292 GelFreeSlot private function. 230 GeiFullPathName function, 85 GetUandlelnformation function, 47 GetLargePageMinimum function, 423 GetLastError function, 4, 88
for additional information, 5
calling immediately after call to Create* function, 50 calling right away, 5
returning 2 (ERROR_FILE_NCT_FOUND), 50 returning 6 (ERRORJNVALID.HANDLE), 50 reiurning ERROR_A(：CESS_DEN1ED, 54 returning ERROR_ALREADY_EXISTS, 51 returning ERROR」NVALID JiANDLE, 39,40 GetLogicalProcessorlnformation function. 214, 397 GetMappedFileName funciion, 387 GetMessage, 613 GetMessage loop, 149 GetModulePileName function, 73, 560 GetModuleFileNameEx, 144 GeiModulellandle function, 74, 75, 559 GetModulcHandleEx function, 74 GeiModulePreferredBaseAddr function, 120 GetMsgProc function, 610 GetMsgProc parameter (SetWindowsHookEx). 609 GetNaiiveSystemlnfo function, 398 GetNewElement functions, 232 GetNexiSloi helper function, 232 GeiNextSlot private helper function, 231 CietNumaAvailableMemoryNode function, 405 GeiNumaHighesiNodeNumber function, 406 GetNumaNodeProcessorMask (unciion, 406 GetNumaProcessorNode function, 405 GeiOverlappedResult function, 314 GeiPriorityClass function, 192 GeiProcAddress function, 561
exact memory location of LoadLibraryW, 623 hooking. 639
GetProcessAffinityMask function, 204
Gows核心编程（第5版）
C «ei ProcessElevation helper function, 117 GetProcessHeaps function, 531 GeiProcessld function, 104
GeiProcessIdOfThread function, 104 GetProcesslmageFileName function, 144 GetProcesslntegrityLevel function, 123 GetProccssIoCounters function, 138
GetProcessMemorylnfo function, 407 GetProcessPriorityBoost function, 195 GetProcessTimes funciion, 138, 169, 180 _getptd_noexii function, 166
GetQueuedComplelionStatus function, 141. 324 GetQueuedCompletionSiatusEx function, 317, 326 GetQueueStatus, 367
GetStariupInfo function, 102
GeiStatus method, of CIOCP, 333 GetStdHandle, opening console, 291 CietSystemDirectory function, 550 GetSystemlnfo function, 203, 395-396, 466 GetThreadContexi function, 185, 187 GelThreadld function, 104 (JeiThreadLocale function, 24 GetThreadPrioriiy function, 193
GetThread PriorilyBoosi function, 195
GeiThreadTimes function, 169, 179 GetThreadWaitChain function, 285 GetTickCount64 function. 179、181 Getting System Version page, 86 GetTokenlnformation function, 118, 123 GetVersion function, 85
GetVersionEx function, 73,86
/GF compiler switch, 90 /Gf compiler switch, 90
Global, as reserved keyword. 53 global atom table, giving job, 133 global data variable, 688 global namespace, 51-52
Global\ prefix, 52
global replaces, performing, 26 global lask count, 345、346 global unwinds, 671,687-690 global variables
in 08-Queue.exe application, 232
altering, 466
available io programs, 73 avoiding, 597 as better choice, 599 in DLL, 538
reflecting number of instances running. 467 globally sei filter function, notifying, 708 GlobalMemoryStatus function, 404
to gel total amount of RAM, 437 listing results of call, 406
GlobalMemoryStatusEx function, 404, 441
GP fault errors, handling. 83 grandchild process, spawning, 45 granularity. See also allocation granularity; page granularity
of reserved region, 396
graphical applications, allowing fine-tuning. 81 (iraphical Device Interface (GDI) objects. 37 growable heap, 525 /GS compiler switch
in Microsoft Visual C++, 457
security features provided by, 570 taking advantage of, 27 gl_ prefix, for global TLS variables, 602 guard page, 451, 454
GUI-based applications, 68,69, 608
GUID.51
H
handle(s)
dosing to child process and thread, 103
counting in Windows Task Manager, 41 gening to device, 291
identifying kernel objeci. 34
measuring as undocumented, 39 obtaining default heap. 520 setting for existing heaps, 531
HANDLE.FLAGJNHERIT flag, 46 HANDLE_FLAG_PROTECT_FROM_CL()SE fiag, 47 IIANDLE_MSG macro
defined in WindowsX.h, 774
not using, 766
HANDLE return type, 3 handle table
flags stored in, 44
for kernel objects, 37
undocumented, 37
handle values
passing as command-line argument, 46
as process-relative, 35
14/\NDLE_WM_* macros, 775
IIANDLE_WM_COMMAND macro,775
Handles column, in Select Process Page Columns dialog box, 41
Handshake (09-Handshake.exe) application, 252 hard affinities, 203, 205 hardware exceptions, 679
HasOverlappedloCompleted macro, 307
h/\u to Reset Even tl objeci. 246 hAutoResetEventl objeci, 246 hComplelionPori parameter
of GetQueuedCompleiionStatus, 325
of GelQueuedCompletionStatusEx function, 326
of PosiQueuedCompletionStaius, 330 header annotation, 14 ''Header Annotations" documentation on MSDN, 14 header file
coding, 542
creating, 541
establishing, 542
including DLL's, 548
including in each DLL's source code files, 543
/headers switch (DumpBin), 468, 586 heap(s), 419, 519
advantage of, 519
索 引
allocating blocks of memory, 525-526 coalescing free blocks within, 532 creating additional, 523-531 destroying, 528-531 disadvantage of, 519 inheritance of, 531 reasons to create additional, 520-523 related functions, 531-533 rules for commiiUng and decommitting storage, 519 serializing access to itself, 523 using multiple, 531 using with C++, 528-531 validating integrity of, 532
HEAP_CREATE-ENABLE_EXECUTE flag, 523, 524 heap dump, custom, 745
heap functions, 703 HEAP_GENERATE_EXCEPTIONS flag, 523, 524, 525, 527
passing lo heap functions, 703
specifying, 525
/HEAP linker switch, 519 heap manager, raising exeption, 524 Hf5AP_NO_SERlALlZE flag, 523, 525, 526. 527, 528 absence of, 524 avoiding, 523 safe use of, 524
HEAP_REALLOC_IN_Pl.A(T_ONLY (lag, 527 HEAP_ZERO_MEMORY flag, 525, 527
HeapAlloc function
actions of. 523
causing to raise software exception, 525 exceptions raised by, 525
HeapCompact function, 532
HeapCreatc function, 523
HeapDestroy function, 528 HeapEnableTerminationOnCorruption parameter. 524 HeapFree function, 527
called by delete operator function, 530 calling to free memory, 77
HeapLock function, 532
HeapReAlloc function, 526
HeapS^tlnformation function, 524
HeapSize function, 527
HeapUnlock function, 532
HeapValidate function, 532
l leapWalk function, 532
hEvent member, of OVERLAPPED structure, 307 hEventMoreWorkToBeDone event, 280 hFile parameter, 301
of CancelloEx, 310
of CreateFileMapping, 479
of GetFileSizeEx, 299
of LoadLibraryEx, 555
of ReadFile and WriteFile, 303
SetFileCompletionNotificationModes function, 313 hFileMappingObject parameter, 482 hFileTemplate parameter, 298, 332 hHeap parameter
of HeapAlloc, 525
of HeapReAlloc, 527
of HeapSize, 527
hidden file, indicating, 297 high 32 bits, 481 High level of trust, 122 HIGH_PRIOR1TY_CLASS, 95, 191 high priority class, 189 high priority level, 191 higher-priority threads, 187 highest memory address, 396 highest thread priority, 190, 193 highestAvailable value, 114 high-resolution performance functions, 181 high-water marker, maintained by NTFS, 332 HINSTANCE type, 74 hlnsianceExe parameter, 73 hlnstDll parameter
containing instance handle of DLL, 562 of GeiProcAddress, 561
of SetWindowsHookEx, 609 hlnstModule parameter, 560 hint value, of symbol, 550 hjob parameter
of AssignProcessToJobObject function, 136 of UserHandleGrantAccess function, 134
HKEY_PERFORMANCE_DATA root key, 118 hmodCur member, of Deiayl.oadlnfo, 574 HMODULE type, parameter of, 74 HMODULE value, 555, 558
hObject parameter
of SetHandlelnformation, 46
of SetThreadpoolWait function, 352
of WaitForSingleObject function, 109, 243 hObjectToSignal parameter, 279 hObjectToWaitOn parameter, 279 hook functions, 576, 635 Hook_MessageBoxA function, 640 hooks
injecting DLL using, 609-616
owned by thread, 155
host machine, 395
host system, version numbers, 87 hPrevInsrance parameter, 75 hProcess parameter
of AllocateUserPhysicalPages, 441
of AssignProcessToJobObject function, 136
of CreateRemoteThread, 621
of GetExiiCodeProcess, 108
of GetProcessMemorylnfo, 407
of ReadProcessMemory, 624
in SetPriority, 191
of SeiProcessAffinityMask function, 203
of TerminateProcess, 106
of VirtualAllocExNuma, 421
of WaitForlnputldle, 278 ofWerGetFlags.737 of WerRepor tAdd Dump, 744 WriteProcessMemory, 624
WS核心编程（第5版）
hReport parameter
of WerReportAddDump, 744
of WerReportAddFile, 745
of WerReportSetParameter. 743
of WerReportSetUIOption, 746 of WerReportSubmit, 746
HRESULT, values for safe string functions, 22 hSourceHandle parameter, 61 hSourceProcessHandle parameter, 61 hStdError value, 98 hStdlnpui value, 98 hStdOutput value. 98 hTargetProcessHandle parameter, 61 hThread parameter, 204
of Cancel Synch ronouslo, 304
of GeiExitCodeThread, 156
of QueueUserAPC function. 319
of SeiThreadldealProcessor function, 205
of SetThreadPriority function, 193
of TcrminateThread, 155
of WerReporiAddDump, 744 hTimer parameter, 257 hUserObj parameter, 134 hWctSession parameter, 285 hyper-threading, 178
I
IA-64, 8-KB page size, 376
1A-64 CPU. 391
1AT (Import Address Table), updating, 638 icacls.exe Vista console mode tool, 123 icons
manually repositioning on desktop, 611 setting fbr dialog boxes, 766
ID(s)
of current process, 104
getting set of those currently in job, 139 reused immediately by system, 103 of running thread, 104
used mostly by utility applications. 103
,idaia section, 470
ideal CPU, setting for thread, 205 1DLE_PRIORITY_CLASS, 95, 191 idle priority class, 188, 189 idle thread priority, 190, 193 #ifdefs, putting into code, 702 1MAGE_F1LE_RELOCS_STR1PPED flag, 589 image files, executing from floppies, 380 Image memory region type, 386 image of .exe file, 379
image regions, displaying pathnames of files, 387 IMAGE-THUNK_DATA structures, 638
Image Walk DLL, 631-633
_ImageBase pseudo-variable, 74
ImageDirectoryEntryToData, 637 implicit linking, 540
Import Address Table (1AT), updating, 638
import section
of each DLL checked during loading, 551
embedded in executable module. 548-550
in executable module, 541
manipulating by API hooking, 636-639
parsed by executable module, 542
virtual addresses of all imporied symbols, 593 -imports switch (DumpBin), 549
Increase Scheduling Priority privilege, 189 IncreaseUserVA parameter. 374
Indexed Locations, searching, 147 indexing, by Windows Indexing Services, 146 INFINITE
passed to WaiiForSingleObject, 244
passing for dwMilliseconds, 177 infinite loop, generating, 692 infinite wait, of mutexes vs. critical sections, 268 information, storing on per-fiber basis. 364 inheritable handle, 44,92
inheritance, 81. See also child process(es); kernel object handles; object handle inheritance
heaps, 531
kernel object handle, 91 inheritance flag, 46 【nherii.cpp program, 91, 92 initial state, of mulex, 266 initialization
of mutexes vs. critical sections, 268
value, passing to thread function, 152 IniiializeCriticalSection function. 220, 223 InitializeCrilicalSection parameter, 222 InitializeCriticalSectionAndSpinCount function, 222, 223
InilializeProcThreadAtiributeList function, 101 InitializeSListHead function, 213
InitializeSRWLock function, 224 IniualizeThreadpoolEnvironment function, 358
Inject Library sample application, 625-626 injecting DLL into process' address space, 607-634 InjeciLib, 626
INNER_ELEMENT structure, 230 instance handle, 75 instruction pointer register, 157 integer-related exceptions, 696 integrity level
assigning to securable resources, 122
setting for file system resource, 123 intercepted Windows messages, 124 interlocked family of functions, 209 interlocked functions, executing extremely quickly, 210 interlocked helper functions, 213
Interlocked Singly Linked List, 213 interlocked (user-mode) functions, 277 InterlockedCompareExchange function, 212 lnterlockedCompareExchange64 function, 213 InterlockedCompareExchangePointer function, 212
InterlockedDecrement function, 213, 346
索 引
Interlocked Exchange function, 211 lnterlockedExchange64 function, 211 InterlockedExchangeAdd function, 209, 210, 213 lnterlockedExchangeAdd64 function, 209 InterlockedExchangePointer function, 211 InterlockedFlushSList function, 213 Interlockedlncrement function, 213, 345
atomically incremerning value by, 210 incrementing volatile long value, 226
InterlockedPopEntrySList function, 213 InterlockedPushEntrySList function, 213 Internal member
origin of. 307
of OVERLAPPED structure, 307, 312, 326 InternalHigh member
origin of, 307
of OVERLAPPED structure. 307. 312 international markets, targeting, 11 Internet Explorer, user canceling Web request, 304 interprocess communication, with DuplicateHandle, 62 interthread communication techniques, 330 inirinsic function, 671
INUSE flag, 600 invalid file handle, checking for, 298 invalid handle, 39,40
INVALID_HAND1.E_VA1.UE
CreateFile returning, 482 functions returning, 3 relumed by CreateFile, 479 returned if CreateFile fails. 298 returning for, 479
invalid memory
attempting to access, 674 occurring inside finally block, 704 invalid parameter, C run time detecting, 20 I/O accounting information, querying, 138 I/O completion notificauons, receiving, 310 I/O completion port(s), 289, 320-333
architecting around, 324-327
associating device with, 321, 322-324 creating, 143, 321-322
designed to work with pool of threads, 32! internal workings of, 323
as interthread communication mechanism, 289 keeping CPUs saturated with work, 328 kernel object, creating, 141 managing thread pool, 327-328 mechanism used by most applications, 262 threads assigned to specified, 328 threads monitoring, 141
for use within single process only, 322
using, 310
waking threads in waiting thread queue, 325 waking up waiting threads, 327
I/O completion queue, 324
IO_COUNTERS structure. 138
I/O notification, 330
I/O request(s)
cancel pending, 310
issuing to device driver, 315
issuing without completion entry, 324 outstanding at any one time, 332 passing to device driver, 305
priorities, 196
queuing for device driver, 305
receiving completed notifications, 310-333 simulating completed, 330
1/O-bound task, using separate thread for, 148 lOCP.h file, CIOCP class found in, 332 lolnfo member, 132
IsDebuggerPresent function, 708
IsModuleLoaded function, 577
isolated applications, taking advantage of, 586 IsOS function, 398
IsProcessInJob function, 127, 136 IsPr<KessorFeaturePreseni function, 396
IsTextUnicode function, 31, 488 IsThreadAFiber function, 364, 367
IsThreadpoolTimerSct function, 347 IsUserAnAdmin function, 118 lsWow64Process function, 94, 398
JAC-compliant applications, 115
Japanese kanji, 12
JIT debugging. See just-in-time debugging job(s)
notifications, 140-142
placing processes in, 136
placing restrictions on, 129-135
terminating all processes in, 136
job event notifications, 142
job kernel object, 125
creating, 128
filling into I/O completion port model, 289
Job Lab application (05JobLab.exe), 143-144 correct use of, 153
demonstrating I/O completion ports and job objects working together, 289
JOB_OBJECT_L1MIT_ACT1VE_PROCESS flag, 131
JOB_OBJEC7T_LIMIT_AFFINITY Hag
in LimitFlags member, 131 setting, 130
JOB_OBJEC7T_LIMIT_BREAKAWAY_OK flag, 136
JOB_OBJECT_LIM!T_BREAKAWAY_OK limit (lag, 136
JOB_OBJECT_LIM1T_DIE_ON_UNHANDLED_ EXCEPTION limit flag, 132
JOB_OBJEC7T_LIMITJOB_MEMORY flag, 132
JOB_OBJECT_LIMITJOB_TIME flag, 130, 131
JOB_OBJ[-CT_L1MIT_PRESERVEJOB_TIME flag, 130,137
JOB_OBJECT_L1MIT_PRIOR1TY_CLASS flag, 130, 131 JOB_OBJECT_LIM1T_PROCESS_MCMORY flag, 132 )OB_OBJECT.LIM1T.SCHEDULING_CLASS flag, 131
idows核心编程（第5版）
JOB_OBJECT_L1M1T_SILENT_BREAKAWAY_OK flag, 136
JOB_OBJECT_LlMiT_WORKINGSET flag, 131
JOB_OBJECT_MSG_ABNORMAL_EX1T_PROCESS notification, 142
JOB_OBJECT_MSG_ACTIVE_PROCESS_LIM1T notification, 142
JOB—OBJECT—MSG^ACTIVE—PROCESS—ZERO notification, 142
JOB_OBJECT_MSG_END_OF」OB_TIME notification, 142
JOB_OBJECT_MSG_END_OF_PROCESS_T1ME notification, 142
JOB_OBJECT_MSG_EXIT_PROCESS nottficaiion, 142 JOB_OBJECT_MSGJOB_MEMORY_L1M1T notification, 142
JOB_OBJECT_MSG_NEW_PROCESS notification, 142 JOB_OBJECT_MSG_PROCESS_MEMORY_L1M1T notification, 142
JOB_OBJECT_TERM1NATE_AT_END_OFJOB notification, 142
JOB_OBJECT_UIL1M1T_DESKTOP (lag, 133
JOB_OBJECT_U1LIM1T_D1SPLAYSETTINGS flag, 133
JOB_OBJECT_UIL1M1T_EXITWINDOWS flag, 133
JOB_OBJECT_UILIMIT_GLOBALATOMS flag. 133 JOB_OBJECT_U1LIM1TJ1ANDLES flag, 133, 134 JOB_OBJECT_U11.1MIT_READC1.1PBOARD flag. 133 JOB_OBJECT_UILIM1T_SYSTEMPARAMETERS flag, 133
JOB_OBJECT_UILIM1T_WR1TECLIPBOARD (lag, 133 job object, creating, 143
job statistics, querying, 137-144
Job tab, of Process Explorer box, 139
Job.h file, 144
jobless process, 143
JobMemoryLimit member, 132
JOBOBJECT_BAS1C_ACCOUNTING_INFORMATION structure, 137
JOBOBJECT_BASIC_AND_IO_ACCOUNTING_ INFORMATION structure, 138
JOBOBJECT_BASIC_L1MIT_INFORMAT1ON structure, 129,132
allocaiing, 129
members of, 131
SchedulingClass member, 130
JOBOBJECT_BASIC_PROCESSJD_L1ST structure, 139
JOBOBJECT_BASIC_U1_RESTRICT1ONS structure, 129, 132
JOBOBJECT_EXTENDED_L1M1T_1NFORMAT1ON structure, 129, 132
JOBOiyECT_SECURITY_LIMlTJNFORMATlON structure, 129, 135
J obObjectBasicAccountinglnformation parameter, 137
JobObjectBasicAndloAccountinglnformation parameter, 138
JobToken member, 135
JUMP instructions, as CPU-dependent, 635 just-in-time debugging, 713-715, 750
kanji, 12
kernel address space, 374
kernel interprocess communication (IPC) mechanism, 281
kernel mode, 185 kernel object(s) applications leaking, 40 binding to thread pool wait object, 352 closing, 39-43, 107,486 containing flag (wave-in-the-air), 242 creating, 38-39 creation functions, 49 gaining access to existing, 36 gelling up-to-date list of, 42 handle table for, 37 identifying, 279 kernel address space, content stored in, 45 keyed event type of, 224 managing thread, 145 manipulating, 34 monitoring number used by any application, 41 multiple namespaces for in Terminal Services, 51 naming, 48-60 outliving process, 35 owned by kernel, 35 performance of, 241 in process, 67 process boundaries, sharing across, 43-64 security descriptor, protecting, 35 sharing by name, 50 sharing names, 50 in signaled or nonsignaled state, 242 signaling and waiting for single atomic operation, 279
thread synchronization, behaving with respect to, 276-277
threads, using to synchronize, 241 types of, 33 usage count, incrementing, 45 kernel object data structures', 34 kernel object handle inheritance, 91 kernel object handles
controlling which child processes to inherit, 46 inherited by child process, 100 as process-relative, 43
kernel time, 179 Kernel32 methods, 27 KerneB2.dll, 537,571 kernel-mode CPU time, 137 kernel-mode partition, 373, 375 KEY_ALL_ACCESS, 37 KEY_QUERY_VALUE, 36 keyboard buffer, identifying, 98 keyed event type, of kernel objects, 224 keystrokes, forcing into application, 278 key/value pair, adding to attribute list, 101 known DLLs. 584-585
索 引
L, before literal string, 14
language identifier, in error code, 9 large blocks, allocating, 526 I.ARGE_INTEGER structure, 258 LARGE」NTEGER union, 299 large pages of RAM, 480 large user-mode address space, 374 /LARGEADDRESSAWARE linker switch, 374, 375 large-page support, in Windows, 422
Last Message Box Info sample application, 639-655 last-chance notification, 729, 730
last-in first-out (LIFO), threads awakened, 325
Latin 1 characters Unicode character set, 13
LB_GETCOUNT message, 776
LB_GETTEXT message, 612
LCID (locale ID), 24
IComparand parameter, 212
_leave keyword, 662
added to Microsoft,s C/C++ compiler. 669 using in try block, 670
LeaveCriticalSection function, 218, 222 forgetting calls to, 219 thread pool calling, 355
LeaveCriticaiSection-WhenCanbackReturns function, 355
legacy replacemeni functions, 20
level attribute, in <trustlnfo> 114
levels of trust, 122
.lib file
passing to linker, 548 producing, 541, 545
/Lib switch, 573
LibCMiD.lib, 159
UbCMt.lib, 159
UDistanceToMove parameter, 301
LIFO order, threads waking up in, 331
LimiiHags member, 130, 131
LineSize field, 214
LINGUIST1CJGNORECASH fiag, 25
L1NGUISTICJGNOREDIACRITIC flag, 25 UnitialCount parameter, 263 linked lists
implementing spreadsheets, 424 memory-mapped files and, 496
linker
creating executable module, 548
forcing to look for entry point function, 766
linker defined pseudo-variable, 72
linker switches
embedding inside your source code, 472 set up by Visual Studio, 69
list boxes, appending strings into, 238 LisiBox_AddString, 237
ListBox_S€tCurSel, 237
ListView control, 612
IMaximumCount parameter, 263
LOAD_IGNORE_AUTHZ_LEVEL (lag, 558
LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE Hag, 556
LOAD_i.IBRARY_AS_DATAFILE flag, 556 L()AD_L1BRARY_AS」MAGE_RESOURCE fiag, 556 LOAD_W1TH_ALTERHD_SEARCH_PATH (lag, 556-558
loader
creating virtual address space, 542, 550 fixing up all references to imported symbols, 551 mapping executable module, 550
search order, 550
searching disk drives for DLL, 550
Loadicon function, 73
LoadLibrary funciion, 555
any program can call, 472
calling for DLLs, 464
calling to load desired DLL, 62i
incrememing per-process usage count, 559 linking to DLL containing static TLS variables, 603 mixing with LoadLibraryEx, 560
steps performed when called by thread, 565 thread calling, 622
LoadLibrary macro, 622
LoadLibraryA function, 622
LoadLibraryEx function, 555, 564
avoiding calls to from inside DllMain, 563 incrementing per-process usage count, 559 mixing wilh LoadLibrary, 560
LoadLibraryW function, 622 l.oadStringA function, 17	.
local access, creating heaps for, 522
Local, as reserved keyword, 53
.local file, 585
Local' prefix, 52
Local Procedure Clall, 281 local unwind, 662, 671 locale ID, 24
LocalFile l imeToEileTime function, 258 localization
DLLs facilitating, 537
made easier by Unicode, 26
localizing applications, 11
)ock(s)
creating, 570
not holding for long time, 239
lips and techniques, 238-240
i.ock Pages in Memory user right, 423
LockCop application, 09-LockCop.exe, 281-287
LockCop tool, 287
Lockobject view, 287
logical disk drive
opening, 291
use of, 290
logical resources
accessing multiple simultaneously, 238
each with lock, 238
logical size, returning file's. 300
LONG return type, 3
indows核心编程（第5版）
long value, constructing, 773
LONGLONG variable. 405
Lovell, Martyn, 19
low 32 bits, 481
Low integrity level processes, 124
Low level of trust, 122
low priority level, thread with, 191 lower-priority thread, 427 lowest thread priority, 190, 193 low-fragmentation heap algorithm, 526 low-priority services, executing long-running. 196 low-priority thread, 196
1 Pa ram parameter, 774
IpAtlributeList field, 99
IpDcsktop value, 97
1 Period parameter, 257, 258
IpFilc field, 115
IpMaximumApplicaiionAddress member, 396
IpMinimumApplicationAddress member. 396
IpParameters field, 116
IpReserved value. 97
lpReserved2 value, 98
IPreviousCount variable, 270
IpSecurityDescripior, 36
IpTide value, 97
IpVerb field, 115
IReleaseCount parameter, 264
Istrcat. not using, 27
Istrcpy, not using, 27
M
macros, in WindowsX.h, 773
mailslot, 43, 290
mailslot client, opening, 291
mailslot server, opening, 291 main Funciion, changing to WinMain, 70 mainCRTStartup function, 69, 70 main festdependency switch, 766 maintability, in code, 15
MAK ELONG macro, from WinDef.h, 773
MAKESOFTWAREEXCEPTION macro. 765
malloc, 26, 167
malware
creating same boundary descriptor, 54 exploiting unsafe string manipulation, 18 inheriting high prixileges of Administrator, 110 isolating core components from, 52 wTiting code into areas of memory, 381
Mandatory Integriiy Control, 122
.manifest suffix, 114
manual-reset events
calling PulseEvent, 251
creating auto-reset event, 248
no successful wait side effect for, 249 signaling, 247 manual-reset timer, signaling, 257 Mapped memory region type, 386 MapUserPhysicalPages function, 441
MapViewOfFile function, 482-484
requirements for file offset parameters, 495 requiring process to call, 497
reserving different address space regions, 498 MapViewOfFileEx Function, 496,497 MapViewOfFileExNuma function, 485 master list, of error codes, 6-7
MAX_PATH characters long, 48. 294
MAX_PATH constant, defined in WinDef.h, 84 _MAX_PATH constant, in various source code, 294 MaxArchiveCount, 740 maximum number of threads, setting, 328 MAXIMUM_PROCESSORS value, 205 maximum resource count, in semaphore kernel object, 262
MAXIMUM_SUSPEND_COUNT times, 175 MAX1MUM_WA1T_OBJECTS value, 245 MaxQueueCount for WER store, 740 Medium level of trust, 122
meeting-planner type of application, 259 MEM_COMM1T flag, 422
MEM_COMM1T identifier, 421 MEM.DECOMM1T identifier, 426 MEM_LARGE_PAGE flag, 423 MEM_PHYSICAL flag, 440 MEM_RELEASE, 426
MEM_RESERVE flag, 440
MEM_RESERVE identifier, 420
MEM.RESET flag, 436, 437 MEM_TOP_DOWN flag, 420 memcpy intrinsic function, 671 memory
allocating for fiber's execution context, 362 copying pages of to paging file, 378 corruption from string manipulation, 18 determining state of regional address space, 429 DLLs conserving, 537
localizing accessses to, 522
reserving and committing all at once, 423 memory address, choosing for reserved region, 420 memory alignment faults, 83 memory architecture, of Windows, 371-393 MEMORY-BAS1CJNFORMATION structure, 409, 410 memory block(s)
changing size of, 526
freeing, 527
in kernel object, 34
obtaining size of, 527
schedulable thread with exclusive access to, 250 memory linkage, avoiding, 166
Memory Load, in VMSiat, 406
memory management
copy-on-uTite. See copy-on-write mechanism
more efficient with heaps, 521
on NUMA machines, 405-408 memory pages, protection attributes for, 381 memory regions, types of, 386 Memory.hdmp file, 735, 736
索 引
memory-mapped file desired access rights, 483 memory-mapped files, 379, 419, 476-477
backed by paging file, 499 cleaning up, 477 coherence and, 495 creating, 479 growable, 509 implementation details of, 497 processing big file using, 494-495 purposes of, 463 reversing contents of ANSI or Unicode text file, 487 sharing data among processes, 498 sharing data in. 109 sharing data with other processes. 496 sparsely committed, 504-515 specifying base address of, 496-497 using, 477-490
Memory-Mapped File Sharing application (17-MMFShare.exe), 500-501 memory-mapping, file, 487 memory-related exceptions, 695 MEMORYSTATUS structure, 404 MEMORYSTATUSEX structure, 405 MemReset.cpp listing, 437 message crackers, 773-775 cracking apart parameters, 774 using with dialog boxes. 766 in WindowsX.h file, 773 message ID, for error, 5 message queue, of a thread, 613 message text, describing error. 5
MessageBox function, hooking all calls to, 639 MessageBoxA, hooking of, 640 MessageBoxW, hooking of, 640 messages, sending to child controls, 776 MFC class library, 18 microdump, custom, 745
Microsoft C compiler. Sec C compiler
Microsoft Spyf See Spy++
Microsoft Visual C++ compiler. Sec also C++ compilers building DLL, 570
C++ exception handling, 728 syntax, 659
Microsoft Visual C++, supporting C++ exception handling, 660
Microsoft Visual Studio. See Visual Studio
Microsoft Windows. See Windows operating system minidump file
adding (o problem report, 744
custom. 745
MiniDump.mdmp file, 736 minidumps, information about, 735 minimum memory address, 396 misaligned data accesses, 392 misaligned data, code accessing, 391
MMF Sparse application (17-MMFSparse.exe), 505-515 Modified letters Unicode character set, 13
modules
binding, 592-595
determining preferred base addresses. 120
import section, strings written in ANSI. 638
Modules! menu item, in Processinfo, 120
Monitor class, 228
mouse cursor, control over, 98
MoveMemory function, 486
MSDN Web site, Getting System Version page, 86 MS-DOS application, forcing system to run, 94 MsgBoxTimeout function, 348
MsgWaitForMuhipleObjects function, 262, 279 MsgWailForMuhipIeObjectsEx function, 279, 317 MSILcode, 159
msPeriod, 347
MSVCMRt.lib. 159
MSVCR80.dll library, 159
MSVCRtD.lib, 159
MSVCRt.lib, 159
MSVCURt.lib. 159 msWindowLengih parameter, 347 multibyte-characier siring, converting, 28 MultiByteToWideChar function, 27, 28 Multimedia Class Scheduler service, 174 multiple paging files, 380
multiple processes, sharing data with each other, 463 multiple threads
accessing shared resource, 207 communicating with each other easily, 150 scheduling, 174
using judiciously, 149
multiprocessor environment, 214 multithreaded applications, debugging, 281 multithreaded environmeni
_icsiok_s function in, 597
working asynchronously, 207 mukithreading, allowing simplification, 148 multithreading operating system, benefits of, 148 mutex kernel objects, 265-271
checks and changes performed atomically, 266 creating, 265
rules fbr, 265
mutex object, creating, 44
mutexes
abandoned, 267
compared to critical sections, 267 ensuring exclusive access, 265 as slower than critical sections, 265
special exception to normal kernel object rules, 266 thread ownership concept for, 267
threads in different processes synchronizing execution, 43
tracked by WCT, 28】
violating normal rules, 265
as worst performing, 226
MWMO.ALERTABLE flag. 317
WS核心编程（第5版）
name uniqueness, ensuring, 51
named kernel objects, functions creating, 48 named objects
forcing to go into global namespace, 52 preventing multiple instances of applications, 51 named pipe clieni, 291 named pipes, 43, 290 named pipe server, 291 namespaces
closing with existing objects, 60
private, 53-60 nanoseconds, measuring, 258 nCmdShow. 99 nested exceptions, 700, 707 .NET framework
easily integrating with, 26
encoding all characters and strings, 12
NetMsg.dll module, 9 network drives, 380 network share, passed to Load Library Ex, 557 new operator, calling in C++, 528 new operator function, 530 nMainRetVal, 72 nNumberOlArguments parameter, 704 nNumBytesToRead parameter, 303 nNumBytesToWrite parameter, 303 non-consiant string, 89 none-gleton application, 53 nonfikered security token, 111 nonfiltered token, grabbing, 118 non-real-time priority class, thread in, 190 nonreentrant function, 153 nonsignaled state, 241 changing event to, 249 object sei io, 157
Non-Uniform Memory Access. See NUMA non-Visual C++ tools, creating DLLs for use with, 546 No-Read-Up, 124
NORM.1GNORECASE (lag, 25 NORMJGNORPKANATYPE flag, 25 NORM_IGNORENONSPACE flag, 25 NORM」GNORESYMBOLS flag, 25 NORMJGNOREWIDTH flag, 25 NORMAL_PR1OR1TY_CLASS, 95, 191 normal priority class, 189 normal thread priority, 190, 193 Notepad
command line, 91 opening both Unicode and ANSI files, 31 property page for shortcut running, 99, 100 spawning instance of, 489 notifications
about jobs. 140-142 more advanced, 14i nPriority parameter, 193 NTFS
creating file on, 294
support for sparse files, 505 NtQuerylnformaiionProcess, 122 NULL return value. 3
NULL-poinier assignment partition, 372
_nulherminated prefix, 14
NUMA machines
applications running on, 485
forcing virtual memory to particular node, 421 memory management on, 405-408
NUMA (Non-Uniform Memory Access), 203 Number Of Processors check box, 206 number pool, for system IDs, 103 Numberparameters member, 701、704
o
.obj module, producing, 541 object handle inheritance, 43-47 object handles, duplicating, 60-64 object inhericance. See object handle inheritance object names, creating unique, 51 objects
creating separate heaps for, 521
managing linked list of, 218
process termination cleaning up, 40
ObjectStatus field, 287
ObjectType field, 286
offline storage, 296, 297
OfTsel member, 306
Offsedligh member, 306
OLE applications, 188
one-file one-buffer method, 476
one-file (wo-buffer method, 476 one-file zero-buffer method, 477
_onexit function, 72
OPEN.ALWAYS value, 294
Open command, 278
OPEN-EXISTING value, 294
Open* functions, 50
OpenEvent function, 249
OpenFile function, 17
OpenFileMapping function, 36, 501 OpenJobObject function, 128
OpenMuiex funciion, 266 OpenPrivaieNamespace function. 60 OpenSemaphore function, 263
OpenThread function, 177 OpenThreadWaitChainSession function, 284 OpenWaitableTimer function, 256
operating system
file, indicating, 297
freeing memory, 104, 154
locating free page of memory in RAM, 378 products, identifying, 87
scheduling threads, 67,68
upgrades, effects on bound modules, 595 operations
always performed synchronously, 308 performing at certain times, 256
索 引
order of execution, in SEH, 689 ordinal number, specifying, 561 ordinal values, 546
OS_WOW6432, passing as parameter, 398 _osver global variable, 73
OSVERSIONINFO structure, 86 OSVERS1ONINFOEX structure, 86, 87 OVERLAPPED_ENTRY. 326
OVERLAPPED structure, 306-307
allocating and initializing unique. 309
C++ class derived from, 307 members initialized, 311 members of, 306 not moving or destroying, 309 OverlappedCompletionRoutine callback function, 354 over-the-shoulder logon, 112 overuTiting code, hooking by, 635 overwriting, protecting against accidental, 455
P
page(s), 376
ahering rights of, 435 committing physical storage in, 376 swapping in and out of memory, 378 writable, 382
page commit information, tracking. 425 PAGE_EXECUTE_* protections, 381 PAGE_EXECUTE_READ protection attribute, 381. 480 PAGE_EXECUTE_READWR1TE protection attribute, 381. 382, 480
PAGE_EXECUTE_WRITECOPY protccuon attribute, 381, 382
PAGE_EXECUTE protection attribute, 381 page faults, 137,378
page frame number, 441
page granularity, 425, 426
PAGE_GUARD protection attribute, 383, 390,411 PAGE_NOACCESS protection attribute, 381, 435 PAGE_NOCACHE protection attribute flag, 382, 390 PAGE_NOCACHE section attribute, 479 PAGE_READONLY protection attribute, 381, 480 PAGE_READWRITE protection attribute, 381, 421, 422.480
assigned to region and committed storage. 422 assigning, 382
page protection for stack's region, 451 passing io VinualAlloc, 440 passing with CreateFileMapping, 482 page size
address space reserved as multiple of, 376 showing CPU's, 396
PAGE_WRITECOMBINE protection attribute flag, 383, 390
PAGE_WR1TECOPY protection auribute, 381, 480 changing to PAC；E_READWR1TE, 484 conserving RAM usage and paging file space, 382 page-locked storage requirement, 308 page-sized threshold, controlling, 457
paging file(s)
backing memory-mapped files, 499
on disk, 377
maximum number of bytes, 407
no storage required from, 594
physical storage not maintained, 379-380 size of system's, 378
using multiple, 380
parallel port
opening, 291
use of, 290
parameter not referenced warning, 76
parent process
adding environment variable, 46
debugging child process, 93
determining, 104
forgetting io close handle to child process, 108 handle table, copying, 45
obtaining its current directories, 85
passing handle value as command-line argument, 46 preventing child process from inheriting error mode, 83
setting child process' current drive and directory, 95 spawning child process, 44, 278
waiting for child to complete initialization, 46 parent-child relationship, of processes, 43 parent's thread, 278
pArguments parameter, 704
ParseThread method
executing for each thread of, 286
as heart of wait chain traversal, 284
ParseThreads function, 282, 284 partition tables, 291 partitions, 372-375 pathname, with CreaieFile, 294 pAttributeList parameier, 101
PAUSE assembly language instruction, 178 paused thread list, moving thread's ID to, 327 pblsCycle parameter, 285
pcchRemaining parameter, 23 pCompletionKey parameter, 141 pCompleuonPortEntries array parameter, 326 pConditionVariable parameter, 227
pConiexi parameter, 285
pde parameter, 279 pDefauliChar parameter, 29 pDueTime parameter, 257, 258 pDumpCustomOpiions parameter, 745 pdwExitCode parameter
of GeilixitCodeProcess, 108
of GetExitCodeThread, 156 pdwFlags parameter, 47 pdwNumBytes parameters, 303 pdwNumBytesRead parameter, 624 pdwNumBytesWriiten parameter, 624 pdwProcessAffinityMask parameter, 204 pdw ReturnSize parameter, 135 pdwSysiemAffinityMask parameter, 204
■^^^idows核心编程（第5版）
pdwThreadID parameter. 153
PE file, mapping. 387
PE header, 451
PeakJobMemoryUsed member, 132 PeakProcessMemoryUsed member, 132 PeakWorkingSetSize field, 408
PEB (process environment block), 121, 376 pei parameter, 745
Pentium floating-point bug, 204
percent signs (%), 82 performance counters. 139 Performance Data database. 118
Performance Data Helper function library (PDH.dll), 139
Performance Data Helper set of functions, 118 performance, of mutexes vs, critical sections, 268 Performance Options dialog box, 195 periodic timer, selling, 351
PeiJoblJserTimeLimii member, 131 PerProcessUserTimeLimil member, 131 persistent mechanism for communication, 104 pExceptionParam parameter, 744 pflOldProtect parameter, 435 pfnAPC parameter, 319 pfnCallback parameter, 340 pfnCur member, 574
PfnDliHook type. 576 pfnHandler parameter, 726 pfn RecoveryCZallback parameter, 756 pfnStartAddr parameter
of CreateRemoteThread, 621
of CreateThread. 152, 157
pfnSiaiusRoutine parameter, 593 pfnTimerCallback parameter, 346 pfnWorkHandler parameter, 341 pfiDueTime parameter, 347 pftTimeout parameter, 352 pHJsedDefauhChar parameter, 29 _pgmptr global variable. 73 pHandler parameter
of RemoveVectoredContinueHandler, 727
of Remove Vectored ExceptionHandler, 727 phObjects parameter, 245 phTargetHandle parameter, 61 physical disk drive, 290, 291 physical memory, allocating. 406,441 physical size, returning file's, 300 physical storage
address, translating virtual address to, 379 assigning or mapping, 372
committing, 421, 424, 499, 505 contents, resetting, 435
data stored in paging file on disk drive, 378 decommitting, 426
methods for determining whether to commit, 425 paging file, not maintained in, 379-380 process, currently in use by, 407
region, reserving and committing, 437
region, wiihin, 376
thread's stack, freeing for, 459
type of, 390,409,411
pidd member, of Delay Load Info, 575
Ping server, 320
plnstance parameter, 355
platform
DLLs resolving differences, 538
supported by current system, 87 plDesiination parameter, 212 pliFileSize parameter, 299 pMuhiByteStr parameter
of MukiByteToWideChar function, 28
of WideCharToMukiByte function, 28 pNodeCount parameter, 285 pNodelnfoArray parameter, 285 pNumArgs parameter, 77 pNumBytesTransferred parameter, 141 pointer variables, 393 pointers, using to reference memory, 605 POL!CY_NEW_PROCESS_MIN security token, 124 POL1CY_NO_WRITE：_UP security token, 124 polling, 216 pool of threads, 321 Portable Executable file format, 546 POSIX subsystem, 91, 296
PostMessage, 124
PostQueuedCompletionStaius function, 262,330, 340 PostThread Message, 613 pOverlapped parameter
of CancelloEx, 310
of GetQueuedCompletionStatus function, 141
of PosiQueuedCompleiionSiatus, 330
of ReadFile and WriteFile, 303
ppfn member, 575
ppiProclnlb parameter, 92, 102 pPreviousValue parameter, 101 ppszDestEnd parameter, 23 #pragma data_seg line, 470 pragma directive
taking advantage of function forwarders, 583
tricking by using macros, 763
pragma, forcing linker to look for entry-point function. 766
pragma message Helper macro, 763
#pragma warning directive, 762 preemptive multithreaded environment, 208 preemptive muhithreading operating system, 174 preemptive multithreading system, Windows as, 152 preferred base address
drawbacks when module cannot load at, 588
of every executable and DLL module, 586 importance of, 589
starling on allocation-granularity boundary, 590 pReportlnhrmation parameter, 743 Preserve Job Time When Applying Limits check box, 143
pResuk parameter, 32
索 引
pReturnSize parameter, 101
primary thread, 67
closing its handle to new thread, 458
creating, 146
creating process', 563
entry-point function returning, 104
examining summation thread's exit code, 458 safely calling any of C/C++ run-time functions, 167 waiting for server thread to die, 253 primary thread object, 109 printf family functions, avoiding, 27 priorities
abstract view, 188-191
programming, 191-198
of threads, 187 priority 0, for thread, 188 priority boosting, 194 priority classes
assigning for applications, 188
for processes. 191
processes attempting to alter, 192
set by fdwCreate, 95
specifying for all processes, 131
supported by Windows, 188
priority inversion, avoiding, 196
priority levels, 189
priority number, for every thread, 187
PriorityClass member, 131
private address space, 464
Private memory region type, 386
private namespace, 53-60
creating, 59
as directory to create kernel objects, 60
name only visible within process, 60 PR1VATE_NAMESPACE_F1.AG_DESTROY.60 private regions, identifying data in, 387 PrivateUsage field, 4()8 privileges elevation, 113
PrivilegesToDelete member, 135 problem reports
closing, 748
creating and customizing, 740-751
customizing within process, 738-739
default parameters for, 744
enumerating application,s, 740
submission customization. 747
submitting, 746-747
types of file added to, 739 PROC_THREAD_ATTRIBUTE_11AND1.E_L1ST, 100.
101
PROC_THREAD_ATTR1BUTE_PARENT_PROCESS, 100, 101
processes)
address space, 482
affinity mask, 204
allocating memory in, 623
associated with jobs, 127
attempting I。commit storage over job's limit, 142
command line in, 76
communicating with process outside of job, 134 container of, 125
converting pseudohandle to real, 172
creating child, 109
creating with CreateProcess, 89
creating with suspended primary thread, 93 customizing problem reports within, 738-739 default heap, 519	-
defined, 67
each getting its own partition, 373 elevating automatically, 113 elevating by hand, 115-116 enumerating running, 118 environment block associated with, 77 error mode, 83 hooking other, 605 as inert, 145 minimum and maximum, 131 no leaks after termination, 107 obtaining handle to existing mutex, 266 obtaining information about job, 135 parent-child relationship, 43 placing in job, 136 priority classes, 191 private address space for each, 605 reading from and writing to another, 624 resources required by, 146 seeing integrity level of, 123 setting its own priority class to idle, 192 sharing named kernel objects, 49 silently terminating, 709
specifying maximum concurrent, 131 suspending and resuming. 176-177 terminating, 104-108, 155 terminating all in job, 136 total number of in job, 138 tracked by WCT, 281 tracking current drive and directory, 84 transferring data between different, 109 using fiat address spaces, 465 virtual address space, 371 process boundaries
breaking through, 605
elevating privileges on, 111 mutexes vs. critical sections, 268 process environment block. See FEB Process Explorer tool
delecting new kernel objects in, 42
finding keyed event, 224
from Sysinternals, 41-43, 123, 139 PROCESSJ IEAP_ENTRY structure, 533 process IDs, 103, 625 PROCESS_INFORMAT1ON structure, 102, 103 process insiance handle. 73-75 process kernel objects
becoming signaled. 109 creating, 61, 89,91, 464
m^dows核心编程（第5版）
process kernel objects, continued decrementing usage count, 105 living at least as long as process, 107 never changing back to nonsignaled, 242 registering wail on, 353 rules Microsoft defined for, 242 status as signaled, 107 unique ID assigned to, 103 usage count decremented, 107
PR()CESS_MEMORY_COUNTERS_EX structure. 407
PROCESS_MODE_BACKGROUND_END, 196 process priority class, 191
PROCESS_QUERY_INFORMATION access right, 407 process' lime usage, thread querying its, 169 PROC：ESS_VM_RiiAD access right, 407 Process32First function, 119
Process32Nexi function, 119
PROCESSENTRY32 structure, 104
ProcessldToSessionld function, 52
Processinfo application (04-Processlnfo.exe), 119
Processlnfo.exe tool, 592 processing time, saved by SignalObjeciAndWait, 280 ProcessMemoryLimit member. 132 processor
affiniiy, 83, 205
architecture, 396
frequency, 182 process-relative handles, 39, 43 ProgMan window, 612
Program Compaiibility Assistant, 128 programmatic strings, comparing, 27 programmatic Windows error reporting, 736-738 programming priorities, 191-198 programming problem, solved by 1 landshake, 252 programs
methods of implementing, 476
readability improved by termination handlers, 672 project management, DLLs simplifying, 537 project properties dialog box, 159 project t)7)e, selecting wrong, 70 properties, displaying for thread, 173 properly page, for shortcut running Notepad, 100 Protect member, 409 protected handle, thread closing during debugging, 47 protected processes, 122 protection attribute flags, 382
associated with block, 390
not using when reserved regions, 421
protection attributes
assigning, 421, 422
associated with regions, 420
changing, 434
listing of, 421
locating hard-to-find bugs, 435
for pages of physical storage, 381-383
for region, 387
specifying, 479
psa parameter
of CreateFile, 294
of CreateFileMapping, 479
of C'reaieSemaphore, 263
of CreateThread, 151
PSAPI functions, 387
psaProcess parameter, 91-92 psaThread parameter, 91-92 PSECURITY_ATTR1BUTES parameter, 37 pseudocode
_beginthreadex source code, 161
showing whai stack-checking function does, 456 pseudohandle
closing, 60
converting to real handle, 170-172 convening lo real process handle, 172 as handle to current thread, 170 passing to Windows function, 169 returning, 59
psiStartlnfo parameter, 96-102 pSize, 101 pSubmiiResult parameter, 747 pszApplicationName parameter, 89-91 pszCmdLine parameter
in CommandLincToArgvW, 77
not writing into. 76
of WinMain, 76
of (w)WinMain, 91 pszCommandLine parameter, 89-91 pszCurDir parameter, 95 pszDl.LPathName parameter, 556-558 pszDst parameter, 82 pszFileName parameter, 478 pszModule parameter, 74 pszName parameter
of CreateFile, 292
of CreateFileMapping, 482
of CreateSemaphore, 263
in functions naming kernel objects, 48	•.
of GetEnvironmencVariable, 81
of Open* functions, 50
of Open Event, 249
of SeiEnvironmentVariable, 83 pszPathNaine parameter, 560 pszSrc parameter. 82 pszSymboiName parameter, 561 pszValue parameter
of GetEnvironmentVariable, 81
of SetEnvironmeniVariable, 83 pTimer parameter
of SetThreadpoolTimer function, 347
of TimerCallback, 346
P1T_CAI.LBACK_ENV1RON parameter
passing, 356
of TrySubmitThreadPoolCaRback, 340 PTP_CALLBACK_ENVIRON structure, 359 PTP_CALLBACK_INSTANCE data type. 355 PTP_POOL value, 356, 358 PTP_WORK object, 342 pulNumHntriesRemoved parameter, 326 pui RAM Pages parameter, 441
索 引
PulseEvern function, 251, 280, 353
Put P1D In Job, in Job Lab sample, 143 pvAddress parameter, 435
of VirtualAlloc, 419
of VirtualFree, 426
of WerRegisterMemoryBlock, 738 pvAddressRemote parameter, 624 pvAddressWindow parameter, 442 pvBaseAddress parameter
of MapViewOfFileEx, 496
of UnmapViewOfFile, 485 pvBlkBaseAddress member, 411 pvBoundaryDescriptor, 59 pvBuffer parameter
of IsTcxtUnicode, 32
of ReadFile and WriteFile, 303 pvBuffer!.ocal parameter. 624 pvCon【ext parameter, 346
of Create I hreadpoolWork function. 341 of TrySubmitThreadPoolCallback, 340 pvEnvironment parameter, 95 pvFiberExecutionContext parameter
of DeleteFiber, 364
of SwitchToFiber, 363
pvMem parameter
of HeapReAlloc, 527
of Heap Validate, 532
PVOID return type. 3
pvParam parameter
of CreateThread, 152, 157, 171
passedCreateThread, 158 pvParameter parameter, 756 pvRgnBaseAddress member, 411 pvTlsValue parameter, 599 pWailhem parameter, 352 pWideCharStr parameter
with Multi By teToWideChar function, 28
of WideCharToMultiByie function, 28 pWork parameter, 341 pwzCommandLine parameter, 755 pwz Even [Type parameter, 742 pwzExeName parameter, 737 pwzFilename parameter
ofWerRegisterFile, 739
of WerReportAddFile, 745 pwzName parameter, 743 pwzValue parameter
of WerReportSetParameter, 743
of WerReportSetUIOption, 746
Q
quantums, 67, 68
QueryDepthSList function, 213
QuerylnformationJobObject
calling at any time, 138
retrieving completion key and completion port handle, 141
QuerylnformaiionJobObject function, 135,137
QueryPerfbrmanceCounter function. 181
QueryPerformanceFrequency function, 181
QueryPr<x:essCycleTime function, 181, 183 QueryThreadCycleTime function, 181 question mark default character, 29
queue
associated with thread, 315
controlling with mutex and semaphore, 268
Queue (08-Queue.exe) application, 228
Queue (09-Queue.exe) application, 268-271 queue data siructure. 269
queue implementation, 229-232
queued device I/O requests, 309
QueueUserAPC function, 318, 319 quick free, with heaps, 523
R
RaiseException function. 703-704, 728
RAM. See also memory
adding to improve performance, 408 allocating, never swapped, 439 finding free page of memory in, 382 forcing heavy demand on, 437 performance boost from adding, 378 portions saved to paging file, 378 swapping(o system's paging file. 435 RAM blocks
accessing via address windows, 440
assigning to address windows, 439, 443
freeing, 442
unassigning current, 442
.rdata section, 470
_rdtsc intrinsic function, 181
READ attribute, 468
ReadDirectoryChangesW function, 17 reader threads, waking up all, 228 readers、distinguishing from writers, 224 reader-writer lock, 238
ReadFile function, 302, 306
ReadFileEx function, 315
read-only data, separating from read-write data, 214 read-only files
as good candidates for memory-mapped files, 496 indicating, 297
read-only handle, 64
ReadProcessMemory function, 624
ReadTimeStampCounier macro, 181 real-time operating system, !74 real-time priority, 197
REALTIME_PR1ORITY_CLASS, 95, 191 real-time priority class, 189. 190 real-time range, 194
Rebase.exe utility, 590
ReBaseimage function, 591-592 rebasing
implementing, 591-592
modules, 586-592
recalculation fiber, 366
recalculation thread, 366 recursion counter, 265
f^^ndows垓心编程（第5版）
Refresh function, 416
regFileType parameter. 739
regions
in address space, 375, 379
committing physical storage within, 376 displaying blocks inside, 388 number of blocks within, 387 number of bytes reserved for, 387 protection attributes for, 387 reserving, 419, 420
reserving and committing storage to, 422
RegionSize member, 409
register on host CPU, 183
RegisterApplicationRecoverCallback function, 756 RegisterApplicationResiart function, 755 registered event, signaling using PulseEvent, 353 RegisterWaitChainCOMCallback function, 283 registry
injecting DLL using, 608-609 keys, continuing environment strings. 80 registry functions modifying entries, 81 settings for WER store, 740
RegNotifyChangeKeyValue funcuon, 357
RegOpen Key Ex function, 36
RegQueryValueEx registry function, 118 relative thread priorities, 189, 190, 193. See also thread priority boosting
relative virtual address, 545, 556
release build
replacing assertion dialog box, 20
setting /GS compiler switch, 457
release, of muiexes vs. critical sections, 268
released thread list, 327
ReleaseMutex function, 266, 267
called by Append, 270
system calling, 570 thread pool calling, 355
ReleaseMuiex-WhenCallbackReturns function. 355
ReleaseSemaphore function, 264, 270 allowing or disallowing, 49 in finally block, 664 putting call into termination handler. 662 thread pool calling, 355
ReleaseSemaphore-WhenCallbackRcturns function, 355
ReleaseSRWLockExclusive function, 224, 234
ReleaseSRW1 .ockShared function, 225, 236 releasing region, 376. 426
Reliability and Performance Monitor, 139
.reloc section, 470
relocating, executable (or DLL) module. 588 relocations, creating image without, 589 remote process, terminating, 187 remote threads, injeciing DLL using, 621-633 Remove method, 270
RemoveVectoredContinueHandler function, 727 RemoveVectoredExceptionHandler function, 727 REP NOP instruction, 178
reparse attribute, 296
replaceable strings, 82
ReplacelATEntrylnAllMods function, 638
ReplacelATEntrylnOneMod function, 637, 638
report generation and sending, disabling for WER, 737 report parameters, setting, 743
ReportPauk function, 748
repType parameter, 743
repUlTypelD parameter, 746 requests
server threads consuming, 234-236
submitting io thread pools, 340 requireAdminisirator value, 114 reserve argument, 151 reserved keywords
Global, 53
Local, 53
Session, 53
reserved region
committing storage in, 421
releasing, 426
reserved space, for thread's slack, 151
reserving, region of address space, 375
ResetEvent, 249
_reseiskoflow function, 454,459
resetting, of physical storage, 435 resource(s)
counting, 262
easily manipulating, 26
leaking. 40
resource compiler, output file, 17
resource handles, initializing, 670
resource leaks
avoiding, 103
eliminating poiential, 487
resource locks, entering in exactly same order, 239 resource policies, 124
resource sharing, DLLs facilitating, 537 resource-only DLLs, loading, 589 restart aware applications, 754
Restart Manager API, 755
RestrictedSids member, 135
restrictions
placing on job's processes, 129-135
querying job's, 135
on server clients, 125
types of, 129
ResumeThread function, 93, 175, 193
resumptive exception handling, 729
return code of 6 (ERROR_INVALID_HANDLE), 49
return statements
avoiding putting into try block, 669
in finally block, 690
return value
data types for Windows functions, 3
indicating error, 4
reversed file, forcing to end, 489
RgnSize member, 411
索 引
RobustHowManyToken function, 685 RobustMemDup function, 686 root directory, as current directory, 84 .rsrc section, 470
RT.MANIFEST, 114 /RTC switches, 457 /RTCs compiler switch, 27 /RTCsu compiler switch, 457 /RTCx Hags, 22
RTL_SRWLOCK, 224 RTL_USER_PROCESS_PARAMETERS structure, 121 RtlUserThreadStarl function
calling C/C++ run-time library's startup code, 158 calling Exi [Process, 158 calling ExitThread, 158
exported by NTDLL.dll module, 157-158 prototyped as returning VOID, 158 thread's instruction pointer sei to. 157 rule of thumb, for creating threads, 324 Run As Administrator command. 111 run time, detecting stack corruptions, 457 runnable threads, in concurrent model, 320 running processes, enumerating. 118 running thread, operating system memory hidden from, 371 run-time checks, 22 run-lime library, 159 Russinovich, Mark, 113
RVA (relative virtual address), 545, 556
s
_s (secure) suffix, 19
SACL, 122
safe string functions
always working with, 27
of C run time, 79
HRESULT values, 22
Safer. See WinSafer /5AFESEH linker switch, 381 sample applications in this book, build environment, 761-767
sandbox
running applications in, 375
setting up, 129 scalable application, 289 schedulable threads
with exclusive access to memory block, 250 system scheduling only, 174 scheduler
not fully documenting, 188
tweaking for foreground process, 195 scheduling algorithm
applications not designing to require specific knowledge of, 193
effect on types of applications run, 188 as subject io change, 188
Scheduling Lab application (07-SchedLab.exe), 197 SchedulingClass member, 130,131, 132
scripts, 13
search algorithm, for finding DLL files, 556 Search window, invoking, 147 searching features, in Microsoft Windows Vista, 146 SEC-COMMIT flag. 504
SEC_COMMIT section attribute, 480 SEC_IMAGE section attribute, 480 SEC_LARGE_PAGES section attribute, 480 SEC_NOCACHE section attribute, 479 SEC_RESERVE flag
specifying in CreateFileMapping, 504 with VirtualAlloc, 505
SEC_RESERVE section attribuie, 480 secondary threads, entry-point function for, 149 section(s)
attributes associated, 467 creating, 470
in every .exe or DLL file image, 467 section attributes, 479 section names
beginning with period, 467
and purposes, 470
/SECTION switch. 471 secure (_s) functions, 19 secure string functions
in C run-time library, 18-25
introducing, 19-22 manipulating Unicode strings via, 11 secure use of Unicode strings, 11 security access Hags, 37 security access information, 36 SECURITY_ATTR1BUTES structure, 44
containing blnheritHandle field sei lo TRUE, 100 example, 36
for file-mapping kernel object, 479
functions creating kernel objects with pointer to, 35 initializing. 36
passed in CreatePrivateNamespace, 59 pointer, 151
pointing to. 294
for psaProcess and psaThread parameters, 91 SECURITY_BUILTIN_DOMAIN_RID parameter, 59 security confirmation dialog boxes, 111 security descriptor, protecting kernel objects. 35 security, for kernel objects, 35-37 security identifier (SID), 54, 59 security limit restriction, 129 security restrictions, 135 SecurityLimitFlags member, 135 segment registers, identifying, 185 SEH frame
in BaseThreadStart. 707 handling exceptions, 158 placing around thread function, 165 SEH (structured execution handling)
available in any programming language, 727 burden falling on compiler, 659 consisting of two main capabilities, 660
WS核心编程（第5版）
SEH (structured execution handling), continued developers avoiding, 702 frame around thread function, 158 illustrating most confusing aspects of. 688 order of execution, 689 using, 425, 716 in Windows, 381 as Windows-specific, 703
SEH termination handler, adding, 668
SEHTerm application (23-SEHTerm.exe), 673-676 Select Columns dialog box, 41
Select Process Page Columns dialog box, 40
SEM_FAILCR1TICALERRORS flag, 83 SEM_NOAL1GNMENTFAULTEXCEPT flag
* of SetErrorMode, 83
setting, 392
SEM_NOGPFAULTERRORBOX flag, 83, 132
SEM_NOOPENFILERRORBOX flag, 83 semaphore(s)
successfully waiting on, 270
synchronizing execution, 43
semaphore kernel objects, 262-264 creating, 263
process-relative handles to, 263 rules for, 263
tracking number of elements in queue, 270
SEMAPHORE_MOD1FY_STATE, 49
SendMessage, 124, 281
sensitive user data, 745
serial model, 320
serial port
opening, 291
use of, 290
serialized calls, to DllMain, 567-570
server applications, requiring more and more memory, 439
server clients, restrictions on, 125
server threads
calling GetNewElement, 231
calling Remove method, 270
consuming requests by, 234-236 created by Queue, 229
Server Threads list box, 269
ServerThread function, 252
service applications
models for architecting, 320
using concurrent model, 320
using single I/O completion port, 325
service pack
major version number of, 87
minor version number of, 87
Session 0 isolation, 52
Session, as reserved keyword, 53
Set Affinity menu item, 206
_set_abort_behavior function, 705 _set_invalid_parameier_handler, 20
SetCommConfig, 291
SetCriticalSectionSpinCount function, 223
SetCurrentDirectory function, 85
SetDllDirectory function, 557
SetEndOfFile function, 302, 332, 489, 509
SetEnvironmentVariable function, 83,85 SetErrorMode function, 83, 392
SetEvent function, 249, 312
called by debugger, 715
making waiting threads schedulable, 251 primary thread calling, 250
thread pool calling, 355 SetEvent-WhenCallbackReturns function, 355 SetFileCompleiionNotificationModes function, 313, 327
SetFilelnformationByHandle function, 196 SetFilePointer function, 509
SetFilePointerEx function, 301-302, 332
SetHandlelnformation function, 46
SetlnformationJobObject function, 129, 141
failing, 135
resetting job object, 140
/setintegritylevel command-line switch, 123 SetLastError function, 7
SetMailslotlnfo function, 292
SetPriorityClass function, 192
to alter priority, 192
child process calling, 191
passing PROCESS_MODE_BACKGROUND_END, 196
process calling, 131
SetProcessAffinityMask function, 203
SetProcessPriorityBoost function, 194 SeiProcessWorkingSetSize function, 308
SetSize member, 131
SetThreadAffinityMask function, 204
SetThreadContext function, 186, 187
SetThreadldealProcessor function, 205
SetThreadpoolCallbackCleanupGroup function, 359 SetThreadpooICallbackLibrary function, 358 SeiThreadpoolOllbackPool function, 358
SetThreadpoolCallbackRunsLong function, 358 SetThreadpoolThreadMaximum function, 357
SetThreadpoolThreadMinimum function, 357 SetThreadpoolTimer function, 346, 347, 348 SetThreadpoolWait function, 352, 353 SeiThreadPriority function, 193, 196
SetThreadPriorityBoost function, 194 SetThreadStackGuarantee function, 454 SetUnhandledExceptionFilter function, 705, 706 setup program, beginning with one floppy, 380 SetWaitableTimer function, 257-259
SetWindowLongPtr function, 605, 610 SetWindowsHookEx function, 609
SHARED attribute, 468
shared objects, protecting against hyacking, 53 shared sections, Microsoft discouraging, 472 ShellExecuteEx function, 115, 116
SHELLEXECUTEINFO structure, 115
SHGetStocklconlnfo, 118
索 引
shield icon, 113,118
ShlwApi.h file, 24
ShowWindow function, 97,99
SID (security identifier), 54, 59 side effect, applying, 246 side-by-side assemblies, 586 SidsToDisable member, 135 signal function, 165, 167, 168 signaled object, 109 signaled process kernel object, 242 signaled state, 241, 249
SignalObjectAndWait function, 279, 317 single-CPU machines, avoiding spinlocks on, 211 single-tasking synchronization, 108
Singleton application, 03-Singleton.exe, 53 Singleton.cpp module, 54
size argument (_aligned_malloc). 210
size parameter, for C+ new operator, 529 SIZE.T variable. 101 sizeof operator, 22 sizeof(wchar_t), 28
Sleep, 177,211
Sleep field, 197
SleepConditionVariableCS function, 227 SleepConditionVariableSRW function, 227 releasing g_srwLock passed as parameter, 234 thread blocking on, 236
SleepEx function, 317
slim reader-writer locks. See SRWLock
SNDMSG macro, 776 socket, 290, 291 soft affinity, 203 software exceptions, 679, 702-704 creating codes for, 765 generating your own, 704 trapping, 703	,
Software Restriction Policies. See WinSafer
SORT_STRINGSORT flag, 25 source code
assuming pointers to be 32-bii values, 374 compiling, 15
examining samples to demonstrate SEH, 660 modules, 538
of simple program calling GetSystemlnfo, 398 space-delimited tokens, 685 spaces, in environment block, 80 sparse file feature, of NTFS, 505
Sparse Memory-Mapped file sample application. See MMF Sparse application
Spawn CMD, in Job button, 143
special access protection attribute flags, 382 spin count, setting, 222 spin loops, executing, 178
spinlocks
assuming protected resource access, 212 critical sections and, 222 implementing, 211
as useful on multiprocessor machines, 212
using with critical sections, 223
wasting CPU lime, 211
Spreadsheet sample application, 716-722 spreadsheets
performing recalculations in background, 148 sharing, 504
Spy++
filtered behavior with, 124
running inside job, 133
SRWLock (slim reader-writer lock), 224-227
acquired exclusive mode, 234
acquiring, 232
acquiring in shared mode, 236
features missing in, 225
performance, 227
performance and scalability boost using, 225 reading volatile long value, 226 synchronization mechanism not tracked, 281 SRWLOCK structure, 224, 225 st_ prefix, for static TLS variables. 602 slack
created by CreateFiber, 362
detecting corruption at run time, 457
emptying, 213
limit, setting, 151
overflows, recovering gracefully from, 454 owned by each thread. 151 removing top element of, 213 returning number of elements stored in, 213 space required for function, 456 storage, increasing, 452
/STACK option. 451
stack pointer register
of thread, 451
in thread's context, 157
stack region
bottommost page always reserved, 455
for thread, 451, 452
/STACK switch, 151
stack underflow, 455
stack-based variables, 597
StackCheck, 457
stack-checking function, 456-457
Standard phonetic Unicode character sec, 13
Standard User, 116
START command, 192
start glass cursor, 99
STARTF_FORCEOFFFEEDBACK flag, 98
STARTF_FORCEONFEEDBACK flag, 98, 99 STARTF_RUNFULLSCREEN (lag, 98 STARTF_USECOUNTCHARS flag, 98 STARTFJJSEFILLATTRIBUTE flag, 98 STARTF_USEPOS1TION flag, 98 STARTF_USESHOWWINDOW flag, 97, 98 STARTF_USESIZE (lag, 98
STARTF_USESTDI IANDLES Rag, 98
StartRestrictedProcess function, 125-128, 129, 141 StariThreadpoolIo, 354
ows核心编程（第5版）
STARTUPINFO structure
members of, 97-98
obtaining copy of, 102 psiStartlnfo pointing to, 96 zeroing contents of, 96
STARTUP1NFOEX structure
members of, 97-98
passing to psiStartlnfo parameter, 95 psiStartlnfo pointing to, 96 role of, 99
zeroing contents of, 96
STARTUP1NFOEX variable, 102 starvation, 187 starved thread, 221 starving thread
dynamically boosting priority of, 195
SwitchToThread scheduling, 178
Slate member, 409
static data
not shared, 465-467
sharing, 467-474
static TLS, 602
static variables
declaring, 153
in DLL, 538
with heaps in C++, 529
STATUS_ACCESS_VIOLAT1ON exception, 525
STATUS_NO_MEMORY exception. 223, 525
STATUS_NO_MEMORY software exception, 703. 704 STATUS_PEND1NG, 307 _STDC_WANT_SECURE_LlB_symbol, 27 _stdcall (WINAP1) calling convention, 546 STILL_ACTIVE exil code. 107, 156, 157 STILL^CTIVE identifier, 156
SiopProcessing function, 237 storage, committing, 421, 692 sircpy function, 18,684 string(s)
comparing, 24
compiling as Unicode string, 14
controlling elimination of duplicate, 90 kinds of, 27
translating between Unicode and ANSI, 27-29 working with, 26
string arithmetic problems, 26
string conversions, 15
string functions, 24-25
string manipulation functions. 27
string manipulations, 22-24
string pointers, 79
StringCbCopyN, 79
StringCchCopy, 22
StringCchCopyN, 79
String.h
calling functions defined in, 20
included with Str Safe, h, 19
StringReverseA function, 30
StringReverseW function, 29, 30 string-termination zero, 76 strlen function, 12, 17
_strrev C run-time function, 488 STRSAFE_E」NSUFFIC1ENT_BUFFER 22, 23 STRSAFE_FILL_BEH1ND_NULL, 23, 24 STRSAFE_FILL_BYTE macro. 24 STRSAFE_FILL_ON_FAILURE, 23 STRSAFE」GNORE_NULLS, 23
STRSAFE_NO_TRUNCAT1ON, 23, 24 STRSAFE_NULL_ON_FAILURE, 23
StrSafe.h file, 18, 19
sirtok C/C++ run-time function, 685 structure, making volatile, 217 structured exception handling. See SEH (siruciured exception handling)
structured exceptions, vs. C++ exceptions, 727 .siscanLs, 46
subclass procedure, 606,607 subclassing, 605
SubmitThreadpoolWork function. 341 /SUBSYSTEM linker switch. 70 /SUBSYSTEMCONSOLE, 5.0 switch, 589 /SUBSYSTEMCONSOLE linker switch, 69, 70 /SUBSYSTEM:WINDOWS, 5.0 switch, 589 /SUBSYSTEM:W1NDCWS linker switch, 69, 70 successful wait side effects, 246-247, 249 suites, available on system, 87
Sum function, 457, 458
Summation (16-Summation.exe) sample application, 457
SumThreadFunc, 458
SuperFetch, 197 surrogates, 12, 13 Suspend button, 198 suspend count of thread, 175 suspend mode, 259 "Suspend Process*' feature, 176 suspended state, 175 suspended thread. 174 SuspendProcess function, 176 SuspendThread function, 175, 185 SW_SHOWDEFAULT、99 SW_SHOWMINNOACTIVE, 99 SW_SHOWNORMAL, 99 /SWAPRUN:CD switch, 380 /SWAPRUN:NET switch. 380 switch statements, 773, 774 Switch Desktop function, 133 SwitchToFiber function, 363, 366 SwitchToThread funciion, 178 synchronizable kernel objects, 277 synchronization kernel object mutex, 226 synchronization mechanism performance, 225 synchronization primitives, 167 synchronization, single-tasking, 108 synchronous device I/O, 302-305 synchronously performed asynchronous request, 327 Syslnfo.cpp listing, 398
Sysinternals
Process Explorer tool, 41-43 WtnObj tool from, 33
索 引
system
creating and initializing threads, 156
making sections of code execute, 689
setting process, exit code, 105
walking up chain of try blocks, 694
system DLLs, loaded a( random address, 122
System Idle Process, 103
SYSTEMJNFO structure
dwPageSize field of, 397
members of, 396
passing to GetSysiemlnfo, 395
System level of trust, 122
SYSTEM_LOC；ICAL_PROCESSOR_INFORMATION structures, 214
SYSTEM_MANDATORY_I.ABEL_NO_READ_UP resource policy, 124
SYSTEM_MANDATORY_LABEL_NO_WR1TE_UP resource policy, 124
System Properties dialog box, 195 system values, retrieving, 395 System Variables list, 81 system version, determining, 85-88 SystemParameterslnfo function, 133 system's affinity mask, 204
SYSTEMTIME structure, initializing, 258 szBuffer. 21
szCSDVersion member, 87
szDll member, 574
_T macro, 26
Task Manager
allowing user io alter process' CPU affinity, 206
determining if objects leak. 40
obtaining process' ID, 625
process ID of, 113
Processes tab, 192
TChar.h, macro defined by. 18
_tcslen, 18
_tcspy_s, 21
_icstok_s function, 597
TEBs (thread environment blocks), 376 temporary file, 298
Terminal Services, 51-53
Terminate Processes button, in Job Lab sample. 143
TerminateJobObject function, 137
TerminateProcess function, 104, 106, 155
as asynchronous, 107
calling from WerFaulLexe, 710
using only as last resort, 564
TerminateThread function, 153, 154
killing any thread, 155
threads calling, 567
terminating
processes, 107-108, 155
threads, 153-156
termination handlers, 660
reasons for using, 672
simplifying programming problems, 667 understanding by example, 660-676
test runs. WER dialog boxes breaking and stopping, 712
test-and-set operation, performing atomically, 264 text
determining if ANSI or Unicode, 31 used by child's console window、97 text files
line termination, 488 no hard and fast rules as to content, 31
TEXT macro, for literal characters and strings, 26 .text section, 467, 470 text strings
as arrays of characters, 26 coding, 12
.texibss section, 470 th32PareniProcessID member, 104 (head synchronization overhead, 522 theme support, enabling, 766 ThisPeriodTotalKernelTitne member, 137 ThisPeriodTotalUserTime member, 137 thrashing, 378 thread(s)
accessing data in paging file, 378 accessing data in process' address space, 378 accessing data in RAM, 378 accessing data via single, 215 accessing memory from its process, 371 all in process dying, 107 appropriate use of, 146-149 assigning io CPUs, 148 attempting to access storage in guard page, 452 ailempting to release mutex, 267 attempting to write to shared blocks, 382 calling CreateProcess, 89 calling wait function, 264 communicating with all in a pool, 330 communicating with devices, 290 components of, 145 contending for critical section, 223 creating and destroying, 328 creating and initializing, 156 creating in other processes, 621 deadlock issues when stopping, 236-238 determining number in pool, 324 ensuring muiual exclusive access, 265 executing code in processes, 67 execution limes. 179-183 experiment with different numbers of, 328 forcing oui of wait state, 319 forcing to specific CPU, 205 gaining access io shared resource, 266 guaranteeing to run, 174 helping partition work, 289 higher-priority preempting lower, 187 incrementing semaphores current count, 264 issuing asynchronous I/O request to device, 305
■^^>dows核心编程（第5版）
thread(s). continued
jumping from user-mode to kernel-mode code, 280 keeping busy, 289
managing creation and destruction of, 339 maximum number runnable at same lime, 322 need to commun记ate with each other, 207 not allowing to waste CPU lime, 215 with nothing to do, 174
notified only once of Slack overflow exception, 459 noticing of task completion, 207
other processes gaining access from, 248 ownership tracked by mutexes, 267 pool, how many in, 328
priorities, 187
process kernel object, referring to. 169 relative lime quantum difference in job, 131 releasing mutex, 266
requiring less overhead than processes, 146 running independently, 3
sharing kernel object handles, 145
sharing kernel objects in different processes, 43 sharing single address space, 145
solving some problems while creating new ones, 149 stack storage guaranteed for, 151 staying on single processor. 203
suspend count, 175 suspending and resuming, 175 suspending themselves, 278 switching to another, 178 synchronizing using event kernel objects, 249 synchronizing with kernel objects, 241 synchronous I/O operations, waiting to complete, 304
lerminaiing、153-156
thread kernel object, referring to, 169 thread times, querying, 169 tracked by WC：T. 281
transitioning from user mode to kernel mode, 222 turning into fiber, 362
wail state, putting themselves into, 242
waiting for its own messages, 278 wailing for wait item, 353 when not【o create, 148 when to create, 146-148 thread affinities, 205 thread environment blocks (TEBs), 376 thread functions, 158
naming, 150
return value from, 165
returning exit code, 150
returning upon termination, 154 using function parameters and local variables, 150 writing, 149-153
thread IDs. 103
identifying threads currently owning mutex. 265 storing, 153
thread internal, 156-158 thread kernel objects, 150
creating. 91, 157
decrementing usage count of, 154
freeing, 102
grabbing current set of CPU registers. 185
never returning to nonsignaled state, 242
rules Microsoft defined for, 242
selecting schedulable, 173
signaled state, 156
system creating, 89
unique identifiers assigned to, 103
usage count decremented, 156
usage count for, 149
Thread Local Storage. See TLS (Thread Local Storage)
THREAD_MODE_BACKGR0UND_BEGIN, 196 THREAD_MODE_BACKGROUND_END, 196 thread pool(s)
continuously refusing threads, 340
creating and destroying, 357
creating new, 356
customized, 356-358
destroying, 357
gracefully destroying, 358-360
how many threads in, 328
internal algorithm of, 340
I/O completion port managing, 327-328
overhead of using, 339
re-architected in Windows Vista, 339
thread pool APIs, 339
thread pooling functions, 339
thread pool I/O object, 354
thread pool wait object, 352
thread priorities, 190. See also relative thread priorities thread priority boosting
disabling for threads executing spinlocks, 211 dynamically boosting, 194
thread stacks
address space for, 451
building, 157
maintaining, 145
setting amount of address space for, 151
system allocating memory for, 150
thread synchronization
advanced, 215-217
aspects of, 207
kernel objects and, 276-277
using device kernel object for, 311
using HeapLock and HeapUnlock. 532 THREAD.TERMINATE, 304 thread/completion port assignment, breaking, 328 threading issues, of alertable I/O, 318 ThreadObjeci view, 287 _【hreadstartex function, 162, 164 throw C++ keyword, 660 thunks, to imported functions, 622 TID parameter, 285 _tiddaia block
association with new thread, 165
for each thread, 162
ExitThread preventing from being freed, 166 freeing. 168
索 引
_iiddata structure
associated with thread, 164
in C++ source code in Mtdll.h file, 162-164 library function requiring, 168 time quantum, 130 time slices. See quantums Time Stamp Counter (TSC), 181 time values, 179 time-based notification, 346 time-critical thread prioriiy, 190, 193 limed intervals, calling functions at, 346-351 Timed Message Box Application (H-TimedMsgBox.exe), 348-351 TimeoutCallback function, 346 timers)
building one-shot, 351
grouping several together, 347 one-shot signaling itself, 259 pausing, 347 setting io go off. 259 timer APC routine, 260 timer kernel object, waitable, 346 TimerAPCRoutine function, 260, 261 TimerCallback function, 347 limes, applying io all threads in process、180 TLS_M1NIMUM_AVA1LABLE、598、599 TLS_OUT_OF」NDEXES, 599 .tls section, 470, 602
TLS (Thread Local Storage), 3、165, 597
adding to application, 600
dynamic, 598-602
slots, 601
static, 602
TlsAlloc function, 599、600
reserving index. 599
setting returned index for all threads. 601 TlsFree funciion, 600 TlsGetValue function, 166, 168, 599, 600 TlsSeiValue operating system function, 165. 168, 599, 600
_tmain function, 72, 146, 158 _tmain (Main) function, 69 _tmain (Wmain) function, 69 TOKEN_ELEVAT1ON_TYPE enumeration, 118 TOKEN_MANDATORY_POLICY_OFF, 124 TOKEN_MANDATORY_POL1CY_VALID_MASK, 124 TokenElevationType parameter, 118 TokenElevationTypeDefauk value, 118 TokenElevationTypeFull value. 118 IbkenElevationlypel-imited value, 118 Tokenl.inkedToken, 118 TokenMandatoryPolicy, 123
Tool Help functions
added io Windows since Windows 2000, 119 allowing processquery its parent process, 104 enumerating all modules. 638 enumerating list of threads in system, 177 enumerating process* heaps, 531
utility, using to produce, 119
Too!Help32, 282
TotalKernelTime member, 137 TotalPageFaultCount member, 137
TotalPageFile, 407
To tai Phys, 406
Totalprocesses member, 138
TotalTerminaiedProcesses member, 138 ToialUserTime member, 137
TotalVirtual, 407
TP_CALLBACK_ENVIRON structure, 358, 359 TP.TIMER object. 347
tracking resources to be freed, 670 TriggerException function, 748
Trojan DLL. injecting DLL with, 633 TRUNCATE.EXISTING value, 294 truncauon, 22
trust, levels of, 122
<trustlnfo> section, in RT_MANIFEST, 114 try block
avoiding code causing premature exits from, 662 avoiding statements causing premature exit of, 666 compiler not having to catch premature exits from, 666
followed by either finally block or except block, 679 returning prematurely from, 666 statements discouraged in、680
_try keyword, 660	•
_try/_except construct, 637 TryEnterCriticalSection function, 221 try-excepi blocks
coding examples, 680
exception filler of, 749
iry-finally blocks
explicitly protecting, 664
nesting inside try-except blocks, 679 TrySubmitThreadpoolCallback, 340 _tWinMain function, 69, 146, 158
with .UNICODE defined, 71
entry-point function for sample applications, 766 without .UNICODE, 72
iwo-file two-buffer method, 476
Type member, 409
u
UAC. See User Account Control feature
uCodePagc parameter
of MuhiByteToWideChar funciion, 27
of WideCharToMukiByie function, 28 uFlags parameter, 313
Ul restriction. 134
U1PI (User Interface Privilege Isolation), 124 UIRestrictionsClass member, 133 ULARGE_INTEGER structure. 299, 300 ulCount parameter. 326
ullAvailExtendedVirtual member, 405 ulRAMPages parameter, 442 _unaligned keyword. 393
mdows核心编程（第5版）
UNALIGNED macro, 393
unaligned references, handling silently, 258 UNALIGNED64 macro, 393 unallocated address space, 375 unelcvated process, 113 unhandled exception, 705
occurring in excluded application. 737
occurring in kernel, 713
unhandled exception dialog box, turning off, 132 unhandled exception filler. 705
unhandled exception reports
comparing with database of known failures, 733 saved on user's machine, 73.3
UnhandledExceptionFilter function, 705, 707
as default filter, 706
EXCEPTlON_CONTINUE_SFiARCH returned by. 710
execution steps inside. 707-713
retrieving output of, 750
WER interactions and, 710-713 UnhookWindowsHookEx function, 610 Unicode
builds, enforcing consistency with. 762
character seis and alphabets, 13 consortium, 12
converting to non-Unicode equivalents, 16 full description of, 12
reasons for using, 26
standard. 12
supported in Windows Vista, 11
UNICODE and .UNICODE symbols
defined in CmnHdr.h, 762
specifying both, 27
Unicode character and string, declaring, H
Unicode code points, 13
Unicode functions
in C run-time library. 17
in Windows. 15-17
Unicode strings
always using, 11
convening to ANSI, 15
separating into separate tokens, 76
UNICODE symbol, 16, 27, 762 .UNICODE symbol. 18, 27, 762 Unicode Transformaiion Format. See UTF
Unicode versions
of entry point functions, 150
of Functions, 17, 22
unique identifier, assigned to objects, 103 unique systemwide ID, 170
UNIX
porting code to Windows, 361
threading architecture library of, 361 unmapping, from process' address space. 485-486 UnmapViewOn-ile function, 485,486 unnamed (anonymous) kernel object, 48 unnamed kernel objects, 53 unpageable memory, 423
UNREFERENCED_PARAMETER macro, 76
UnregisterApplicationRestart function, 755 unresolved external symbol error, 70 unsuccessful calls, object states never altered for, 246
Update Speed, changing to Paused, 42
UpdateProcThreadAttribute function, 101
upper bound, for number of threads, 321 usage count
incrementing kernel object's, 45
of kernel objects, 35
of semaphore object, 263
user(s)
changing priority class of process, 192
choosing to optimize performance for programs, 195 running Run As Administrator command, 111 starting applications, 99
User Account Control (UAC) feature, 110
forcing applications to run in restricted context, 37 security confirmation dialog boxes. 111 taking advantage of, 110 usurping WinSafer, 558-
User CPU Limit, 144
user data, sensitive. 739
user interface components. See window (objects)
User Interface Privilege Isolation (UIPI), 124
user interface thread, 149
user mode time, 131
User object handles, 155
User objects
differentiating from kernel objects, 37 owned by thread, 155
preventing processes in job from using, 133
user rights, granting, 423
user strings, 27
user time, 179
User timers, 262
User32.dll library, 537,608
UserHandleGrantAccess function, 134 user-interface-related events, 262 user-mode code, fibers implemented in, 361 user-mode context, as stable, 185
user-mode CPU time, used by job processes, 137 user-mode partition, 373-375
user-mode thread synchronization, limitations of, 241 USERPROFILE environment variable, 82
UTF (Unicode Transformation Format), 12, 13 utility applications, using IDs, 103
Utimers, 262
V
variables
avoiding exporting, 542
creating to manage thread pool, 328
in default data section, 470
in multithreaded environments, 160
sharing, 467,471,472
storing handles for kernel objects, 40
in their own section. 471
索 引
VcppException(ERROR_SEVERITY_ERROR. ERROR_MOD_NOT_FOUND), 574
VcppException(ERROR_SEVERlTYJ:RROR, ERROR_PROC_NOT」：OUND), 574
VDM (Virtual DOS Machine)、94 vectored exception handling (VEH), 726 VEH exception handier function. 727 VEH list, calling functions before any SEH filler, 726 VER_BU1LDNUMBER flag, 87 VLR_MAJORVERSION flag, 87 VTiR-MlNORVERSION flag. 87 VER_PLATI:ORM_W1N32_NT. 87 VER_PI.ATFORM_W1N32_W1NDOWS. 87 VER_PLATF()RM_WlN32s, 87 VER_PLATFORM1D flag, 87 VER_PRODUCT_TYPE information, comparing, 88 VER_SI:RV1CEPACKMAJOR flag, 87 VER_SERVK：EPACKMINOR (lag. 87 VFR_SET_CONDITION macro, 87 VER_SU1TENAME flag, 87. 88 VerifyVersionlnfo function, 86-88 Version.txt file, 736 very large memory (VLM) portion, 405 view
mapping for large file, 494
mapping into address space, 483
View Problem History link, 734, 741
vinual address, translating to physical storage address.
379
virtual address space, 372
bytes reserved in. 407
creating for process, 146
partitions of, 372-375
for process, 371
Virtual DOS Machine (VDM), 94
virtual memory, 419
address for DLL's g_x variable. 587
〔unctions, using instead of heaps, 519
loading code and data for application into, 465 making available, 377
retrieving dynamic informalion about state of, 404 virtual memory allocation sample application. See VMAlloc.cpp listing
virtual memory map, 383-387
Virtual Memory section, Chahgc button, 380
virtual memory techniques
advantages of, 424
combining with structured exception handling, 692 committing physical storage. 425
VirlualAlloc function, 375, 376, 378, 419, 422
io commit physical storage, 421,437, 505 passing PA(；E_WRH ECOPY or
PAGE_HXECUTE_WR1TECOPY, 382
io reserve region, 428
rounding up when resetting storage, 436
using to allocate large blocks, 526
VirtualAllocEx function, 623 ViriualAlloclixNuma function. 421
VinualFree function, 376,377, 426
decommiuing storage. 427, 505
VirtualFreeEx function, 624
ViriualMcmoryStaius function. See
GlobalMemorySiaius function
ViriualProteci function, 435
VirtualQuery function, 408, 429 determining if physical storage has been committed, 425
filling MEMORY_BASIC_INFORMAT1ON structure. 631
lirnitations of, 410
ViriualQueryEx function, 409
Visual Studio
creating application project, 69
debugger, 729
delining UNICODE by default, 16
Error Lookup utility, 6
linker, default base address, 74
shipping with C/C++ run-lime libraries. 159 wizards, 7 2
Visual Studio IDE, 148
Visual Studio Project Properties dialog box, 589
VLM portion, of virtual address space, 405
VMAUoc.cpp listing, 427-429
VMMap 叩plication (14-VMMap.exe), 415-417 memory map of, 383 performing tests, 429 running, 119 using SEH to commit storage、692
VMMap menu item, in Processinfo, 119
VMQuery function, 410-412, 416
VMQUERY structure, 410
VMQuery.cpp file, 411-412
VMSiai application ( H-VMStai.exe), 406-408
VOID return type, 3
volatile type qualifier, 216 vsjitdebugger.exe, 714, 715
_vstprintf_s function, 238
w
WMT_ABANDONED_0 value, of WaitResull, 353
WAIT_ABAN DON El), returned by wail function, 267 wait chain
defined, 282
node object types, 286
session, opening, 283
traversal of, 282
Wail Chain Traversal (WCT)
cancelling, 284
ParseThread method and, 284
set of functions, 281
synchronization mechanisms tracked by. 281
WAIT_FAILED return value, 244
wait function. 266
checking semaphore's current resource count, 264 returning special value of W/\IT_ABANDONI:I), 267 Wait functions, 243
WS核心编程（第5版）
WAIT_1O_COMPLET1ON return value, 318
wait item, 353
WA1T_OBJKCT_0 value. 244, 353
wail state
forcing thread out of, 319
Leave(:rilicalSeciion never placing thread in, 222
never allowing calling thread to enter, 221
placing thread in, 215, 221
threads placing themselves into, 243
WAIT.TIMEOUT value, 244, 353
waitable timer objects, creating, 257 waitable timers, 256
comparing with User timers, 262
creating, 256, 346
queuing APC entries, 260-26!
W/\1TCHAIN_NODE_INFO structure
defined in wct.h header file, 286
filling array of, 285
WCT filling up. 287
WaitForDebugEvent function, 176, 279 WaitForlnpuddle (unction, 278 Waiil'orMukipleObjects function, 244, 311, 313
calling with array, 237
not supported. 287
performing operations atomically, 246
Remove method calling, 270
return value of, 245
successful call altering state of object, 246
using one thread per 64 kernel objects, 352
working atomically, 247
WaitForMultipIeObjectsEx function, 317 WailForSingleObjeci funciion, 107, 109, 140,155, 243, 244,253, 311,312、458, 568
not calling inside any DLL's DllMain function. 570 return value of, 244
successful call altering state of object. 246
threads calling, 250
WaitForSingleObjectEx function
placing thread in alertable state, 317
suspending thread, 319
waiting on timer twice, 261 WaitI:orThreadpoo!loCallbacks function. 355 WaitForThreadpoolTimerCallbacks function, 347, 351 WailForThreadpoolWaitCallbacks function, 353 WaitForThreadpoolWork function, 353 WaitFor'i hreadpoolWorkCallbacks function. 341 waiting thread queue. 325 WaiiResuh parameter, 352 WaitResuh values, possible, 353 Wake/MlConditionVariable function. 227, 234, 237 WakeC'onditionVariable function, 227
with &rg_cvRcadyToProduce, 236
cal! to, 234
_wargv variable, 73, 76 warning level 4, sample applications using, 762 Watch window, 5 wchari_t data type, 13
wcslen function, 17
wespy function, 18 WCT. See Wail Chain Traversal (WCT) WCT_ASYNC_OPEN_I;LAG value, 284 WCT_OBJECI_STATUS enumeration, 287 WCT_OBjECr_ I YPE enumeration, 286 WCT_OUT_OF_PROC_COM_FLAG, 285 WCT_OUT_OF_PROC_CS_FLAG, 285 WCT_OUT_OF_PROC_FLAC；, 285 WctAlpcType node object type, 286 WctComAciivaiionType node object type, 286 WciComType node object lype, 286 WctCriiicalSeleciionType node object type, 286 WciMutexType node object type, 286 WCTP_GETIN l:O_ALL_FLAGS, 285 WciProcessWaitType node object type, 286 WciSendMessageType node object type, 286 WctThreadType node object ty^pe, 286 WctThreadWaitType node object type, 286 WctUnknown Type node object type, 286 Web browsers, communicating in background, 148 _wenviron global variable, 73
WER API, 733
WER code, running inside faulting process, 664
WER console, 733-736
listing problems, 712 opening, 710, 712 problem report displayed in, 735 showing each application crash, 734 View Problem 1 listory link, 741 WER_DUMP_NOHEAP_ONQUEUE flag, 745 WER_E_NOT_FOUND, 737 WER_FAULT_REPORTING_FLAG_QUEUE_UPLOAD fiag. 737
WER_FAULT_REPCRT1NG_FLAG_QUEUE (lag, 737 WUR_MAX_REGISTERED_ENTR1ES, 739 WER problem report, manually generating, 751 WER_REPORTJNFORMATION structure, 743 WER_SUBMIT_0UTOFPROCESS_ASYNC flag, 747 WER_SUBMIT_RESULT variable, 747
WER (Windows Error Reporting), 710-713 creating, customizing, and submitting problem report to, 740
default parameters for noncustomized report, 744 details of files generated by, 736 generating problem reports silently, 712 notifying to not restart application, 755 restarting applications automatically, 754 shifting control to, 454 telling not to suspend other threads, 736
Wer* functions, accepting only Unicode strings. 742 WerAddExdudedApplicaiion function, 737 WerConsen(Approved value, 746 WerConsentDenied value、746 WerConsenlNot/Ksked value, 746 WcrFauli.exe application, 710, 713 WerGetFlags function, 737 WerRegisterFile function, 738, 739 WerRegisierMemoryBlock function. 738
索 引
WerRemoveExcludedApplication function, 738 WerReport* functions, 751
WerReportAddDump function, 740, 744 WerReporiAddFile function, 740. 745 WerReportClosel landle function, 740, 748 WerReporiCreate function, 740. 742 WerReportSetParameter function, 740, 743 WerReportSeiUlOption function, 740, 746 WerReportSubmit function, 740s 746-747 WerSeiblags function. 736 WerSvc, exception sei to, 710 WerUnregisterFile function, 739 WerUnregisterMemoryBlock function. 739 WH_C；ETMESSA＜；H hook
installing, 609
unhooking, 613 while loop, spinning, 211 wide characters, 16. 622 wide-character siring, converting, 28 WideC-harToMukiByte function, 27. 28, 29 Win32 Console Application, 70 Win32 Exceptions, 729 _WIN32_W1NNT symbol, 761 WinDbg, 121 window (objects)
owned by thread. 155
sharing same thread, 149
subclassing, 605
window procedures, writing with message crackers, 773
window title, for console window, 97
WindowDump utility, 124
Windows operating system
data types, 15
designed to work with extremely large files. 299 devices supported by. 29。
Features available only to DLLs, 538
internal data structures for managing TLS, 598 memory architecture, 371-393
as preemptive multithreading system, i 52 scheduling concurrent threads, 68 string functions, 24-25
Unicode and ANSI functions in, 15-17
Windows 32-bit On Windows 64-bit, 397
Windows 98,94
Windows API
backward compatibility with 16-bit Windows, 17 exposing abstract layer over system,s scheduler. 188 Windows application programming interface (API), 537
Windows applications. See applications
Windows Error Reporting. See WER (Windows Error Reporting)
Windows Explorer
process associated io dedicated job. 128
separate thread for each folder s window, 149 Windows functions. See functions
Windows header file (WinNT.h), 15
CONTEXT structure, 157
defining data types, 14
Windows heap functions, 703
Windows hooks. See hooks
Windows Indexing Services, 146 Windows Integrity Mechanism. 122
Windows Management Instrumentation (WM1),
programmatic configuration of BCD, 206 Windows Notepad application. Sec Notepad Windows problems, gening in WER console. 713 Windows Quality Online Services Web site, 733 Windows Reliability and Performance Monitor, 392 Windows system directory
never touching, 585
placing DLLs in, 608
Windows Task Manager. See Task Manager Windows Vista
cancelling pending synchronous I/O. 304
CPU time charged for thread, 181 dialog boxes when exception is passed, 709 dialog box for unhandled exception, 674 error reporting in separate process, 664 extended mechanisms available in, 174 functions with both Unicode and ANSI versions, 17 I/O requests, expecting large number of, 326 mapping of priority classes and relative thread priorities, 190
Notepad File Save As dialog box, 31
raising security bar for end user, 110 soft affinity assigning threads to processors. 203 source code for CreateWindowExA, 16 starting applications in new session, 52 synchronous I/O, features added to improve, 304 testing whether host system is, 88 thread pool rc-architected, 339
threads issuing requests and terminating, 330 unhandled exception, major rearchiteclure of. 675 UNICODE macro, if application doesn't define, 17 Windows XP
exception passed to UnhandledlixceptionFiher, 709 message for unhandled exception, 674 WindowsX.h file, 775
WinHrror.h header file, 4、5
WinExec function, replacing with Create Process, 17 Win Main function
changing main to, 70
pszCmdLine parameter, 76 WinMainCRTStartup function, 69, 70 _winmajor global variable. 73 _winminor global variable, 73 WinNT.h header file. See Windows header file
(WinNT.h)
WinObj tool, 33
WinSafer, 558
Wintcllect Applicalions Suite product section, 741 _winver global variable. 73
WINVER symbol, 761
WM_COMMAND message
macro for, 775
processing, 774
wParam containing two different values, 774
lows核心编程（第5版）
WM_INITD1ALOG message-handling code, 118
WM_SETnNGCHANGE message, 81
WM_T1MER messages, 262 wmainCRTStartup function, 69, 70 word processor applications, background operations, 148
work iiem(s)
adding to thread pool's queue, 340 creating, 341 explicitly controlling, 340-342 freeing, 342
functions implementing batch processing, 342 refusing to execute multiple actions, 341 worker threads, compuie-bound or I/O-bound. 149 working sci, 407
knowing process*, 408
minimizing, 408
of process. 131
WorkingSetSize field, 408
WOW64, 397
wParam parameter, for messages, 774
_wpgmptr global variable, 73 wProcessorArchiteciure member, 396 wProcessorl.evcl member, 396 wProcessorRevision member, 396 wProduct lype member, 87 wReserved member
of OSVERSION1NFOEX structure. 87 ofSYSTEMJNFO, 396
writable buffer, passing as parameter, 19
writable pages, 382
write access, 708
WRITE attribute, 468
Write method, of ClOReq, 333
WriteFile function, 302, 306
WriteFileEx function, 315
WrileProcessMemory function, 624 writers, distinguishing from readers, 224 wServkcPackMajor member, 87 wSen'icePackMinor member, 87 wShowWindow member, 99 wShowWindow value, 97 wSuileMask member, 87
(w)WinMain function, writing, 75 wWinMainCRTStartup function, 69, 70
X
x64 system. 4-KB page size, 376
x86 compiler, 393
x86 CPUs. See also CPU(s)
dealing with unaligned data references silently, 258 handling data alignment, 391
interlocked functions asserting hardware signal, 210 page size of, 387
performing, 392
x86 system, 4-KB page size、376
x86 Windows, larger user-mode partition in、373-374 _XcpFilter function, 708
.xdata section, 470
XML manifesi, 114
Y
Yield Processor macro, 178
Z
/Zc:wchar_t compiler switch, 13 zero page thread, 188. 190 ZeroMemory, 437 zero-terminated siring
passing address of, 48
passing address of in pszName. 50
/Z1 switch, 90
